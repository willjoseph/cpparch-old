
extern "C"
{
	typedef unsigned int uintptr_t;
	typedef char*va_list;
}
extern "C"
{
	typedef unsigned int size_t;
	typedef size_t rsize_t;
	typedef int intptr_t;
	typedef int ptrdiff_t;
	typedef unsigned short wint_t;
	typedef unsigned short wctype_t;
	typedef int errcode;
	typedef int errno_t;
	typedef long __time32_t;
	typedef __int64 __time64_t;
	typedef __time64_t time_t;
	struct threadlocaleinfostruct;
	struct threadmbcinfostruct;
	typedef struct threadlocaleinfostruct*pthreadlocinfo;
	typedef struct threadmbcinfostruct*pthreadmbcinfo;
	struct __lc_time_data;
	typedef struct localeinfo_struct
	{
		pthreadlocinfo locinfo;
		pthreadmbcinfo mbcinfo;
	}
	_locale_tstruct, *_locale_t;
	typedef struct tagLC_ID
	{
		unsigned short wLanguage;
		unsigned short wCountry;
		unsigned short wCodePage;
	}
	LC_ID, *LPLC_ID;
	typedef struct threadlocaleinfostruct
	{
		int refcount;
		unsigned int lc_codepage;
		unsigned int lc_collate_cp;
		unsigned long lc_handle[6];
		LC_ID lc_id[6];
		struct
		{
			char*locale;
			wchar_t*wlocale;
			int*refcount;
			int*wrefcount;
		}
		lc_category[6];
		int lc_clike;
		int mb_cur_max;
		int*lconv_intl_refcount;
		int*lconv_num_refcount;
		int*lconv_mon_refcount;
		struct lconv*lconv;
		int*ctype1_refcount;
		unsigned short*ctype1;
		const unsigned short*pctype;
		const unsigned char*pclmap;
		const unsigned char*pcumap;
		struct __lc_time_data*lc_time_curr;
	}
	threadlocinfo;
}
extern "C"
{
	void*_memccpy(void*_Dst, const void*_Src, int _Val, size_t _MaxCount);
	const void*memchr(const void*_Buf, int _Val, size_t _MaxCount);
	int _memicmp(const void*_Buf1, const void*_Buf2, size_t _Size);
	int _memicmp_l(const void*_Buf1, const void*_Buf2, size_t _Size, _locale_t _Locale);
	int memcmp(const void*_Buf1, const void*_Buf2, size_t _Size);
	void*memcpy(void*_Dst, const void*_Src, size_t _Size);
	errno_t memcpy_s(void*_Dst, rsize_t _DstSize, const void*_Src, rsize_t _MaxCount);
	void*memset(void*_Dst, int _Val, size_t _Size);
	char*_strset(char*_Str, int _Val);
	errno_t _strset_s(char*_Dst, size_t _DstSize, int _Value);
	errno_t strcpy_s(char*_Dst, rsize_t _DstSize, const char*_Src);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strcpy_s(char(&_Dest)[_SizeFIXED], const char*_Source)
		{
			return strcpy_s(_Dest, _SizeFIXED, _Source);
		}
	}
	char*strcpy(char*_Dest, const char*_Source);
	errno_t strcat_s(char*_Dst, rsize_t _DstSize, const char*_Src);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strcat_s(char(&_Dest)[_SizeFIXED], const char*_Source)
		{
			return strcat_s(_Dest, _SizeFIXED, _Source);
		}
	}
	char*strcat(char*_Dest, const char*_Source);
	int strcmp(const char*_Str1, const char*_Str2);
	size_t strlen(const char*_Str);
	size_t strnlen(const char*_Str, size_t _MaxCount);
	static size_t strnlen_s(const char*_Str, size_t _MaxCount)
	{
		return strnlen(_Str, _MaxCount);
	}
	errno_t memmove_s(void*_Dst, rsize_t _DstSize, const void*_Src, rsize_t _MaxCount);
	void*memmove(void*_Dst, const void*_Src, size_t _Size);
	char*_strdup(const char*_Src);
	const char*strchr(const char*_Str, int _Val);
	int _stricmp(const char*_Str1, const char*_Str2);
	int _strcmpi(const char*_Str1, const char*_Str2);
	int _stricmp_l(const char*_Str1, const char*_Str2, _locale_t _Locale);
	int strcoll(const char*_Str1, const char*_Str2);
	int _strcoll_l(const char*_Str1, const char*_Str2, _locale_t _Locale);
	int _stricoll(const char*_Str1, const char*_Str2);
	int _stricoll_l(const char*_Str1, const char*_Str2, _locale_t _Locale);
	int _strncoll(const char*_Str1, const char*_Str2, size_t _MaxCount);
	int _strncoll_l(const char*_Str1, const char*_Str2, size_t _MaxCount, _locale_t _Locale);
	int _strnicoll(const char*_Str1, const char*_Str2, size_t _MaxCount);
	int _strnicoll_l(const char*_Str1, const char*_Str2, size_t _MaxCount, _locale_t _Locale);
	size_t strcspn(const char*_Str, const char*_Control);
	char*_strerror(const char*_ErrMsg);
	errno_t _strerror_s(char*_Buf, size_t _SizeInBytes, const char*_ErrMsg);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strerror_s(char(&_Buffer)[_SizeFIXED], const char*_ErrorMessage)
		{
			return _strerror_s(_Buffer, _SizeFIXED, _ErrorMessage);
		}
	}
	char*strerror(int);
	errno_t strerror_s(char*_Buf, size_t _SizeInBytes, int _ErrNum);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strerror_s(char(&_Buffer)[_SizeFIXED], int _ErrorMessage)
		{
			return strerror_s(_Buffer, _SizeFIXED, _ErrorMessage);
		}
	}
	errno_t _strlwr_s(char*_Str, size_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strlwr_s(char(&_String)[_SizeFIXED])
		{
			return _strlwr_s(_String, _SizeFIXED);
		}
	}
	char*_strlwr(char*_String);
	errno_t _strlwr_s_l(char*_Str, size_t _Size, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strlwr_s_l(char(&_String)[_SizeFIXED], _locale_t _Locale)
		{
			return _strlwr_s_l(_String, _SizeFIXED, _Locale);
		}
	}
	char*_strlwr_l(char*_String, _locale_t _Locale);
	errno_t strncat_s(char*_Dst, rsize_t _DstSize, const char*_Src, rsize_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strncat_s(char(&_Dest)[_SizeFIXED], const char*_Source, size_t _Count)
		{
			return strncat_s(_Dest, _SizeFIXED, _Source, _Count);
		}
	}
	char*strncat(char*_Dest, const char*_Source, size_t _Count);
	int strncmp(const char*_Str1, const char*_Str2, size_t _MaxCount);
	int _strnicmp(const char*_Str1, const char*_Str2, size_t _MaxCount);
	int _strnicmp_l(const char*_Str1, const char*_Str2, size_t _MaxCount, _locale_t _Locale);
	errno_t strncpy_s(char*_Dst, rsize_t _DstSize, const char*_Src, rsize_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strncpy_s(char(&_Dest)[_SizeFIXED], const char*_Source, size_t _Count)
		{
			return strncpy_s(_Dest, _SizeFIXED, _Source, _Count);
		}
	}
	char*strncpy(char*_Dest, const char*_Source, size_t _Count);
	char*_strnset(char*_Str, int _Val, size_t _MaxCount);
	errno_t _strnset_s(char*_Str, size_t _Size, int _Val, size_t _MaxCount);
	const char*strpbrk(const char*_Str, const char*_Control);
	const char*strrchr(const char*_Str, int _Ch);
	char*_strrev(char*_Str);
	size_t strspn(const char*_Str, const char*_Control);
	const char*strstr(const char*_Str, const char*_SubStr);
	char*strtok(char*_Str, const char*_Delim);
	char*strtok_s(char*_Str, const char*_Delim, char**_Context);
	errno_t _strupr_s(char*_Str, size_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strupr_s(char(&_String)[_SizeFIXED])
		{
			return _strupr_s(_String, _SizeFIXED);
		}
	}
	char*_strupr(char*_String);
	errno_t _strupr_s_l(char*_Str, size_t _Size, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strupr_s_l(char(&_String)[_SizeFIXED], _locale_t _Locale)
		{
			return _strupr_s_l(_String, _SizeFIXED, _Locale);
		}
	}
	char*_strupr_l(char*_String, _locale_t _Locale);
	size_t strxfrm(char*_Dst, const char*_Src, size_t _MaxCount);
	size_t _strxfrm_l(char*_Dst, const char*_Src, size_t _MaxCount, _locale_t _Locale);
	extern "C++"
	{
		inline char*strchr(char*_Str, int _Ch)
		{
			return (char*)strchr((const char*)_Str, _Ch);
		}
		inline char*strpbrk(char*_Str, const char*_Control)
		{
			return (char*)strpbrk((const char*)_Str, _Control);
		}
		inline char*strrchr(char*_Str, int _Ch)
		{
			return (char*)strrchr((const char*)_Str, _Ch);
		}
		inline char*strstr(char*_Str, const char*_SubStr)
		{
			return (char*)strstr((const char*)_Str, _SubStr);
		}
		inline void*memchr(void*_Pv, int _C, size_t _N)
		{
			return (void*)memchr((const void*)_Pv, _C, _N);
		}
	}
	wchar_t*_wcsdup(const wchar_t*_Str);
	errno_t wcscat_s(wchar_t*_Dst, rsize_t _DstSize, const wchar_t*_Src);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcscat_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Source)
		{
			return wcscat_s(_Dest, _SizeFIXED, _Source);
		}
	}
	wchar_t*wcscat(wchar_t*_Dest, const wchar_t*_Source);
	const wchar_t*wcschr(const wchar_t*_Str, wchar_t _Ch);
	int wcscmp(const wchar_t*_Str1, const wchar_t*_Str2);
	errno_t wcscpy_s(wchar_t*_Dst, rsize_t _DstSize, const wchar_t*_Src);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcscpy_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Source)
		{
			return wcscpy_s(_Dest, _SizeFIXED, _Source);
		}
	}
	wchar_t*wcscpy(wchar_t*_Dest, const wchar_t*_Source);
	size_t wcscspn(const wchar_t*_Str, const wchar_t*_Control);
	size_t wcslen(const wchar_t*_Str);
	size_t wcsnlen(const wchar_t*_Src, size_t _MaxCount);
	static size_t wcsnlen_s(const wchar_t*_Src, size_t _MaxCount)
	{
		return wcsnlen(_Src, _MaxCount);
	}
	errno_t wcsncat_s(wchar_t*_Dst, rsize_t _DstSize, const wchar_t*_Src, rsize_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcsncat_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Source, size_t _Count)
		{
			return wcsncat_s(_Dest, _SizeFIXED, _Source, _Count);
		}
	}
	wchar_t*wcsncat(wchar_t*_Dest, const wchar_t*_Source, size_t _Count);
	int wcsncmp(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount);
	errno_t wcsncpy_s(wchar_t*_Dst, rsize_t _DstSize, const wchar_t*_Src, rsize_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcsncpy_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Source, size_t _Count)
		{
			return wcsncpy_s(_Dest, _SizeFIXED, _Source, _Count);
		}
	}
	wchar_t*wcsncpy(wchar_t*_Dest, const wchar_t*_Source, size_t _Count);
	const wchar_t*wcspbrk(const wchar_t*_Str, const wchar_t*_Control);
	const wchar_t*wcsrchr(const wchar_t*_Str, wchar_t _Ch);
	size_t wcsspn(const wchar_t*_Str, const wchar_t*_Control);
	const wchar_t*wcsstr(const wchar_t*_Str, const wchar_t*_SubStr);
	wchar_t*wcstok(wchar_t*_Str, const wchar_t*_Delim);
	wchar_t*wcstok_s(wchar_t*_Str, const wchar_t*_Delim, wchar_t**_Context);
	wchar_t*_wcserror(int _ErrNum);
	errno_t _wcserror_s(wchar_t*_Buf, size_t _SizeInWords, int _ErrNum);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcserror_s(wchar_t(&_Buffer)[_SizeFIXED], int _Error)
		{
			return _wcserror_s(_Buffer, _SizeFIXED, _Error);
		}
	}
	wchar_t*__wcserror(const wchar_t*_Str);
	errno_t __wcserror_s(wchar_t*_Buffer, size_t _SizeInWords, const wchar_t*_ErrMsg);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t __wcserror_s(wchar_t(&_Buffer)[_SizeFIXED], const wchar_t*_ErrorMessage)
		{
			return __wcserror_s(_Buffer, _SizeFIXED, _ErrorMessage);
		}
	}
	int _wcsicmp(const wchar_t*_Str1, const wchar_t*_Str2);
	int _wcsicmp_l(const wchar_t*_Str1, const wchar_t*_Str2, _locale_t _Locale);
	int _wcsnicmp(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount);
	int _wcsnicmp_l(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount, _locale_t _Locale);
	wchar_t*_wcsnset(wchar_t*_Str, wchar_t _Val, size_t _MaxCount);
	errno_t _wcsnset_s(wchar_t*_Dst, size_t _DstSizeInWords, wchar_t _Val, size_t _MaxCount);
	wchar_t*_wcsrev(wchar_t*_Str);
	wchar_t*_wcsset(wchar_t*_Str, wchar_t _Val);
	errno_t _wcsset_s(wchar_t*_Str, size_t _SizeInWords, wchar_t _Val);
	errno_t _wcslwr_s(wchar_t*_Str, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcslwr_s(wchar_t(&_String)[_SizeFIXED])
		{
			return _wcslwr_s(_String, _SizeFIXED);
		}
	}
	wchar_t*_wcslwr(wchar_t*_String);
	errno_t _wcslwr_s_l(wchar_t*_Str, size_t _SizeInWords, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcslwr_s_l(wchar_t(&_String)[_SizeFIXED], _locale_t _Locale)
		{
			return _wcslwr_s_l(_String, _SizeFIXED, _Locale);
		}
	}
	wchar_t*_wcslwr_l(wchar_t*_String, _locale_t _Locale);
	errno_t _wcsupr_s(wchar_t*_Str, size_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcsupr_s(wchar_t(&_String)[_SizeFIXED])
		{
			return _wcsupr_s(_String, _SizeFIXED);
		}
	}
	wchar_t*_wcsupr(wchar_t*_String);
	errno_t _wcsupr_s_l(wchar_t*_Str, size_t _Size, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcsupr_s_l(wchar_t(&_String)[_SizeFIXED], _locale_t _Locale)
		{
			return _wcsupr_s_l(_String, _SizeFIXED, _Locale);
		}
	}
	wchar_t*_wcsupr_l(wchar_t*_String, _locale_t _Locale);
	size_t wcsxfrm(wchar_t*_Dst, const wchar_t*_Src, size_t _MaxCount);
	size_t _wcsxfrm_l(wchar_t*_Dst, const wchar_t*_Src, size_t _MaxCount, _locale_t _Locale);
	int wcscoll(const wchar_t*_Str1, const wchar_t*_Str2);
	int _wcscoll_l(const wchar_t*_Str1, const wchar_t*_Str2, _locale_t _Locale);
	int _wcsicoll(const wchar_t*_Str1, const wchar_t*_Str2);
	int _wcsicoll_l(const wchar_t*_Str1, const wchar_t*_Str2, _locale_t _Locale);
	int _wcsncoll(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount);
	int _wcsncoll_l(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount, _locale_t _Locale);
	int _wcsnicoll(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount);
	int _wcsnicoll_l(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount, _locale_t _Locale);
	extern "C++"
	{
		inline wchar_t*wcschr(wchar_t*_Str, wchar_t _Ch)
		{
			return ((wchar_t*)wcschr((const wchar_t*)_Str, _Ch));
		}
		inline wchar_t*wcspbrk(wchar_t*_Str, const wchar_t*_Control)
		{
			return ((wchar_t*)wcspbrk((const wchar_t*)_Str, _Control));
		}
		inline wchar_t*wcsrchr(wchar_t*_Str, wchar_t _Ch)
		{
			return ((wchar_t*)wcsrchr((const wchar_t*)_Str, _Ch));
		}
		inline wchar_t*wcsstr(wchar_t*_Str, const wchar_t*_SubStr)
		{
			return ((wchar_t*)wcsstr((const wchar_t*)_Str, _SubStr));
		}
	}
}
extern "C" void _invalid_parameter(const wchar_t*, const wchar_t*, const wchar_t*, unsigned int, uintptr_t);
namespace std
{
	typedef bool _Bool;
}
typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;
namespace std
{
	class _Lockit
	{
	public:
		explicit _Lockit();
		explicit _Lockit(int);
		~_Lockit();
		static void _Lockit_ctor(int);
		static void _Lockit_dtor(int);
	private:
		static void _Lockit_ctor(_Lockit*);
		static void _Lockit_ctor(_Lockit*, int);
		static void _Lockit_dtor(_Lockit*);
		_Lockit(const _Lockit&);
		_Lockit&operator=(const _Lockit&);
		int _Locktype;
	};
	class _Mutex
	{
	public:
		_Mutex();
		~_Mutex();
		void _Lock();
		void _Unlock();
	private:
		static void _Mutex_ctor(_Mutex*);
		static void _Mutex_dtor(_Mutex*);
		static void _Mutex_Lock(_Mutex*);
		static void _Mutex_Unlock(_Mutex*);
		_Mutex(const _Mutex&);
		_Mutex&operator=(const _Mutex&);
		void*_Mtx;
	};
	class _Init_locks
	{
	public:
		_Init_locks();
		~_Init_locks();
	private:
		static void _Init_locks_ctor(_Init_locks*);
		static void _Init_locks_dtor(_Init_locks*);
	};
}
void _Atexit(void(*)(void));
typedef int _Mbstatet;
extern "C"
{
	struct _iobuf
	{
		char*_ptr;
		int _cnt;
		char*_base;
		int _flag;
		int _file;
		int _charbuf;
		int _bufsiz;
		char*_tmpfname;
	};
	typedef struct _iobuf FILE;
	FILE*__iob_func(void);
	typedef long long fpos_t;
	int _filbuf(FILE*_File);
	int _flsbuf(int _Ch, FILE*_File);
	FILE*_fsopen(const char*_Filename, const char*_Mode, int _ShFlag);
	void clearerr(FILE*_File);
	errno_t clearerr_s(FILE*_File);
	int fclose(FILE*_File);
	int _fcloseall(void);
	FILE*_fdopen(int _FileHandle, const char*_Mode);
	int feof(FILE*_File);
	int ferror(FILE*_File);
	int fflush(FILE*_File);
	int fgetc(FILE*_File);
	int _fgetchar(void);
	int fgetpos(FILE*_File, fpos_t*_Pos);
	char*fgets(char*_Buf, int _MaxCount, FILE*_File);
	int _fileno(FILE*_File);
	char*_tempnam(const char*_DirName, const char*_FilePrefix);
	int _flushall(void);
	FILE*fopen(const char*_Filename, const char*_Mode);
	errno_t fopen_s(FILE**_File, const char*_Filename, const char*_Mode);
	int fprintf(FILE*_File, const char*_Format, ...);
	int fprintf_s(FILE*_File, const char*_Format, ...);
	int fputc(int _Ch, FILE*_File);
	int _fputchar(int _Ch);
	int fputs(const char*_Str, FILE*_File);
	size_t fread(void*_DstBuf, size_t _ElementSize, size_t _Count, FILE*_File);
	size_t fread_s(void*_DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE*_File);
	FILE*freopen(const char*_Filename, const char*_Mode, FILE*_File);
	errno_t freopen_s(FILE**_File, const char*_Filename, const char*_Mode, FILE*_OldFile);
	int fscanf(FILE*_File, const char*_Format, ...);
	int _fscanf_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int fscanf_s(FILE*_File, const char*_Format, ...);
	int _fscanf_s_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int fsetpos(FILE*_File, const fpos_t*_Pos);
	int fseek(FILE*_File, long _Offset, int _Origin);
	long ftell(FILE*_File);
	int _fseeki64(FILE*_File, __int64 _Offset, int _Origin);
	__int64 _ftelli64(FILE*_File);
	size_t fwrite(const void*_Str, size_t _Size, size_t _Count, FILE*_File);
	int getc(FILE*_File);
	int getchar(void);
	int _getmaxstdio(void);
	char*gets_s(char*_Buf, rsize_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline char*gets_s(char(&_Buffer)[_SizeFIXED])
		{
			return gets_s(_Buffer, _SizeFIXED);
		}
	}
	char*gets(char*_Buffer);
	int _getw(FILE*_File);
	void perror(const char*_ErrMsg);
	int _pclose(FILE*_File);
	FILE*_popen(const char*_Command, const char*_Mode);
	int printf(const char*_Format, ...);
	int printf_s(const char*_Format, ...);
	int putc(int _Ch, FILE*_File);
	int putchar(int _Ch);
	int puts(const char*_Str);
	int _putw(int _Word, FILE*_File);
	int remove(const char*_Filename);
	int rename(const char*_OldFilename, const char*_NewFilename);
	int _unlink(const char*_Filename);
	void rewind(FILE*_File);
	int _rmtmp(void);
	int scanf(const char*_Format, ...);
	int _scanf_l(const char*_Format, _locale_t _Locale, ...);
	int scanf_s(const char*_Format, ...);
	int _scanf_s_l(const char*_Format, _locale_t _Locale, ...);
	void setbuf(FILE*_File, char*_Buffer);
	int _setmaxstdio(int _Max);
	unsigned int _set_output_format(unsigned int _Format);
	unsigned int _get_output_format(void);
	int setvbuf(FILE*_File, char*_Buf, int _Mode, size_t _Size);
	int _snprintf_s(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, ...);
	int sprintf_s(char*_DstBuf, size_t _DstSize, const char*_Format, ...);
	int _scprintf(const char*_Format, ...);
	int sscanf(const char*_Src, const char*_Format, ...);
	int _sscanf_l(const char*_Src, const char*_Format, _locale_t _Locale, ...);
	int sscanf_s(const char*_Src, const char*_Format, ...);
	int _sscanf_s_l(const char*_Src, const char*_Format, _locale_t _Locale, ...);
	int _snscanf(const char*_Src, size_t _MaxCount, const char*_Format, ...);
	int _snscanf_l(const char*_Src, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _snscanf_s(const char*_Src, size_t _MaxCount, const char*_Format, ...);
	int _snscanf_s_l(const char*_Src, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	FILE*tmpfile(void);
	errno_t tmpfile_s(FILE**_File);
	errno_t tmpnam_s(char*_Buf, rsize_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t tmpnam_s(char(&_Buf)[_SizeFIXED])
		{
			return tmpnam_s(_Buf, _SizeFIXED);
		}
	}
	char*tmpnam(char*_Buffer);
	int ungetc(int _Ch, FILE*_File);
	int vfprintf(FILE*_File, const char*_Format, va_list _ArgList);
	int vfprintf_s(FILE*_File, const char*_Format, va_list _ArgList);
	int vprintf(const char*_Format, va_list _ArgList);
	int vprintf_s(const char*_Format, va_list _ArgList);
	int vsnprintf(char*_DstBuf, size_t _MaxCount, const char*_Format, va_list _ArgList);
	int vsnprintf_s(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, va_list _ArgList);
	int _vsnprintf_s(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, va_list _ArgList);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline int _vsnprintf_s(char(&_Dest)[_SizeFIXED], size_t _Size, const char*_Format, va_list _Args)
		{
			return _vsnprintf_s(_Dest, _SizeFIXED, _Size, _Format, _Args);
		}
	}
	int _snprintf(char*_Dest, size_t _Count, const char*_Format, ...);
	int _vsnprintf(char*_Dest, size_t _Count, const char*_Format, va_list _Args);
	int vsprintf_s(char*_DstBuf, size_t _Size, const char*_Format, va_list _ArgList);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline int vsprintf_s(char(&_Dest)[_SizeFIXED], const char*_Format, va_list _Args)
		{
			return vsprintf_s(_Dest, _SizeFIXED, _Format, _Args);
		}
	}
	int sprintf(char*_Dest, const char*_Format, ...);
	int vsprintf(char*_Dest, const char*_Format, va_list _Args);
	extern "C++"
	{
		;
		;
		template<size_t _SizeFIXED>
		inline int _snprintf_s(char(&_Dest)[_SizeFIXED], size_t _Size, const char*_Format, ...)
		{
			va_list _ArgList;
			(_ArgList=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
			return _vsnprintf_s(_Dest, _SizeFIXED, _Size, _Format, _ArgList);
		};
	}
	extern "C++"
	{
		;
		;
		template<size_t _SizeFIXED>
		inline int sprintf_s(char(&_Dest)[_SizeFIXED], const char*_Format, ...)
		{
			va_list _ArgList;
			(_ArgList=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
			return vsprintf_s(_Dest, _SizeFIXED, _Format, _ArgList);
		};
	}
	int _vscprintf(const char*_Format, va_list _ArgList);
	int _snprintf_c(char*_DstBuf, size_t _MaxCount, const char*_Format, ...);
	int _vsnprintf_c(char*_DstBuf, size_t _MaxCount, const char*_Format, va_list _ArgList);
	int _fprintf_p(FILE*_File, const char*_Format, ...);
	int _printf_p(const char*_Format, ...);
	int _sprintf_p(char*_Dst, size_t _MaxCount, const char*_Format, ...);
	int _vfprintf_p(FILE*_File, const char*_Format, va_list _ArgList);
	int _vprintf_p(const char*_Format, va_list _ArgList);
	int _vsprintf_p(char*_Dst, size_t _MaxCount, const char*_Format, va_list _ArgList);
	int _scprintf_p(const char*_Format, ...);
	int _vscprintf_p(const char*_Format, va_list _ArgList);
	int _set_printf_count_output(int _Value);
	int _get_printf_count_output();
	int _printf_l(const char*_Format, _locale_t _Locale, ...);
	int _printf_p_l(const char*_Format, _locale_t _Locale, ...);
	int _printf_s_l(const char*_Format, _locale_t _Locale, ...);
	int _vprintf_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vprintf_p_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vprintf_s_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _fprintf_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int _fprintf_p_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int _fprintf_s_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int _vfprintf_l(FILE*_File, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vfprintf_p_l(FILE*_File, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vfprintf_s_l(FILE*_File, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _sprintf_l(char*_DstBuf, const char*_Format, _locale_t _Locale, ...);
	int _sprintf_p_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _sprintf_s_l(char*_DstBuf, size_t _DstSize, const char*_Format, _locale_t _Locale, ...);
	int _vsprintf_l(char*_DstBuf, const char*_Format, _locale_t, va_list _ArgList);
	int _vsprintf_p_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vsprintf_s_l(char*_DstBuf, size_t _DstSize, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _scprintf_l(const char*_Format, _locale_t _Locale, ...);
	int _scprintf_p_l(const char*_Format, _locale_t _Locale, ...);
	int _vscprintf_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vscprintf_p_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _snprintf_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _snprintf_c_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _snprintf_s_l(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _vsnprintf_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vsnprintf_c_l(char*_DstBuf, size_t _MaxCount, const char*, _locale_t _Locale, va_list _ArgList);
	int _vsnprintf_s_l(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, _locale_t _Locale, va_list _ArgList);
	FILE*_wfsopen(const wchar_t*_Filename, const wchar_t*_Mode, int _ShFlag);
	wint_t fgetwc(FILE*_File);
	wint_t _fgetwchar(void);
	wint_t fputwc(wchar_t _Ch, FILE*_File);
	wint_t _fputwchar(wchar_t _Ch);
	wint_t getwc(FILE*_File);
	wint_t getwchar(void);
	wint_t putwc(wchar_t _Ch, FILE*_File);
	wint_t putwchar(wchar_t _Ch);
	wint_t ungetwc(wint_t _Ch, FILE*_File);
	wchar_t*fgetws(wchar_t*_Dst, int _SizeInWords, FILE*_File);
	int fputws(const wchar_t*_Str, FILE*_File);
	wchar_t*_getws_s(wchar_t*_Str, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline wchar_t*_getws_s(wchar_t(&_String)[_SizeFIXED])
		{
			return _getws_s(_String, _SizeFIXED);
		}
	}
	wchar_t*_getws(wchar_t*_String);
	int _putws(const wchar_t*_Str);
	int fwprintf(FILE*_File, const wchar_t*_Format, ...);
	int fwprintf_s(FILE*_File, const wchar_t*_Format, ...);
	int wprintf(const wchar_t*_Format, ...);
	int wprintf_s(const wchar_t*_Format, ...);
	int _scwprintf(const wchar_t*_Format, ...);
	int vfwprintf(FILE*_File, const wchar_t*_Format, va_list _ArgList);
	int vfwprintf_s(FILE*_File, const wchar_t*_Format, va_list _ArgList);
	int vwprintf(const wchar_t*_Format, va_list _ArgList);
	int vwprintf_s(const wchar_t*_Format, va_list _ArgList);
	int swprintf_s(wchar_t*_Dst, size_t _SizeInWords, const wchar_t*_Format, ...);
	int vswprintf_s(wchar_t*_Dst, size_t _SizeInWords, const wchar_t*_Format, va_list _ArgList);
	extern "C++"
	{
		;
		;
		template<size_t _SizeFIXED>
		inline int swprintf_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Format, ...)
		{
			va_list _ArgList;
			(_ArgList=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
			return vswprintf_s(_Dest, _SizeFIXED, _Format, _ArgList);
		};
	}
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline int vswprintf_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Format, va_list _Args)
		{
			return vswprintf_s(_Dest, _SizeFIXED, _Format, _Args);
		}
	}
	int _swprintf_c(wchar_t*_DstBuf, size_t _SizeInWords, const wchar_t*_Format, ...);
	int _vswprintf_c(wchar_t*_DstBuf, size_t _SizeInWords, const wchar_t*_Format, va_list _ArgList);
	int _snwprintf_s(wchar_t*_DstBuf, size_t _DstSizeInWords, size_t _MaxCount, const wchar_t*_Format, ...);
	int _vsnwprintf_s(wchar_t*_DstBuf, size_t _DstSizeInWords, size_t _MaxCount, const wchar_t*_Format, va_list _ArgList);
	extern "C++"
	{
		;
		;
		template<size_t _SizeFIXED>
		inline int _snwprintf_s(wchar_t(&_Dest)[_SizeFIXED], size_t _Count, const wchar_t*_Format, ...)
		{
			va_list _ArgList;
			(_ArgList=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
			return _vsnwprintf_s(_Dest, _SizeFIXED, _Count, _Format, _ArgList);
		};
	}
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline int _vsnwprintf_s(wchar_t(&_Dest)[_SizeFIXED], size_t _Count, const wchar_t*_Format, va_list _Args)
		{
			return _vsnwprintf_s(_Dest, _SizeFIXED, _Count, _Format, _Args);
		}
	}
	int _snwprintf(wchar_t*_Dest, size_t _Count, const wchar_t*_Format, ...);
	int _vsnwprintf(wchar_t*_Dest, size_t _Count, const wchar_t*_Format, va_list _Args);
	int _fwprintf_p(FILE*_File, const wchar_t*_Format, ...);
	int _wprintf_p(const wchar_t*_Format, ...);
	int _vfwprintf_p(FILE*_File, const wchar_t*_Format, va_list _ArgList);
	int _vwprintf_p(const wchar_t*_Format, va_list _ArgList);
	int _swprintf_p(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, ...);
	int _vswprintf_p(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, va_list _ArgList);
	int _scwprintf_p(const wchar_t*_Format, ...);
	int _vscwprintf_p(const wchar_t*_Format, va_list _ArgList);
	int _wprintf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _wprintf_p_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _wprintf_s_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vwprintf_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vwprintf_s_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _fwprintf_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int _fwprintf_p_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int _fwprintf_s_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int _vfwprintf_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vfwprintf_p_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vfwprintf_s_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _swprintf_c_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _swprintf_p_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _swprintf_s_l(wchar_t*_DstBuf, size_t _DstSize, const wchar_t*_Format, _locale_t _Locale, ...);
	int _vswprintf_c_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vswprintf_p_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vswprintf_s_l(wchar_t*_DstBuf, size_t _DstSize, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _scwprintf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _scwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vscwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _snwprintf_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _snwprintf_s_l(wchar_t*_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _vsnwprintf_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vsnwprintf_s_l(wchar_t*_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _swprintf(wchar_t*_Dest, const wchar_t*_Format, ...);
	int _vswprintf(wchar_t*_Dest, const wchar_t*_Format, va_list _Args);
	int __swprintf_l(wchar_t*_Dest, const wchar_t*_Format, _locale_t _Plocinfo, ...);
	int __vswprintf_l(wchar_t*_Dest, const wchar_t*_Format, _locale_t _Plocinfo, va_list _Args);
	static int swprintf(wchar_t*_String, size_t _Count, const wchar_t*_Format, ...)
	{
		va_list _Arglist;
		int _Ret;
		(_Arglist=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
		_Ret=_vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
		(_Arglist=(va_list)0);
		return _Ret;
	}
	static int vswprintf(wchar_t*_String, size_t _Count, const wchar_t*_Format, va_list _Ap)
	{
		return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
	}
	static int _swprintf_l(wchar_t*_String, size_t _Count, const wchar_t*_Format, _locale_t _Plocinfo, ...)
	{
		va_list _Arglist;
		int _Ret;
		(_Arglist=(va_list)(&reinterpret_cast<const char&>(_Plocinfo))+((sizeof(_Plocinfo)+sizeof(int)-1)&~(sizeof(int)-1)));
		_Ret=_vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
		(_Arglist=(va_list)0);
		return _Ret;
	}
	static int _vswprintf_l(wchar_t*_String, size_t _Count, const wchar_t*_Format, _locale_t _Plocinfo, va_list _Ap)
	{
		return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
	}
	extern "C++" int swprintf(wchar_t*_String, const wchar_t*_Format, ...)
	{
		va_list _Arglist;
		(_Arglist=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
		int _Ret=_vswprintf(_String, _Format, _Arglist);
		(_Arglist=(va_list)0);
		return _Ret;
	}
	extern "C++" int vswprintf(wchar_t*_String, const wchar_t*_Format, va_list _Ap)
	{
		return _vswprintf(_String, _Format, _Ap);
	}
	extern "C++" int _swprintf_l(wchar_t*_String, const wchar_t*_Format, _locale_t _Plocinfo, ...)
	{
		va_list _Arglist;
		(_Arglist=(va_list)(&reinterpret_cast<const char&>(_Plocinfo))+((sizeof(_Plocinfo)+sizeof(int)-1)&~(sizeof(int)-1)));
		int _Ret=__vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
		(_Arglist=(va_list)0);
		return _Ret;
	}
	extern "C++" int _vswprintf_l(wchar_t*_String, const wchar_t*_Format, _locale_t _Plocinfo, va_list _Ap)
	{
		return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
	}
	wchar_t*_wtempnam(const wchar_t*_Directory, const wchar_t*_FilePrefix);
	int _vscwprintf(const wchar_t*_Format, va_list _ArgList);
	int _vscwprintf_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int fwscanf(FILE*_File, const wchar_t*_Format, ...);
	int _fwscanf_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int fwscanf_s(FILE*_File, const wchar_t*_Format, ...);
	int _fwscanf_s_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int swscanf(const wchar_t*_Src, const wchar_t*_Format, ...);
	int _swscanf_l(const wchar_t*_Src, const wchar_t*_Format, _locale_t _Locale, ...);
	int swscanf_s(const wchar_t*_Src, const wchar_t*_Format, ...);
	int _swscanf_s_l(const wchar_t*_Src, const wchar_t*_Format, _locale_t _Locale, ...);
	int _snwscanf(const wchar_t*_Src, size_t _MaxCount, const wchar_t*_Format, ...);
	int _snwscanf_l(const wchar_t*_Src, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _snwscanf_s(const wchar_t*_Src, size_t _MaxCount, const wchar_t*_Format, ...);
	int _snwscanf_s_l(const wchar_t*_Src, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int wscanf(const wchar_t*_Format, ...);
	int _wscanf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int wscanf_s(const wchar_t*_Format, ...);
	int _wscanf_s_l(const wchar_t*_Format, _locale_t _Locale, ...);
	FILE*_wfdopen(int _FileHandle, const wchar_t*_Mode);
	FILE*_wfopen(const wchar_t*_Filename, const wchar_t*_Mode);
	errno_t _wfopen_s(FILE**_File, const wchar_t*_Filename, const wchar_t*_Mode);
	FILE*_wfreopen(const wchar_t*_Filename, const wchar_t*_Mode, FILE*_OldFile);
	errno_t _wfreopen_s(FILE**_File, const wchar_t*_Filename, const wchar_t*_Mode, FILE*_OldFile);
	void _wperror(const wchar_t*_ErrMsg);
	FILE*_wpopen(const wchar_t*_Command, const wchar_t*_Mode);
	int _wremove(const wchar_t*_Filename);
	errno_t _wtmpnam_s(wchar_t*_DstBuf, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wtmpnam_s(wchar_t(&_Buffer)[_SizeFIXED])
		{
			return _wtmpnam_s(_Buffer, _SizeFIXED);
		}
	}
	wchar_t*_wtmpnam(wchar_t*_Buffer);
	wint_t _fgetwc_nolock(FILE*_File);
	wint_t _fputwc_nolock(wchar_t _Ch, FILE*_File);
	wint_t _ungetwc_nolock(wint_t _Ch, FILE*_File);
	inline wint_t getwchar()
	{
		return (fgetwc((&__iob_func()[0])));
	}
	inline wint_t putwchar(wchar_t _C)
	{
		return (fputwc(_C, (&__iob_func()[1])));
	}
	int _fclose_nolock(FILE*_File);
	int _fflush_nolock(FILE*_File);
	size_t _fread_nolock(void*_DstBuf, size_t _ElementSize, size_t _Count, FILE*_File);
	size_t _fread_nolock_s(void*_DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE*_File);
	int _fseek_nolock(FILE*_File, long _Offset, int _Origin);
	long _ftell_nolock(FILE*_File);
	int _fseeki64_nolock(FILE*_File, __int64 _Offset, int _Origin);
	__int64 _ftelli64_nolock(FILE*_File);
	size_t _fwrite_nolock(const void*_DstBuf, size_t _Size, size_t _Count, FILE*_File);
	int _ungetc_nolock(int _Ch, FILE*_File);
}
namespace std
{
	using::size_t;
	using::fpos_t;
	using::FILE;
	using::clearerr;
	using::fclose;
	using::feof;
	using::ferror;
	using::fflush;
	using::fgetc;
	using::fgetpos;
	using::fgets;
	using::fopen;
	using::fprintf;
	using::fputc;
	using::fputs;
	using::fread;
	using::freopen;
	using::fscanf;
	using::fseek;
	using::fsetpos;
	using::ftell;
	using::fwrite;
	using::getc;
	using::getchar;
	using::gets;
	using::perror;
	using::putc;
	using::putchar;
	using::printf;
	using::puts;
	using::remove;
	using::rename;
	using::rewind;
	using::scanf;
	using::setbuf;
	using::setvbuf;
	using::sprintf;
	using::sscanf;
	using::tmpfile;
	using::tmpnam;
	using::ungetc;
	using::vfprintf;
	using::vprintf;
	using::vsprintf;
}
namespace std
{
	using::size_t;
	using::memchr;
	using::memcmp;
	using::memcpy;
	using::memmove;
	using::memset;
	using::strcat;
	using::strchr;
	using::strcmp;
	using::strcoll;
	using::strcpy;
	using::strcspn;
	using::strerror;
	using::strlen;
	using::strncat;
	using::strncmp;
	using::strncpy;
	using::strpbrk;
	using::strrchr;
	using::strspn;
	using::strstr;
	using::strtok;
	using::strxfrm;
}
extern "C"
{
	typedef unsigned long _fsize_t;
	struct _wfinddata32_t
	{
		unsigned attrib;
		__time32_t time_create;
		__time32_t time_access;
		__time32_t time_write;
		_fsize_t size;
		wchar_t name[260];
	};
	struct _wfinddata32i64_t
	{
		unsigned attrib;
		__time32_t time_create;
		__time32_t time_access;
		__time32_t time_write;
		__int64 size;
		wchar_t name[260];
	};
	struct _wfinddata64i32_t
	{
		unsigned attrib;
		__time64_t time_create;
		__time64_t time_access;
		__time64_t time_write;
		_fsize_t size;
		wchar_t name[260];
	};
	struct _wfinddata64_t
	{
		unsigned attrib;
		__time64_t time_create;
		__time64_t time_access;
		__time64_t time_write;
		__int64 size;
		wchar_t name[260];
	};
	const unsigned short*__pctype_func(void);
	extern const unsigned short*_pctype;
	extern const unsigned short _wctype[];
	const wctype_t*__pwctype_func(void);
	extern const wctype_t*_pwctype;
	int iswalpha(wint_t _C);
	int _iswalpha_l(wint_t _C, _locale_t _Locale);
	int iswupper(wint_t _C);
	int _iswupper_l(wint_t _C, _locale_t _Locale);
	int iswlower(wint_t _C);
	int _iswlower_l(wint_t _C, _locale_t _Locale);
	int iswdigit(wint_t _C);
	int _iswdigit_l(wint_t _C, _locale_t _Locale);
	int iswxdigit(wint_t _C);
	int _iswxdigit_l(wint_t _C, _locale_t _Locale);
	int iswspace(wint_t _C);
	int _iswspace_l(wint_t _C, _locale_t _Locale);
	int iswpunct(wint_t _C);
	int _iswpunct_l(wint_t _C, _locale_t _Locale);
	int iswalnum(wint_t _C);
	int _iswalnum_l(wint_t _C, _locale_t _Locale);
	int iswprint(wint_t _C);
	int _iswprint_l(wint_t _C, _locale_t _Locale);
	int iswgraph(wint_t _C);
	int _iswgraph_l(wint_t _C, _locale_t _Locale);
	int iswcntrl(wint_t _C);
	int _iswcntrl_l(wint_t _C, _locale_t _Locale);
	int iswascii(wint_t _C);
	int isleadbyte(int _C);
	int _isleadbyte_l(int _C, _locale_t _Locale);
	wint_t towupper(wint_t _C);
	wint_t _towupper_l(wint_t _C, _locale_t _Locale);
	wint_t towlower(wint_t _C);
	wint_t _towlower_l(wint_t _C, _locale_t _Locale);
	int iswctype(wint_t _C, wctype_t _Type);
	int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale);
	int __iswcsymf(wint_t _C);
	int _iswcsymf_l(wint_t _C, _locale_t _Locale);
	int __iswcsym(wint_t _C);
	int _iswcsym_l(wint_t _C, _locale_t _Locale);
	int is_wctype(wint_t _C, wctype_t _Type);
	wchar_t*_wgetcwd(wchar_t*_DstBuf, int _SizeInWords);
	wchar_t*_wgetdcwd(int _Drive, wchar_t*_DstBuf, int _SizeInWords);
	wchar_t*_wgetdcwd_nolock(int _Drive, wchar_t*_DstBuf, int _SizeInWords);
	int _wchdir(const wchar_t*_Path);
	int _wmkdir(const wchar_t*_Path);
	int _wrmdir(const wchar_t*_Path);
	int _waccess(const wchar_t*_Filename, int _AccessMode);
	errno_t _waccess_s(const wchar_t*_Filename, int _AccessMode);
	int _wchmod(const wchar_t*_Filename, int _Mode);
	int _wcreat(const wchar_t*_Filename, int _PermissionMode);
	intptr_t _wfindfirst32(const wchar_t*_Filename, struct _wfinddata32_t*_FindData);
	int _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t*_FindData);
	int _wunlink(const wchar_t*_Filename);
	int _wrename(const wchar_t*_NewFilename, const wchar_t*_OldFilename);
	errno_t _wmktemp_s(wchar_t*_TemplateName, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wmktemp_s(wchar_t(&_TemplateName)[_SizeFIXED])
		{
			return _wmktemp_s(_TemplateName, _SizeFIXED);
		}
	}
	wchar_t*_wmktemp(wchar_t*_TemplateName);
	intptr_t _wfindfirst32i64(const wchar_t*_Filename, struct _wfinddata32i64_t*_FindData);
	intptr_t _wfindfirst64i32(const wchar_t*_Filename, struct _wfinddata64i32_t*_FindData);
	intptr_t _wfindfirst64(const wchar_t*_Filename, struct _wfinddata64_t*_FindData);
	int _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t*_FindData);
	int _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t*_FindData);
	int _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t*_FindData);
	errno_t _wsopen_s(int*_FileHandle, const wchar_t*_Filename, int _OpenFlag, int _ShareFlag, int _PermissionFlag);
	extern "C++" int _wopen(const wchar_t*_Filename, int _OpenFlag, int _PermissionMode=0);
	extern "C++" int _wsopen(const wchar_t*_Filename, int _OpenFlag, int _ShareFlag, int _PermissionMode=0);
	wchar_t*_wsetlocale(int _Category, const wchar_t*_Locale);
	intptr_t _wexecl(const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wexecle(const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wexeclp(const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wexeclpe(const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wexecv(const wchar_t*_Filename, const wchar_t*const*_ArgList);
	intptr_t _wexecve(const wchar_t*_Filename, const wchar_t*const*_ArgList, const wchar_t*const*_Env);
	intptr_t _wexecvp(const wchar_t*_Filename, const wchar_t*const*_ArgList);
	intptr_t _wexecvpe(const wchar_t*_Filename, const wchar_t*const*_ArgList, const wchar_t*const*_Env);
	intptr_t _wspawnl(int _Mode, const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wspawnle(int _Mode, const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wspawnlp(int _Mode, const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wspawnlpe(int _Mode, const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wspawnv(int _Mode, const wchar_t*_Filename, const wchar_t*const*_ArgList);
	intptr_t _wspawnve(int _Mode, const wchar_t*_Filename, const wchar_t*const*_ArgList, const wchar_t*const*_Env);
	intptr_t _wspawnvp(int _Mode, const wchar_t*_Filename, const wchar_t*const*_ArgList);
	intptr_t _wspawnvpe(int _Mode, const wchar_t*_Filename, const wchar_t*const*_ArgList, const wchar_t*const*_Env);
	int _wsystem(const wchar_t*_Command);
	typedef unsigned short _ino_t;
	typedef unsigned int _dev_t;
	typedef long _off_t;
	struct _stat32
	{
		_dev_t st_dev;
		_ino_t st_ino;
		unsigned short st_mode;
		short st_nlink;
		short st_uid;
		short st_gid;
		_dev_t st_rdev;
		_off_t st_size;
		__time32_t st_atime;
		__time32_t st_mtime;
		__time32_t st_ctime;
	};
	struct _stat32i64
	{
		_dev_t st_dev;
		_ino_t st_ino;
		unsigned short st_mode;
		short st_nlink;
		short st_uid;
		short st_gid;
		_dev_t st_rdev;
		__int64 st_size;
		__time32_t st_atime;
		__time32_t st_mtime;
		__time32_t st_ctime;
	};
	struct _stat64i32
	{
		_dev_t st_dev;
		_ino_t st_ino;
		unsigned short st_mode;
		short st_nlink;
		short st_uid;
		short st_gid;
		_dev_t st_rdev;
		_off_t st_size;
		__time64_t st_atime;
		__time64_t st_mtime;
		__time64_t st_ctime;
	};
	struct _stat64
	{
		_dev_t st_dev;
		_ino_t st_ino;
		unsigned short st_mode;
		short st_nlink;
		short st_uid;
		short st_gid;
		_dev_t st_rdev;
		__int64 st_size;
		__time64_t st_atime;
		__time64_t st_mtime;
		__time64_t st_ctime;
	};
	int _wstat32(const wchar_t*_Name, struct _stat32*_Stat);
	int _wstat32i64(const wchar_t*_Name, struct _stat32i64*_Stat);
	int _wstat64i32(const wchar_t*_Name, struct _stat64i32*_Stat);
	int _wstat64(const wchar_t*_Name, struct _stat64*_Stat);
	errno_t _cgetws_s(wchar_t*_Buffer, size_t _SizeInWords, size_t*_SizeRead);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _cgetws_s(wchar_t(&_Buffer)[_SizeFIXED], size_t*_Size)
		{
			return _cgetws_s(_Buffer, _SizeFIXED, _Size);
		}
	}
	wchar_t*_cgetws(wchar_t*_Buffer);
	wint_t _getwch(void);
	wint_t _getwche(void);
	wint_t _putwch(wchar_t _WCh);
	wint_t _ungetwch(wint_t _WCh);
	int _cputws(const wchar_t*_String);
	int _cwprintf(const wchar_t*_Format, ...);
	int _cwprintf_s(const wchar_t*_Format, ...);
	int _cwscanf(const wchar_t*_Format, ...);
	int _cwscanf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _cwscanf_s(const wchar_t*_Format, ...);
	int _cwscanf_s_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vcwprintf(const wchar_t*_Format, va_list _ArgList);
	int _vcwprintf_s(const wchar_t*_Format, va_list _ArgList);
	int _cwprintf_p(const wchar_t*_Format, ...);
	int _vcwprintf_p(const wchar_t*_Format, va_list _ArgList);
	int _cwprintf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _cwprintf_s_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vcwprintf_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vcwprintf_s_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _cwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vcwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	wint_t _putwch_nolock(wchar_t _WCh);
	wint_t _getwch_nolock(void);
	wint_t _getwche_nolock(void);
	wint_t _ungetwch_nolock(wint_t _WCh);
	errno_t _itow_s(int _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _itow_s(int _Value, wchar_t(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _itow_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	wchar_t*_itow(int _Value, wchar_t*_Dest, int _Radix);
	errno_t _ltow_s(long _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ltow_s(long _Value, wchar_t(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _ltow_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	wchar_t*_ltow(long _Value, wchar_t*_Dest, int _Radix);
	errno_t _ultow_s(unsigned long _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ultow_s(unsigned long _Value, wchar_t(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _ultow_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	wchar_t*_ultow(unsigned long _Value, wchar_t*_Dest, int _Radix);
	double wcstod(const wchar_t*_Str, wchar_t**_EndPtr);
	double _wcstod_l(const wchar_t*_Str, wchar_t**_EndPtr, _locale_t _Locale);
	long wcstol(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix);
	long _wcstol_l(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix, _locale_t _Locale);
	unsigned long wcstoul(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix);
	unsigned long _wcstoul_l(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix, _locale_t _Locale);
	wchar_t*_wgetenv(const wchar_t*_VarName);
	errno_t _wgetenv_s(size_t*_ReturnSize, wchar_t*_DstBuf, size_t _DstSizeInWords, const wchar_t*_VarName);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wgetenv_s(size_t*_ReturnSize, wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_VarName)
		{
			return _wgetenv_s(_ReturnSize, _Dest, _SizeFIXED, _VarName);
		}
	}
	errno_t _wdupenv_s(wchar_t**_Buffer, size_t*_BufferSizeInWords, const wchar_t*_VarName);
	double _wtof(const wchar_t*_Str);
	double _wtof_l(const wchar_t*_Str, _locale_t _Locale);
	int _wtoi(const wchar_t*_Str);
	int _wtoi_l(const wchar_t*_Str, _locale_t _Locale);
	long _wtol(const wchar_t*_Str);
	long _wtol_l(const wchar_t*_Str, _locale_t _Locale);
	errno_t _i64tow_s(__int64 _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	wchar_t*_i64tow(__int64 _Val, wchar_t*_DstBuf, int _Radix);
	errno_t _ui64tow_s(unsigned __int64 _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	wchar_t*_ui64tow(unsigned __int64 _Val, wchar_t*_DstBuf, int _Radix);
	__int64 _wtoi64(const wchar_t*_Str);
	__int64 _wtoi64_l(const wchar_t*_Str, _locale_t _Locale);
	__int64 _wcstoi64(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix);
	__int64 _wcstoi64_l(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix, _locale_t _Locale);
	unsigned __int64 _wcstoui64(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix);
	unsigned __int64 _wcstoui64_l(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix, _locale_t _Locale);
	wchar_t*_wfullpath(wchar_t*_FullPath, const wchar_t*_Path, size_t _SizeInWords);
	errno_t _wmakepath_s(wchar_t*_PathResult, size_t _SizeInWords, const wchar_t*_Drive, const wchar_t*_Dir, const wchar_t*_Filename, const wchar_t*_Ext);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wmakepath_s(wchar_t(&_ResultPath)[_SizeFIXED], const wchar_t*_Drive, const wchar_t*_Dir, const wchar_t*_Filename, const wchar_t*_Ext)
		{
			return _wmakepath_s(_ResultPath, _SizeFIXED, _Drive, _Dir, _Filename, _Ext);
		}
	}
	void _wmakepath(wchar_t*_ResultPath, const wchar_t*_Drive, const wchar_t*_Dir, const wchar_t*_Filename, const wchar_t*_Ext);
	int _wputenv(const wchar_t*_EnvString);
	errno_t _wputenv_s(const wchar_t*_Name, const wchar_t*_Value);
	errno_t _wsearchenv_s(const wchar_t*_Filename, const wchar_t*_EnvVar, wchar_t*_ResultPath, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wsearchenv_s(const wchar_t*_Filename, const wchar_t*_EnvVar, wchar_t(&_ResultPath)[_SizeFIXED])
		{
			return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _SizeFIXED);
		}
	}
	void _wsearchenv(const wchar_t*_Filename, const wchar_t*_EnvVar, wchar_t*_ResultPath);
	void _wsplitpath(const wchar_t*_FullPath, wchar_t*_Drive, wchar_t*_Dir, wchar_t*_Filename, wchar_t*_Ext);
	errno_t _wsplitpath_s(const wchar_t*_FullPath, wchar_t*_Drive, size_t _DriveSizeInWords, wchar_t*_Dir, size_t _DirSizeInWords, wchar_t*_Filename, size_t _FilenameSizeInWords, wchar_t*_Ext, size_t _ExtSizeInWords);
	extern "C++"
	{
		template<size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>
		inline errno_t _wsplitpath_s(const wchar_t*_Path, wchar_t(&_Drive)[_DriveSize], wchar_t(&_Dir)[_DirSize], wchar_t(&_Name)[_NameSize], wchar_t(&_Ext)[_ExtSize])
		{
			return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize);
		}
	}
	struct tm
	{
		int tm_sec;
		int tm_min;
		int tm_hour;
		int tm_mday;
		int tm_mon;
		int tm_year;
		int tm_wday;
		int tm_yday;
		int tm_isdst;
	};
	wchar_t*_wasctime(const struct tm*_Tm);
	errno_t _wasctime_s(wchar_t*_Buf, size_t _SizeInWords, const struct tm*_Tm);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wasctime_s(wchar_t(&_Buffer)[_SizeFIXED], const struct tm*_Time)
		{
			return _wasctime_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	wchar_t*_wctime32(const __time32_t*_Time);
	errno_t _wctime32_s(wchar_t*_Buf, size_t _SizeInWords, const __time32_t*_Time);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wctime32_s(wchar_t(&_Buffer)[_SizeFIXED], const __time32_t*_Time)
		{
			return _wctime32_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	size_t wcsftime(wchar_t*_Buf, size_t _SizeInWords, const wchar_t*_Format, const struct tm*_Tm);
	size_t _wcsftime_l(wchar_t*_Buf, size_t _SizeInWords, const wchar_t*_Format, const struct tm*_Tm, _locale_t _Locale);
	errno_t _wstrdate_s(wchar_t*_Buf, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wstrdate_s(wchar_t(&_Buffer)[_SizeFIXED])
		{
			return _wstrdate_s(_Buffer, _SizeFIXED);
		}
	}
	wchar_t*_wstrdate(wchar_t*_Buffer);
	errno_t _wstrtime_s(wchar_t*_Buf, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wstrtime_s(wchar_t(&_Buffer)[_SizeFIXED])
		{
			return _wstrtime_s(_Buffer, _SizeFIXED);
		}
	}
	wchar_t*_wstrtime(wchar_t*_Buffer);
	wchar_t*_wctime64(const __time64_t*_Time);
	errno_t _wctime64_s(wchar_t*_Buf, size_t _SizeInWords, const __time64_t*_Time);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wctime64_s(wchar_t(&_Buffer)[_SizeFIXED], const __time64_t*_Time)
		{
			return _wctime64_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	static wchar_t*_wctime(const time_t*_Time)
	{
		return _wctime64(_Time);
	}
	static errno_t _wctime_s(wchar_t*_Buffer, size_t _SizeInWords, const time_t*_Time)
	{
		return _wctime64_s(_Buffer, _SizeInWords, _Time);
	}
	typedef int mbstate_t;
	typedef wchar_t _Wint_t;
	wint_t btowc(int);
	size_t mbrlen(const char*_Ch, size_t _SizeInBytes, mbstate_t*_State);
	size_t mbrtowc(wchar_t*_DstCh, const char*_SrcCh, size_t _SizeInBytes, mbstate_t*_State);
	errno_t mbsrtowcs_s(size_t*_Retval, wchar_t*_Dst, size_t _SizeInWords, const char**_PSrc, size_t _N, mbstate_t*_State);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t mbsrtowcs_s(size_t*_Retval, wchar_t(&_Dest)[_SizeFIXED], const char**_PSource, size_t _Count, mbstate_t*_State)
		{
			return mbsrtowcs_s(_Retval, _Dest, _SizeFIXED, _PSource, _Count, _State);
		}
	}
	size_t mbsrtowcs(wchar_t*_Dest, const char**_PSrc, size_t _Count, mbstate_t*_State);
	errno_t wcrtomb_s(size_t*_Retval, char*_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t*_State);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcrtomb_s(size_t*_Retval, char(&_Dest)[_SizeFIXED], wchar_t _Source, mbstate_t*_State)
		{
			return wcrtomb_s(_Retval, _Dest, _SizeFIXED, _Source, _State);
		}
	}
	size_t wcrtomb(char*_Dest, wchar_t _Source, mbstate_t*_State);
	errno_t wcsrtombs_s(size_t*_Retval, char*_Dst, size_t _SizeInBytes, const wchar_t**_Src, size_t _Size, mbstate_t*_State);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcsrtombs_s(size_t*_Retval, char(&_Dest)[_SizeFIXED], const wchar_t**_PSrc, size_t _Count, mbstate_t*_State)
		{
			return wcsrtombs_s(_Retval, _Dest, _SizeFIXED, _PSrc, _Count, _State);
		}
	}
	size_t wcsrtombs(char*_Dest, const wchar_t**_PSource, size_t _Count, mbstate_t*_State);
	int wctob(wint_t _WCh);
	void*memmove(void*_Dst, const void*_Src, size_t _MaxCount);
	void*memcpy(void*_Dst, const void*_Src, size_t _MaxCount);
	errno_t memcpy_s(void*_Dst, rsize_t _DstSize, const void*_Src, rsize_t _MaxCount);
	errno_t memmove_s(void*_Dst, rsize_t _DstSize, const void*_Src, rsize_t _MaxCount);
	int fwide(FILE*_F, int _M)
	{
		(void)_F;
		return (_M);
	}
	int mbsinit(const mbstate_t*_P)
	{
		return (_P==0||*_P==0);
	}
	const wchar_t*wmemchr(const wchar_t*_S, wchar_t _C, size_t _N)
	{
		for(;
		0<_N;
		++_S, --_N)if(*_S==_C)return (const wchar_t*)(_S);
		return (0);
	}
	int wmemcmp(const wchar_t*_S1, const wchar_t*_S2, size_t _N)
	{
		for(;
		0<_N;
		++_S1, ++_S2, --_N)if(*_S1!=*_S2)return (*_S1<*_S2?-1: +1);
		return (0);
	}
	wchar_t*wmemcpy(wchar_t*_S1, const wchar_t*_S2, size_t _N)
	{
		return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
	}
	errno_t wmemcpy_s(wchar_t*_S1, rsize_t _N1, const wchar_t*_S2, rsize_t _N)
	{
		return memcpy_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
	}
	wchar_t*wmemmove(wchar_t*_S1, const wchar_t*_S2, size_t _N)
	{
		return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
	}
	errno_t wmemmove_s(wchar_t*_S1, rsize_t _N1, const wchar_t*_S2, rsize_t _N)
	{
		return memmove_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
	}
	wchar_t*wmemset(wchar_t*_S, wchar_t _C, size_t _N)
	{
		wchar_t*_Su=_S;
		for(;
		0<_N;
		++_Su, --_N)
		{
			*_Su=_C;
		}
		return (_S);
	}
	extern "C++"
	{
		inline wchar_t*wmemchr(wchar_t*_S, wchar_t _C, size_t _N)
		{
			return (wchar_t*)wmemchr((const wchar_t*)_S, _C, _N);
		}
	}
}
typedef mbstate_t _Mbstatet;
namespace std
{
	using::mbstate_t;
	using::size_t;
	using::tm;
	using::wint_t;
	using::btowc;
	using::fgetwc;
	using::fgetws;
	using::fputwc;
	using::fputws;
	using::fwide;
	using::fwprintf;
	using::fwscanf;
	using::getwc;
	using::getwchar;
	using::mbrlen;
	using::mbrtowc;
	using::mbsrtowcs;
	using::mbsinit;
	using::putwc;
	using::putwchar;
	using::swprintf;
	using::swscanf;
	using::ungetwc;
	using::vfwprintf;
	using::vswprintf;
	using::vwprintf;
	using::wcrtomb;
	using::wprintf;
	using::wscanf;
	using::wcsrtombs;
	using::wcstol;
	using::wcscat;
	using::wcschr;
	using::wcscmp;
	using::wcscoll;
	using::wcscpy;
	using::wcscspn;
	using::wcslen;
	using::wcsncat;
	using::wcsncmp;
	using::wcsncpy;
	using::wcspbrk;
	using::wcsrchr;
	using::wcsspn;
	using::wcstod;
	using::wcstoul;
	using::wcsstr;
	using::wcstok;
	using::wcsxfrm;
	using::wctob;
	using::wmemchr;
	using::wmemcmp;
	using::wmemcpy;
	using::wmemmove;
	using::wmemset;
	using::wcsftime;
}
extern "C"
{
	extern int*_errno(void);
	errno_t _set_errno(int _Value);
	errno_t _get_errno(int*_Value);
}
namespace std
{
	using::ptrdiff_t;
	using::size_t;
}
namespace std
{
	enum _Uninitialized
	{
		_Noinit
	};
}
extern "C"
{
	typedef void*_HFILE;
	typedef int(*_CRT_REPORT_HOOK)(int, char*, int*);
	typedef int(*_CRT_REPORT_HOOKW)(int, wchar_t*, int*);
	typedef int(*_CRT_ALLOC_HOOK)(int, void*, size_t, int, long, const unsigned char*, int);
	typedef void(*_CRT_DUMP_CLIENT)(void*, size_t);
	struct _CrtMemBlockHeader;
	typedef struct _CrtMemState
	{
		struct _CrtMemBlockHeader*pBlockHeader;
		size_t lCounts[5];
		size_t lSizes[5];
		size_t lHighWaterCount;
		size_t lTotalCount;
	}
	_CrtMemState;
	extern long _crtAssertBusy;
	_CRT_REPORT_HOOK _CrtGetReportHook(void);
	_CRT_REPORT_HOOK _CrtSetReportHook(_CRT_REPORT_HOOK _PFnNewHook);
	int _CrtSetReportHook2(int _Mode, _CRT_REPORT_HOOK _PFnNewHook);
	int _CrtSetReportHookW2(int _Mode, _CRT_REPORT_HOOKW _PFnNewHook);
	int _CrtSetReportMode(int _ReportType, int _ReportMode);
	_HFILE _CrtSetReportFile(int _ReportType, _HFILE _ReportFile);
	int _CrtDbgReport(int _ReportType, const char*_Filename, int _Linenumber, const char*_ModuleName, const char*_Format, ...);
	size_t _CrtSetDebugFillThreshold(size_t _NewDebugFillThreshold);
	int _CrtDbgReportW(int _ReportType, const wchar_t*_Filename, int _LineNumber, const wchar_t*_ModuleName, const wchar_t*_Format, ...);
	extern long _crtBreakAlloc;
	long _CrtSetBreakAlloc(long _BreakAlloc);
	void*_malloc_dbg(size_t _Size, int _BlockType, const char*_Filename, int _LineNumber);
	void*_calloc_dbg(size_t _NumOfElements, size_t _SizeOfElements, int _BlockType, const char*_Filename, int _LineNumber);
	void*_realloc_dbg(void*_Memory, size_t _NewSize, int _BlockType, const char*_Filename, int _LineNumber);
	void*_recalloc_dbg(void*_Memory, size_t _NumOfElements, size_t _SizeOfElements, int _BlockType, const char*_Filename, int _LineNumber);
	void*_expand_dbg(void*_Memory, size_t _NewSize, int _BlockType, const char*_Filename, int _LineNumber);
	void _free_dbg(void*_Memory, int _BlockType);
	size_t _msize_dbg(void*_Memory, int _BlockType);
	void*_aligned_malloc_dbg(size_t _Size, size_t _Alignment, const char*_Filename, int _LineNumber);
	void*_aligned_realloc_dbg(void*_Memory, size_t _Size, size_t _Alignment, const char*_Filename, int _LineNumber);
	void*_aligned_recalloc_dbg(void*_Memory, size_t _NumOfElements, size_t _SizeOfElements, size_t _Alignment, const char*_Filename, int _LineNumber);
	void*_aligned_offset_malloc_dbg(size_t _Size, size_t _Alignment, size_t _Offset, const char*_Filename, int _LineNumber);
	void*_aligned_offset_realloc_dbg(void*_Memory, size_t _Size, size_t _Alignment, size_t _Offset, const char*_Filename, int _LineNumber);
	void*_aligned_offset_recalloc_dbg(void*_Memory, size_t _NumOfElements, size_t _SizeOfElements, size_t _Alignment, size_t _Offset, const char*_Filename, int _LineNumber);
	void _aligned_free_dbg(void*_Memory);
	char*_strdup_dbg(const char*_Str, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wcsdup_dbg(const wchar_t*_Str, int _BlockType, const char*_Filename, int _LineNumber);
	char*_tempnam_dbg(const char*_DirName, const char*_FilePrefix, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wtempnam_dbg(const wchar_t*_DirName, const wchar_t*_FilePrefix, int _BlockType, const char*_Filename, int _LineNumber);
	char*_fullpath_dbg(char*_FullPath, const char*_Path, size_t _SizeInBytes, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wfullpath_dbg(wchar_t*_FullPath, const wchar_t*_Path, size_t _SizeInWords, int _BlockType, const char*_Filename, int _LineNumber);
	char*_getcwd_dbg(char*_DstBuf, int _SizeInBytes, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wgetcwd_dbg(wchar_t*_DstBuf, int _SizeInWords, int _BlockType, const char*_Filename, int _LineNumber);
	char*_getdcwd_dbg(int _Drive, char*_DstBuf, int _SizeInBytes, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wgetdcwd_dbg(int _Drive, wchar_t*_DstBuf, int _SizeInWords, int _BlockType, const char*_Filename, int _LineNumber);
	char*_getdcwd_lk_dbg(int _Drive, char*_DstBuf, int _SizeInBytes, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wgetdcwd_lk_dbg(int _Drive, wchar_t*_DstBuf, int _SizeInWords, int _BlockType, const char*_Filename, int _LineNumber);
	errno_t _dupenv_s_dbg(char**_PBuffer, size_t*_PBufferSizeInBytes, const char*_VarName, int _BlockType, const char*_Filename, int _LineNumber);
	errno_t _wdupenv_s_dbg(wchar_t**_PBuffer, size_t*_PBufferSizeInWords, const wchar_t*_VarName, int _BlockType, const char*_Filename, int _LineNumber);
	_CRT_ALLOC_HOOK _CrtGetAllocHook(void);
	_CRT_ALLOC_HOOK _CrtSetAllocHook(_CRT_ALLOC_HOOK _PfnNewHook);
	extern int _crtDbgFlag;
	int _CrtCheckMemory(void);
	int _CrtSetDbgFlag(int _NewFlag);
	void _CrtDoForAllClientObjects(void(*_PFn)(void*, void*), void*_Context);
	int _CrtIsValidPointer(const void*_Ptr, unsigned int _Bytes, int _ReadWrite);
	int _CrtIsValidHeapPointer(const void*_HeapPtr);
	int _CrtIsMemoryBlock(const void*_Memory, unsigned int _Bytes, long*_RequestNumber, char**_Filename, int*_LineNumber);
	int _CrtReportBlockType(const void*_Memory);
	_CRT_DUMP_CLIENT _CrtGetDumpClient(void);
	_CRT_DUMP_CLIENT _CrtSetDumpClient(_CRT_DUMP_CLIENT _PFnNewDump);
	void _CrtMemCheckpoint(_CrtMemState*_State);
	int _CrtMemDifference(_CrtMemState*_State, const _CrtMemState*_OldState, const _CrtMemState*_NewState);
	void _CrtMemDumpAllObjectsSince(const _CrtMemState*_State);
	void _CrtMemDumpStatistics(const _CrtMemState*_State);
	int _CrtDumpMemoryLeaks(void);
	int _CrtSetCheckCount(int _CheckCount);
	int _CrtGetCheckCount(void);
}
extern "C++"
{
	void*operator new[](size_t _Size);
	void*operator new(size_t _Size, int, const char*, int);
	void*operator new[](size_t _Size, int, const char*, int);
	void operator delete[](void*);
	inline void operator delete(void*_P, int, const char*, int)
	{
		::operator delete(_P);
	}
	inline void operator delete[](void*_P, int, const char*, int)
	{
		::operator delete[](_P);
	}
}
namespace std
{
	typedef long streamoff;
	typedef int streamsize;
	extern fpos_t _Fpz;
	extern const streamoff _BADOFF;
	template<class _Statetype>
	class fpos
	{
		typedef fpos<_Statetype>_Myt;
	public:
		fpos(streamoff _Off=0): _Myoff(_Off), _Fpos(0), _Mystate(_Stz)
		{
		}
		fpos(_Statetype _State, fpos_t _Fileposition): _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{
		}
		_Statetype state()const
		{
			return (_Mystate);
		}
		void state(_Statetype _State)
		{
			_Mystate=_State;
		}
		fpos_t seekpos()const
		{
			return (_Fpos);
		}
		operator streamoff()const
		{
			return (_Myoff+((long)(_Fpos)));
		}
		streamoff operator-(const _Myt&_Right)const
		{
			return ((streamoff)*this-(streamoff)_Right);
		}
		_Myt&operator+=(streamoff _Off)
		{
			_Myoff+=_Off;
			return (*this);
		}
		_Myt&operator-=(streamoff _Off)
		{
			_Myoff-=_Off;
			return (*this);
		}
		_Myt operator+(streamoff _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt operator-(streamoff _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		bool operator==(const _Myt&_Right)const
		{
			return ((streamoff)*this==(streamoff)_Right);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
	private:
		static const _Statetype _Stz;
		streamoff _Myoff;
		fpos_t _Fpos;
		_Statetype _Mystate;
	};
	template<class _Statetype>
	const _Statetype fpos<_Statetype>::_Stz=_Statetype();
	typedef fpos<_Mbstatet>streampos;
	typedef streampos wstreampos;
	struct _Unsecure_char_traits_tag
	{
	};
	struct _Secure_char_traits_tag
	{
	};
	struct _Char_traits_base
	{
		typedef _Unsecure_char_traits_tag _Secure_char_traits;
	};
	template<class _Elem>
	struct char_traits: public _Char_traits_base
	{
		typedef _Elem char_type;
		typedef long int_type;
		typedef streampos pos_type;
		typedef streamoff off_type;
		typedef _Mbstatet state_type;
		static void assign(_Elem&_Left, const _Elem&_Right)
		{
			_Left=_Right;
		}
		static bool eq(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left==_Right);
		}
		static bool lt(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left<_Right);
		}
		static int compare(const _Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			for(;
			0<_Count;
			--_Count, ++_First1, ++_First2)if(!eq(*_First1, *_First2))return (lt(*_First1, *_First2)?-1: +1);
			return (0);
		}
		static size_t length(const _Elem*_First)
		{
			size_t _Count;
			for(_Count=0;
			!eq(*_First, _Elem());
			++_First)++_Count;
			return (_Count);
		}
		static _Elem*copy(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Copy_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Copy_s(_Elem*_First1, size_t _Dest_size, const _Elem*_First2, size_t _Count)
		{

			{
				if(!(_Dest_size>=_Count))
				{
					(void)((!!((("_Dest_size >= _Count", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iosfwd", 212, 0, L"(\"_Dest_size >= _Count\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"_Dest_size >= _Count", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iosfwd", 212, 0);
					return (0);
				}
			};
			_Elem*_Next=_First1;
			for(;
			0<_Count;
			--_Count, ++_Next, ++_First2)assign(*_Next, *_First2);
			return (_First1);
		}
		static const _Elem*find(const _Elem*_First, size_t _Count, const _Elem&_Ch)
		{
			for(;
			0<_Count;
			--_Count, ++_First)if(eq(*_First, _Ch))return (_First);
			return (0);
		}
		static _Elem*move(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Move_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Move_s(_Elem*_First1, size_t _Dest_size, const _Elem*_First2, size_t _Count)
		{

			{
				if(!(_Dest_size>=_Count))
				{
					(void)((!!((("_Dest_size >= _Count", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iosfwd", 242, 0, L"(\"_Dest_size >= _Count\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"_Dest_size >= _Count", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iosfwd", 242, 0);
					return (0);
				}
			};
			_Elem*_Next=_First1;
			if(_First2<_Next&&_Next<_First2+_Count)for(_Next+=_Count, _First2+=_Count;
			0<_Count;
			--_Count)assign(*--_Next, *--_First2);
			else for(;
			0<_Count;
			--_Count, ++_Next, ++_First2)assign(*_Next, *_First2);
			return (_First1);
		}
		static _Elem*assign(_Elem*_First, size_t _Count, _Elem _Ch)
		{
			_Elem*_Next=_First;
			for(;
			0<_Count;
			--_Count, ++_Next)assign(*_Next, _Ch);
			return (_First);
		}
		static _Elem to_char_type(const int_type&_Meta)
		{
			return ((_Elem)_Meta);
		}
		static int_type to_int_type(const _Elem&_Ch)
		{
			return ((int_type)_Ch);
		}
		static bool eq_int_type(const int_type&_Left, const int_type&_Right)
		{
			return (_Left==_Right);
		}
		static int_type eof()
		{
			return ((int_type)(-1));
		}
		static int_type not_eof(const int_type&_Meta)
		{
			return (_Meta!=eof()?(int_type)_Meta: (int_type)!eof());
		}
	};
	template<>
	struct char_traits<wchar_t>: public _Char_traits_base
	{
		typedef wchar_t _Elem;
		typedef _Elem char_type;
		typedef wint_t int_type;
		typedef streampos pos_type;
		typedef streamoff off_type;
		typedef _Mbstatet state_type;
		static void assign(_Elem&_Left, const _Elem&_Right)
		{
			_Left=_Right;
		}
		static bool eq(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left==_Right);
		}
		static bool lt(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left<_Right);
		}
		static int compare(const _Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return (::wmemcmp(_First1, _First2, _Count));
		}
		static size_t length(const _Elem*_First)
		{
			return (::wcslen(_First));
		}
		static _Elem*copy(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Copy_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Copy_s(_Elem*_First1, size_t _Size_in_words, const _Elem*_First2, size_t _Count)
		{
			::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
			return _First1;
		}
		static const _Elem*find(const _Elem*_First, size_t _Count, const _Elem&_Ch)
		{
			return ((const _Elem*)::wmemchr(_First, _Ch, _Count));
		}
		static _Elem*move(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Move_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Move_s(_Elem*_First1, size_t _Size_in_words, const _Elem*_First2, size_t _Count)
		{
			::wmemmove_s((_First1), (_Size_in_words), (_First2), (_Count));
			return (_Elem*)_First1;
		}
		static _Elem*assign(_Elem*_First, size_t _Count, _Elem _Ch)
		{
			return ((_Elem*)::wmemset(_First, _Ch, _Count));
		}
		static _Elem to_char_type(const int_type&_Meta)
		{
			return (_Meta);
		}
		static int_type to_int_type(const _Elem&_Ch)
		{
			return (_Ch);
		}
		static bool eq_int_type(const int_type&_Left, const int_type&_Right)
		{
			return (_Left==_Right);
		}
		static int_type eof()
		{
			return ((wint_t)(0xFFFF));
		}
		static int_type not_eof(const int_type&_Meta)
		{
			return (_Meta!=eof()?_Meta: !eof());
		}
	};
	template<>
	struct char_traits<char>: public _Char_traits_base
	{
		typedef char _Elem;
		typedef _Elem char_type;
		typedef int int_type;
		typedef streampos pos_type;
		typedef streamoff off_type;
		typedef _Mbstatet state_type;
		static void assign(_Elem&_Left, const _Elem&_Right)
		{
			_Left=_Right;
		}
		static bool eq(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left==_Right);
		}
		static bool lt(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left<_Right);
		}
		static int compare(const _Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return (::memcmp(_First1, _First2, _Count));
		}
		static size_t length(const _Elem*_First)
		{
			return (::strlen(_First));
		}
		static _Elem*copy(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Copy_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Copy_s(_Elem*_First1, size_t _Size_in_bytes, const _Elem*_First2, size_t _Count)
		{
			::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
			return _First1;
		}
		static const _Elem*find(const _Elem*_First, size_t _Count, const _Elem&_Ch)
		{
			return ((const _Elem*)::memchr(_First, _Ch, _Count));
		}
		static _Elem*move(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Move_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Move_s(_Elem*_First1, size_t _Size_in_bytes, const _Elem*_First2, size_t _Count)
		{
			::memmove_s((_First1), (_Size_in_bytes), (_First2), (_Count));
			return _First1;
		}
		static _Elem*assign(_Elem*_First, size_t _Count, _Elem _Ch)
		{
			return ((_Elem*)::memset(_First, _Ch, _Count));
		}
		static _Elem to_char_type(const int_type&_Meta)
		{
			return ((_Elem)_Meta);
		}
		static int_type to_int_type(const _Elem&_Ch)
		{
			return ((unsigned char)_Ch);
		}
		static bool eq_int_type(const int_type&_Left, const int_type&_Right)
		{
			return (_Left==_Right);
		}
		static int_type eof()
		{
			return ((-1));
		}
		static int_type not_eof(const int_type&_Meta)
		{
			return (_Meta!=eof()?_Meta: !eof());
		}
	};
	template<class _Traits>
	class _Inherits_from_char_traits_base
	{
		typedef char _True;
		class _False
		{
			char _Dummy[2];
		};
		static _True _Inherits(_Char_traits_base);
		static _False _Inherits(...);
		static _Traits _Make_traits();
	public:
		enum
		{
			_Exists=sizeof(_Inherits(_Make_traits()))==sizeof(_True)
		};
	};
	template<class _Traits, bool _Inherits_from_char_traits_base>
	class _Char_traits_category_helper
	{
	public:
		typedef _Unsecure_char_traits_tag _Secure_char_traits;
	};
	template<class _Elem>
	class _Char_traits_category_helper<char_traits<_Elem>, true>
	{
	public:
		typedef _Secure_char_traits_tag _Secure_char_traits;
	};
	template<class _Traits>
	class _Char_traits_category_helper<_Traits, true>
	{
	public:
		typedef typename _Traits::_Secure_char_traits _Secure_char_traits;
	};
	template<class _Traits>
	class _Char_traits_category
	{
	public:
		typedef typename _Char_traits_category_helper<_Traits, _Inherits_from_char_traits_base<_Traits>::_Exists>::_Secure_char_traits _Secure_char_traits;
	};
	template<class _Traits>
	inline typename _Char_traits_category<_Traits>::_Secure_char_traits _Char_traits_cat()
	{
		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
		return (_Secure);
	}
	namespace _Traits_helper
	{
		template<class _Traits>
		inline typename _Traits::char_type*copy_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count)
		{
			return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());
		}
		template<class _Traits>
		inline typename _Traits::char_type*copy_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count, _Secure_char_traits_tag)
		{
			return _Traits::_Copy_s(_First1, _Size, _First2, _Count);
		}
		template<class _Traits>
		inline typename _Traits::char_type*copy_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count, _Unsecure_char_traits_tag)
		{
			return _Traits::copy(_First1, _First2, _Count);
		}
		template<class _Traits>
		inline typename _Traits::char_type*move_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count)
		{
			return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());
		}
		template<class _Traits>
		inline typename _Traits::char_type*move_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count, _Secure_char_traits_tag)
		{
			return _Traits::_Move_s(_First1, _Size, _First2, _Count);
		}
		template<class _Traits>
		inline typename _Traits::char_type*move_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count, _Unsecure_char_traits_tag)
		{
			return _Traits::move(_First1, _First2, _Count);
		}
	}
	template<class _Ty>
	class allocator;
	class ios_base;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_ios;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class istreambuf_iterator;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class ostreambuf_iterator;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_streambuf;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_istream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_ostream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_iostream;
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Alloc=allocator<_Elem> >
	class basic_stringbuf;
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Alloc=allocator<_Elem> >
	class basic_istringstream;
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Alloc=allocator<_Elem> >
	class basic_ostringstream;
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Alloc=allocator<_Elem> >
	class basic_stringstream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_filebuf;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_ifstream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_ofstream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_fstream;
	typedef basic_ios<char, char_traits<char> >ios;
	typedef basic_streambuf<char, char_traits<char> >streambuf;
	typedef basic_istream<char, char_traits<char> >istream;
	typedef basic_ostream<char, char_traits<char> >ostream;
	typedef basic_iostream<char, char_traits<char> >iostream;
	typedef basic_stringbuf<char, char_traits<char>, allocator<char> >stringbuf;
	typedef basic_istringstream<char, char_traits<char>, allocator<char> >istringstream;
	typedef basic_ostringstream<char, char_traits<char>, allocator<char> >ostringstream;
	typedef basic_stringstream<char, char_traits<char>, allocator<char> >stringstream;
	typedef basic_filebuf<char, char_traits<char> >filebuf;
	typedef basic_ifstream<char, char_traits<char> >ifstream;
	typedef basic_ofstream<char, char_traits<char> >ofstream;
	typedef basic_fstream<char, char_traits<char> >fstream;
	typedef basic_ios<wchar_t, char_traits<wchar_t> >wios;
	typedef basic_streambuf<wchar_t, char_traits<wchar_t> >wstreambuf;
	typedef basic_istream<wchar_t, char_traits<wchar_t> >wistream;
	typedef basic_ostream<wchar_t, char_traits<wchar_t> >wostream;
	typedef basic_iostream<wchar_t, char_traits<wchar_t> >wiostream;
	typedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wstringbuf;
	typedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wistringstream;
	typedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wostringstream;
	typedef basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wstringstream;
	typedef basic_filebuf<wchar_t, char_traits<wchar_t> >wfilebuf;
	typedef basic_ifstream<wchar_t, char_traits<wchar_t> >wifstream;
	typedef basic_ofstream<wchar_t, char_traits<wchar_t> >wofstream;
	typedef basic_fstream<wchar_t, char_traits<wchar_t> >wfstream;
}
namespace std
{
	template<class _Ty>
	inline void swap(_Ty&_Left, _Ty&_Right)
	{
		_Ty _Tmp=_Left;
		_Left=_Right, _Right=_Tmp;
	}
	template<class _Ty1, class _Ty2>
	struct pair
	{
		typedef pair<_Ty1, _Ty2>_Myt;
		typedef _Ty1 first_type;
		typedef _Ty2 second_type;
		pair(): first(_Ty1()), second(_Ty2())
		{
		}
		pair(const _Ty1&_Val1, const _Ty2&_Val2): first(_Val1), second(_Val2)
		{
		}
		template<class _Other1, class _Other2>
		pair(const pair<_Other1, _Other2>&_Right): first(_Right.first), second(_Right.second)
		{
		}
		void swap(_Myt&_Right)
		{
			std::swap(first, _Right.first);
			std::swap(second, _Right.second);
		}
		_Ty1 first;
		_Ty2 second;
	};
	template<class _Ty1, class _Ty2>
	inline bool operator==(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (_Left.first==_Right.first&&_Left.second==_Right.second);
	}
	template<class _Ty1, class _Ty2>
	inline bool operator!=(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty1, class _Ty2>
	inline bool operator<(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (_Left.first<_Right.first||!(_Right.first<_Left.first)&&_Left.second<_Right.second);
	}
	template<class _Ty1, class _Ty2>
	inline bool operator>(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Ty1, class _Ty2>
	inline bool operator<=(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Ty1, class _Ty2>
	inline bool operator>=(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Ty1, class _Ty2>
	inline pair<_Ty1, _Ty2>make_pair(_Ty1 _Val1, _Ty2 _Val2)
	{
		return (pair<_Ty1, _Ty2>(_Val1, _Val2));
	}
	template<class _Ty1, class _Ty2>
	inline void swap(pair<_Ty1, _Ty2>&_Left, pair<_Ty1, _Ty2>&_Right)
	{
		_Left.swap(_Right);
	}
	namespace rel_ops
	{
		template<class _Ty>
		inline bool operator!=(const _Ty&_Left, const _Ty&_Right)
		{
			return (!(_Left==_Right));
		}
		template<class _Ty>
		inline bool operator>(const _Ty&_Left, const _Ty&_Right)
		{
			return (_Right<_Left);
		}
		template<class _Ty>
		inline bool operator<=(const _Ty&_Left, const _Ty&_Right)
		{
			return (!(_Right<_Left));
		}
		template<class _Ty>
		inline bool operator>=(const _Ty&_Left, const _Ty&_Right)
		{
			return (!(_Left<_Right));
		}
	}
}
namespace std
{
	struct _Unchecked_iterator_tag
	{
	};
	struct _Range_checked_iterator_tag
	{
	};
	struct _Unchanged_checked_iterator_base_type_tag
	{
	};
	struct _Different_checked_iterator_base_type_tag
	{
	};
	struct _Undefined_inner_type_tag
	{
	};
	struct _Undefined_move_tag
	{
	};
	struct _Swap_move_tag
	{
	};
	void _Debug_message(const char*, const char*);
	void _Debug_message(const wchar_t*, const wchar_t*, unsigned int line);
	class _Iterator_base;
	class _Container_base
	{
	public:
		friend class _Iterator_base;
		typedef _Undefined_move_tag _Move_category;
		_Container_base(): _Myfirstiter(0)
		{
		}
		_Container_base(const _Container_base&): _Myfirstiter(0)
		{
		}
		_Container_base&operator=(const _Container_base&)
		{
			return (*this);
		}
		~_Container_base()
		{
			_Orphan_all();
		}
		void _Orphan_all()const;
		void _Swap_all(_Container_base&)const;
		_Iterator_base*_Myfirstiter;
	};
	class _Iterator_base
	{
	public:
		typedef _Unchecked_iterator_tag _Checked_iterator_category;
		typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type;
		typedef _Undefined_inner_type_tag _Inner_type;
		friend class _Container_base;
		_Iterator_base(): _Mycont(0), _Mynextiter(0)
		{
		}
		_Iterator_base(const _Iterator_base&_Right): _Mycont(0), _Mynextiter(0)
		{
			*this=_Right;
		}
		_Iterator_base&operator=(const _Iterator_base&_Right)
		{
			if(_Mycont!=_Right._Mycont)
			{
				_Lockit _Lock(3);
				_Orphan_me();
				_Adopt(_Right._Mycont);
			}
			return (*this);
		}
		~_Iterator_base()
		{
			_Lockit _Lock(3);
			_Orphan_me();
		}
		void _Adopt(const _Container_base*_Parent)
		{
			if(_Mycont!=_Parent)
			{
				_Lockit _Lock(3);
				_Orphan_me();
				if(_Parent!=0&&_Parent->_Myfirstiter!=((_Iterator_base*)-3))
				{
					_Mynextiter=_Parent->_Myfirstiter;
					((_Container_base*)_Parent)->_Myfirstiter=this;
				}
				_Mycont=_Parent;
			}
		}
		void _Orphan_me()
		{
			if(_Mycont!=0&&_Mycont->_Myfirstiter!=((_Iterator_base*)-3))
			{
				_Iterator_base**_Pnext=(_Iterator_base**)&_Mycont->_Myfirstiter;
				while(*_Pnext!=0&&*_Pnext!=this)_Pnext=&(*_Pnext)->_Mynextiter;
				if(*_Pnext==0)_Debug_message(L"ITERATOR LIST CORRUPTED!", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 178);
				*_Pnext=_Mynextiter;
				_Mycont=0;
			}
		}
		const _Container_base*_Mycont;
		_Iterator_base*_Mynextiter;
	};
	typedef _Iterator_base _Iterator_base_secure;
	inline void _Container_base::_Orphan_all()const
	{
		_Lockit _Lock(3);
		if(_Myfirstiter!=((_Iterator_base*)-3))
		{
			for(_Iterator_base**_Pnext=(_Iterator_base**)&_Myfirstiter;
			*_Pnext!=0;
			*_Pnext=(*_Pnext)->_Mynextiter)(*_Pnext)->_Mycont=0;
			*(_Iterator_base**)&_Myfirstiter=0;
		}
	}
	inline void _Container_base::_Swap_all(_Container_base&_Right)const
	{
		_Lockit _Lock(3);
		_Iterator_base*_Pnext;
		_Iterator_base*_Temp=(_Iterator_base*)_Myfirstiter;
		*(_Iterator_base**)&_Myfirstiter=(_Iterator_base*)_Right._Myfirstiter;
		*(_Iterator_base**)&_Right._Myfirstiter=_Temp;
		if(_Myfirstiter!=((_Iterator_base*)-3))
		{
			for(_Pnext=(_Iterator_base*)_Myfirstiter;
			_Pnext!=0;
			_Pnext=_Pnext->_Mynextiter)_Pnext->_Mycont=this;
		}
		if(_Right._Myfirstiter!=((_Iterator_base*)-3))
		{
			for(_Pnext=(_Iterator_base*)_Right._Myfirstiter;
			_Pnext!=0;
			_Pnext=_Pnext->_Mynextiter)_Pnext->_Mycont=&_Right;
		}
	}
	template<class _Iter>
	inline const _Container_base*_Debug_get_cont(const _Iter&)
	{
		return (0);
	}
	inline const _Container_base*_Debug_get_cont(const _Iterator_base&_Where)
	{
		return (_Where._Mycont);
	}
	template<class _Ty1, class _Ty2>
	inline bool _Debug_lt(const _Ty1&_Left, const _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!(_Left<_Right))return (false);
		else if(_Right<_Left)_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Ty1, class _Ty2>
	inline bool _Debug_lt(const _Ty1&_Left, _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!(_Left<_Right))return (false);
		else if(_Right<_Left)_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Ty1, class _Ty2>
	inline bool _Debug_lt(_Ty1&_Left, const _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!(_Left<_Right))return (false);
		else if(_Right<_Left)_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Ty1, class _Ty2>
	inline bool _Debug_lt(_Ty1&_Left, _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!(_Left<_Right))return (false);
		else if(_Right<_Left)_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Pr, class _Ty1, class _Ty2>
	inline bool _Debug_lt_pred(_Pr _Pred, const _Ty1&_Left, const _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!_Pred(_Left, _Right))return (false);
		else if(_Pred(_Right, _Left))_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Pr, class _Ty1, class _Ty2>
	inline bool _Debug_lt_pred(_Pr _Pred, const _Ty1&_Left, _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!_Pred(_Left, _Right))return (false);
		else if(_Pred(_Right, _Left))_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Pr, class _Ty1, class _Ty2>
	inline bool _Debug_lt_pred(_Pr _Pred, _Ty1&_Left, const _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!_Pred(_Left, _Right))return (false);
		else if(_Pred(_Right, _Left))_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Pr, class _Ty1, class _Ty2>
	inline bool _Debug_lt_pred(_Pr _Pred, _Ty1&_Left, _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!_Pred(_Left, _Right))return (false);
		else if(_Pred(_Right, _Left))_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	struct input_iterator_tag
	{
	};
	struct output_iterator_tag
	{
	};
	struct forward_iterator_tag: public input_iterator_tag
	{
	};
	struct bidirectional_iterator_tag: public forward_iterator_tag
	{
	};
	struct random_access_iterator_tag: public bidirectional_iterator_tag
	{
	};
	struct _Int_iterator_tag
	{
	};
	struct _Float_iterator_tag
	{
	};
	struct _Nonscalar_ptr_iterator_tag
	{
	};
	struct _Scalar_ptr_iterator_tag
	{
	};
	template<class _Category, class _Ty, class _Diff=ptrdiff_t, class _Pointer=_Ty*, class _Reference=_Ty&>
	struct iterator: public _Iterator_base
	{
		typedef _Category iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template<class _Category, class _Ty, class _Diff=ptrdiff_t, class _Pointer=_Ty*, class _Reference=_Ty&, class _Base_class=_Iterator_base>
	struct _Iterator_with_base: public _Base_class
	{
		typedef _Category iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template<class _Ty, class _Diff, class _Pointer, class _Reference>
	struct _Bidit: public _Iterator_base
	{
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template<class _Ty, class _Diff, class _Pointer, class _Reference>
	struct _Ranit: public _Iterator_base
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template<class _Ty, class _Diff, class _Pointer, class _Reference, class _Base_class>
	struct _Ranit_base: public _Base_class
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	struct _Outit: public iterator<output_iterator_tag, void, void, void, void>
	{
	};
	template<class _Base_class>
	struct _Outit_with_base: public _Iterator_with_base<output_iterator_tag, void, void, void, void, _Base_class>
	{
	};
	template<class _Iter>
	struct iterator_traits
	{
		typedef typename _Iter::iterator_category iterator_category;
		typedef typename _Iter::value_type value_type;
		typedef typename _Iter::difference_type difference_type;
		typedef difference_type distance_type;
		typedef typename _Iter::pointer pointer;
		typedef typename _Iter::reference reference;
	};
	template<class _Ty>
	struct iterator_traits<_Ty*>
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef ptrdiff_t difference_type;
		typedef ptrdiff_t distance_type;
		typedef _Ty*pointer;
		typedef _Ty&reference;
	};
	template<class _Ty>
	struct iterator_traits<const _Ty*>
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef ptrdiff_t difference_type;
		typedef ptrdiff_t distance_type;
		typedef const _Ty*pointer;
		typedef const _Ty&reference;
	};
	template<>
	struct iterator_traits<_Bool>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef _Bool difference_type;
		typedef _Bool distance_type;
		typedef _Bool*pointer;
		typedef _Bool&reference;
	};
	template<>
	struct iterator_traits<char>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef char value_type;
		typedef char difference_type;
		typedef char distance_type;
		typedef char*pointer;
		typedef char&reference;
	};
	template<>
	struct iterator_traits<signed char>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef signed char value_type;
		typedef signed char difference_type;
		typedef signed char distance_type;
		typedef signed char*pointer;
		typedef signed char&reference;
	};
	template<>
	struct iterator_traits<unsigned char>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned char value_type;
		typedef unsigned char difference_type;
		typedef unsigned char distance_type;
		typedef unsigned char*pointer;
		typedef unsigned char&reference;
	};
	template<>
	struct iterator_traits<wchar_t>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef wchar_t value_type;
		typedef wchar_t difference_type;
		typedef wchar_t distance_type;
		typedef wchar_t*pointer;
		typedef wchar_t&reference;
	};
	template<>
	struct iterator_traits<short>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef short value_type;
		typedef short difference_type;
		typedef short distance_type;
		typedef short*pointer;
		typedef short&reference;
	};
	template<>
	struct iterator_traits<unsigned short>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned short value_type;
		typedef unsigned short difference_type;
		typedef unsigned short distance_type;
		typedef unsigned short*pointer;
		typedef unsigned short&reference;
	};
	template<>
	struct iterator_traits<int>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef int value_type;
		typedef int difference_type;
		typedef int distance_type;
		typedef int*pointer;
		typedef int&reference;
	};
	template<>
	struct iterator_traits<unsigned int>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned int value_type;
		typedef unsigned int difference_type;
		typedef unsigned int distance_type;
		typedef unsigned int*pointer;
		typedef unsigned int&reference;
	};
	template<>
	struct iterator_traits<long>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef long value_type;
		typedef long difference_type;
		typedef long distance_type;
		typedef long*pointer;
		typedef long&reference;
	};
	template<>
	struct iterator_traits<unsigned long>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned long value_type;
		typedef unsigned long difference_type;
		typedef unsigned long distance_type;
		typedef unsigned long*pointer;
		typedef unsigned long&reference;
	};
	template<>
	struct iterator_traits<double>
	{
		typedef _Float_iterator_tag iterator_category;
		typedef double value_type;
		typedef double difference_type;
		typedef double distance_type;
		typedef double*pointer;
		typedef double&reference;
	};
	template<>
	struct iterator_traits<float>
	{
		typedef _Float_iterator_tag iterator_category;
		typedef float value_type;
		typedef float difference_type;
		typedef float distance_type;
		typedef float*pointer;
		typedef float&reference;
	};
	template<>
	struct iterator_traits<__int64>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef __int64 value_type;
		typedef __int64 difference_type;
		typedef __int64 distance_type;
		typedef __int64*pointer;
		typedef __int64&reference;
	};
	template<>
	struct iterator_traits<unsigned __int64>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned __int64 value_type;
		typedef unsigned __int64 difference_type;
		typedef unsigned __int64 distance_type;
		typedef unsigned __int64*pointer;
		typedef unsigned __int64&reference;
	};
	template<class _Iter>
	inline typename iterator_traits<_Iter>::iterator_category _Iter_cat(const _Iter&)
	{
		typename iterator_traits<_Iter>::iterator_category _Cat;
		return (_Cat);
	}
	template<class _Cat1, class _Cat2>
	class _Iter_random_helper
	{
	public:
		typedef forward_iterator_tag _Iter_random_cat;
	};
	template<>
	class _Iter_random_helper<random_access_iterator_tag, random_access_iterator_tag>
	{
	public:
		typedef random_access_iterator_tag _Iter_random_cat;
	};
	template<class _Cat1, class _Cat2, class _Cat3>
	class _Iter_random_helper3
	{
	public:
		typedef forward_iterator_tag _Iter_random_cat;
	};
	template<>
	class _Iter_random_helper3<random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag>
	{
	public:
		typedef random_access_iterator_tag _Iter_random_cat;
	};
	template<class _Iter1, class _Iter2>
	inline typename _Iter_random_helper<typename iterator_traits<_Iter1>::iterator_category, typename iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Iter_random(const _Iter1&, const _Iter2&)
	{
		typename _Iter_random_helper<iterator_traits<_Iter1>::iterator_category, iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
		return (_Cat);
	}
	template<class _Iter1, class _Iter2, class _Iter3>
	inline typename _Iter_random_helper3<typename iterator_traits<_Iter1>::iterator_category, typename iterator_traits<_Iter2>::iterator_category, typename iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Iter_random(const _Iter1&, const _Iter2&, const _Iter3&)
	{
		typename _Iter_random_helper3<iterator_traits<_Iter1>::iterator_category, iterator_traits<_Iter2>::iterator_category, iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
		return (_Cat);
	}
	template<bool _Cond, class _Ty1, class _Ty2>
	class _If
	{
	public:
		typedef _Ty2 _Result;
	};
	template<class _Ty1, class _Ty2>
	class _If<true, _Ty1, _Ty2>
	{
	public:
		typedef _Ty1 _Result;
	};
	template<bool _Secure_validation>
	class _Secure_validation_helper
	{
	public:
		typedef _Unchecked_iterator_tag _Checked_iterator_category;
	};
	template<>
	class _Secure_validation_helper<true>
	{
	public:
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
	};
	template<class _Iter, bool _Inherits_from_iterator_base>
	class _Checked_iterator_category_helper
	{
	public:
		typedef _Unchecked_iterator_tag _Checked_cat;
	};
	template<class _Iter>
	class _Checked_iterator_category_helper<_Iter, true>
	{
	public:
		typedef typename _Iter::_Checked_iterator_category _Checked_cat;
	};
	template<class _Iter>
	class _Checked_iterator_category
	{
	public:
		typedef typename _Checked_iterator_category_helper<_Iter, __is_base_of(_Iterator_base, _Iter)>::_Checked_cat _Checked_cat;
	};
	template<class _Iter>
	inline typename _Checked_iterator_category<_Iter>::_Checked_cat _Checked_cat(const _Iter&)
	{
		typename _Checked_iterator_category<_Iter>::_Checked_cat _Cat;
		return (_Cat);
	}
	template<class _Iter, bool _Inherits_from_iterator_base>
	class _Checked_iterator_base_helper2
	{
	public:
		typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type;
	};
	template<class _Iter>
	class _Checked_iterator_base_helper2<_Iter, true>
	{
	public:
		typedef typename _Iter::_Checked_iterator_base_type _Checked_iterator_base_type;
	};
	template<class _Iter, class _Base_type>
	class _Checked_iterator_base_helper1
	{
	public:
		typedef _Different_checked_iterator_base_type_tag _Base_type_tag;
		typedef _Base_type _Checked_iterator_base_type;
	};
	template<class _Iter>
	class _Checked_iterator_base_helper1<_Iter, _Unchanged_checked_iterator_base_type_tag>
	{
	public:
		typedef _Unchanged_checked_iterator_base_type_tag _Base_type_tag;
		typedef _Iter _Checked_iterator_base_type;
	};
	template<class _Iter>
	class _Checked_iterator_base_helper
	{
	public:
		typedef _Checked_iterator_base_helper2<_Iter, __is_base_of(_Iterator_base, _Iter)>_Base_helper2;
		typedef _Checked_iterator_base_helper1<_Iter, typename _Base_helper2::_Checked_iterator_base_type>_Base_helper1;
		typedef typename _Base_helper1::_Base_type_tag _Checked_iterator_base_type_tag;
		typedef typename _Base_helper1::_Checked_iterator_base_type _Checked_iterator_base_type;
	};
	template<class _Iter, class _Base_tag>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(const _Iter&_It, _Base_tag)
	{
		return _It._Checked_iterator_base();
	}
	template<class _Iter>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(const _Iter&_It, _Unchanged_checked_iterator_base_type_tag)
	{
		return _It;
	}
	template<class _Iter, class _Base_tag>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(_Iter&_It, _Base_tag)
	{
		return _It._Checked_iterator_base();
	}
	template<class _Iter>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(_Iter&_It, _Unchanged_checked_iterator_base_type_tag)
	{
		return _It;
	}
	template<class _Iter>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(const _Iter&_It)
	{
		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
		return _Checked_base(_It, _Base_tag);
	}
	template<class _Iter>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(_Iter&_It)
	{
		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
		return _Checked_base(_It, _Base_tag);
	}
	template<class _DstIter, class _BaseIter>
	inline void _Checked_assign_from_base(_DstIter&_Dest, const _BaseIter&_Src)
	{
		_Dest._Checked_iterator_assign_from_base(_Src);
	}
	template<class _Iter>
	inline void _Checked_assign_from_base(_Iter&_Dest, const _Iter&_Src)
	{
		_Dest=_Src;
	}
	template<class _Value>
	class _Move_operation_category
	{
	public:
		typedef _Undefined_move_tag _Move_cat;
	};
	template<class _Iter>
	inline typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Move_cat(const _Iter&)
	{
		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
		return (_Cat);
	}
	template<class _T1, class _T2, class _Checked_Cat1, class _Checked_Cat2>
	struct _Ptr_cat_with_checked_cat_helper
	{
		typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _T1, class _T2>
	struct _Ptr_cat_helper
	{
		typedef typename _Ptr_cat_with_checked_cat_helper<_T1, _T2, typename _Checked_iterator_category<_T1>::_Checked_cat, typename _Checked_iterator_category<_T2>::_Checked_cat>::_Ptr_cat _Ptr_cat;
	};
	template<class _T1, class _T2, class _Checked_Cat1>
	struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Checked_Cat1, _Range_checked_iterator_tag>
	{
		typedef typename _Ptr_cat_helper<_T1, typename _T2::_Inner_type>::_Ptr_cat _Ptr_cat;
	};
	template<class _T1, class _T2, class _Checked_Cat2>
	struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Range_checked_iterator_tag, _Checked_Cat2>
	{
		typedef typename _Ptr_cat_helper<typename _T1::_Inner_type, _T2>::_Ptr_cat _Ptr_cat;
	};
	template<class _T1, class _T2>
	struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Range_checked_iterator_tag, _Range_checked_iterator_tag>
	{
		typedef typename _Ptr_cat_helper<typename _T1::_Inner_type, typename _T2::_Inner_type>::_Ptr_cat _Ptr_cat;
	};
	template<class _T1>
	struct _Ptr_cat_helper<_T1, _Undefined_inner_type_tag>
	{
		typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _T2>
	struct _Ptr_cat_helper<_Undefined_inner_type_tag, _T2>
	{
		typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<_Undefined_inner_type_tag, _Undefined_inner_type_tag>
	{
		typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<_Bool*, _Bool*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const _Bool*, _Bool*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<char*, char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const char*, char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<signed char*, signed char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const signed char*, signed char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned char*, unsigned char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned char*, unsigned char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<wchar_t*, wchar_t*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const wchar_t*, wchar_t*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<short*, short*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const short*, short*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned short*, unsigned short*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned short*, unsigned short*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<int*, int*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const int*, int*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned int*, unsigned int*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned int*, unsigned int*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<long*, long*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const long*, long*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned long*, unsigned long*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned long*, unsigned long*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<float*, float*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const float*, float*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<double*, double*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const double*, double*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<long double*, long double*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const long double*, long double*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<__int64*, __int64*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const __int64*, __int64*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned __int64*, unsigned __int64*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned __int64*, unsigned __int64*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _Ty>
	struct _Ptr_cat_helper<_Ty**, _Ty**>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _Ty>
	struct _Ptr_cat_helper<_Ty**, const _Ty**>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _Ty>
	struct _Ptr_cat_helper<_Ty*const*, _Ty**>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _Ty>
	struct _Ptr_cat_helper<_Ty*const*, const _Ty**>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _T1, class _T2>
	inline typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Ptr_cat(_T1&, _T2&)
	{
		typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
		return (_Cat);
	}
	template<class _InIt>
	inline void _Debug_pointer(_InIt&, const wchar_t*, unsigned int)
	{
	}
	template<class _Ty>
	inline void _Debug_pointer(const _Ty*_First, const wchar_t*_File, unsigned int _Line)
	{
		if(_First==0)_Debug_message(L"invalid null pointer", _File, _Line);
	}
	template<class _Ty>
	inline void _Debug_pointer(_Ty*_First, const wchar_t*_File, unsigned int _Line)
	{
		if(_First==0)_Debug_message(L"invalid null pointer", _File, _Line);
	}
	template<class _InIt>
	inline void _Debug_range2(_InIt, _InIt, const wchar_t*, unsigned int, input_iterator_tag)
	{
	}
	template<class _RanIt>
	inline void _Debug_range2(_RanIt _First, _RanIt _Last, const wchar_t*_File, unsigned int _Line, random_access_iterator_tag)
	{
		if(_First!=_Last)
		{
			_Debug_pointer(_First, _File, _Line);
			_Debug_pointer(_Last, _File, _Line);
			if(_Last<_First)_Debug_message(L"invalid iterator range", _File, _Line);
		}
	}
	template<class _InIt>
	inline void _Debug_range(_InIt _First, _InIt _Last, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}
	template<class _InIt>
	inline void _Debug_order2(_InIt _First, _InIt _Last, const wchar_t*_File, unsigned int _Line, input_iterator_tag)
	{
	}
	template<class _FwdIt>
	inline void _Debug_order2(_FwdIt _First, _FwdIt _Last, const wchar_t*_File, unsigned int _Line, forward_iterator_tag)
	{
		if(_First!=_Last)for(_FwdIt _Next=_First;
		++_Next!=_Last;
		++_First)if(_Debug_lt(*_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1384))_Debug_message(L"sequence not ordered", _File, _Line);
	}
	template<class _InIt>
	inline void _Debug_order(_InIt _First, _InIt _Last, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_range(_First, _Last, _File, _Line);
		_Debug_order2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}
	template<class _InIt, class _Pr>
	inline void _Debug_order2(_InIt _First, _InIt _Last, _Pr _Pred, const wchar_t*_File, unsigned int _Line, input_iterator_tag)
	{
	}
	template<class _FwdIt, class _Pr>
	inline void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const wchar_t*_File, unsigned int _Line, forward_iterator_tag)
	{
		if(_First!=_Last)for(_FwdIt _Next=_First;
		++_Next!=_Last;
		++_First)if(_Debug_lt_pred(_Pred, *_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1411))_Debug_message(L"sequence not ordered", _File, _Line);
	}
	template<class _InIt, class _Pr>
	inline void _Debug_order(_InIt _First, _InIt _Last, _Pr _Pred, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_range(_First, _Last, _File, _Line);
		_Debug_pointer(_Pred, _File, _Line);
		_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat(_First));
	}
	template<class _InIt>
	inline void _Debug_order_single2(_InIt _First, _InIt _Last, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line, input_iterator_tag)
	{
	}
	template<class _FwdIt>
	inline void _Debug_order_single2(_FwdIt _First, _FwdIt _Last, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line, forward_iterator_tag)
	{
		if(_First!=_Last)
		{
			_FwdIt _Next=_First;
			if(++_Next!=_Last)if(_Debug_lt(*_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1440))_Debug_message(L"sequence not ordered", _File, _Line);
		}
	}
	template<class _InIt>
	inline void _Debug_order_single(_InIt _First, _InIt _Last, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_order_single2(_First, _Last, _IsFirstIteration, _File, _Line, _Iter_cat(_First));
	}
	template<class _InIt, class _Pr>
	inline void _Debug_order_single2(_InIt _First, _InIt _Last, _Pr _Pred, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line, input_iterator_tag)
	{
	}
	template<class _FwdIt, class _Pr>
	inline void _Debug_order_single2(_FwdIt _First, _FwdIt _Last, _Pr _Pred, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line, forward_iterator_tag)
	{
		if(_First!=_Last)
		{
			_FwdIt _Next=_First;
			if(++_Next!=_Last)if(_Debug_lt_pred(_Pred, *_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1469))_Debug_message(L"sequence not ordered", _File, _Line);
		}
	}
	template<class _InIt, class _Pr>
	inline void _Debug_order_single(_InIt _First, _InIt _Last, _Pr _Pred, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_order_single2(_First, _Last, _Pred, _IsFirstIteration, _File, _Line, _Iter_cat(_First));
	}
	template<class _Iter>
	inline typename iterator_traits<_Iter>::value_type*_Val_type(_Iter)
	{
		return (0);
	}
	template<class _InIt, class _Diff>
	inline void _Advance(_InIt&_Where, _Diff _Off, input_iterator_tag)
	{
		for(;
		0<_Off;
		--_Off)++_Where;
	}
	template<class _InIt, class _Diff>
	inline void advance(_InIt&_Where, _Diff _Off)
	{
		_Advance(_Where, _Off, _Iter_cat(_Where));
	}
	template<class _FI, class _Diff>
	inline void _Advance(_FI&_Where, _Diff _Off, forward_iterator_tag)
	{
		for(;
		0<_Off;
		--_Off)++_Where;
	}
	template<class _BI, class _Diff>
	inline void _Advance(_BI&_Where, _Diff _Off, bidirectional_iterator_tag)
	{
		for(;
		0<_Off;
		--_Off)++_Where;
		for(;
		_Off<0;
		++_Off)--_Where;
	}
	template<class _RI, class _Diff>
	inline void _Advance(_RI&_Where, _Diff _Off, random_access_iterator_tag)
	{
		_Where+=_Off;
	}
	template<class _Iter>
	inline typename iterator_traits<_Iter>::difference_type*_Dist_type(_Iter)
	{
		return (0);
	}
	template<class _InIt, class _Diff>
	inline void _Distance2(_InIt _First, _InIt _Last, _Diff&_Off, input_iterator_tag)
	{
		for(;
		_First!=_Last;
		++_First)++_Off;
	}
	template<class _FwdIt, class _Diff>
	inline void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff&_Off, forward_iterator_tag)
	{
		for(;
		_First!=_Last;
		++_First)++_Off;
	}
	template<class _BidIt, class _Diff>
	inline void _Distance2(_BidIt _First, _BidIt _Last, _Diff&_Off, bidirectional_iterator_tag)
	{
		for(;
		_First!=_Last;
		++_First)++_Off;
	}
	template<class _RanIt, class _Diff>
	inline void _Distance2(_RanIt _First, _RanIt _Last, _Diff&_Off, random_access_iterator_tag)
	{
		if(_First!=_Last)
		{
			_Debug_pointer(_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1642);
			_Debug_pointer(_Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1643);
		}
		_Off+=_Last-_First;
	}
	template<class _InIt>
	inline typename iterator_traits<_InIt>::difference_type distance(_InIt _First, _InIt _Last)
	{
		typename iterator_traits<_InIt>::difference_type _Off=0;
		_Distance2(_First, _Last, _Off, _Iter_cat(_First));
		return (_Off);
	}
	template<class _InIt, class _Diff>
	inline void _Distance(_InIt _First, _InIt _Last, _Diff&_Off)
	{
		_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}
	template<class _RanIt>
	class reverse_iterator: public _Iterator_base_secure
	{
	public:
		typedef reverse_iterator<_RanIt>_Myt;
		typedef typename iterator_traits<_RanIt>::iterator_category iterator_category;
		typedef typename iterator_traits<_RanIt>::value_type value_type;
		typedef typename iterator_traits<_RanIt>::difference_type difference_type;
		typedef typename iterator_traits<_RanIt>::difference_type distance_type;
		typedef typename iterator_traits<_RanIt>::pointer pointer;
		typedef typename iterator_traits<_RanIt>::reference reference;
		typedef _RanIt iterator_type;
		reverse_iterator()
		{
		}
		explicit reverse_iterator(_RanIt _Right): current(_Right)
		{
		}
		template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>&_Right): current(_Right.base())
		{
		}
		_RanIt base()const
		{
			return (current);
		}
		typedef typename::std::_Checked_iterator_category<_RanIt>::_Checked_cat _Checked_iterator_category;
		typedef reverse_iterator<typename _Checked_iterator_base_helper<_RanIt>::_Checked_iterator_base_type>_Checked_iterator_base_type;
		_Checked_iterator_base_type _Checked_iterator_base()const
		{
			typename _Checked_iterator_base_type _Base(::std::_Checked_base(current));
			return _Base;
		}
		void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
		{
			::std::_Checked_assign_from_base(current, _Base.base());
		}
		reference operator*()const
		{
			_RanIt _Tmp=current;
			return (*--_Tmp);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			--current;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			--current;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			++current;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			++current;
			return (_Tmp);
		}
		template<class _Other>
		bool _Equal(const reverse_iterator<_Other>&_Right)const
		{
			return (current==_Right.base());
		}
		_Myt&operator+=(difference_type _Off)
		{
			current-=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			return (_Myt(current-_Off));
		}
		_Myt&operator-=(difference_type _Off)
		{
			current+=_Off;
			return (*this);
		}
		_Myt operator-(difference_type _Off)const
		{
			return (_Myt(current+_Off));
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		template<class _Other>
		bool _Less(const reverse_iterator<_Other>&_Right)const
		{
			return (_Right.base()<current);
		}
		template<class _Other>
		difference_type _Minus(const reverse_iterator<_Other>&_Right)const
		{
			return (_Right.base()-current);
		}
		protected: _RanIt current;
	};
	template<class _RanIt, class _Diff>
	inline reverse_iterator<_RanIt>operator+(_Diff _Off, const reverse_iterator<_RanIt>&_Right)
	{
		return (_Right+_Off);
	}
	template<class _RanIt1, class _RanIt2>
	inline typename reverse_iterator<_RanIt1>::difference_type operator-(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (_Left._Minus(_Right));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator==(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (_Left._Equal(_Right));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator!=(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator<(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (_Left._Less(_Right));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator>(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator<=(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator>=(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _BidIt, class _Ty, class _Reference=_Ty&, class _Pointer=_Ty*, class _Diff=ptrdiff_t>
	class reverse_bidirectional_iterator: public iterator<bidirectional_iterator_tag, _Ty, _Diff, _Pointer, _Reference>
	{
	public:
		typedef reverse_bidirectional_iterator<_BidIt, _Ty, _Reference, _Pointer, _Diff>_Myt;
		typedef _BidIt iterator_type;
		reverse_bidirectional_iterator()
		{
		}
		explicit reverse_bidirectional_iterator(_BidIt _Right): current(_Right)
		{
		}
		_BidIt base()const
		{
			return (current);
		}
		_Reference operator*()const
		{
			_BidIt _Tmp=current;
			return (*--_Tmp);
		}
		_Pointer operator->()const
		{
			_Reference _Tmp=**this;
			return (&_Tmp);
		}
		_Myt&operator++()
		{
			--current;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			--current;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			++current;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			++current;
			return (_Tmp);
		}
		bool operator==(const _Myt&_Right)const
		{
			return (current==_Right.current);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		protected: _BidIt current;
	};
	template<class _BidIt, class _BidIt2=_BidIt>
	class _Revbidit: public iterator<typename iterator_traits<_BidIt>::iterator_category, typename iterator_traits<_BidIt>::value_type, typename iterator_traits<_BidIt>::difference_type, typename iterator_traits<_BidIt>::pointer, typename iterator_traits<_BidIt>::reference>
	{
	public:
		typedef _Revbidit<_BidIt, _BidIt2>_Myt;
		typedef typename iterator_traits<_BidIt>::difference_type _Diff;
		typedef typename iterator_traits<_BidIt>::pointer _Pointer;
		typedef typename iterator_traits<_BidIt>::reference _Reference;
		typedef _BidIt iterator_type;
		_Revbidit()
		{
		}
		explicit _Revbidit(_BidIt _Right): current(_Right)
		{
		}
		_Revbidit(const _Revbidit<_BidIt2>&_Other): current(_Other.base())
		{
		}
		_BidIt base()const
		{
			return (current);
		}
		_Reference operator*()const
		{
			_BidIt _Tmp=current;
			return (*--_Tmp);
		}
		_Pointer operator->()const
		{
			_Reference _Tmp=**this;
			return (&_Tmp);
		}
		_Myt&operator++()
		{
			--current;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			--current;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			++current;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			++current;
			return (_Tmp);
		}
		bool operator==(const _Myt&_Right)const
		{
			return (current==_Right.current);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		protected: _BidIt current;
	};
	template<class _Elem, class _Traits>
	class istreambuf_iterator: public _Iterator_with_base<input_iterator_tag, _Elem, typename _Traits::off_type, _Elem*, _Elem&, _Iterator_base_secure>
	{
		typedef istreambuf_iterator<_Elem, _Traits>_Myt;
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef basic_streambuf<_Elem, _Traits>streambuf_type;
		typedef basic_istream<_Elem, _Traits>istream_type;
		typedef typename traits_type::int_type int_type;
		istreambuf_iterator(streambuf_type*_Sb=0)throw(): _Strbuf(_Sb), _Got(_Sb==0)
		{
		}
		istreambuf_iterator(istream_type&_Istr)throw(): _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf()==0)
		{
		}
		_Elem operator*()const
		{
			if(!_Got)((_Myt*)this)->_Peek();
			if(_Strbuf==0)_Debug_message(L"istreambuf_iterator is not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2074);
			return (_Val);
		}
		_Myt&operator++()
		{
			if(_Strbuf==0)_Debug_message(L"istreambuf_iterator is not incrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2085);
			_Inc();
			return (*this);
		}
		_Myt operator++(int)
		{
			if(!_Got)_Peek();
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		bool equal(const _Myt&_Right)const
		{
			if(!_Got)((_Myt*)this)->_Peek();
			if(!_Right._Got)((_Myt*)&_Right)->_Peek();
			return (_Strbuf==0&&_Right._Strbuf==0||_Strbuf!=0&&_Right._Strbuf!=0);
		}
	private:
		void _Inc()
		{
			if(_Strbuf==0||traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc()))_Strbuf=0, _Got=true;
			else _Got=false;
		}
		_Elem _Peek()
		{
			int_type _Meta;
			if(_Strbuf==0||traits_type::eq_int_type(traits_type::eof(), _Meta=_Strbuf->sgetc()))_Strbuf=0;
			else _Val=traits_type::to_char_type(_Meta);
			_Got=true;
			return (_Val);
		}
		streambuf_type*_Strbuf;
		bool _Got;
		_Elem _Val;
	};
	template<class _Elem, class _Traits>
	inline bool operator==(const istreambuf_iterator<_Elem, _Traits>&_Left, const istreambuf_iterator<_Elem, _Traits>&_Right)
	{
		return (_Left.equal(_Right));
	}
	template<class _Elem, class _Traits>
	inline bool operator!=(const istreambuf_iterator<_Elem, _Traits>&_Left, const istreambuf_iterator<_Elem, _Traits>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Elem, class _Traits>
	class ostreambuf_iterator: public _Outit_with_base<_Iterator_base_secure>
	{
		typedef ostreambuf_iterator<_Elem, _Traits>_Myt;
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef basic_streambuf<_Elem, _Traits>streambuf_type;
		typedef basic_ostream<_Elem, _Traits>ostream_type;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		ostreambuf_iterator(streambuf_type*_Sb)throw(): _Failed(false), _Strbuf(_Sb)
		{
		}
		ostreambuf_iterator(ostream_type&_Ostr)throw(): _Failed(false), _Strbuf(_Ostr.rdbuf())
		{
		}
		_Myt&operator=(_Elem _Right)
		{
			if(_Strbuf==0||traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right)))_Failed=true;
			return (*this);
		}
		_Myt&operator*()
		{
			return (*this);
		}
		_Myt&operator++()
		{
			return (*this);
		}
		_Myt&operator++(int)
		{
			return (*this);
		}
		bool failed()const throw()
		{
			return (_Failed);
		}
	private:
		bool _Failed;
		streambuf_type*_Strbuf;
	};
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2226);
		for(;
		_First!=_Last;
		++_Dest, ++_First)*_Dest=*_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest, random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Copy_opt(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2253);
		if(_First!=_Last)_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2255);
		ptrdiff_t _Off=_Last-_First;
		_OutIt _Result=_Dest+_Off;
		if(_Off>0)::memmove_s((&*_Dest), (_Off*sizeof(*_First)), (&*_First), (_Off*sizeof(*_First)));
		return _Result;
	}
	template<class _InIt, class _OutIt, class _InOutItCat, class _Ty>
	inline _OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat _First_dest_cat, _Ty _PtrCat, _Unchecked_iterator_tag)
	{
		return _Copy_opt(_First, _Last, _Dest, _First_dest_cat, _PtrCat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt>
	inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (_Copy_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy>
	inline _OutIt _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag)
	{
		return _Copy_opt(_First, _Last, _Dest, _First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2300);
		for(;
		_First!=_Last;
		++_Dest, ++_First)::std::swap(*_Dest, *_First);
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest, random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Move_opt(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy>
	inline _OutIt _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat _First_dest_cat, _MoveCatTy _Move_cat, _Unchecked_iterator_tag)
	{
		return _Move_opt(_First, _Last, _Dest, _First_dest_cat, _Move_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return _Move_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), _Move_cat(_Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat>
	inline _BidIt2 _Copy_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2345);
		while(_First!=_Last)*--_Dest=*--_Last;
		return (_Dest);
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest, random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest-(_Last-_First);
		_Copy_backward_opt(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2372);
		if(_First!=_Last)_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2374);
		ptrdiff_t _Off=_Last-_First;
		_OutIt _Result=_Dest-_Off;
		if(_Off>0)::memmove_s((&*_Result), (_Off*sizeof(*_First)), (&*_First), (_Off*sizeof(*_First)));
		return _Result;
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat, class _Ty>
	inline _BidIt2 _Copy_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat _First_dest_cat, _Ty _PtrCat, _Unchecked_iterator_tag)
	{
		return _Copy_backward_opt(_First, _Last, _Dest, _First_dest_cat, _PtrCat, _Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return _Copy_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy>
	inline _BidIt2 _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag)
	{
		return _Copy_backward_opt(_First, _Last, _Dest, _First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat>
	inline _BidIt2 _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2422);
		while(_First!=_Last)::std::swap(*--_Dest, *--_Last);
		return (_Dest);
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag)
	{
		_BidIt2 _Result=_Dest-(_Last-_First);
		_Move_backward_opt(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy>
	inline _BidIt2 _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat _First_dest_cat, _MoveCatTy _Move_cat, _Unchecked_iterator_tag)
	{
		return _Move_backward_opt(_First, _Last, _Dest, _First_dest_cat, _Move_cat, _Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return _Move_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), _Move_cat(_Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _InItCats>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InItCats, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2471);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2473);
		for(;
		_First1!=_Last1&&*_First1==*_First2;
		)++_First1, ++_First2;
		return (pair<_InIt1, _InIt2>(_First1, _First2));
	}
	template<class _InIt1, class _InIt2>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		pair<_InIt1, typename::std::_Checked_iterator_base_helper<_InIt2>::_Checked_iterator_base_type>_Result=_Mismatch(_First1, _Last1, ::std::_Checked_base(_First2), forward_iterator_tag(), _Range_checked_iterator_tag());
		::std::_Checked_assign_from_base(_First2, _Result.second);
		return (pair<_InIt1, _InIt2>(_Result.first, _First2));
	}
	template<class _InIt1, class _InIt2, class _InItCats>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InItCats _InIt_cats, _Unchecked_iterator_tag)
	{
		return _Mismatch(_First1, _Last1, _First2, _InIt_cats, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2>
	inline pair<_InIt1, _InIt2>mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, _InItCats, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2537);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2539);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2540);
		for(;
		_First1!=_Last1&&_Pred(*_First1, *_First2);
		)++_First1, ++_First2;
		return (pair<_InIt1, _InIt2>(_First1, _First2));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		pair<_InIt1, typename::std::_Checked_iterator_base_helper<_InIt2>::_Checked_iterator_base_type>_Result=_Mismatch(_First1, _Last1, ::std::_Checked_base(_First2), _Pred, forward_iterator_tag(), _Range_checked_iterator_tag());
		::std::_Checked_assign_from_base(_First2, _Result.second);
		return (pair<_InIt1, _InIt2>(_Result.first, _First2));
	}
	template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, _InItCats _InIt_cats, _Unchecked_iterator_tag)
	{
		return _Mismatch(_First1, _Last1, _First2, _Pred, _InIt_cats, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline pair<_InIt1, _InIt2>mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2, class _InItCats>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InItCats, _Range_checked_iterator_tag)
	{
		return (_Mismatch(_First1, _Last1, _First2, forward_iterator_tag(), _Range_checked_iterator_tag()).first==_Last1);
	}
	inline bool _Equal(const char*_First1, const char*_Last1, const char*_First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2610);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2612);
		return (::memcmp(_First1, _First2, _Last1-_First1)==0);
	}
	inline bool _Equal(const signed char*_First1, const signed char*_Last1, const signed char*_First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2623);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2625);
		return (::memcmp(_First1, _First2, _Last1-_First1)==0);
	}
	inline bool _Equal(const unsigned char*_First1, const unsigned char*_Last1, const unsigned char*_First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2636);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2638);
		return (::memcmp(_First1, _First2, _Last1-_First1)==0);
	}
	template<class _InIt1, class _InIt2>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		return _Equal(_First1, _Last1, ::std::_Checked_base(_First2), forward_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _InItCats>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InItCats _InIt_cats, _Unchecked_iterator_tag)
	{
		return _Equal(_First1, _Last1, _First2, _InIt_cats, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2>
	inline bool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		return _Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
	template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, _InItCats, _Range_checked_iterator_tag)
	{
		return (_Mismatch(_First1, _Last1, _First2, _Pred, forward_iterator_tag(), _Range_checked_iterator_tag()).first==_Last1);
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		return _Equal(_First1, _Last1, ::std::_Checked_base(_First2), _Pred, forward_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, _InItCats _InIt_cats, _Unchecked_iterator_tag)
	{
		return _Equal(_First1, _Last1, _First2, _Pred, _InIt_cats, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		return _Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
	template<class _FwdIt, class _Ty>
	inline void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2724);
		for(;
		_First!=_Last;
		++_First)*_First=_Val;
	}
	inline void _Fill(char*_First, char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2732);
		::memset(_First, _Val, _Last-_First);
	}
	inline void _Fill(signed char*_First, signed char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2739);
		::memset(_First, _Val, _Last-_First);
	}
	inline void _Fill(unsigned char*_First, unsigned char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2747);
		::memset(_First, _Val, _Last-_First);
	}
	template<class _FwdIt, class _Ty>
	inline void fill(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		_Fill(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val);
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void _Fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val, _Range_checked_iterator_tag)
	{
		for(;
		0<_Count;
		--_Count, ++_First)*_First=_Val;
	}
	inline void _Fill_n(char*_First, size_t _Count, int _Val, _Range_checked_iterator_tag)
	{
		if(0<_Count)_Debug_pointer(_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2774);
		::memset(_First, _Val, _Count);
	}
	inline void _Fill_n(signed char*_First, size_t _Count, int _Val, _Range_checked_iterator_tag)
	{
		if(0<_Count)_Debug_pointer(_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2786);
		::memset(_First, _Val, _Count);
	}
	inline void _Fill_n(unsigned char*_First, size_t _Count, int _Val, _Range_checked_iterator_tag)
	{
		if(0<_Count)_Debug_pointer(_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2798);
		::memset(_First, _Val, _Count);
	}
	template<class _OutIt, class _Diff, class _Ty, class _OutCat>
	inline void _Fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val, _OutCat, _Range_checked_iterator_tag)
	{
		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void _Fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Last=_First+_Count;
		(_Last);
		_Fill_n(::std::_Checked_base(_First), _Count, _Val, _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Ty, class _OutCat>
	inline void _Fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val, _OutCat _First_cat, _Unchecked_iterator_tag)
	{
		_Fill_n(_First, _Count, _Val, _First_cat, _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val)
	{
		_Fill_n(_First, _Count, _Val, _Iter_cat(_First), ::std::_Checked_cat(_First));
	}
	template<class _InIt1, class _InIt2>
	inline bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2849);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2850);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_First1, ++_First2)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2852))return (true);
		else if(*_First2<*_First1)return (false);
		return (_First1==_Last1&&_First2!=_Last2);
	}
	template<class _InIt1, class _InIt2>
	inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{
		return _Lexicographical_compare(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2));
	}
	inline bool lexicographical_compare(const unsigned char*_First1, const unsigned char*_Last1, const unsigned char*_First2, const unsigned char*_Last2)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2871);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2872);
		ptrdiff_t _Num1=_Last1-_First1;
		ptrdiff_t _Num2=_Last2-_First2;
		int _Ans=::memcmp(_First1, _First2, _Num1<_Num2?_Num1: _Num2);
		return (_Ans<0||_Ans==0&&_Num1<_Num2);
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2900);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2901);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2902);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_First1, ++_First2)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2904))return (true);
		else if(_Pred(*_First2, *_First1))return (false);
		return (_First1==_Last1&&_First2!=_Last2);
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
		return _Lexicographical_compare(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred);
	}
	template<class _Ty>
	inline const _Ty&(max)(const _Ty&_Left, const _Ty&_Right)
	{
		return (_Debug_lt(_Left, _Right, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2938)?_Right: _Left);
	}
	template<class _Ty, class _Pr>
	inline const _Ty&(max)(const _Ty&_Left, const _Ty&_Right, _Pr _Pred)
	{
		return (_Debug_lt_pred(_Pred, _Left, _Right, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2946)?_Right: _Left);
	}
	template<class _Ty>
	inline const _Ty&(min)(const _Ty&_Left, const _Ty&_Right)
	{
		return (_Debug_lt(_Right, _Left, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2953)?_Right: _Left);
	}
	template<class _Ty, class _Pr>
	inline const _Ty&(min)(const _Ty&_Left, const _Ty&_Right, _Pr _Pred)
	{
		return (_Debug_lt_pred(_Pred, _Right, _Left, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2961)?_Right: _Left);
	}
}
namespace stdext
{
	template<class _InIt, class _OutIt>
	inline _OutIt unchecked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (::std::_Copy_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Ptr_cat(_First, _Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt checked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (::std::_Copy_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 unchecked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return (::std::_Copy_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Ptr_cat(_First, _Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 checked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return (::std::_Copy_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Unchecked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (::std::_Move_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Move_cat(_Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Checked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (::std::_Move_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Move_cat(_Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 _Unchecked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return (::std::_Move_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Move_cat(_Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 _Checked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return (::std::_Move_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Move_cat(_Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void unchecked_fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val)
	{
		::std::_Fill_n(_First, _Count, _Val, ::std::_Iter_cat(_First), ::std::_Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void checked_fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val)
	{
		::std::_Fill_n(_First, _Count, _Val, ::std::_Iter_cat(_First), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2>
	inline::std::pair<_InIt1, _InIt2>unchecked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		::std::pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=::std::_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (::std::pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2>
	inline::std::pair<_InIt1, _InIt2>checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		::std::pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=::std::_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (::std::pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline::std::pair<_InIt1, _InIt2>unchecked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		::std::pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=::std::_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (::std::pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline::std::pair<_InIt1, _InIt2>checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		::std::pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=::std::_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (::std::pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2>
	inline bool unchecked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		return ::std::_Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2>
	inline bool checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		return ::std::_Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool unchecked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		return ::std::_Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		return ::std::_Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
}
extern "C" void _invalid_parameter(const wchar_t*, const wchar_t*, const wchar_t*, unsigned int, uintptr_t);
namespace std
{
}
typedef void(*terminate_function)();
typedef void(*terminate_handler)();
typedef void(*unexpected_function)();
typedef void(*unexpected_handler)();
struct _EXCEPTION_POINTERS;
typedef void(*_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
void terminate(void);
void unexpected(void);
int _is_exception_typeof(const type_info&_Type, struct _EXCEPTION_POINTERS*_ExceptionPtr);
terminate_function set_terminate(terminate_function _NewPtFunc);
extern "C" terminate_function _get_terminate(void);
unexpected_function set_unexpected(unexpected_function _NewPtFunc);
extern "C" unexpected_function _get_unexpected(void);
_se_translator_function _set_se_translator(_se_translator_function _NewPtFunc);
bool __uncaught_exception();
extern "C"
{
	typedef struct _heapinfo
	{
		int*_pentry;
		size_t _size;
		int _useflag;
	}
	_HEAPINFO;
	extern unsigned int _amblksiz;
	void*calloc(size_t _NumOfElements, size_t _SizeOfElements);
	void free(void*_Memory);
	void*malloc(size_t _Size);
	void*realloc(void*_Memory, size_t _NewSize);
	void*_recalloc(void*_Memory, size_t _Count, size_t _Size);
	void _aligned_free(void*_Memory);
	void*_aligned_malloc(size_t _Size, size_t _Alignment);
	void*_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset);
	void*_aligned_realloc(void*_Memory, size_t _Size, size_t _Alignment);
	void*_aligned_recalloc(void*_Memory, size_t _Count, size_t _Size, size_t _Alignment);
	void*_aligned_offset_realloc(void*_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
	void*_aligned_offset_recalloc(void*_Memory, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset);
	int _resetstkoflw(void);
	unsigned long _set_malloc_crt_max_wait(unsigned long _NewValue);
	void*_expand(void*_Memory, size_t _NewSize);
	size_t _msize(void*_Memory);
	void*_alloca(size_t _Size);
	size_t _get_sbh_threshold(void);
	int _set_sbh_threshold(size_t _NewValue);
	errno_t _set_amblksiz(size_t _Value);
	errno_t _get_amblksiz(size_t*_Value);
	int _heapadd(void*_Memory, size_t _Size);
	int _heapchk(void);
	int _heapmin(void);
	int _heapset(unsigned int _Fill);
	int _heapwalk(_HEAPINFO*_EntryInfo);
	size_t _heapused(size_t*_Used, size_t*_Commit);
	intptr_t _get_heap_handle(void);
	typedef char __static_assert_t[(sizeof(unsigned int)<=8)];
	void*_MarkAllocaS(void*_Ptr, unsigned int _Marker)
	{
		if(_Ptr)
		{
			*((unsigned int*)_Ptr)=_Marker;
			_Ptr=(char*)_Ptr+8;
		}
		return _Ptr;
	}
	void _freea(void*_Memory)
	{
		unsigned int _Marker;
		if(_Memory)
		{
			_Memory=(char*)_Memory-8;
			_Marker=*(unsigned int*)_Memory;
			if(_Marker==0xDDDD)
			{
				free(_Memory);
			}
			else if(_Marker!=0xCCCC)
			{
				(void)((!!((("Corrupted pointer passed to _freea", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\malloc.h", 245, 0, L"(\"Corrupted pointer passed to _freea\", 0)"))||(__debugbreak(), 0));
			}
		}
	}
}
typedef const char*__exString;
extern "C" size_t strlen(const char*);
extern "C" errno_t strcpy_s(char*_Dst, size_t _DstSize, const char*_Src);
namespace std
{
	class exception
	{
	public:
		exception();
		exception(const char*const&);
		exception(const char*const&, int);
		exception(const exception&);
		exception&operator=(const exception&);
		virtual~exception();
		virtual const char*what()const;
	private:
		const char*_m_what;
		int _m_doFree;
	};
	using::set_terminate;
	using::terminate_handler;
	using::terminate;
	using::set_unexpected;
	using::unexpected_handler;
	using::unexpected;
	typedef void(*_Prhand)(const exception&);
	bool uncaught_exception();
	class bad_exception: public exception
	{
	public:
		bad_exception(const char*_Message="bad exception")throw(): exception(_Message)
		{
		}
		virtual~bad_exception()throw()
		{
		}
	};
	static const char*_bad_alloc_Message="bad allocation";
	class bad_alloc: public exception
	{
	public:
		bad_alloc(const char*_Message)throw(): exception(_Message)
		{
		}
		bad_alloc()throw(): exception(_bad_alloc_Message, 1)
		{
		}
		virtual~bad_alloc()throw()
		{
		}
	};
}
extern "C"
{
	typedef int(*_onexit_t)(void);
	typedef struct _div_t
	{
		int quot;
		int rem;
	}
	div_t;
	typedef struct _ldiv_t
	{
		long quot;
		long rem;
	}
	ldiv_t;
	typedef struct
	{
		unsigned char ld[10];
	}
	_LDOUBLE;
	typedef struct
	{
		double x;
	}
	_CRT_DOUBLE;
	typedef struct
	{
		float f;
	}
	_CRT_FLOAT;
	typedef struct
	{
		long double x;
	}
	_LONGDOUBLE;
	typedef struct
	{
		unsigned char ld12[12];
	}
	_LDBL12;
	extern int __mb_cur_max;
	int ___mb_cur_max_func(void);
	int ___mb_cur_max_l_func(_locale_t);
	typedef void(*_purecall_handler)(void);
	_purecall_handler _set_purecall_handler(_purecall_handler _Handler);
	_purecall_handler _get_purecall_handler();
	extern "C++"
	{
	}
	typedef void(*_invalid_parameter_handler)(const wchar_t*, const wchar_t*, const wchar_t*, unsigned int, uintptr_t);
	_invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
	_invalid_parameter_handler _get_invalid_parameter_handler(void);
	extern "C++"
	{
	}
	unsigned long*__doserrno(void);
	errno_t _set_doserrno(unsigned long _Value);
	errno_t _get_doserrno(unsigned long*_Value);
	char**__sys_errlist(void);
	int*__sys_nerr(void);
	extern int __argc;
	extern char**__argv;
	extern wchar_t**__wargv;
	extern char**_environ;
	extern wchar_t**_wenviron;
	extern char*_pgmptr;
	extern wchar_t*_wpgmptr;
	errno_t _get_pgmptr(char**_Value);
	errno_t _get_wpgmptr(wchar_t**_Value);
	extern int _fmode;
	errno_t _set_fmode(int _Mode);
	errno_t _get_fmode(int*_PMode);
	extern unsigned int _osplatform;
	extern unsigned int _osver;
	extern unsigned int _winver;
	extern unsigned int _winmajor;
	extern unsigned int _winminor;
	errno_t _get_osplatform(unsigned int*_Value);
	errno_t _get_osver(unsigned int*_Value);
	errno_t _get_winver(unsigned int*_Value);
	errno_t _get_winmajor(unsigned int*_Value);
	errno_t _get_winminor(unsigned int*_Value);
	extern "C++"
	{
		template<typename _CountofType, size_t _SizeOfArray>
		char(*__countof_helper(_CountofType(&_Array)[_SizeOfArray]))[_SizeOfArray];
	}
	void exit(int _Code);
	void _exit(int _Code);
	void abort(void);
	unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask);
	int abs(int _X);
	long labs(long _X);
	__int64 _abs64(__int64);
	int atexit(void(*)(void));
	double atof(const char*_String);
	double _atof_l(const char*_String, _locale_t _Locale);
	int atoi(const char*_Str);
	int _atoi_l(const char*_Str, _locale_t _Locale);
	long atol(const char*_Str);
	long _atol_l(const char*_Str, _locale_t _Locale);
	void*bsearch_s(const void*_Key, const void*_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, int(*_PtFuncCompare)(void*, const void*, const void*), void*_Context);
	void*bsearch(const void*_Key, const void*_Base, size_t _NumOfElements, size_t _SizeOfElements, int(*_PtFuncCompare)(const void*, const void*));
	void qsort_s(void*_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, int(*_PtFuncCompare)(void*, const void*, const void*), void*_Context);
	void qsort(void*_Base, size_t _NumOfElements, size_t _SizeOfElements, int(*_PtFuncCompare)(const void*, const void*));
	unsigned short _byteswap_ushort(unsigned short _Short);
	unsigned long _byteswap_ulong(unsigned long _Long);
	unsigned __int64 _byteswap_uint64(unsigned __int64 _Int64);
	div_t div(int _Numerator, int _Denominator);
	char*getenv(const char*_VarName);
	errno_t getenv_s(size_t*_ReturnSize, char*_DstBuf, rsize_t _DstSize, const char*_VarName);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t getenv_s(size_t*_ReturnSize, char(&_Dest)[_SizeFIXED], const char*_VarName)
		{
			return getenv_s(_ReturnSize, _Dest, _SizeFIXED, _VarName);
		}
	}
	errno_t _dupenv_s(char**_PBuffer, size_t*_PBufferSizeInBytes, const char*_VarName);
	errno_t _itoa_s(int _Value, char*_DstBuf, size_t _Size, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _itoa_s(int _Value, char(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _itoa_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	char*_itoa(int _Value, char*_Dest, int _Radix);
	errno_t _i64toa_s(__int64 _Val, char*_DstBuf, size_t _Size, int _Radix);
	char*_i64toa(__int64 _Val, char*_DstBuf, int _Radix);
	errno_t _ui64toa_s(unsigned __int64 _Val, char*_DstBuf, size_t _Size, int _Radix);
	char*_ui64toa(unsigned __int64 _Val, char*_DstBuf, int _Radix);
	__int64 _atoi64(const char*_String);
	__int64 _atoi64_l(const char*_String, _locale_t _Locale);
	__int64 _strtoi64(const char*_String, char**_EndPtr, int _Radix);
	__int64 _strtoi64_l(const char*_String, char**_EndPtr, int _Radix, _locale_t _Locale);
	unsigned __int64 _strtoui64(const char*_String, char**_EndPtr, int _Radix);
	unsigned __int64 _strtoui64_l(const char*_String, char**_EndPtr, int _Radix, _locale_t _Locale);
	ldiv_t ldiv(long _Numerator, long _Denominator);
	extern "C++"
	{
		inline ldiv_t div(long _A1, long _A2)
		{
			return ldiv(_A1, _A2);
		}
	}
	errno_t _ltoa_s(long _Val, char*_DstBuf, size_t _Size, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ltoa_s(long _Value, char(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _ltoa_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	char*_ltoa(long _Value, char*_Dest, int _Radix);
	int mblen(const char*_Ch, size_t _MaxCount);
	int _mblen_l(const char*_Ch, size_t _MaxCount, _locale_t _Locale);
	size_t _mbstrlen(const char*_Str);
	size_t _mbstrlen_l(const char*_Str, _locale_t _Locale);
	size_t _mbstrnlen(const char*_Str, size_t _MaxCount);
	size_t _mbstrnlen_l(const char*_Str, size_t _MaxCount, _locale_t _Locale);
	int mbtowc(wchar_t*_DstCh, const char*_SrcCh, size_t _SrcSizeInBytes);
	int _mbtowc_l(wchar_t*_DstCh, const char*_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale);
	errno_t mbstowcs_s(size_t*_PtNumOfCharConverted, wchar_t*_DstBuf, size_t _SizeInWords, const char*_SrcBuf, size_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t mbstowcs_s(size_t*_PtNumOfCharConverted, wchar_t(&_Dest)[_SizeFIXED], const char*_Source, size_t _MaxCount)
		{
			return mbstowcs_s(_PtNumOfCharConverted, _Dest, _SizeFIXED, _Source, _MaxCount);
		}
	}
	size_t mbstowcs(wchar_t*_Dest, const char*_Source, size_t _MaxCount);
	errno_t _mbstowcs_s_l(size_t*_PtNumOfCharConverted, wchar_t*_DstBuf, size_t _SizeInWords, const char*_SrcBuf, size_t _MaxCount, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _mbstowcs_s_l(size_t*_PtNumOfCharConverted, wchar_t(&_Dest)[_SizeFIXED], const char*_Source, size_t _MaxCount, _locale_t _Locale)
		{
			return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _SizeFIXED, _Source, _MaxCount, _Locale);
		}
	}
	size_t _mbstowcs_l(wchar_t*_Dest, const char*_Source, size_t _MaxCount, _locale_t _Locale);
	int rand(void);
	int _set_error_mode(int _Mode);
	void srand(unsigned int _Seed);
	double strtod(const char*_Str, char**_EndPtr);
	double _strtod_l(const char*_Str, char**_EndPtr, _locale_t _Locale);
	long strtol(const char*_Str, char**_EndPtr, int _Radix);
	long _strtol_l(const char*_Str, char**_EndPtr, int _Radix, _locale_t _Locale);
	unsigned long strtoul(const char*_Str, char**_EndPtr, int _Radix);
	unsigned long _strtoul_l(const char*_Str, char**_EndPtr, int _Radix, _locale_t _Locale);
	int system(const char*_Command);
	errno_t _ultoa_s(unsigned long _Val, char*_DstBuf, size_t _Size, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ultoa_s(unsigned long _Value, char(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _ultoa_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	char*_ultoa(unsigned long _Value, char*_Dest, int _Radix);
	int wctomb(char*_MbCh, wchar_t _WCh);
	int _wctomb_l(char*_MbCh, wchar_t _WCh, _locale_t _Locale);
	errno_t wctomb_s(int*_SizeConverted, char*_MbCh, rsize_t _SizeInBytes, wchar_t _WCh);
	errno_t _wctomb_s_l(int*_SizeConverted, char*_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale);
	errno_t wcstombs_s(size_t*_PtNumOfCharConverted, char*_Dst, size_t _DstSizeInBytes, const wchar_t*_Src, size_t _MaxCountInBytes);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcstombs_s(size_t*_PtNumOfCharConverted, char(&_Dest)[_SizeFIXED], const wchar_t*_Source, size_t _MaxCount)
		{
			return wcstombs_s(_PtNumOfCharConverted, _Dest, _SizeFIXED, _Source, _MaxCount);
		}
	}
	size_t wcstombs(char*_Dest, const wchar_t*_Source, size_t _MaxCount);
	errno_t _wcstombs_s_l(size_t*_PtNumOfCharConverted, char*_Dst, size_t _DstSizeInBytes, const wchar_t*_Src, size_t _MaxCountInBytes, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcstombs_s_l(size_t*_PtNumOfCharConverted, char(&_Dest)[_SizeFIXED], const wchar_t*_Source, size_t _MaxCount, _locale_t _Locale)
		{
			return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _SizeFIXED, _Source, _MaxCount, _Locale);
		}
	}
	size_t _wcstombs_l(char*_Dest, const wchar_t*_Source, size_t _MaxCount, _locale_t _Locale);
	char*_fullpath(char*_FullPath, const char*_Path, size_t _SizeInBytes);
	errno_t _ecvt_s(char*_DstBuf, size_t _Size, double _Val, int _NumOfDights, int*_PtDec, int*_PtSign);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ecvt_s(char(&_Dest)[_SizeFIXED], double _Value, int _NumOfDigits, int*_PtDec, int*_PtSign)
		{
			return _ecvt_s(_Dest, _SizeFIXED, _Value, _NumOfDigits, _PtDec, _PtSign);
		}
	}
	char*_ecvt(double _Val, int _NumOfDigits, int*_PtDec, int*_PtSign);
	errno_t _fcvt_s(char*_DstBuf, size_t _Size, double _Val, int _NumOfDec, int*_PtDec, int*_PtSign);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _fcvt_s(char(&_Dest)[_SizeFIXED], double _Value, int _NumOfDigits, int*_PtDec, int*_PtSign)
		{
			return _fcvt_s(_Dest, _SizeFIXED, _Value, _NumOfDigits, _PtDec, _PtSign);
		}
	}
	char*_fcvt(double _Val, int _NumOfDec, int*_PtDec, int*_PtSign);
	errno_t _gcvt_s(char*_DstBuf, size_t _Size, double _Val, int _NumOfDigits);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _gcvt_s(char(&_Dest)[_SizeFIXED], double _Value, int _NumOfDigits)
		{
			return _gcvt_s(_Dest, _SizeFIXED, _Value, _NumOfDigits);
		}
	}
	char*_gcvt(double _Val, int _NumOfDigits, char*_DstBuf);
	int _atodbl(_CRT_DOUBLE*_Result, char*_Str);
	int _atoldbl(_LDOUBLE*_Result, char*_Str);
	int _atoflt(_CRT_FLOAT*_Result, char*_Str);
	int _atodbl_l(_CRT_DOUBLE*_Result, char*_Str, _locale_t _Locale);
	int _atoldbl_l(_LDOUBLE*_Result, char*_Str, _locale_t _Locale);
	int _atoflt_l(_CRT_FLOAT*_Result, char*_Str, _locale_t _Locale);
	unsigned long _lrotl(unsigned long _Val, int _Shift);
	unsigned long _lrotr(unsigned long _Val, int _Shift);
	errno_t _makepath_s(char*_PathResult, size_t _Size, const char*_Drive, const char*_Dir, const char*_Filename, const char*_Ext);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _makepath_s(char(&_Path)[_SizeFIXED], const char*_Drive, const char*_Dir, const char*_Filename, const char*_Ext)
		{
			return _makepath_s(_Path, _SizeFIXED, _Drive, _Dir, _Filename, _Ext);
		}
	}
	void _makepath(char*_Path, const char*_Drive, const char*_Dir, const char*_Filename, const char*_Ext);
	_onexit_t _onexit(_onexit_t _Func);
	int _putenv(const char*_EnvString);
	errno_t _putenv_s(const char*_Name, const char*_Value);
	unsigned int _rotl(unsigned int _Val, int _Shift);
	unsigned __int64 _rotl64(unsigned __int64 _Val, int _Shift);
	unsigned int _rotr(unsigned int _Val, int _Shift);
	unsigned __int64 _rotr64(unsigned __int64 _Val, int _Shift);
	errno_t _searchenv_s(const char*_Filename, const char*_EnvVar, char*_ResultPath, size_t _SizeInBytes);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _searchenv_s(const char*_Filename, const char*_EnvVar, char(&_ResultPath)[_SizeFIXED])
		{
			return _searchenv_s(_Filename, _EnvVar, _ResultPath, _SizeFIXED);
		}
	}
	void _searchenv(const char*_Filename, const char*_EnvVar, char*_ResultPath);
	void _splitpath(const char*_FullPath, char*_Drive, char*_Dir, char*_Filename, char*_Ext);
	errno_t _splitpath_s(const char*_FullPath, char*_Drive, size_t _DriveSize, char*_Dir, size_t _DirSize, char*_Filename, size_t _FilenameSize, char*_Ext, size_t _ExtSize);
	extern "C++"
	{
		template<size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>
		inline errno_t _splitpath_s(const char*_Dest, char(&_Drive)[_DriveSize], char(&_Dir)[_DirSize], char(&_Name)[_NameSize], char(&_Ext)[_ExtSize])
		{
			return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize);
		}
	}
	void _swab(char*_Buf1, char*_Buf2, int _SizeInBytes);
	void _seterrormode(int _Mode);
	void _beep(unsigned _Frequency, unsigned _Duration);
	void _sleep(unsigned long _Duration);
}
namespace std
{
	using::size_t;
	using::div_t;
	using::ldiv_t;
	using::abort;
	using::abs;
	using::atexit;
	using::atof;
	using::atoi;
	using::atol;
	using::bsearch;
	using::calloc;
	using::div;
	using::exit;
	using::free;
	using::getenv;
	using::labs;
	using::ldiv;
	using::malloc;
	using::mblen;
	using::mbstowcs;
	using::mbtowc;
	using::qsort;
	using::rand;
	using::realloc;
	using::srand;
	using::strtod;
	using::strtol;
	using::strtoul;
	using::system;
	using::wcstombs;
	using::wctomb;
}
namespace std
{
	typedef void(*new_handler)();
	struct nothrow_t
	{
	};
	extern const nothrow_t nothrow;
	new_handler set_new_handler(new_handler)throw();
}
void operator delete(void*)throw();
void*operator new(size_t _Size)throw(...);
inline void*operator new(size_t, void*_Where)throw()
{
	return (_Where);
}
inline void operator delete(void*, void*)throw()
{
}
inline void*operator new[](size_t, void*_Where)throw()
{
	return (_Where);
}
inline void operator delete[](void*, void*)throw()
{
}
void operator delete[](void*)throw();
void*operator new[](size_t _Size)throw(...);
void*operator new(size_t _Size, const std::nothrow_t&)throw();
void*operator new[](size_t _Size, const std::nothrow_t&)throw();
void operator delete(void*, const std::nothrow_t&)throw();
void operator delete[](void*, const std::nothrow_t&)throw();
using std::new_handler;
namespace std
{
	template<class _Ty>
	inline _Ty*_Allocate(size_t _Count, _Ty*)
	{
		if(_Count<=0)_Count=0;
		else if(((size_t)(-1)/_Count)<sizeof(_Ty))throw std::bad_alloc(0);
		return ((_Ty*)::operator new(_Count*sizeof(_Ty)));
	}
	template<class _T1, class _T2>
	inline void _Construct(_T1*_Ptr, const _T2&_Val)
	{
		void*_Vptr=_Ptr;
		::new(_Vptr)_T1(_Val);
	}
	template<class _Ty>
	inline void _Destroy(_Ty*_Ptr)
	{
		(_Ptr)->~_Ty();
	}
	template<>
	inline void _Destroy(char*)
	{
	}
	template<>
	inline void _Destroy(wchar_t*)
	{
	}
	template<class _Ty>
	struct _Allocator_base
	{
		typedef _Ty value_type;
	};
	template<class _Ty>
	struct _Allocator_base<const _Ty>
	{
		typedef _Ty value_type;
	};
	template<class _Ty>
	class allocator: public _Allocator_base<_Ty>
	{
	public:
		typedef _Allocator_base<_Ty>_Mybase;
		typedef typename _Mybase::value_type value_type;
		typedef value_type*pointer;
		typedef value_type&reference;
		typedef const value_type*const_pointer;
		typedef const value_type&const_reference;
		typedef size_t size_type;
		typedef ptrdiff_t difference_type;
		template<class _Other>
		struct rebind
		{
			typedef allocator<_Other>other;
		};
		pointer address(reference _Val)const
		{
			return (&_Val);
		}
		const_pointer address(const_reference _Val)const
		{
			return (&_Val);
		}
		allocator()throw()
		{
		}
		allocator(const allocator<_Ty>&)throw()
		{
		}
		template<class _Other>
		allocator(const allocator<_Other>&)throw()
		{
		}
		template<class _Other>
		allocator<_Ty>&operator=(const allocator<_Other>&)
		{
			return (*this);
		}
		void deallocate(pointer _Ptr, size_type)
		{
			::operator delete(_Ptr);
		}
		pointer allocate(size_type _Count)
		{
			return (_Allocate(_Count, (pointer)0));
		}
		pointer allocate(size_type _Count, const void*)
		{
			return (allocate(_Count));
		}
		void construct(pointer _Ptr, const _Ty&_Val)
		{
			_Construct(_Ptr, _Val);
		}
		void destroy(pointer _Ptr)
		{
			_Destroy(_Ptr);
		}
		size_t max_size()const throw()
		{
			size_t _Count=(size_t)(-1)/sizeof(_Ty);
			return (0<_Count?_Count: 1);
		}
	};
	template<class _Ty, class _Other>
	inline bool operator==(const allocator<_Ty>&, const allocator<_Other>&)throw()
	{
		return (true);
	}
	template<class _Ty, class _Other>
	inline bool operator!=(const allocator<_Ty>&, const allocator<_Other>&)throw()
	{
		return (false);
	}
	template<>
	class allocator<void>
	{
	public:
		typedef void _Ty;
		typedef _Ty*pointer;
		typedef const _Ty*const_pointer;
		typedef _Ty value_type;
		template<class _Other>
		struct rebind
		{
			typedef allocator<_Other>other;
		};
		allocator()throw()
		{
		}
		allocator(const allocator<_Ty>&)throw()
		{
		}
		template<class _Other>
		allocator(const allocator<_Other>&)throw()
		{
		}
		template<class _Other>
		allocator<_Ty>&operator=(const allocator<_Other>&)
		{
			return (*this);
		}
	};
	template<class _Ty, class _Alloc>
	inline void _Destroy_range(_Ty*_First, _Ty*_Last, _Alloc&_Al)
	{
		_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}
	template<class _Ty, class _Alloc>
	inline void _Destroy_range(_Ty*_First, _Ty*_Last, _Alloc&_Al, _Nonscalar_ptr_iterator_tag)
	{
		for(;
		_First!=_Last;
		++_First)_Al.destroy(_First);
	}
	template<class _Ty, class _Alloc>
	inline void _Destroy_range(_Ty*_First, _Ty*_Last, _Alloc&_Al, _Scalar_ptr_iterator_tag)
	{
	}
}
namespace std
{
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Ax=allocator<_Elem> >
	class basic_string;
	template<class _Elem, class _Traits, class _Alloc>
	class _String_const_iterator: public _Ranit_base<_Elem, typename _Alloc::difference_type, typename _Alloc::const_pointer, typename _Alloc::const_reference, _Iterator_base_secure>
	{
	public:
		typedef _String_const_iterator<_Elem, _Traits, _Alloc>_Myt;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystring;
		typedef random_access_iterator_tag iterator_category;
		typedef _Elem value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::const_pointer pointer;
		typedef typename _Alloc::const_reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		_String_const_iterator()
		{
			_Myptr=0;
		}
		_String_const_iterator(pointer _Ptr, const _Container_base*_Pstring)
		{

			{
				if(!(_Pstring==0||_Ptr!=0&&((_Mystring*)_Pstring)->_Myptr()<=_Ptr&&_Ptr<=(((_Mystring*)_Pstring)->_Myptr()+((_Mystring*)_Pstring)->_Mysize)))
				{
					(void)((!!((("_Pstring == NULL || _Ptr != NULL && ((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 72, 0, L"(\"_Pstring == NULL || _Ptr != NULL && ((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 72, 0);
				};
			};
			this->_Adopt(_Pstring);
			_Myptr=_Ptr;
		}
		reference operator*()const
		{
			if(this->_Mycont==0||_Myptr==0||_Myptr<((_Mystring*)this->_Mycont)->_Myptr()||((_Mystring*)this->_Mycont)->_Myptr()+((_Mystring*)this->_Mycont)->_Mysize<=_Myptr)
			{
				_Debug_message(L"string iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 111);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 112, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 112, 0);
				};
			}
			return (*_Myptr);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			if(this->_Mycont!=((const _Container_base*)-2))
			{

				{
					if(!(this->_Mycont!=0))
					{
						(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 134, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 134, 0);
					};
				};

				{
					if(!(_Myptr<(((_Mystring*)this->_Mycont)->_Myptr()+((_Mystring*)this->_Mycont)->_Mysize)))
					{
						(void)((!!((("_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 135, 0, L"(\"_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize)\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 135, 0);
					};
				};
			}
			++_Myptr;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			if(this->_Mycont!=((const _Container_base*)-2))
			{

				{
					if(!(this->_Mycont!=0))
					{
						(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 152, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 152, 0);
					};
				};

				{
					if(!(_Myptr>((_Mystring*)this->_Mycont)->_Myptr()))
					{
						(void)((!!((("_Myptr > ((_Mystring *)this->_Mycont)->_Myptr()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 153, 0, L"(\"_Myptr > ((_Mystring *)this->_Mycont)->_Myptr()\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 153, 0);
					};
				};
			}
			--_Myptr;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{
			if(this->_Mycont!=((const _Container_base*)-2))
			{

				{
					if(!(this->_Mycont!=0))
					{
						(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 170, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 170, 0);
					};
				};

				{
					if(!(_Myptr+_Off<=(((_Mystring*)this->_Mycont)->_Myptr()+((_Mystring*)this->_Mycont)->_Mysize)&&_Myptr+_Off>=((_Mystring*)this->_Mycont)->_Myptr()))
					{
						(void)((!!((("_Myptr + _Off <= (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize) && _Myptr + _Off >= ((_Mystring *)this->_Mycont)->_Myptr()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 171, 0, L"(\"_Myptr + _Off <= (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize) && _Myptr + _Off >= ((_Mystring *)this->_Mycont)->_Myptr()\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 171, 0);
					};
				};
			}
			_Myptr+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr-_Right._Myptr);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		bool operator==(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr==_Right._Myptr);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		bool operator<(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr<_Right._Myptr);
		}
		bool operator>(const _Myt&_Right)const
		{
			return (_Right<*this);
		}
		bool operator<=(const _Myt&_Right)const
		{
			return (!(_Right<*this));
		}
		bool operator>=(const _Myt&_Right)const
		{
			return (!(*this<_Right));
		}
		void _Compat(const _Myt&_Right)const
		{
			if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
			{
				_Debug_message(L"string iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 271);

				{
					(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 272, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 272, 0);
				};
			}
		}
		static void _Xlen()
		{
			_Mystring::_Xlen();
		}
		static void _Xran()
		{
			_Mystring::_Xran();
		}
		static void _Xinvarg()
		{
			_Mystring::_Xinvarg();
		}
		pointer _Myptr;
	};
	template<class _Elem, class _Traits, class _Alloc>
	inline _String_const_iterator<_Elem, _Traits, _Alloc>operator+(typename _String_const_iterator<_Elem, _Traits, _Alloc>::difference_type _Off, _String_const_iterator<_Elem, _Traits, _Alloc>_Next)
	{
		return (_Next+=_Off);
	}
	template<class _Elem, class _Traits, class _Alloc>
	class _String_iterator: public _String_const_iterator<_Elem, _Traits, _Alloc>
	{
	public:
		typedef _String_iterator<_Elem, _Traits, _Alloc>_Myt;
		typedef _String_const_iterator<_Elem, _Traits, _Alloc>_Mybase;
		typedef random_access_iterator_tag iterator_category;
		typedef _Elem value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::pointer pointer;
		typedef typename _Alloc::reference reference;
		_String_iterator()
		{
		}
		_String_iterator(pointer _Ptr, const _Container_base*_Pstring): _Mybase(_Ptr, _Pstring)
		{
		}
		reference operator*()const
		{
			return ((reference)**(_Mybase*)this);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			++(*(_Mybase*)this);
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			--(*(_Mybase*)this);
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{
			(*(_Mybase*)this)+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Mybase&_Right)const
		{
			return ((_Mybase)*this-_Right);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
	};
	template<class _Elem, class _Traits, class _Alloc>
	inline _String_iterator<_Elem, _Traits, _Alloc>operator+(typename _String_iterator<_Elem, _Traits, _Alloc>::difference_type _Off, _String_iterator<_Elem, _Traits, _Alloc>_Next)
	{
		return (_Next+=_Off);
	}
	class _String_base: public _Container_base
	{
	public:
		static void _Xlen();
		static void _Xran();
		static void _Xinvarg();
	};
	template<class _Ty, class _Alloc>
	class _String_val: public _String_base
	{
		protected: typedef typename _Alloc::template rebind<_Ty>::other _Alty;
		_String_val(_Alty _Al=_Alty()): _Alval(_Al)
		{
		}
		_Alty _Alval;
	};
	template<class _Elem, class _Traits, class _Ax>
	class basic_string: public _String_val<_Elem, _Ax>
	{
	public:
		typedef basic_string<_Elem, _Traits, _Ax>_Myt;
		typedef _String_val<_Elem, _Ax>_Mybase;
		typedef typename _Mybase::_Alty _Alloc;
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename _Alloc::pointer _Tptr;
		typedef typename _Alloc::const_pointer _Ctptr;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef typename _Alloc::reference _Reft;
		typedef _Reft reference;
		typedef typename _Alloc::const_reference const_reference;
		typedef typename _Alloc::value_type value_type;
		typedef _String_iterator<_Elem, _Traits, _Alloc>iterator;
		typedef _String_const_iterator<_Elem, _Traits, _Alloc>const_iterator;
		friend class _String_const_iterator<_Elem, _Traits, _Alloc>;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		basic_string(): _Mybase()
		{
			_Tidy();
		}
		explicit basic_string(const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
		}
		basic_string(const _Myt&_Right): _Mybase(_Right._Alval)
		{
			_Tidy();
			assign(_Right, 0, npos);
		}
		basic_string(const _Myt&_Right, size_type _Roff, size_type _Count=npos): _Mybase()
		{
			_Tidy();
			assign(_Right, _Roff, _Count);
		}
		basic_string(const _Myt&_Right, size_type _Roff, size_type _Count, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			assign(_Right, _Roff, _Count);
		}
		basic_string(const _Elem*_Ptr, size_type _Count): _Mybase()
		{
			_Tidy();
			assign(_Ptr, _Count);
		}
		basic_string(const _Elem*_Ptr, size_type _Count, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			assign(_Ptr, _Count);
		}
		basic_string(const _Elem*_Ptr): _Mybase()
		{
			_Tidy();
			assign(_Ptr);
		}
		basic_string(const _Elem*_Ptr, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			assign(_Ptr);
		}
		basic_string(size_type _Count, _Elem _Ch): _Mybase()
		{
			_Tidy();
			assign(_Count, _Ch);
		}
		basic_string(size_type _Count, _Elem _Ch, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			assign(_Count, _Ch);
		}
		template<class _It>
		basic_string(_It _First, _It _Last): _Mybase()
		{
			_Tidy();
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		basic_string(_It _First, _It _Last, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		void _Construct(_It _Count, _It _Ch, _Int_iterator_tag)
		{
			assign((size_type)_Count, (_Elem)_Ch);
		}
		template<class _It>
		void _Construct(_It _First, _It _Last, input_iterator_tag)
		{
			try
			{
				for(;
				_First!=_Last;
				++_First)append((size_type)1, (_Elem)*_First);
			}
			catch(...)
			{
				_Tidy(true);
				throw;
			}
		}
		template<class _It>
		void _Construct(_It _First, _It _Last, forward_iterator_tag)
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 819);
			}
			size_type _Count=0;
			_Distance(_First, _Last, _Count);
			reserve(_Count);
			try
			{
				for(;
				_First!=_Last;
				++_First)append((size_type)1, (_Elem)*_First);
			}
			catch(...)
			{
				_Tidy(true);
				throw;
			}
		}
		basic_string(const_pointer _First, const_pointer _Last): _Mybase()
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 842);
			}
			_Tidy();
			if(_First!=_Last)assign(&*_First, _Last-_First);
		}
		basic_string(const_iterator _First, const_iterator _Last): _Mybase()
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 857);
			}
			_Tidy();
			if(_First!=_Last)assign(&*_First, _Last-_First);
		}
		~basic_string()
		{
			_Tidy(true);
		}
		typedef _Traits traits_type;
		typedef _Alloc allocator_type;
		static const size_type npos;
		_Myt&operator=(const _Myt&_Right)
		{
			return (assign(_Right));
		}
		_Myt&operator=(const _Elem*_Ptr)
		{
			return (assign(_Ptr));
		}
		_Myt&operator=(_Elem _Ch)
		{
			return (assign(1, _Ch));
		}
		_Myt&operator+=(const _Myt&_Right)
		{
			return (append(_Right));
		}
		_Myt&operator+=(const _Elem*_Ptr)
		{
			return (append(_Ptr));
		}
		_Myt&operator+=(_Elem _Ch)
		{
			return (append((size_type)1, _Ch));
		}
		_Myt&append(const _Myt&_Right)
		{
			return (append(_Right, 0, npos));
		}
		_Myt&append(const _Myt&_Right, size_type _Roff, size_type _Count)
		{
			if(_Right.size()<_Roff)_String_base::_Xran();
			size_type _Num=_Right.size()-_Roff;
			if(_Num<_Count)_Count=_Num;
			if(npos-_Mysize<=_Count||_Mysize+_Count<_Mysize)_String_base::_Xlen();
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Mysize, _Myres-_Mysize, _Right._Myptr()+_Roff, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&append(const _Elem*_Ptr, size_type _Count)
		{
			if(_Inside(_Ptr))return (append(*this, _Ptr-_Myptr(), _Count));
			if(npos-_Mysize<=_Count||_Mysize+_Count<_Mysize)_String_base::_Xlen();
			size_type _Num;
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Mysize, _Myres-_Mysize, _Ptr, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&append(const _Elem*_Ptr)
		{
			return (append(_Ptr, _Traits::length(_Ptr)));
		}
		_Myt&append(size_type _Count, _Elem _Ch)
		{
			if(npos-_Mysize<=_Count)_String_base::_Xlen();
			size_type _Num;
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Chassign(_Mysize, _Count, _Ch);
				_Eos(_Num);
			}
			return (*this);
		}
		template<class _It>
		_Myt&append(_It _First, _It _Last)
		{
			return (_Append(_First, _Last, _Iter_cat(_First)));
		}
		template<class _It>
		_Myt&_Append(_It _Count, _It _Ch, _Int_iterator_tag)
		{
			return (append((size_type)_Count, (_Elem)_Ch));
		}
		template<class _It>
		_Myt&_Append(_It _First, _It _Last, input_iterator_tag)
		{
			return (replace(end(), end(), _First, _Last));
		}
		_Myt&append(const_pointer _First, const_pointer _Last)
		{
			return (replace(end(), end(), _First, _Last));
		}
		_Myt&append(const_iterator _First, const_iterator _Last)
		{
			return (replace(end(), end(), _First, _Last));
		}
		_Myt&assign(const _Myt&_Right)
		{
			return (assign(_Right, 0, npos));
		}
		_Myt&assign(const _Myt&_Right, size_type _Roff, size_type _Count)
		{
			if(_Right.size()<_Roff)_String_base::_Xran();
			size_type _Num=_Right.size()-_Roff;
			if(_Count<_Num)_Num=_Count;
			if(this==&_Right)erase((size_type)(_Roff+_Num)), erase(0, _Roff);
			else if(_Grow(_Num))
			{
				_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr()+_Roff, _Num);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&assign(const _Elem*_Ptr, size_type _Num)
		{
			if(_Inside(_Ptr))return (assign(*this, _Ptr-_Myptr(), _Num));
			if(_Grow(_Num))
			{
				_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&assign(const _Elem*_Ptr)
		{
			return (assign(_Ptr, _Traits::length(_Ptr)));
		}
		_Myt&assign(size_type _Count, _Elem _Ch)
		{
			if(_Count==npos)_String_base::_Xlen();
			if(_Grow(_Count))
			{
				_Chassign(0, _Count, _Ch);
				_Eos(_Count);
			}
			return (*this);
		}
		template<class _It>
		_Myt&assign(_It _First, _It _Last)
		{
			return (_Assign(_First, _Last, _Iter_cat(_First)));
		}
		template<class _It>
		_Myt&_Assign(_It _Count, _It _Ch, _Int_iterator_tag)
		{
			return (assign((size_type)_Count, (_Elem)_Ch));
		}
		template<class _It>
		_Myt&_Assign(_It _First, _It _Last, input_iterator_tag)
		{
			return (replace(begin(), end(), _First, _Last));
		}
		_Myt&assign(const_pointer _First, const_pointer _Last)
		{
			return (replace(begin(), end(), _First, _Last));
		}
		_Myt&assign(const_iterator _First, const_iterator _Last)
		{
			return (replace(begin(), end(), _First, _Last));
		}
		_Myt&insert(size_type _Off, const _Myt&_Right)
		{
			return (insert(_Off, _Right, 0, npos));
		}
		_Myt&insert(size_type _Off, const _Myt&_Right, size_type _Roff, size_type _Count)
		{
			if(_Mysize<_Off||_Right.size()<_Roff)_String_base::_Xran();
			size_type _Num=_Right.size()-_Roff;
			if(_Num<_Count)_Count=_Num;
			if(npos-_Mysize<=_Count)_String_base::_Xlen();
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off, _Mysize-_Off);
				if(this==&_Right)_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+(_Off<_Roff?_Roff+_Count: _Roff), _Count);
				else _Traits_helper::copy_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Right._Myptr()+_Roff, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&insert(size_type _Off, const _Elem*_Ptr, size_type _Count)
		{
			if(_Inside(_Ptr))return (insert(_Off, *this, _Ptr-_Myptr(), _Count));
			if(_Mysize<_Off)_String_base::_Xran();
			if(npos-_Mysize<=_Count)_String_base::_Xlen();
			size_type _Num;
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off, _Mysize-_Off);
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Ptr, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&insert(size_type _Off, const _Elem*_Ptr)
		{
			return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}
		_Myt&insert(size_type _Off, size_type _Count, _Elem _Ch)
		{
			if(_Mysize<_Off)_String_base::_Xran();
			if(npos-_Mysize<=_Count)_String_base::_Xlen();
			size_type _Num;
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off, _Mysize-_Off);
				_Chassign(_Off, _Count, _Ch);
				_Eos(_Num);
			}
			return (*this);
		}
		iterator insert(iterator _Where)
		{
			return (insert(_Where, _Elem()));
		}
		iterator insert(iterator _Where, _Elem _Ch)
		{
			size_type _Off=_Pdif(_Where, begin());
			insert(_Off, 1, _Ch);
			return (begin()+_Off);
		}
		void insert(iterator _Where, size_type _Count, _Elem _Ch)
		{
			size_type _Off=_Pdif(_Where, begin());
			insert(_Off, _Count, _Ch);
		}
		template<class _It>
		void insert(iterator _Where, _It _First, _It _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		void _Insert(iterator _Where, _It _Count, _It _Ch, _Int_iterator_tag)
		{
			insert(_Where, (size_type)_Count, (_Elem)_Ch);
		}
		template<class _It>
		void _Insert(iterator _Where, _It _First, _It _Last, input_iterator_tag)
		{
			replace(_Where, _Where, _First, _Last);
		}
		void insert(iterator _Where, const_pointer _First, const_pointer _Last)
		{
			replace(_Where, _Where, _First, _Last);
		}
		void insert(iterator _Where, const_iterator _First, const_iterator _Last)
		{
			replace(_Where, _Where, _First, _Last);
		}
		_Myt&erase(size_type _Off=0, size_type _Count=npos)
		{
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_Count)_Count=_Mysize-_Off;
			if(0<_Count)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+_Off+_Count, _Mysize-_Off-_Count);
				size_type _Newsize=_Mysize-_Count;
				_Eos(_Newsize);
			}
			return (*this);
		}
		iterator erase(iterator _Where)
		{
			size_type _Count=_Pdif(_Where, begin());
			erase(_Count, 1);
			return (iterator(_Myptr()+_Count, this));
		}
		iterator erase(iterator _First, iterator _Last)
		{
			size_type _Count=_Pdif(_First, begin());
			erase(_Count, _Pdif(_Last, _First));
			return (iterator(_Myptr()+_Count, this));
		}
		void clear()
		{
			erase(begin(), end());
		}
		_Myt&replace(size_type _Off, size_type _N0, const _Myt&_Right)
		{
			return (replace(_Off, _N0, _Right, 0, npos));
		}
		_Myt&replace(size_type _Off, size_type _N0, const _Myt&_Right, size_type _Roff, size_type _Count)
		{
			if(_Mysize<_Off||_Right.size()<_Roff)_String_base::_Xran();
			if(_Mysize-_Off<_N0)_N0=_Mysize-_Off;
			size_type _Num=_Right.size()-_Roff;
			if(_Num<_Count)_Count=_Num;
			if(npos-_Count<=_Mysize-_N0)_String_base::_Xlen();
			size_type _Nm=_Mysize-_N0-_Off;
			size_type _Newsize=_Mysize+_Count-_N0;
			if(_Mysize<_Newsize)_Grow(_Newsize);
			if(this!=&_Right)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Right._Myptr()+_Roff, _Count);
			}
			else if(_Count<=_N0)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+_Roff, _Count);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
			}
			else if(_Roff<=_Off)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+_Roff, _Count);
			}
			else if(_Off+_N0<=_Roff)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+(_Roff+_Count-_N0), _Count);
			}
			else
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+_Roff, _N0);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_N0, _Myres-_Off-_N0, _Myptr()+_Roff+_Count, _Count-_N0);
			}
			_Eos(_Newsize);
			return (*this);
		}
		_Myt&replace(size_type _Off, size_type _N0, const _Elem*_Ptr, size_type _Count)
		{
			if(_Inside(_Ptr))return (replace(_Off, _N0, *this, _Ptr-_Myptr(), _Count));
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_N0)_N0=_Mysize-_Off;
			if(npos-_Count<=_Mysize-_N0)_String_base::_Xlen();
			size_type _Nm=_Mysize-_N0-_Off;
			if(_Count<_N0)_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
			size_type _Num;
			if((0<_Count||0<_N0)&&_Grow(_Num=_Mysize+_Count-_N0))
			{
				if(_N0<_Count)_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Ptr, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&replace(size_type _Off, size_type _N0, const _Elem*_Ptr)
		{
			return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}
		_Myt&replace(size_type _Off, size_type _N0, size_type _Count, _Elem _Ch)
		{
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_N0)_N0=_Mysize-_Off;
			if(npos-_Count<=_Mysize-_N0)_String_base::_Xlen();
			size_type _Nm=_Mysize-_N0-_Off;
			if(_Count<_N0)_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
			size_type _Num;
			if((0<_Count||0<_N0)&&_Grow(_Num=_Mysize+_Count-_N0))
			{
				if(_N0<_Count)_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Chassign(_Off, _Count, _Ch);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&replace(iterator _First, iterator _Last, const _Myt&_Right)
		{
			return (replace(_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
		}
		_Myt&replace(iterator _First, iterator _Last, const _Elem*_Ptr, size_type _Count)
		{
			return (replace(_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
		}
		_Myt&replace(iterator _First, iterator _Last, const _Elem*_Ptr)
		{
			return (replace(_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
		}
		_Myt&replace(iterator _First, iterator _Last, size_type _Count, _Elem _Ch)
		{
			return (replace(_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
		}
		template<class _It>
		_Myt&replace(iterator _First, iterator _Last, _It _First2, _It _Last2)
		{
			return (_Replace(_First, _Last, _First2, _Last2, _Iter_cat(_First2)));
		}
		template<class _It>
		_Myt&_Replace(iterator _First, iterator _Last, _It _Count, _It _Ch, _Int_iterator_tag)
		{
			return (replace(_First, _Last, (size_type)_Count, (_Elem)_Ch));
		}
		template<class _It>
		_Myt&_Replace(iterator _First, iterator _Last, _It _First2, _It _Last2, input_iterator_tag)
		{
			_Myt _Right(_First2, _Last2);
			replace(_First, _Last, _Right);
			return (*this);
		}
		_Myt&replace(iterator _First, iterator _Last, const_pointer _First2, const_pointer _Last2)
		{
			if(_First2==_Last2)erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
			else replace(_Pdif(_First, begin()), _Pdif(_Last, _First), &*_First2, _Last2-_First2);
			return (*this);
		}
		_Myt&replace(iterator _First, iterator _Last, const_iterator _First2, const_iterator _Last2)
		{
			if(_First2==_Last2)erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
			else replace(_Pdif(_First, begin()), _Pdif(_Last, _First), &*_First2, _Last2-_First2);
			return (*this);
		}
		iterator begin()
		{
			return (iterator(_Myptr(), this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Myptr(), this));
		}
		iterator end()
		{
			return (iterator(_Myptr()+_Mysize, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Myptr()+_Mysize, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		reference at(size_type _Off)
		{
			if(_Mysize<=_Off)_String_base::_Xran();
			return (_Myptr()[_Off]);
		}
		const_reference at(size_type _Off)const
		{
			if(_Mysize<=_Off)_String_base::_Xran();
			return (_Myptr()[_Off]);
		}
		reference operator[](size_type _Off)
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				if(_Mysize<_Off)
				{
					_Debug_message(L"string subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1498);

					{
						(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1499, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1499, 0);
					};
				}
			}
			return (_Myptr()[_Off]);
		}
		const_reference operator[](size_type _Off)const
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				if(_Mysize<_Off)
				{
					_Debug_message(L"string subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1518);

					{
						(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1519, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1519, 0);
					};
				}
			}
			return (_Myptr()[_Off]);
		}
		void push_back(_Elem _Ch)
		{
			insert(end(), _Ch);
		}
		const _Elem*c_str()const
		{
			return (_Myptr());
		}
		const _Elem*data()const
		{
			return (c_str());
		}
		size_type length()const
		{
			return (_Mysize);
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			size_type _Num=_Mybase::_Alval.max_size();
			return (_Num<=1?1: _Num-1);
		}
		void resize(size_type _Newsize)
		{
			resize(_Newsize, _Elem());
		}
		void resize(size_type _Newsize, _Elem _Ch)
		{
			if(_Newsize<=_Mysize)erase(_Newsize);
			else append(_Newsize-_Mysize, _Ch);
		}
		size_type capacity()const
		{
			return (_Myres);
		}
		void reserve(size_type _Newcap=0)
		{
			if(_Mysize<=_Newcap&&_Myres!=_Newcap)
			{
				size_type _Size=_Mysize;
				if(_Grow(_Newcap, true))_Eos(_Size);
			}
		}
		bool empty()const
		{
			return (_Mysize==0);
		}
		size_type copy(_Elem*_Dest, size_type _Count, size_type _Off=0)const
		{
			return _Copy_s(_Dest, _Count, _Count, _Off);
		}
		size_type _Copy_s(_Elem*_Dest, size_type _Dest_size, size_type _Count, size_type _Off=0)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1652);
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_Count)_Count=_Mysize-_Off;
			_Traits_helper::copy_s<_Traits>(_Dest, _Dest_size, _Myptr()+_Off, _Count);
			return (_Count);
		}
		void swap(_Myt&_Right)
		{
			if(_Mybase::_Alval==_Right._Alval)
			{
				this->_Swap_all(_Right);
				_Bxty _Tbx=_Bx;
				_Bx=_Right._Bx, _Right._Bx=_Tbx;
				size_type _Tlen=_Mysize;
				_Mysize=_Right._Mysize, _Right._Mysize=_Tlen;
				size_type _Tres=_Myres;
				_Myres=_Right._Myres, _Right._Myres=_Tres;
			}
			else
			{
				_Myt _Tmp=*this;
				*this=_Right, _Right=_Tmp;
			}
		}
		size_type find(const _Myt&_Right, size_type _Off=0)const
		{
			return (find(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1693);
			if(_Count==0&&_Off<=_Mysize)return (_Off);
			size_type _Nm;
			if(_Off<_Mysize&&_Count<=(_Nm=_Mysize-_Off))
			{
				const _Elem*_Uptr, *_Vptr;
				for(_Nm-=_Count-1, _Vptr=_Myptr()+_Off;
				(_Uptr=_Traits::find(_Vptr, _Nm, *_Ptr))!=0;
				_Nm-=_Uptr-_Vptr+1, _Vptr=_Uptr+1)if(_Traits::compare(_Uptr, _Ptr, _Count)==0)return (_Uptr-_Myptr());
			}
			return (npos);
		}
		size_type find(const _Elem*_Ptr, size_type _Off=0)const
		{
			return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find(_Elem _Ch, size_type _Off=0)const
		{
			return (find((const _Elem*)&_Ch, _Off, 1));
		}
		size_type rfind(const _Myt&_Right, size_type _Off=npos)const
		{
			return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type rfind(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1729);
			if(_Count==0)return (_Off<_Mysize?_Off: _Mysize);
			if(_Count<=_Mysize)
			{
				const _Elem*_Uptr=_Myptr()+(_Off<_Mysize-_Count?_Off: _Mysize-_Count);
				for(;
				;
				--_Uptr)if(_Traits::eq(*_Uptr, *_Ptr)&&_Traits::compare(_Uptr, _Ptr, _Count)==0)return (_Uptr-_Myptr());
				else if(_Uptr==_Myptr())break;
			}
			return (npos);
		}
		size_type rfind(const _Elem*_Ptr, size_type _Off=npos)const
		{
			return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type rfind(_Elem _Ch, size_type _Off=npos)const
		{
			return (rfind((const _Elem*)&_Ch, _Off, 1));
		}
		size_type find_first_of(const _Myt&_Right, size_type _Off=0)const
		{
			return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find_first_of(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1766);
			if(0<_Count&&_Off<_Mysize)
			{
				const _Elem*const _Vptr=_Myptr()+_Mysize;
				for(const _Elem*_Uptr=_Myptr()+_Off;
				_Uptr<_Vptr;
				++_Uptr)if(_Traits::find(_Ptr, _Count, *_Uptr)!=0)return (_Uptr-_Myptr());
			}
			return (npos);
		}
		size_type find_first_of(const _Elem*_Ptr, size_type _Off=0)const
		{
			return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find_first_of(_Elem _Ch, size_type _Off=0)const
		{
			return (find((const _Elem*)&_Ch, _Off, 1));
		}
		size_type find_last_of(const _Myt&_Right, size_type _Off=npos)const
		{
			return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find_last_of(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1797);
			if(0<_Count&&0<_Mysize)for(const _Elem*_Uptr=_Myptr()+(_Off<_Mysize?_Off: _Mysize-1);
			;
			--_Uptr)if(_Traits::find(_Ptr, _Count, *_Uptr)!=0)return (_Uptr-_Myptr());
			else if(_Uptr==_Myptr())break;
			return (npos);
		}
		size_type find_last_of(const _Elem*_Ptr, size_type _Off=npos)const
		{
			return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find_last_of(_Elem _Ch, size_type _Off=npos)const
		{
			return (rfind((const _Elem*)&_Ch, _Off, 1));
		}
		size_type find_first_not_of(const _Myt&_Right, size_type _Off=0)const
		{
			return (find_first_not_of(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find_first_not_of(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1830);
			if(_Off<_Mysize)
			{
				const _Elem*const _Vptr=_Myptr()+_Mysize;
				for(const _Elem*_Uptr=_Myptr()+_Off;
				_Uptr<_Vptr;
				++_Uptr)if(_Traits::find(_Ptr, _Count, *_Uptr)==0)return (_Uptr-_Myptr());
			}
			return (npos);
		}
		size_type find_first_not_of(const _Elem*_Ptr, size_type _Off=0)const
		{
			return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find_first_not_of(_Elem _Ch, size_type _Off=0)const
		{
			return (find_first_not_of((const _Elem*)&_Ch, _Off, 1));
		}
		size_type find_last_not_of(const _Myt&_Right, size_type _Off=npos)const
		{
			return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find_last_not_of(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1861);
			if(0<_Mysize)for(const _Elem*_Uptr=_Myptr()+(_Off<_Mysize?_Off: _Mysize-1);
			;
			--_Uptr)if(_Traits::find(_Ptr, _Count, *_Uptr)==0)return (_Uptr-_Myptr());
			else if(_Uptr==_Myptr())break;
			return (npos);
		}
		size_type find_last_not_of(const _Elem*_Ptr, size_type _Off=npos)const
		{
			return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find_last_not_of(_Elem _Ch, size_type _Off=npos)const
		{
			return (find_last_not_of((const _Elem*)&_Ch, _Off, 1));
		}
		_Myt substr(size_type _Off=0, size_type _Count=npos)const
		{
			return (_Myt(*this, _Off, _Count));
		}
		int compare(const _Myt&_Right)const
		{
			return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));
		}
		int compare(size_type _Off, size_type _N0, const _Myt&_Right)const
		{
			return (compare(_Off, _N0, _Right, 0, npos));
		}
		int compare(size_type _Off, size_type _N0, const _Myt&_Right, size_type _Roff, size_type _Count)const
		{
			if(_Right.size()<_Roff)_String_base::_Xran();
			if(_Right._Mysize-_Roff<_Count)_Count=_Right._Mysize-_Roff;
			return (compare(_Off, _N0, _Right._Myptr()+_Roff, _Count));
		}
		int compare(const _Elem*_Ptr)const
		{
			return (compare(0, _Mysize, _Ptr, _Traits::length(_Ptr)));
		}
		int compare(size_type _Off, size_type _N0, const _Elem*_Ptr)const
		{
			return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}
		int compare(size_type _Off, size_type _N0, const _Elem*_Ptr, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1923);
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_N0)_N0=_Mysize-_Off;
			size_type _Ans=_Traits::compare(_Myptr()+_Off, _Ptr, _N0<_Count?_N0: _Count);
			return (_Ans!=0?(int)_Ans: _N0<_Count?-1: _N0==_Count?0: +1);
		}
		allocator_type get_allocator()const
		{
			return (_Mybase::_Alval);
		}
		enum
		{
			_BUF_SIZE=16/sizeof(_Elem)<1?1: 16/sizeof(_Elem)
		};
		protected: enum
		{
			_ALLOC_MASK=sizeof(_Elem)<=1?15: sizeof(_Elem)<=2?7: sizeof(_Elem)<=4?3: sizeof(_Elem)<=8?1: 0
		};
		void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{
			if(_Count==1)_Traits::assign(*(_Myptr()+_Off), _Ch);
			else _Traits::assign(_Myptr()+_Off, _Count, _Ch);
		}
		void _Copy(size_type _Newsize, size_type _Oldlen)
		{
			size_type _Newres=_Newsize|_ALLOC_MASK;
			if(max_size()<_Newres)_Newres=_Newsize;
			else if(_Newres/3<_Myres/2&&_Myres<=max_size()-_Myres/2)_Newres=_Myres+_Myres/2;
			_Elem*_Ptr=0;
			try
			{
				_Ptr=_Mybase::_Alval.allocate(_Newres+1);
			}
			catch(...)
			{
				_Newres=_Newsize;
				try
				{
					_Ptr=_Mybase::_Alval.allocate(_Newres+1);
				}
				catch(...)
				{
					_Tidy(true);
					throw;
				}
			}
			if(0<_Oldlen)_Traits_helper::copy_s<_Traits>(_Ptr, _Newres+1, _Myptr(), _Oldlen);
			_Tidy(true);
			_Bx._Ptr=_Ptr;
			_Myres=_Newres;
			_Eos(_Oldlen);
		}
		void _Eos(size_type _Newsize)
		{
			_Traits::assign(_Myptr()[_Mysize=_Newsize], _Elem());
		}
		bool _Grow(size_type _Newsize, bool _Trim=false)
		{
			if(max_size()<_Newsize)_String_base::_Xlen();
			if(_Myres<_Newsize)_Copy(_Newsize, _Mysize);
			else if(_Trim&&_Newsize<_BUF_SIZE)_Tidy(true, _Newsize<_Mysize?_Newsize: _Mysize);
			else if(_Newsize==0)_Eos(0);
			return (0<_Newsize);
		}
		bool _Inside(const _Elem*_Ptr)
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 2013);
			if(_Ptr<_Myptr()||_Myptr()+_Mysize<=_Ptr)return (false);
			else return (true);
		}
		static size_type _Pdif(const_iterator _P2, const_iterator _P1)
		{
			return ((_P2)._Myptr==0?0: _P2-_P1);
		}
		void _Tidy(bool _Built=false, size_type _Newsize=0)
		{
			if(!_Built);
			else if(_BUF_SIZE<=_Myres)
			{
				_Elem*_Ptr=_Bx._Ptr;
				if(0<_Newsize)_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);
				_Mybase::_Alval.deallocate(_Ptr, _Myres+1);
			}
			_Myres=_BUF_SIZE-1;
			_Eos(_Newsize);
		}
		union _Bxty
		{
			_Elem _Buf[_BUF_SIZE];
			_Elem*_Ptr;
		}
		_Bx;
		_Elem*_Myptr()
		{
			return (_BUF_SIZE<=_Myres?_Bx._Ptr: _Bx._Buf);
		}
		const _Elem*_Myptr()const
		{
			return (_BUF_SIZE<=_Myres?_Bx._Ptr: _Bx._Buf);
		}
		size_type _Mysize;
		size_type _Myres;
	};
	template<class _Elem, class _Traits, class _Ax>
	class _Move_operation_category<basic_string<_Elem, _Traits, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Elem, class _Traits, class _Alloc>
	const typename basic_string<_Elem, _Traits, _Alloc>::size_type basic_string<_Elem, _Traits, _Alloc>::npos=(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
	template<class _Elem, class _Traits, class _Alloc>
	inline void swap(basic_string<_Elem, _Traits, _Alloc>&_Left, basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	typedef basic_string<char, char_traits<char>, allocator<char> >string;
	typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wstring;
}
namespace std
{
	class logic_error: public std::exception
	{
	public:
		explicit logic_error(const string&_Message): _Str(_Message)
		{
		}
		virtual~logic_error()throw()
		{
		}
		virtual const char*what()const throw()
		{
			return (_Str.c_str());
		}
	private:
		string _Str;
	};
	class domain_error: public logic_error
	{
	public:
		explicit domain_error(const string&_Message): logic_error(_Message)
		{
		}
		virtual~domain_error()throw()
		{
		}
	};
	class invalid_argument: public logic_error
	{
	public:
		explicit invalid_argument(const string&_Message): logic_error(_Message)
		{
		}
		virtual~invalid_argument()throw()
		{
		}
	};
	class length_error: public logic_error
	{
	public:
		explicit length_error(const string&_Message): logic_error(_Message)
		{
		}
		virtual~length_error()throw()
		{
		}
	};
	class out_of_range: public logic_error
	{
	public:
		explicit out_of_range(const string&_Message): logic_error(_Message)
		{
		}
		virtual~out_of_range()throw()
		{
		}
	};
	class runtime_error: public std::exception
	{
	public:
		explicit runtime_error(const string&_Message): _Str(_Message)
		{
		}
		virtual~runtime_error()throw()
		{
		}
		virtual const char*what()const throw()
		{
			return (_Str.c_str());
		}
	private:
		string _Str;
	};
	class overflow_error: public runtime_error
	{
	public:
		explicit overflow_error(const string&_Message): runtime_error(_Message)
		{
		}
		virtual~overflow_error()throw()
		{
		}
	};
	class underflow_error: public runtime_error
	{
	public:
		explicit underflow_error(const string&_Message): runtime_error(_Message)
		{
		}
		virtual~underflow_error()throw()
		{
		}
	};
	class range_error: public runtime_error
	{
	public:
		explicit range_error(const string&_Message): runtime_error(_Message)
		{
		}
		virtual~range_error()throw()
		{
		}
	};
}
namespace std
{
	template<class _Container>
	class back_insert_iterator: public _Outit
	{
	public:
		typedef _Container container_type;
		typedef typename _Container::reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		explicit back_insert_iterator(_Container&_Cont): container(&_Cont)
		{
		}
		back_insert_iterator<_Container>&operator=(typename _Container::const_reference _Val)
		{
			container->push_back(_Val);
			return (*this);
		}
		back_insert_iterator<_Container>&operator*()
		{
			return (*this);
		}
		back_insert_iterator<_Container>&operator++()
		{
			return (*this);
		}
		back_insert_iterator<_Container>operator++(int)
		{
			return (*this);
		}
		protected: _Container*container;
	};
	template<class _Container>
	inline back_insert_iterator<_Container>back_inserter(_Container&_Cont)
	{
		return (std::back_insert_iterator<_Container>(_Cont));
	}
	template<class _Container>
	class front_insert_iterator: public _Outit
	{
	public:
		typedef _Container container_type;
		typedef typename _Container::reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		explicit front_insert_iterator(_Container&_Cont): container(&_Cont)
		{
		}
		front_insert_iterator<_Container>&operator=(typename _Container::const_reference _Val)
		{
			container->push_front(_Val);
			return (*this);
		}
		front_insert_iterator<_Container>&operator*()
		{
			return (*this);
		}
		front_insert_iterator<_Container>&operator++()
		{
			return (*this);
		}
		front_insert_iterator<_Container>operator++(int)
		{
			return (*this);
		}
		protected: _Container*container;
	};
	template<class _Container>
	inline front_insert_iterator<_Container>front_inserter(_Container&_Cont)
	{
		return (std::front_insert_iterator<_Container>(_Cont));
	}
	template<class _Container>
	class insert_iterator: public _Outit
	{
	public:
		typedef _Container container_type;
		typedef typename _Container::reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		insert_iterator(_Container&_Cont, typename _Container::iterator _Where): container(&_Cont), iter(_Where)
		{
		}
		insert_iterator<_Container>&operator=(typename _Container::const_reference _Val)
		{
			iter=container->insert(iter, _Val);
			++iter;
			return (*this);
		}
		insert_iterator<_Container>&operator*()
		{
			return (*this);
		}
		insert_iterator<_Container>&operator++()
		{
			return (*this);
		}
		insert_iterator<_Container>&operator++(int)
		{
			return (*this);
		}
		protected: _Container*container;
		typename _Container::iterator iter;
	};
	template<class _Container, class _Iter>
	inline insert_iterator<_Container>inserter(_Container&_Cont, _Iter _Where)
	{
		return (std::insert_iterator<_Container>(_Cont, _Where));
	}
	template<class _Ty, class _Elem=char, class _Traits=char_traits<_Elem>, class _Diff=ptrdiff_t>
	class istream_iterator: public iterator<input_iterator_tag, _Ty, _Diff, const _Ty*, const _Ty&>
	{
		typedef istream_iterator<_Ty, _Elem, _Traits, _Diff>_Myt;
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef basic_istream<_Elem, _Traits>istream_type;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		istream_iterator(): _Myistr(0)
		{
		}
		istream_iterator(istream_type&_Istr): _Myistr(&_Istr)
		{
			_Getval();
		}
		const _Ty&operator*()const
		{
			if(_Myistr==0)
			{
				_Debug_message(L"istream_iterator is not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 202);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 203, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 203, 0);
				};
			}
			return (_Myval);
		}
		const _Ty*operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			if(_Myistr==0)
			{
				_Debug_message(L"istream_iterator is not incrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 223);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 224, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 224, 0);
				};
			}
			_Getval();
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		bool _Equal(const _Myt&_Right)const
		{
			return (_Myistr==_Right._Myistr);
		}
		protected: void _Getval()
		{
			if(_Myistr!=0&&!(*_Myistr>>_Myval))_Myistr=0;
		}
		static void _Xran()
		{
			throw out_of_range("invalid istream_iterator");
		}
		istream_type*_Myistr;
		_Ty _Myval;
	};
	template<class _Ty, class _Elem, class _Traits, class _Diff>
	inline bool operator==(const istream_iterator<_Ty, _Elem, _Traits, _Diff>&_Left, const istream_iterator<_Ty, _Elem, _Traits, _Diff>&_Right)
	{
		return (_Left._Equal(_Right));
	}
	template<class _Ty, class _Elem, class _Traits, class _Diff>
	inline bool operator!=(const istream_iterator<_Ty, _Elem, _Traits, _Diff>&_Left, const istream_iterator<_Ty, _Elem, _Traits, _Diff>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty, class _Elem=char, class _Traits=char_traits<_Elem> >
	class ostream_iterator: public _Outit
	{
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef basic_ostream<_Elem, _Traits>ostream_type;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		ostream_iterator(ostream_type&_Ostr, const _Elem*_Delim=0): _Myostr(&_Ostr), _Mydelim(_Delim)
		{
		}
		ostream_iterator<_Ty, _Elem, _Traits>&operator=(const _Ty&_Val)
		{
			*_Myostr<<_Val;
			if(_Mydelim!=0)*_Myostr<<_Mydelim;
			if(!*_Myostr)
			{
				_Debug_message(L"ostream_iterator is not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 316);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 317, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 317, 0);
				};
			}
			return (*this);
		}
		ostream_iterator<_Ty, _Elem, _Traits>&operator*()
		{
			return (*this);
		}
		ostream_iterator<_Ty, _Elem, _Traits>&operator++()
		{
			return (*this);
		}
		ostream_iterator<_Ty, _Elem, _Traits>operator++(int)
		{
			return (*this);
		}
		protected: static void _Xran()
		{
			throw out_of_range("invalid ostream_iterator");
		}
		const _Elem*_Mydelim;
		ostream_type*_Myostr;
	};
}
namespace stdext
{
	template<class _Cont, class _Iter=typename _Cont::iterator>
	class checked_iterator: public::std::iterator<typename::std::iterator_traits<_Iter>::iterator_category, typename::std::iterator_traits<_Iter>::value_type, typename::std::iterator_traits<_Iter>::difference_type, typename::std::iterator_traits<_Iter>::pointer, typename::std::iterator_traits<_Iter>::reference>
	{
		friend class checked_iterator;
	public:
		typedef checked_iterator<_Cont, _Iter>_Myt;
		typedef typename::std::iterator_traits<_Iter>::difference_type difference_type;
		typedef typename::std::iterator_traits<_Iter>::pointer pointer;
		typedef typename::std::iterator_traits<_Iter>::reference reference;
		typedef ::std::_Range_checked_iterator_tag _Checked_iterator_category;
		typedef _Iter _Inner_type;
		typedef _Iter _Checked_iterator_base_type;
		_Checked_iterator_base_type _Checked_iterator_base()const
		{
			return _Current;
		}
		void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
		{
			_Current=_Base;
		}
		checked_iterator(): _Mycont(0)
		{
		}
		checked_iterator(_Cont&_C, _Iter _Ptr): _Mycont(&_C), _Current(_Ptr)
		{
		}
		checked_iterator(const _Myt&_Right): _Mycont(_Right._Mycont), _Current(_Right._Current)
		{
		}
		template<class Iter2>
		checked_iterator(const checked_iterator<_Cont, Iter2>&_Right): _Mycont(_Right._Mycont), _Current(_Right._Current)
		{
		}
		_Iter base()const
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 412, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 412, 0);
				}
			};
			return _Current;
		}
		template<class Iter2>
		bool operator==(const checked_iterator<_Cont, Iter2>&_Right)const
		{

			{
				if(!(_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 419, 0, L"(\"_Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 419, 0);
				}
			};
			return _Current==_Right._Current;
		}
		template<class Iter2>
		bool operator!=(const checked_iterator<_Cont, Iter2>&_Right)const
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 426, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 426, 0);
				}
			};
			return !(*this==_Right);
		}
		template<class Iter2>
		bool operator<(const checked_iterator<_Cont, Iter2>&_Right)const
		{

			{
				if(!(_Mycont!=0&&_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont != NULL && _Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 433, 0, L"(\"_Mycont != NULL && _Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 433, 0);
				}
			};
			return _Current<_Right._Current;
		}
		template<class Iter2>
		bool operator>(const checked_iterator<_Cont, Iter2>&_Right)const
		{
			return _Right<*this;
		}
		template<class Iter2>
		bool operator<=(const checked_iterator<_Cont, Iter2>&_Right)const
		{
			return !(_Right<*this);
		}
		template<class Iter2>
		bool operator>=(const checked_iterator<_Cont, Iter2>&_Right)const
		{
			return !(*this<_Right);
		}
		reference operator*()const
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 457, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 457, 0);
				}
			};

			{
				if(!(_Current!=_Mycont->end()))
				{
					(void)((!!((("_Current != _Mycont->end()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 458, 0, L"(\"_Current != _Mycont->end()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 458, 0);
				}
			};
			return *_Current;
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 469, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 469, 0);
				}
			};

			{
				if(!(_Current!=_Mycont->end()))
				{
					(void)((!!((("_Current != _Mycont->end()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 470, 0, L"(\"_Current != _Mycont->end()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 470, 0);
				}
			};
			++_Current;
			return *this;
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return _Tmp;
		}
		_Myt&operator--()
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 484, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 484, 0);
				}
			};

			{
				if(!(_Current!=_Mycont->begin()))
				{
					(void)((!!((("_Current != _Mycont->begin()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 485, 0, L"(\"_Current != _Mycont->begin()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 485, 0);
				}
			};
			--_Current;
			return *this;
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return _Tmp;
		}
		_Myt&operator+=(difference_type _Off)
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 501, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 501, 0);
				}
			};

			{
				if(!((_Mycont->end()-_Current)>=_Off&&(_Mycont->begin()-_Current)<=_Off))
				{
					(void)((!!((("(_Mycont->end() - _Current) >= _Off && (_Mycont->begin() - _Current) <= _Off", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 502, 0, L"(\"(_Mycont->end() - _Current) >= _Off && (_Mycont->begin() - _Current) <= _Off\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 502, 0);
				}
			};
			_Current+=_Off;
			return *this;
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Myt&_Right)const
		{

			{
				if(!(_Mycont!=0&&_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont != NULL && _Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 526, 0, L"(\"_Mycont != NULL && _Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 526, 0);
				}
			};
			return _Current-_Right._Current;
		}
		reference operator[](difference_type _Off)const
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 532, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 532, 0);
				}
			};

			{
				if(!((_Mycont->end()-_Current)>_Off&&(_Mycont->begin()-_Current)<=_Off))
				{
					(void)((!!((("(_Mycont->end() - _Current) > _Off && (_Mycont->begin() - _Current) <= _Off", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 533, 0, L"(\"(_Mycont->end() - _Current) > _Off && (_Mycont->begin() - _Current) <= _Off\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 533, 0);
				}
			};
			return _Current[_Off];
		}
		protected: void _Xran()const
		{
			throw::std::out_of_range("invalid checked_iterator<T> subscript");
		}
		void _Xinvarg()const
		{
			throw::std::invalid_argument("invalid checked_iterator<T> argument");
		}
		_Cont*_Mycont;
		_Iter _Current;
	};
	template<class _Iterator>
	class checked_array_iterator: public::std::iterator<typename::std::iterator_traits<_Iterator>::iterator_category, typename::std::iterator_traits<_Iterator>::value_type, typename::std::iterator_traits<_Iterator>::difference_type, typename::std::iterator_traits<_Iterator>::pointer, typename::std::iterator_traits<_Iterator>::reference>
	{
	public:
		typedef checked_array_iterator<_Iterator>_Myt;
		typedef typename::std::iterator_traits<_Iterator>::difference_type difference_type;
		typedef typename::std::iterator_traits<_Iterator>::pointer pointer;
		typedef typename::std::iterator_traits<_Iterator>::reference reference;
		typedef ::std::_Range_checked_iterator_tag _Checked_iterator_category;
		typedef _Iterator _Inner_type;
		typedef _Iterator _Checked_iterator_base_type;
		_Checked_iterator_base_type _Checked_iterator_base()const
		{
			return _Mycont+_Current;
		}
		void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
		{
			_Current=_Base-_Mycont;
		}
		checked_array_iterator(): _Size(0), _Current(0)
		{
		}
		checked_array_iterator(_Iterator _Cont, size_t _S, size_t _Index=0)
		{

			{
				if(!(_Index<=_S))
				{
					(void)((!!((("_Index <= _S", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 592, 0, L"(\"_Index <= _S\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 592, 0);
				}
			};
			_Mycont=_Cont;
			_Size=_S;
			_Current=_Index;
		}
		_Iterator base()const
		{
			return _Mycont+_Current;
		}
		size_t __Size()const
		{
			return _Size;
		}
		bool operator==(const _Myt&_Right)const
		{

			{
				if(!(_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 610, 0, L"(\"_Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 610, 0);
				}
			};
			return _Current==_Right._Current;
		}
		bool operator!=(const _Myt&_Right)const
		{
			return !(*this==_Right);
		}
		bool operator<(const _Myt&_Right)const
		{

			{
				if(!(_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 621, 0, L"(\"_Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 621, 0);
				}
			};
			return _Current<_Right._Current;
		}
		bool operator>(const _Myt&_Right)const
		{
			return _Right<*this;
		}
		bool operator<=(const _Myt&_Right)const
		{
			return !(_Right<*this);
		}
		bool operator>=(const _Myt&_Right)const
		{
			return !(*this<_Right);
		}
		reference operator*()const
		{

			{
				if(!(_Current<_Size))
				{
					(void)((!!((("_Current < _Size", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 642, 0, L"(\"_Current < _Size\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 642, 0);
				}
			};
			return *(_Mycont+_Current);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		checked_array_iterator&operator++()
		{

			{
				if(!(_Current<_Size))
				{
					(void)((!!((("_Current < _Size", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 653, 0, L"(\"_Current < _Size\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 653, 0);
				}
			};
			++_Current;
			return *this;
		}
		_Myt operator++(int)
		{
			checked_array_iterator _Tmp=*this;
			++*this;
			return _Tmp;
		}
		_Myt&operator--()
		{

			{
				if(!(_Current>0))
				{
					(void)((!!((("_Current > 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 667, 0, L"(\"_Current > 0\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 667, 0);
				}
			};
			--_Current;
			return *this;
		}
		_Myt operator--(int)
		{
			checked_array_iterator _Tmp=*this;
			--*this;
			return _Tmp;
		}
		_Myt&operator+=(difference_type _Off)
		{

			{
				if(!(_Current+_Off<=_Size&&_Current+_Off>=0))
				{
					(void)((!!((("_Current + _Off <= _Size && _Current + _Off >= 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 683, 0, L"(\"_Current + _Off <= _Size && _Current + _Off >= 0\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 683, 0);
				}
			};
			_Current+=_Off;
			return *this;
		}
		_Myt operator+(difference_type _Off)const
		{
			checked_array_iterator _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			checked_array_iterator _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const checked_array_iterator&_Right)const
		{

			{
				if(!(_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 707, 0, L"(\"_Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 707, 0);
				}
			};
			return _Current-_Right._Current;
		}
		reference operator[](difference_type _Off)const
		{

			{
				if(!(_Current+_Off<_Size&&_Current+_Off>0))
				{
					(void)((!!((("_Current + _Off < _Size && _Current + _Off > 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 713, 0, L"(\"_Current + _Off < _Size && _Current + _Off > 0\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 713, 0);
				}
			};
			return *(_Mycont+_Current+_Off);
		}
		protected: void _Xran()const
		{
			throw::std::out_of_range("invalid checked_array_iterator<T> subscript");
		}
		void _Xinvarg()const
		{
			throw::std::invalid_argument("invalid checked_array_iterator<T> argument");
		}
		_Iterator _Mycont;
		size_t _Current;
		size_t _Size;
	};
}
namespace std
{
	template<class _Ty>
	inline pair<_Ty*, ptrdiff_t>get_temporary_buffer(ptrdiff_t _Count)
	{
		_Ty*_Pbuf;
		if(_Count<=0)_Count=0;
		else if(((size_t)(-1)/_Count)<sizeof(_Ty))throw std::bad_alloc(0);
		for(_Pbuf=0;
		0<_Count;
		_Count/=2)if((_Pbuf=(_Ty*)operator new((size_t)_Count*sizeof(_Ty), nothrow))!=0)break;
		return (pair<_Ty*, ptrdiff_t>(_Pbuf, _Count));
	}
	template<class _Ty>
	inline void return_temporary_buffer(_Ty*_Pbuf)
	{
		operator delete(_Pbuf);
	}
	template<class _InIt, class _FwdIt>
	inline _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 49);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 50);
		_FwdIt _Next=_Dest;
		try
		{
			for(;
			_First!=_Last;
			++_Dest, ++_First)_Construct(&*_Dest, *_First);
		}
		catch(...)
		{
			for(;
			_Next!=_Dest;
			++_Next)_Destroy(&*_Next);
			throw;
		}
		return (_Dest);
	}
	template<class _Ty1, class _Ty2>
	inline _Ty2 _Uninit_copy(_Ty1 _First, _Ty1 _Last, _Ty2 _Dest, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 69);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 70);
		size_t _Count=(size_t)(_Last-_First);
		_Ty2 _Result=_Dest+_Count;
		if(_Count>0)::memmove_s((&*_Dest), (_Count*sizeof(*_First)), (&*_First), (_Count*sizeof(*_First)));
		return _Result;
	}
	template<class _Ty1, class _Ty2, class _Ty3>
	inline _Ty2 _Uninit_copy(_Ty1 _First, _Ty1 _Last, _Ty2 _Dest, _Ty3 _Ptr_cat, _Unchecked_iterator_tag)
	{
		return _Uninit_copy(_First, _Last, _Dest, _Ptr_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _FwdIt>
	inline _FwdIt uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{
		return (_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 103);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 104);
		_FwdIt _Next=_Dest;
		try
		{
			for(;
			_First!=_Last;
			++_Dest, ++_First)_Al.construct(_Dest, *_First);
		}
		catch(...)
		{
			for(;
			_Next!=_Dest;
			++_Next)_Al.destroy(_Next);
			throw;
		}
		return (_Dest);
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 124);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 125);
		size_t _Count=(size_t)(_Last-_First);
		_FwdIt _Result=_Dest+_Count;
		if(_Count>0)::memmove_s((&*_Dest), (_Count*sizeof(*_First)), (&*_First), (_Count*sizeof(*_First)));
		return _Result;
	}
	template<class _InIt, class _FwdIt, class _Alloc, class _Ty>
	inline _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc _Al, _Ty _Ptr_cat, _Unchecked_iterator_tag)
	{
		return _Uninit_copy(_First, _Last, _Dest, _Al, _Ptr_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc, class _MoveCatTy>
	inline _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al, _MoveCatTy, _Range_checked_iterator_tag)
	{
		return (_Uninit_copy(_First, _Last, _Dest, _Al, _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al, _Swap_move_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 169);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 170);
		_FwdIt _Next=_Dest;
		typename _Alloc::value_type _Val;
		try
		{
			for(;
			_First!=_Last;
			++_Dest, ++_First)
			{
				_Al.construct(_Dest, _Val);
				::std::swap(*_Dest, *_First);
			}
		}
		catch(...)
		{
			for(;
			_Next!=_Dest;
			++_Next)_Al.destroy(_Next);
			throw;
		}
		return (_Dest);
	}
	template<class _InIt, class _FwdIt, class _Alloc, class _MoveCatTy>
	inline _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc _Al, _MoveCatTy _Move_cat, _Unchecked_iterator_tag)
	{
		return _Uninit_move(_First, _Last, _Dest, _Al, _Move_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (_Uninit_move(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, _Move_cat(_Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _FwdIt, class _Tval>
	inline void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval&_Val, _Nonscalar_ptr_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 215);
		_FwdIt _Next=_First;
		try
		{
			for(;
			_First!=_Last;
			++_First)_Construct(&*_First, _Val);
		}
		catch(...)
		{
			for(;
			_Next!=_First;
			++_Next)_Destroy(&*_Next);
			throw;
		}
	}
	template<class _Ty, class _Tval>
	inline void _Uninit_fill(_Ty*_First, _Ty*_Last, const _Tval&_Val, _Scalar_ptr_iterator_tag)
	{
		std::fill(_First, _Last, _Val);
	}
	template<class _FwdIt, class _Tval>
	inline void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval&_Val)
	{
		_Uninit_fill(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Ptr_cat(_First, _First));
	}
	template<class _FwdIt, class _Diff, class _Tval>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_FwdIt _Next=_First;
		try
		{
			for(;
			0<_Count;
			--_Count, ++_First)_Construct(&*_First, _Val);
		}
		catch(...)
		{
			for(;
			_Next!=_First;
			++_Next)_Destroy(&*_Next);
			throw;
		}
	}
	template<class _Ty, class _Diff, class _Tval>
	inline void _Uninit_fill_n(_Ty*_First, _Diff _Count, const _Tval&_Val, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		::stdext::unchecked_fill_n(_First, _Count, _Val);
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Ty2>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Ty2 _Ptr_cat, _Unchecked_iterator_tag)
	{
		_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat, _Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _Diff, class _Tval>
	inline void uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val)
	{
		_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First), ::std::_Checked_cat(_First));
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_FwdIt _Next=_First;
		try
		{
			for(;
			0<_Count;
			--_Count, ++_First)_Al.construct(_First, _Val);
		}
		catch(...)
		{
			for(;
			_Next!=_First;
			++_Next)_Al.destroy(_Next);
			throw;
		}
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		::stdext::unchecked_fill_n(_First, _Count, _Val);
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc, class _Ty>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al, _Ty _Ptr_cat, _Unchecked_iterator_tag)
	{
		_Uninit_fill_n(_First, _Count, _Val, _Al, _Ptr_cat, _Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al)
	{
		_Uninit_fill_n(_First, _Count, _Val, _Al, _Ptr_cat(_First, _First), ::std::_Checked_cat(_First));
	}
	template<class _FwdIt, class _Ty>
	class raw_storage_iterator: public _Outit
	{
	public:
		typedef _FwdIt iterator_type;
		typedef _FwdIt iter_type;
		typedef _Ty element_type;
		explicit raw_storage_iterator(_FwdIt _First): _Next(_First)
		{
		}
		raw_storage_iterator<_FwdIt, _Ty>&operator*()
		{
			return (*this);
		}
		raw_storage_iterator<_FwdIt, _Ty>&operator=(const _Ty&_Val)
		{
			_Construct(&*_Next, _Val);
			return (*this);
		}
		raw_storage_iterator<_FwdIt, _Ty>&operator++()
		{
			++_Next;
			return (*this);
		}
		raw_storage_iterator<_FwdIt, _Ty>operator++(int)
		{
			raw_storage_iterator<_FwdIt, _Ty>_Ans=*this;
			++_Next;
			return (_Ans);
		}
	private:
		_FwdIt _Next;
	};
	template<class _Ty>
	class _Temp_iterator: public _Outit
	{
	public:
		typedef _Ty*_Pty;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		_Temp_iterator(ptrdiff_t _Count=0)
		{
			_Buf._Begin=0;
			_Buf._Current=0;
			_Buf._Hiwater=0;
			_Buf._Size=_Count;
			_Pbuf=&_Buf;
		}
		_Temp_iterator(const _Temp_iterator<_Ty>&_Right)
		{
			_Buf._Begin=0;
			_Buf._Current=0;
			_Buf._Hiwater=0;
			_Buf._Size=0;
			*this=_Right;
		}
		~_Temp_iterator()
		{
			if(_Buf._Begin!=0)
			{
				for(_Pty _Next=_Buf._Begin;
				_Next!=_Buf._Hiwater;
				++_Next)_Destroy(&*_Next);
				std::return_temporary_buffer(_Buf._Begin);
			}
		}
		_Temp_iterator<_Ty>&operator=(const _Temp_iterator<_Ty>&_Right)
		{
			_Pbuf=_Right._Pbuf;
			return (*this);
		}
		_Temp_iterator<_Ty>&operator=(const _Ty&_Val)
		{
			if(_Pbuf->_Current<_Pbuf->_Hiwater)*_Pbuf->_Current++=_Val;
			else
			{

				{
					if(!((_Pbuf->_Current-_Pbuf->_Begin)<_Pbuf->_Size))
					{
						(void)((!!((("(_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 451, 0, L"(\"(_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 451, 0);
					};
				};
				_Pty _Ptr=&*_Pbuf->_Current;
				_Construct(_Ptr, _Val);
				_Pbuf->_Hiwater=++_Pbuf->_Current;
			}
			return (*this);
		}
		_Temp_iterator<_Ty>&operator*()
		{
			return (*this);
		}
		_Temp_iterator<_Ty>&operator++()
		{
			return (*this);
		}
		_Temp_iterator<_Ty>&operator++(int)
		{
			return (*this);
		}
		_Temp_iterator<_Ty>&_Init()
		{
			_Pbuf->_Current=_Pbuf->_Begin;
			return (*this);
		}
		_Pty _First()const
		{
			return (_Pbuf->_Begin);
		}
		_Pty _Last()const
		{
			return (_Pbuf->_Current);
		}
		ptrdiff_t _Maxlen()
		{
			if(_Pbuf->_Begin==0&&0<_Pbuf->_Size)
			{
				pair<_Pty, ptrdiff_t>_Pair=std::get_temporary_buffer<_Ty>(_Pbuf->_Size);
				_Pbuf->_Begin=_Pair.first;
				_Pbuf->_Current=_Pair.first;
				_Pbuf->_Hiwater=_Pair.first;
				_Pbuf->_Size=_Pair.second;
			}
			return (_Pbuf->_Size);
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid _Temp_iterator<T> argument");
		}
	private:
		struct _Bufpar
		{
			_Pty _Begin;
			_Pty _Current;
			_Pty _Hiwater;
			ptrdiff_t _Size;
		};
		_Bufpar _Buf;
		_Bufpar*_Pbuf;
	};
	template<class _Ty>
	class auto_ptr;
	template<class _Ty>
	struct auto_ptr_ref
	{
		auto_ptr_ref(void*_Right): _Ref(_Right)
		{
		}
		void*_Ref;
	};
	template<class _Ty>
	class auto_ptr
	{
	public:
		typedef _Ty element_type;
		explicit auto_ptr(_Ty*_Ptr=0)throw(): _Myptr(_Ptr)
		{
		}
		auto_ptr(auto_ptr<_Ty>&_Right)throw(): _Myptr(_Right.release())
		{
		}
		auto_ptr(auto_ptr_ref<_Ty>_Right)throw()
		{
			_Ty**_Pptr=(_Ty**)_Right._Ref;
			_Ty*_Ptr=*_Pptr;
			*_Pptr=0;
			_Myptr=_Ptr;
		}
		template<class _Other>
		operator auto_ptr<_Other>()throw()
		{
			return (auto_ptr<_Other>(*this));
		}
		template<class _Other>
		operator auto_ptr_ref<_Other>()throw()
		{
			_Other*_Testptr=(_Ty*)_Myptr;
			auto_ptr_ref<_Other>_Ans(&_Myptr);
			return (_Testptr!=0?_Ans: _Ans);
		}
		template<class _Other>
		auto_ptr<_Ty>&operator=(auto_ptr<_Other>&_Right)throw()
		{
			reset(_Right.release());
			return (*this);
		}
		template<class _Other>
		auto_ptr(auto_ptr<_Other>&_Right)throw(): _Myptr(_Right.release())
		{
		}
		auto_ptr<_Ty>&operator=(auto_ptr<_Ty>&_Right)throw()
		{
			reset(_Right.release());
			return (*this);
		}
		auto_ptr<_Ty>&operator=(auto_ptr_ref<_Ty>_Right)throw()
		{
			_Ty**_Pptr=(_Ty**)_Right._Ref;
			_Ty*_Ptr=*_Pptr;
			*_Pptr=0;
			reset(_Ptr);
			return (*this);
		}
		~auto_ptr()
		{
			delete(_Ty*)_Myptr;
		}
		_Ty&operator*()const throw()
		{
			if(_Myptr==0)_Debug_message(L"auto_ptr not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 613);
			;
			return (*(_Ty*)_Myptr);
		}
		_Ty*operator->()const throw()
		{
			return (&**this);
		}
		_Ty*get()const throw()
		{
			return ((_Ty*)_Myptr);
		}
		_Ty*release()throw()
		{
			_Ty*_Tmp=(_Ty*)_Myptr;
			_Myptr=0;
			return (_Tmp);
		}
		void reset(_Ty*_Ptr=0)
		{
			if(_Ptr!=_Myptr)delete(_Ty*)_Myptr;
			_Myptr=_Ptr;
		}
	private:
		const _Ty*_Myptr;
	};
}
namespace stdext
{
	template<class _InIt, class _FwdIt>
	inline _FwdIt unchecked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{
		return (::std::_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Ptr_cat(_First, _Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _FwdIt>
	inline _FwdIt checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{
		return (::std::_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt unchecked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (::std::_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, ::std::_Ptr_cat(_First, _Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (::std::_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, ::std::_Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Unchecked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (::std::_Uninit_move(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, ::std::_Move_cat(_Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Checked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (::std::_Uninit_move(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, ::std::_Move_cat(_Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _FwdIt, class _Diff, class _Tval>
	inline void unchecked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val)
	{
		::std::_Uninit_fill_n(_First, _Count, _Val, ::std::_Ptr_cat(_First, _First), ::std::_Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _Diff, class _Tval>
	inline void checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val)
	{
		::std::_Uninit_fill_n(_First, _Count, _Val, ::std::_Ptr_cat(_First, _First), ::std::_Checked_cat(_First));
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void unchecked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al)
	{
		::std::_Uninit_fill_n(_First, _Count, _Val, _Al, ::std::_Ptr_cat(_First, _First), ::std::_Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al)
	{
		::std::_Uninit_fill_n(_First, _Count, _Val, _Al, ::std::_Ptr_cat(_First, _First), ::std::_Checked_cat(_First));
	}
}
namespace std
{
	template<class _Ty, class _Ax=allocator<_Ty> >
	class vector;
	template<class _Ty, class _Alloc>
	class _Vector_const_iterator: public _Ranit<_Ty, typename _Alloc::difference_type, typename _Alloc::const_pointer, typename _Alloc::const_reference>
	{
	public:
		typedef _Vector_const_iterator<_Ty, _Alloc>_Myt;
		typedef vector<_Ty, _Alloc>_Myvec;
		typedef typename _Alloc::pointer _Tptr;
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::const_pointer pointer;
		typedef typename _Alloc::const_reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		typedef _Tptr _Inner_type;
		_Vector_const_iterator()
		{
			_Myptr=0;
		}
		_Vector_const_iterator(_Tptr _Ptr, const _Container_base*_Pvector)
		{

			{
				if(!(_Pvector==0||(((_Myvec*)_Pvector)->_Myfirst<=_Ptr&&_Ptr<=((_Myvec*)_Pvector)->_Mylast)))
				{
					(void)((!!((("_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 71, 0, L"(\"_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 71, 0);
				};
			};
			this->_Adopt(_Pvector);
			_Myptr=_Ptr;
		}
		reference operator*()const
		{
			if(this->_Mycont==0||_Myptr<((_Myvec*)this->_Mycont)->_Myfirst||((_Myvec*)this->_Mycont)->_Mylast<=_Myptr)
			{
				_Debug_message(L"vector iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 99);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 100, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 100, 0);
				};
			}
			return (*_Myptr);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{

			{
				if(!(this->_Mycont!=0))
				{
					(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 117, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 117, 0);
				};
			};

			{
				if(!(_Myptr<((_Myvec*)(this->_Mycont))->_Mylast))
				{
					(void)((!!((("_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 118, 0, L"(\"_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 118, 0);
				};
			};
			++_Myptr;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{

			{
				if(!(this->_Mycont!=0))
				{
					(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 132, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 132, 0);
				};
			};

			{
				if(!(_Myptr>((_Myvec*)(this->_Mycont))->_Myfirst))
				{
					(void)((!!((("_Myptr > ((_Myvec *)(this->_Mycont))->_Myfirst", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 133, 0, L"(\"_Myptr > ((_Myvec *)(this->_Mycont))->_Myfirst\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 133, 0);
				};
			};
			--_Myptr;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{

			{
				if(!(this->_Mycont!=0))
				{
					(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 147, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 147, 0);
				};
			};

			{
				if(!(_Myptr+_Off<=((_Myvec*)(this->_Mycont))->_Mylast&&_Myptr+_Off>=((_Myvec*)(this->_Mycont))->_Myfirst))
				{
					(void)((!!((("_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast && _Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 148, 0, L"(\"_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast && _Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 148, 0);
				};
			};
			_Myptr+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr-_Right._Myptr);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		bool operator==(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr==_Right._Myptr);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		bool operator<(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr<_Right._Myptr);
		}
		bool operator>(const _Myt&_Right)const
		{
			return (_Right<*this);
		}
		bool operator<=(const _Myt&_Right)const
		{
			return (!(_Right<*this));
		}
		bool operator>=(const _Myt&_Right)const
		{
			return (!(*this<_Right));
		}
		void _Compat(const _Myt&_Right)const
		{
			if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
			{
				_Debug_message(L"vector iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 238);

				{
					(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 239, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 239, 0);
				};
			}
		}
		static void _Xlen()
		{
			throw length_error("vector<T> too long");
		}
		static void _Xran()
		{
			throw out_of_range("invalid vector<T> subscript");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid vector<T> argument");
		}
		_Tptr _Myptr;
	};
	template<class _Ty, class _Alloc>
	inline _Vector_const_iterator<_Ty, _Alloc>operator+(typename _Vector_const_iterator<_Ty, _Alloc>::difference_type _Off, _Vector_const_iterator<_Ty, _Alloc>_Next)
	{
		return (_Next+=_Off);
	}
	template<class _Ty, class _Alloc>
	class _Vector_iterator: public _Vector_const_iterator<_Ty, _Alloc>
	{
	public:
		typedef _Vector_iterator<_Ty, _Alloc>_Myt;
		typedef _Vector_const_iterator<_Ty, _Alloc>_Mybase;
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::pointer pointer;
		typedef typename _Alloc::reference reference;
		_Vector_iterator()
		{
		}
		_Vector_iterator(pointer _Ptr, const _Container_base*_Pvector): _Mybase(_Ptr, _Pvector)
		{
		}
		reference operator*()const
		{
			return ((reference)**(_Mybase*)this);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			++(*(_Mybase*)this);
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			--(*(_Mybase*)this);
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{
			(*(_Mybase*)this)+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Mybase&_Right)const
		{
			return (*(_Mybase*)this-_Right);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
	};
	template<class _Ty, class _Alloc>
	inline _Vector_iterator<_Ty, _Alloc>operator+(typename _Vector_iterator<_Ty, _Alloc>::difference_type _Off, _Vector_iterator<_Ty, _Alloc>_Next)
	{
		return (_Next+=_Off);
	}
	template<class _Ty, class _Alloc>
	class _Vector_val: public _Container_base
	{
		protected: _Vector_val()
		{
		}
		explicit _Vector_val(_Alloc _Al): _Alval(_Al)
		{
		}
		typedef typename _Alloc::template rebind<_Ty>::other _Alty;
		_Alty _Alval;
	};
	template<class _Ty, class _Ax>
	class vector: public _Vector_val<_Ty, _Ax>
	{
	public:
		typedef vector<_Ty, _Ax>_Myt;
		typedef _Vector_val<_Ty, _Ax>_Mybase;
		typedef typename _Mybase::_Alty _Alloc;
		typedef _Alloc allocator_type;
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename _Alloc::pointer _Tptr;
		typedef typename _Alloc::const_pointer _Ctptr;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef typename _Alloc::reference _Reft;
		typedef _Reft reference;
		typedef typename _Alloc::const_reference const_reference;
		typedef typename _Alloc::value_type value_type;
		typedef _Vector_iterator<_Ty, _Alloc>iterator;
		typedef _Vector_const_iterator<_Ty, _Alloc>const_iterator;
		friend class _Vector_const_iterator<_Ty, _Alloc>;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		vector(): _Mybase()
		{
			_Buy(0);
		}
		explicit vector(const _Alloc&_Al): _Mybase(_Al)
		{
			_Buy(0);
		}
		explicit vector(size_type _Count): _Mybase()
		{
			_Construct_n(_Count, _Ty());
		}
		vector(size_type _Count, const _Ty&_Val): _Mybase()
		{
			_Construct_n(_Count, _Val);
		}
		vector(size_type _Count, const _Ty&_Val, const _Alloc&_Al): _Mybase(_Al)
		{
			_Construct_n(_Count, _Val);
		}
		vector(const _Myt&_Right): _Mybase(_Right._Alval)
		{
			if(_Buy(_Right.size()))try
			{
				_Mylast=_Ucopy(_Right.begin(), _Right.end(), _Myfirst);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		template<class _Iter>
		vector(_Iter _First, _Iter _Last): _Mybase()
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc&_Al): _Mybase(_Al)
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			size_type _Size=(size_type)_Count;
			_Construct_n(_Size, (_Ty)_Val);
		}
		template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			_Buy(0);
			try
			{
				insert(begin(), _First, _Last);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		void _Construct_n(size_type _Count, const _Ty&_Val)
		{
			if(_Buy(_Count))
			{
				try
				{
					_Mylast=_Ufill(_Myfirst, _Count, _Val);
				}
				catch(...)
				{
					_Tidy();
					throw;
				}
			}
		}
		~vector()
		{
			_Tidy();
		}
		_Myt&operator=(const _Myt&_Right)
		{
			if(this!=&_Right)
			{
				this->_Orphan_all();
				if(_Right.size()==0)clear();
				else if(_Right.size()<=size())
				{
					pointer _Ptr=::stdext::unchecked_copy(_Right._Myfirst, _Right._Mylast, _Myfirst);
					_Destroy(_Ptr, _Mylast);
					_Mylast=_Myfirst+_Right.size();
				}
				else if(_Right.size()<=capacity())
				{
					pointer _Ptr=_Right._Myfirst+size();
					::stdext::unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);
					_Mylast=_Ucopy(_Ptr, _Right._Mylast, _Mylast);
				}
				else
				{
					if(_Myfirst!=0)
					{
						_Destroy(_Myfirst, _Mylast);
						this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
					}
					if(_Buy(_Right.size()))_Mylast=_Ucopy(_Right._Myfirst, _Right._Mylast, _Myfirst);
				}
			}
			return (*this);
		}
		void reserve(size_type _Count)
		{
			if(max_size()<_Count)_Xlen();
			else if(capacity()<_Count)
			{
				pointer _Ptr=this->_Alval.allocate(_Count);
				try
				{
					_Umove(begin(), end(), _Ptr);
				}
				catch(...)
				{
					this->_Alval.deallocate(_Ptr, _Count);
					throw;
				}
				size_type _Size=size();
				if(_Myfirst!=0)
				{
					_Destroy(_Myfirst, _Mylast);
					this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
				}
				this->_Orphan_all();
				_Myend=_Ptr+_Count;
				_Mylast=_Ptr+_Size;
				_Myfirst=_Ptr;
			}
		}
		size_type capacity()const
		{
			return (_Myfirst==0?0: _Myend-_Myfirst);
		}
		iterator begin()
		{
			return (iterator(_Myfirst, this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Myfirst, this));
		}
		iterator end()
		{
			return (iterator(_Mylast, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Mylast, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		void resize(size_type _Newsize)
		{
			resize(_Newsize, _Ty());
		}
		void resize(size_type _Newsize, _Ty _Val)
		{
			if(size()<_Newsize)_Insert_n(end(), _Newsize-size(), _Val);
			else if(_Newsize<size())erase(begin()+_Newsize, end());
		}
		size_type size()const
		{
			return (_Myfirst==0?0: _Mylast-_Myfirst);
		}
		size_type max_size()const
		{
			return (this->_Alval.max_size());
		}
		bool empty()const
		{
			return (size()==0);
		}
		_Alloc get_allocator()const
		{
			return (this->_Alval);
		}
		const_reference at(size_type _Pos)const
		{
			if(size()<=_Pos)_Xran();
			return (*(begin()+_Pos));
		}
		reference at(size_type _Pos)
		{
			if(size()<=_Pos)_Xran();
			return (*(begin()+_Pos));
		}
		const_reference operator[](size_type _Pos)const
		{
			if(size()<=_Pos)
			{
				_Debug_message(L"vector subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 744);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 745, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 745, 0);
				};
			}

			{
				if(!(_Pos<size()))
				{
					(void)((!!((("_Pos < size()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 748, 0, L"(\"_Pos < size()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 748, 0);
				};
			};
			return (*(_Myfirst+_Pos));
		}
		reference operator[](size_type _Pos)
		{
			if(size()<=_Pos)
			{
				_Debug_message(L"vector subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 759);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 760, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 760, 0);
				};
			}

			{
				if(!(_Pos<size()))
				{
					(void)((!!((("_Pos < size()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 763, 0, L"(\"_Pos < size()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 763, 0);
				};
			};
			return (*(_Myfirst+_Pos));
		}
		reference front()
		{
			return (*begin());
		}
		const_reference front()const
		{
			return (*begin());
		}
		reference back()
		{
			return (*(end()-1));
		}
		const_reference back()const
		{
			return (*(end()-1));
		}
		void push_back(const _Ty&_Val)
		{
			if(size()<capacity())
			{
				_Orphan_range(_Mylast, _Mylast);
				_Mylast=_Ufill(_Mylast, 1, _Val);
			}
			else insert(end(), _Val);
		}
		void pop_back()
		{
			if(empty())_Debug_message(L"vector empty before pop", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 810);
			else
			{
				_Orphan_range(_Mylast-1, _Mylast);
				_Destroy(_Mylast-1, _Mylast);
				--_Mylast;
			}
		}
		template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
			_Assign(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Assign_n((size_type)_Count, (_Ty)_Val);
		}
		template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			erase(begin(), end());
			insert(begin(), _First, _Last);
		}
		void assign(size_type _Count, const _Ty&_Val)
		{
			_Assign_n(_Count, _Val);
		}
		iterator insert(iterator _Where, const _Ty&_Val)
		{
			size_type _Off=size()==0?0: _Where-begin();
			_Insert_n(_Where, (size_type)1, _Val);
			return (begin()+_Off);
		}
		void insert(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			_Insert_n(_Where, _Count, _Val);
		}
		template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, _Int_iterator_tag)
		{
			_Insert_n(_Where, (size_type)_First, (_Ty)_Last);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
		{
			for(;
			_First!=_Last;
			++_First, ++_Where)_Where=insert(_Where, *_First);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
		{
			if(_Where._Mycont!=this||_Where._Myptr<_Myfirst||_Mylast<_Where._Myptr)_Debug_message(L"vector insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 895);
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 896);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"vector insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 898);
			size_type _Count=0;
			_Distance(_First, _Last, _Count);
			size_type _Capacity=capacity();
			if(_Count==0);
			else if(max_size()-size()<_Count)_Xlen();
			else if(_Capacity<size()+_Count)
			{
				_Capacity=max_size()-_Capacity/2<_Capacity?0: _Capacity+_Capacity/2;
				if(_Capacity<size()+_Count)_Capacity=size()+_Count;
				pointer _Newvec=this->_Alval.allocate(_Capacity);
				pointer _Ptr=_Newvec;
				try
				{
					_Ptr=_Umove(_Myfirst, (_Where)._Myptr, _Newvec);
					_Ptr=_Ucopy(_First, _Last, _Ptr);
					_Umove((_Where)._Myptr, _Mylast, _Ptr);
				}
				catch(...)
				{
					_Destroy(_Newvec, _Ptr);
					this->_Alval.deallocate(_Newvec, _Capacity);
					throw;
				}
				_Count+=size();
				if(_Myfirst!=0)
				{
					_Destroy(_Myfirst, _Mylast);
					this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
				}
				this->_Orphan_all();
				_Myend=_Newvec+_Capacity;
				_Mylast=_Newvec+_Count;
				_Myfirst=_Newvec;
			}
			else if((size_type)(end()-_Where)<_Count)
			{
				_Umove((_Where)._Myptr, _Mylast, (_Where)._Myptr+_Count);
				_Iter _Mid=_First;
				advance(_Mid, end()-_Where);
				try
				{
					_Ucopy(_Mid, _Last, _Mylast);
				}
				catch(...)
				{
					_Destroy((_Where)._Myptr+_Count, _Mylast+_Count);
					throw;
				}
				_Mylast+=_Count;
				_Orphan_range(_Where._Myptr, _Mylast);
				::stdext::unchecked_copy(_First, _Mid, (_Where)._Myptr);
			}
			else
			{
				pointer _Oldend=_Mylast;
				_Mylast=_Umove(_Oldend-_Count, _Oldend, _Mylast);
				::stdext::_Unchecked_move_backward((_Where)._Myptr, _Oldend-_Count, _Oldend);
				_Orphan_range(_Where._Myptr, _Mylast);
				::stdext::unchecked_copy(_First, _Last, (_Where)._Myptr);
			}
		}
		iterator erase(iterator _Where)
		{
			if(_Where._Mycont!=this||_Where._Myptr<_Myfirst||_Mylast<=_Where._Myptr)_Debug_message(L"vector erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 989);
			::stdext::unchecked_copy(_Where._Myptr+1, _Mylast, _Where._Myptr);
			_Destroy(_Mylast-1, _Mylast);
			_Orphan_range(_Where._Myptr, _Mylast);
			--_Mylast;
			return (iterator(_Where._Myptr, this));
		}
		iterator erase(iterator _First, iterator _Last)
		{
			if(_First!=_Last)
			{
				if(_Last<_First||_First._Mycont!=this||_First._Myptr<_Myfirst||_Mylast<_Last._Myptr)_Debug_message(L"vector erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1016);
				pointer _Ptr=::stdext::unchecked_copy((_Last)._Myptr, _Mylast, (_First)._Myptr);
				_Orphan_range(_First._Myptr, _Mylast);
				_Destroy(_Ptr, _Mylast);
				_Mylast=_Ptr;
			}
			return (iterator(_First._Myptr, this));
		}
		void clear()
		{
			erase(begin(), end());
		}
		void swap(_Myt&_Right)
		{
			if(this->_Alval==_Right._Alval)
			{
				this->_Swap_all(_Right);
				std::swap(_Myfirst, _Right._Myfirst);
				std::swap(_Mylast, _Right._Mylast);
				std::swap(_Myend, _Right._Myend);
			}
			else
			{
				_Myt _Ts=*this;
				*this=_Right, _Right=_Ts;
			}
		}
		protected: void _Assign_n(size_type _Count, const _Ty&_Val)
		{
			_Ty _Tmp=_Val;
			erase(begin(), end());
			insert(begin(), _Count, _Tmp);
		}
		bool _Buy(size_type _Capacity)
		{
			_Myfirst=0, _Mylast=0, _Myend=0;
			if(_Capacity==0)return (false);
			else if(max_size()<_Capacity)_Xlen();
			else
			{
				_Myfirst=this->_Alval.allocate(_Capacity);
				_Mylast=_Myfirst;
				_Myend=_Myfirst+_Capacity;
			}
			return (true);
		}
		void _Destroy(pointer _First, pointer _Last)
		{
			_Destroy_range(_First, _Last, this->_Alval);
		}
		void _Tidy()
		{
			if(_Myfirst!=0)
			{
				this->_Orphan_all();
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
			}
			_Myfirst=0, _Mylast=0, _Myend=0;
		}
		template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{
			return (::stdext::unchecked_uninitialized_copy(_First, _Last, _Ptr, this->_Alval));
		}
		template<class _Iter>
		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
		{
			return (::stdext::_Unchecked_uninitialized_move(_First, _Last, _Ptr, this->_Alval));
		}
		void _Insert_n(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			if(_Where._Mycont!=this||_Where._Myptr<_Myfirst||_Mylast<_Where._Myptr)_Debug_message(L"vector insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1125);
			_Ty _Tmp=_Val;
			size_type _Capacity=capacity();
			if(_Count==0);
			else if(max_size()-size()<_Count)_Xlen();
			else if(_Capacity<size()+_Count)
			{
				_Capacity=max_size()-_Capacity/2<_Capacity?0: _Capacity+_Capacity/2;
				if(_Capacity<size()+_Count)_Capacity=size()+_Count;
				pointer _Newvec=this->_Alval.allocate(_Capacity);
				pointer _Ptr=_Newvec;
				try
				{
					_Ptr=_Umove(_Myfirst, (_Where)._Myptr, _Newvec);
					_Ptr=_Ufill(_Ptr, _Count, _Tmp);
					_Umove((_Where)._Myptr, _Mylast, _Ptr);
				}
				catch(...)
				{
					_Destroy(_Newvec, _Ptr);
					this->_Alval.deallocate(_Newvec, _Capacity);
					throw;
				}
				_Count+=size();
				if(_Myfirst!=0)
				{
					_Destroy(_Myfirst, _Mylast);
					this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
				}
				this->_Orphan_all();
				_Myend=_Newvec+_Capacity;
				_Mylast=_Newvec+_Count;
				_Myfirst=_Newvec;
			}
			else if((size_type)(_Mylast-(_Where)._Myptr)<_Count)
			{
				_Umove((_Where)._Myptr, _Mylast, (_Where)._Myptr+_Count);
				try
				{
					_Ufill(_Mylast, _Count-(_Mylast-(_Where)._Myptr), _Tmp);
				}
				catch(...)
				{
					_Destroy((_Where)._Myptr+_Count, _Mylast+_Count);
					throw;
				}
				_Mylast+=_Count;
				_Orphan_range(_Where._Myptr, _Mylast);
				fill((_Where)._Myptr, _Mylast-_Count, _Tmp);
			}
			else
			{
				pointer _Oldend=_Mylast;
				_Mylast=_Umove(_Oldend-_Count, _Oldend, _Mylast);
				_Orphan_range(_Where._Myptr, _Mylast);
				::stdext::_Unchecked_move_backward((_Where)._Myptr, _Oldend-_Count, _Oldend);
				fill((_Where)._Myptr, (_Where)._Myptr+_Count, _Tmp);
			}
		}
		pointer _Ufill(pointer _Ptr, size_type _Count, const _Ty&_Val)
		{
			::stdext::unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);
			return (_Ptr+_Count);
		}
		static void _Xlen()
		{
			throw length_error("vector<T> too long");
		}
		static void _Xran()
		{
			throw out_of_range("invalid vector<T> subscript");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid vector<T> argument");
		}
		void _Orphan_range(pointer _First, pointer _Last)const
		{
			_Lockit _Lock(3);
			const_iterator**_Pnext=(const_iterator**)&this->_Myfirstiter;
			while(*_Pnext!=0)if((*_Pnext)->_Myptr<_First||_Last<(*_Pnext)->_Myptr)_Pnext=(const_iterator**)&(*_Pnext)->_Mynextiter;
			else
			{
				(*_Pnext)->_Mycont=0;
				*_Pnext=(const_iterator*)(*_Pnext)->_Mynextiter;
			}
		}
		pointer _Myfirst;
		pointer _Mylast;
		pointer _Myend;
	};
	template<class _Ty, class _Ax>
	class _Move_operation_category<vector<_Ty, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Ty, class _Alloc>
	inline bool operator==(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (_Left.size()==_Right.size()&&equal(_Left.begin(), _Left.end(), _Right.begin()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator!=(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty, class _Alloc>
	inline bool operator<(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Ty, class _Alloc>
	inline bool operator<=(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>=(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Ty, class _Alloc>
	inline void swap(vector<_Ty, _Alloc>&_Left, vector<_Ty, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	typedef unsigned _Vbase;
	const int _VBITS=8*sizeof(_Vbase);
	template<class _MycontTy>
	class _Vb_iter_base: public _Ranit<_Bool, typename _MycontTy::difference_type, bool*, bool>
	{
	public:
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		_Vb_iter_base(): _Myptr(0), _Myoff(0)
		{
		}
		_Vb_iter_base(const _Vb_iter_base<_MycontTy>&_Right): _Myptr(_Right._Myptr), _Myoff(_Right._Myoff)
		{

			{
				if(!(_Right._Mycont!=0))
				{
					(void)((!!((("_Right._Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1343, 0, L"(\"_Right._Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1343, 0);
				};
			};
			this->_Adopt(_Right._Mycont);
		}
		_Vb_iter_base(_Vbase*_Ptr, _MycontTy*_Mypvbool): _Myptr(_Ptr), _Myoff(0)
		{

			{
				if(!(_Mypvbool!=0))
				{
					(void)((!!((("_Mypvbool != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1350, 0, L"(\"_Mypvbool != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1350, 0);
				};
			};
			this->_Adopt(_Mypvbool);
		}
		_Vbase*_Myptr;
		typename _MycontTy::size_type _Myoff;
		static void _Xlen()
		{
			throw length_error("vector<bool> too long");
		}
		static void _Xran()
		{
			throw out_of_range("invalid vector<bool> subscript");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid vector<bool> argument");
		}
		_Vbase*_My_cont_begin()const
		{
			return (((_MycontTy*)this->_Mycont)->_Myvec.begin())._Myptr;
		}
		typename _MycontTy::size_type _My_actual_offset()const
		{
			typename _MycontTy::size_type _Off=this->_Myoff;
			_Off+=_VBITS*(this->_Myptr-_My_cont_begin());
			return _Off;
		}
	};
	template<class _MycontTy>
	class _Vb_reference: public _Vb_iter_base<_MycontTy>
	{
	public:
		_Vb_reference()
		{
		}
		_Vb_reference(const _Vb_iter_base<_MycontTy>&_Right): _Vb_iter_base<_MycontTy>(_Right)
		{
		}
		_Vb_reference&operator=(const _Vb_reference<_MycontTy>&_Right)
		{
			return (*this=bool(_Right));
		}
		_Vb_reference<_MycontTy>&operator=(bool _Val)
		{
			if(_Val)*_Getptr()|=_Mask();
			else*_Getptr()&=~_Mask();
			return (*this);
		}
		void flip()
		{
			*_Getptr()^=_Mask();
		}
		bool operator~()const
		{
			return (!bool(*this));
		}
		operator bool()const
		{
			return ((*_Getptr()&_Mask())!=0);
		}
		_Vbase*_Getptr()const
		{
			if(this->_Mycont==0||this->_Myptr==0||((_MycontTy*)this->_Mycont)->_Mysize<=this->_My_actual_offset())
			{
				_Debug_message(L"vector<bool> iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1466);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1467, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1467, 0);
				};
			}
			return (this->_Myptr);
		}
		protected: _Vbase _Mask()const
		{
			return ((_Vbase)(1<<this->_Myoff));
		}
	};
	template<class _MycontTy>
	void swap(_Vb_reference<_MycontTy>_Left, _Vb_reference<_MycontTy>_Right)
	{
		bool _Val=_Left;
		_Left=_Right;
		_Right=_Val;
	}
	template<class _MycontTy>
	class _Vb_const_iterator: public _Vb_iter_base<_MycontTy>
	{
	public:
		typedef _Vb_reference<_MycontTy>_Reft;
		typedef bool const_reference;
		typedef random_access_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef typename _MycontTy::size_type size_type;
		typedef typename _MycontTy::difference_type difference_type;
		typedef const_reference*pointer;
		typedef const_reference reference;
		_Vb_const_iterator()
		{
		}
		_Vb_const_iterator(const _Vbase*_Ptr, const _MycontTy*_Mypvbool): _Vb_iter_base<_MycontTy>((_Vbase*)_Ptr, (_MycontTy*)_Mypvbool)
		{
		}
		const_reference operator*()const
		{
			return (_Reft(*this));
		}
		_Vb_const_iterator<_MycontTy>&operator++()
		{
			_Inc();
			return (*this);
		}
		_Vb_const_iterator<_MycontTy>operator++(int)
		{
			_Vb_const_iterator<_MycontTy>_Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Vb_const_iterator<_MycontTy>&operator--()
		{
			_Dec();
			return (*this);
		}
		_Vb_const_iterator<_MycontTy>operator--(int)
		{
			_Vb_const_iterator<_MycontTy>_Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Vb_const_iterator<_MycontTy>&operator+=(difference_type _Off)
		{
			if(_Off==0)return (*this);

			{
				if(!(this->_Mycont!=0&&this->_Myptr!=0))
				{
					(void)((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1559, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1559, 0);
				};
			};
			if(_Off<0)
			{

				{
					if(!(this->_My_actual_offset()>=((size_type)-_Off)))
					{
						(void)((!!((("this->_My_actual_offset() >= ((size_type)-_Off)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1562, 0, L"(\"this->_My_actual_offset() >= ((size_type)-_Off)\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1562, 0);
					};
				};
			}
			else
			{

				{
					if(!((this->_My_actual_offset()+_Off)<=((_MycontTy*)this->_Mycont)->_Mysize))
					{
						(void)((!!((("(this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Mycont)->_Mysize", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1566, 0, L"(\"(this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Mycont)->_Mysize\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1566, 0);
					};
				};
			}
			if(_Off<0&&this->_Myoff<0-(size_type)_Off)
			{
				this->_Myoff+=_Off;
				this->_Myptr-=1+((size_type)(-1)-this->_Myoff)/_VBITS;
				this->_Myoff%=_VBITS;
			}
			else
			{
				this->_Myoff+=_Off;
				this->_Myptr+=this->_Myoff/_VBITS;
				this->_Myoff%=_VBITS;
			}
			return (*this);
		}
		_Vb_const_iterator<_MycontTy>operator+(difference_type _Off)const
		{
			_Vb_const_iterator<_MycontTy>_Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Vb_const_iterator<_MycontTy>&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Vb_const_iterator<_MycontTy>operator-(difference_type _Off)const
		{
			_Vb_const_iterator<_MycontTy>_Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			_Compat(_Right);
			return (_VBITS*(this->_Myptr-_Right._Myptr)+(difference_type)this->_Myoff-(difference_type)_Right._Myoff);
		}
		const_reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		bool operator==(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			_Compat(_Right);
			return (this->_Myptr==_Right._Myptr&&this->_Myoff==_Right._Myoff);
		}
		bool operator!=(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (!(*this==_Right));
		}
		bool operator<(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			_Compat(_Right);
			return (this->_Myptr<_Right._Myptr||this->_Myptr==_Right._Myptr&&this->_Myoff<_Right._Myoff);
		}
		bool operator>(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (_Right<*this);
		}
		bool operator<=(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (!(_Right<*this));
		}
		bool operator>=(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (!(*this<_Right));
		}
		protected: void _Compat(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)_Debug_message(L"vector<bool> iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1667);
		}
		void _Dec()
		{
			if(this->_Myoff!=0)
			{
				--this->_Myoff;
			}
			else
			{

				{
					if(!(this->_Mycont!=0&&this->_Myptr!=0))
					{
						(void)((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1679, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1679, 0);
					};
				};

				{
					if(!(this->_Myptr>this->_My_cont_begin()))
					{
						(void)((!!((("this->_Myptr > this->_My_cont_begin()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1680, 0, L"(\"this->_Myptr > this->_My_cont_begin()\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1680, 0);
					};
				};
				--this->_Myptr;
				this->_Myoff=_VBITS-1;
			}
		}
		void _Inc()
		{

			{
				if(!(this->_Mycont!=0&&this->_Myptr!=0))
				{
					(void)((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1688, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1688, 0);
				};
			};

			{
				if(!((this->_My_actual_offset()+1)<=((_MycontTy*)this->_Mycont)->_Mysize))
				{
					(void)((!!((("(this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Mycont)->_Mysize", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1689, 0, L"(\"(this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Mycont)->_Mysize\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1689, 0);
				};
			};
			if(this->_Myoff<_VBITS-1)++this->_Myoff;
			else this->_Myoff=0, ++this->_Myptr;
		}
	};
	template<class _MycontTy>
	_Vb_const_iterator<_MycontTy>operator+(typename _Vb_const_iterator<_MycontTy>::difference_type _Off, _Vb_const_iterator<_MycontTy>_Right)
	{
		return (_Right+=_Off);
	}
	template<class _MycontTy>
	class _Vb_iterator: public _Vb_const_iterator<_MycontTy>
	{
	public:
		typedef _Vb_reference<_MycontTy>_Reft;
		typedef bool const_reference;
		typedef random_access_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef typename _MycontTy::size_type size_type;
		typedef typename _MycontTy::difference_type difference_type;
		typedef _Reft*pointer;
		typedef _Reft reference;
		_Vb_iterator()
		{
		}
		_Vb_iterator(_Vbase*_Ptr, _MycontTy*_Mypvbool): _Vb_const_iterator<_MycontTy>(_Ptr, _Mypvbool)
		{
		}
		reference operator*()const
		{
			return (_Reft(*this));
		}
		_Vb_iterator<_MycontTy>&operator++()
		{
			++*(_Vb_const_iterator<_MycontTy>*)this;
			return (*this);
		}
		_Vb_iterator<_MycontTy>operator++(int)
		{
			_Vb_iterator<_MycontTy>_Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Vb_iterator<_MycontTy>&operator--()
		{
			--*(_Vb_const_iterator<_MycontTy>*)this;
			return (*this);
		}
		_Vb_iterator<_MycontTy>operator--(int)
		{
			_Vb_iterator<_MycontTy>_Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Vb_iterator<_MycontTy>&operator+=(difference_type _Off)
		{
			*(_Vb_const_iterator<_MycontTy>*)this+=_Off;
			return (*this);
		}
		_Vb_iterator<_MycontTy>operator+(difference_type _Off)const
		{
			_Vb_iterator<_MycontTy>_Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Vb_iterator<_MycontTy>&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Vb_iterator<_MycontTy>operator-(difference_type _Off)const
		{
			_Vb_iterator<_MycontTy>_Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (*(_Vb_const_iterator<_MycontTy>*)this-_Right);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
	};
	template<class _MycontTy>
	_Vb_iterator<_MycontTy>operator+(typename _Vb_iterator<_MycontTy>::difference_type _Off, _Vb_iterator<_MycontTy>_Right)
	{
		return (_Right+=_Off);
	}
	template<class _Alloc>
	class vector<_Bool, _Alloc>: public _Container_base
	{
	public:
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef std::vector<_Vbase, typename _Alloc::template rebind<_Vbase>::other>_Vbtype;
		typedef std::vector<_Bool, _Alloc>_Myt;
		typedef _Dift difference_type;
		typedef _Bool _Ty;
		typedef _Alloc allocator_type;
		typedef _Vb_reference<_Myt>reference;
		typedef bool const_reference;
		typedef bool value_type;
		typedef reference _Reft;
		typedef _Vb_const_iterator<_Myt>const_iterator;
		typedef _Vb_iterator<_Myt>iterator;
		friend class _Vb_reference<_Myt>;
		friend class _Vb_iter_base<_Myt>;
		friend class _Vb_const_iterator<_Myt>;
		typedef iterator pointer;
		typedef const_iterator const_pointer;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		vector(): _Mysize(0), _Myvec()
		{
		}
		explicit vector(const _Alloc&_Al): _Mysize(0), _Myvec(_Al)
		{
		}
		explicit vector(size_type _Count, bool _Val=false): _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val?-1: 0))
		{
			_Trim(_Count);
		}
		vector(size_type _Count, bool _Val, const _Alloc&_Al): _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val?-1: 0), _Al)
		{
			_Trim(_Count);
		}
		template<class _Iter>
		vector(_Iter _First, _Iter _Last): _Mysize(0), _Myvec()
		{
			_BConstruct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc&_Al): _Mysize(0), _Myvec(_Al)
		{
			_BConstruct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _BConstruct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			size_type _Num=(size_type)_Count;
			_Myvec.assign(_Num, (_Ty)_Val?-1: 0);
			_Trim(_Num);
		}
		template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			insert(begin(), _First, _Last);
		}
		~vector()
		{
			_Mysize=0;
		}
		void reserve(size_type _Count)
		{
			_Myvec.reserve(_Nw(_Count));
		}
		size_type capacity()const
		{
			return (_Myvec.capacity()*_VBITS);
		}
		iterator begin()
		{
			return (iterator((_Myvec.begin())._Myptr, this));
		}
		const_iterator begin()const
		{
			return (const_iterator((_Myvec.begin())._Myptr, this));
		}
		iterator end()
		{
			iterator _Tmp=begin();
			if(0<_Mysize)_Tmp+=_Mysize;
			return (_Tmp);
		}
		const_iterator end()const
		{
			const_iterator _Tmp=begin();
			if(0<_Mysize)_Tmp+=_Mysize;
			return (_Tmp);
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		void resize(size_type _Newsize, bool _Val=false)
		{
			if(size()<_Newsize)_Insert_n(end(), _Newsize-size(), _Val);
			else if(_Newsize<size())erase(begin()+_Newsize, end());
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			const size_type _Maxsize=_Myvec.max_size();
			return (_Maxsize<(size_type)(-1)/_VBITS?_Maxsize*_VBITS: (size_type)(-1));
		}
		bool empty()const
		{
			return (size()==0);
		}
		_Alloc get_allocator()const
		{
			return (_Myvec.get_allocator());
		}
		const_reference at(size_type _Off)const
		{
			if(size()<=_Off)_Xran();
			return (*(begin()+_Off));
		}
		reference at(size_type _Off)
		{
			if(size()<=_Off)_Xran();
			return (*(begin()+_Off));
		}
		const_reference operator[](size_type _Off)const
		{
			return (*(begin()+_Off));
		}
		reference operator[](size_type _Off)
		{
			return (*(begin()+_Off));
		}
		reference front()
		{
			return (*begin());
		}
		const_reference front()const
		{
			return (*begin());
		}
		reference back()
		{
			return (*(end()-1));
		}
		const_reference back()const
		{
			return (*(end()-1));
		}
		void push_back(bool _Val)
		{
			insert(end(), _Val);
		}
		void pop_back()
		{
			if(!empty())erase(end()-1);
		}
		template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
			_Assign(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Assign_n((size_type)_Count, (bool)_Val);
		}
		template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			erase(begin(), end());
			insert(begin(), _First, _Last);
		}
		void assign(size_type _Count, bool _Val)
		{
			_Assign_n(_Count, _Val);
		}
		iterator insert(iterator _Where, bool _Val)
		{
			size_type _Off=_Where-begin();
			_Insert_n(_Where, (size_type)1, _Val);
			return (begin()+_Off);
		}
		void insert(iterator _Where, size_type _Count, bool _Val)
		{
			_Insert_n(_Where, _Count, _Val);
		}
		template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Insert_n(_Where, (size_type)_Count, (bool)_Val);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
		{
			size_type _Off=_Where-begin();
			for(;
			_First!=_Last;
			++_First, ++_Off)insert(begin()+_Off, *_First);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2118);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"vector<bool> insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2120);
			size_type _Count=0;
			_Distance(_First, _Last, _Count);
			size_type _Off=_Insert_x(_Where, _Count);
			std::copy(_First, _Last, begin()+_Off);
		}
		iterator erase(iterator _Where)
		{
			size_type _Off=_Where-begin();
			if(end()<=_Where)_Debug_message(L"vector<bool> erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2136);
			std::copy(_Where+1, end(), _Where);
			_Orphan_range(_Off, _Mysize);
			_Trim(_Mysize-1);
			return (begin()+_Off);
		}
		iterator erase(iterator _First, iterator _Last)
		{
			size_type _Off=_First-begin();
			if(_Last<_First||end()<_Last)_Debug_message(L"vector<bool> erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2154);
			iterator _Next=std::copy(_Last, end(), _First);
			size_type _Newsize=_Next-begin();
			_Orphan_range(_Newsize, _Mysize);
			_Trim(_Newsize);
			return (begin()+_Off);
		}
		void clear()
		{
			erase(begin(), end());
		}
		void flip()
		{
			for(typename _Vbtype::iterator _Next=_Myvec.begin();
			_Next!=_Myvec.end();
			++_Next)*_Next=(_Vbase)~*_Next;
			_Trim(_Mysize);
		}
		void swap(_Myt&_Right)
		{
			this->_Swap_all(_Right);
			std::swap(_Mysize, _Right._Mysize);
			_Myvec.swap(_Right._Myvec);
		}
		static void swap(reference _Left, reference _Right)
		{
			bool _Val=_Left;
			_Left=_Right;
			_Right=_Val;
		}
		protected: void _Assign_n(size_type _Count, bool _Val)
		{
			erase(begin(), end());
			_Insert_n(begin(), _Count, _Val);
		}
		void _Insert_n(iterator _Where, size_type _Count, bool _Val)
		{
			size_type _Off=_Insert_x(_Where, _Count);
			fill(begin()+_Off, begin()+(_Off+_Count), _Val);
		}
		size_type _Insert_x(iterator _Where, size_type _Count)
		{
			size_type _Off=_Where-begin();
			if(end()<_Where)_Debug_message(L"vector<bool> insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2220);
			bool _Realloc=capacity()-size()<_Count;
			if(_Count==0);
			else if(max_size()-size()<_Count)_Xlen();
			else
			{
				_Myvec.resize(_Nw(size()+_Count), 0);
				if(size()==0)_Mysize+=_Count;
				else
				{
					iterator _Oldend=end();
					_Mysize+=_Count;
					copy_backward(begin()+_Off, _Oldend, end());
				}
				_Orphan_range(_Realloc?0: _Off, _Mysize);
			}
			return (_Off);
		}
		static size_type _Nw(size_type _Count)
		{
			return ((_Count+_VBITS-1)/_VBITS);
		}
		void _Orphan_range(size_type _Offlo, size_type _Offhi)const
		{
			_Lockit _Lock(3);
			_Vbase*_Base=(_Vbase*)(_Myvec.begin())._Myptr;
			_Vb_iter_base<_Myt>**_Pnext=(_Vb_iter_base<_Myt>**)&this->_Myfirstiter;
			while(*_Pnext!=0)
			{
				size_type _Off=_VBITS*((*_Pnext)->_Myptr-_Base)+(*_Pnext)->_Myoff;
				if(_Off<_Offlo||_Offhi<_Off)_Pnext=(_Vb_iter_base<_Myt>**)&(*_Pnext)->_Mynextiter;
				else
				{
					(*_Pnext)->_Mycont=0;
					*_Pnext=(_Vb_iter_base<_Myt>*)(*_Pnext)->_Mynextiter;
				}
			}
		}
		void _Trim(size_type _Size)
		{
			if(max_size()<_Size)_Xlen();
			size_type _Words=_Nw(_Size);
			if(_Words<_Myvec.size())_Myvec.erase(_Myvec.begin()+_Words, _Myvec.end());
			_Mysize=_Size;
			_Size%=_VBITS;
			if(0<_Size)_Myvec[_Words-1]&=(_Vbase)((1<<_Size)-1);
		}
		void _Xlen()const
		{
			throw length_error("vector<bool> too long");
		}
		void _Xran()const
		{
			throw out_of_range("invalid vector<bool> subscript");
		}
		size_type _Mysize;
		_Vbtype _Myvec;
	};
	typedef vector<bool, allocator<bool> >_Bvector;
}
inline const char*findFilename(const char*path)
{
	const char*result=strrchr(path, '/');
	if(result==0)
	{
		result=strrchr(path, '\\');
		if(result==0)
		{
			return path;
		}
	}
	return ++result;
}
inline const char*findFilenameSafe(const char*path)
{
	if(path!=0)
	{
		return findFilename(path);
	}
	return "<error>";
}
inline const char*findExtension(const char*path)
{
	const char*result=strrchr(path, '.');
	return result==0?path+strlen(path): result;
}
inline bool string_equal(const char*string, const char*other)
{
	return strcmp(string, other)==0;
}
inline bool string_equal_nocase(const char*string, const char*other)
{
	return _stricmp(string, other)==0;
}
inline bool string_equal_prefix(const char*left, const char*right)
{
	for(;
	*left!='\0'&&*right!='\0';
	++left, ++right)
	{
		if(*left!=*right)
		{
			return false;
		}
	}
	return true;
}
struct StringRange
{
	const char*first;
	const char*last;
	StringRange(const char*first, const char*last): first(first), last(last)
	{
	}
};
inline StringRange makeRange(const char*s)
{
	return StringRange(s, s+strlen(s));
}
inline size_t getLength(const StringRange&range)
{
	return range.last-range.first;
}
inline StringRange makeRange(const std::vector<char>&buffer)
{
	return buffer.empty()?StringRange(0, 0): StringRange(&(*buffer.begin()), &(*buffer.begin())+buffer.size());
}
struct Concatenate
{
	typedef std::vector<char>Buffer;
	Buffer buffer;
	Concatenate(const StringRange&left, const StringRange&right)
	{
		buffer.reserve(getLength(left)+getLength(right)+1);
		append(left);
		append(right);
		buffer.push_back('\0');
	}
	Concatenate(const StringRange&left, const StringRange&mid, const StringRange&right)
	{
		buffer.reserve(getLength(left)+getLength(mid)+getLength(right)+1);
		append(left);
		append(mid);
		append(right);
		buffer.push_back('\0');
	}
	void append(const StringRange&range)
	{
		buffer.insert(buffer.end(), range.first, range.last);
	}
	const char*c_str()const
	{
		return &(*buffer.begin());
	}
};
template<typename T, size_t CAPACITY>
struct Stack
{
	Stack(): depth(0)
	{
	}
	typedef T value_type;
	typedef value_type*iterator;
	typedef const value_type*const_iterator;
	value_type stack[CAPACITY];
	size_t depth;
	bool empty()const
	{
		return depth==0;
	}
	value_type&top()
	{
		return stack[depth-1];
	}
	const value_type&top()const
	{
		return stack[depth-1];
	}
	void push(value_type v)
	{
		stack[depth++]=v;
	}
	void pop()
	{
		--depth;
	}
	const_iterator begin()const
	{
		return stack;
	}
	const_iterator end()const
	{
		return stack+depth;
	}
};
typedef Stack<const char*, 1024>StringStack;
struct __type_info_node
{
	void*memPtr;
	__type_info_node*next;
};
extern __type_info_node __type_info_root_node;
class type_info
{
public:
	virtual~type_info();
	bool operator==(const type_info&rhs)const;
	bool operator!=(const type_info&rhs)const;
	int before(const type_info&rhs)const;
	const char*name(__type_info_node*__ptype_info_node=&__type_info_root_node)const;
	const char*raw_name()const;
private:
	void*_m_data;
	char _m_d_name[1];
	type_info(const type_info&rhs);
	type_info&operator=(const type_info&rhs);
	static const char*_Name_base(const type_info*, __type_info_node*__ptype_info_node);
	static void _Type_info_dtor(type_info*);
};
namespace std
{
	using::type_info;
}
namespace std
{
	class bad_cast: public exception
	{
	public:
		bad_cast(const char*_Message="bad cast");
		bad_cast(const bad_cast&);
		virtual~bad_cast();
	};
	class bad_typeid: public exception
	{
	public:
		bad_typeid(const char*_Message="bad typeid");
		bad_typeid(const bad_typeid&);
		virtual~bad_typeid();
	};
	class __non_rtti_object: public bad_typeid
	{
	public:
		__non_rtti_object(const char*_Message);
		__non_rtti_object(const __non_rtti_object&);
		virtual~__non_rtti_object();
	};
}
namespace std
{
	struct _DebugHeapTag_t
	{
		int _Type;
	};
}
void*operator new(size_t _Size, const std::_DebugHeapTag_t&, char*, int)throw(...);
void*operator new[](size_t _Size, const std::_DebugHeapTag_t&, char*, int)throw(...);
void operator delete(void*, const std::_DebugHeapTag_t&, char*, int)throw();
void operator delete[](void*, const std::_DebugHeapTag_t&, char*, int)throw();
namespace std
{
	const _DebugHeapTag_t&_DebugHeapTag_func();
	template<class _Ty>
	void _DebugHeapDelete(_Ty*_Ptr)
	{
		if(_Ptr!=0)
		{
			_Ptr->~_Ty();
			free(_Ptr);
		}
	}
	template<class _Ty>
	class _DebugHeapAllocator: public allocator<_Ty>
	{
	public:
		template<class _Other>
		struct rebind
		{
			typedef typename _DebugHeapAllocator<_Other>other;
		};
		typename allocator<_Ty>::pointer allocate(typename allocator<_Ty>::size_type _Count, const void*)
		{
			if(_Count<=0)_Count=0;
			else if(((size_t)(-1)/_Count)<sizeof(_Ty))throw std::bad_alloc(0);
			return ((_Ty*)new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xdebug", 86)char[_Count*sizeof(_Ty)]);
		}
		typename allocator<_Ty>::pointer allocate(typename allocator<_Ty>::size_type _Count)
		{
			if(_Count<=0)_Count=0;
			else if(((size_t)(-1)/_Count)<sizeof(_Ty))throw std::bad_alloc(0);
			return ((_Ty*)new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xdebug", 97)char[_Count*sizeof(_Ty)]);
		}
		void deallocate(typename allocator<_Ty>::pointer _Ptr, typename allocator<_Ty>::size_type)
		{
			std::_DebugHeapDelete((void*)_Ptr);
		}
	};
	template class _DebugHeapAllocator<char>
	;
	class _DebugHeapString: public basic_string<char, char_traits<char>, _DebugHeapAllocator<char> >
	{
	public:
		typedef _DebugHeapString _Myt;
		typedef basic_string<char, char_traits<char>, _DebugHeapAllocator<char> >_Mybase;
		typedef char _Elem;
		_DebugHeapString(): _Mybase()
		{
		}
		_DebugHeapString(const _Myt&_Right): _Mybase(_Right)
		{
		}
		_DebugHeapString(const _Elem*_Ptr): _Mybase(_Ptr)
		{
		}
		_DebugHeapString(const string&_Str): _Mybase(_Str.c_str())
		{
		}
		operator string()const
		{
			return (string(c_str()));
		}
	};
}
extern "C"
{
	int _isctype(int _C, int _Type);
	int _isctype_l(int _C, int _Type, _locale_t _Locale);
	int isalpha(int _C);
	int _isalpha_l(int _C, _locale_t _Locale);
	int isupper(int _C);
	int _isupper_l(int _C, _locale_t _Locale);
	int islower(int _C);
	int _islower_l(int _C, _locale_t _Locale);
	int isdigit(int _C);
	int _isdigit_l(int _C, _locale_t _Locale);
	int isxdigit(int _C);
	int _isxdigit_l(int _C, _locale_t _Locale);
	int isspace(int _C);
	int _isspace_l(int _C, _locale_t _Locale);
	int ispunct(int _C);
	int _ispunct_l(int _C, _locale_t _Locale);
	int isalnum(int _C);
	int _isalnum_l(int _C, _locale_t _Locale);
	int isprint(int _C);
	int _isprint_l(int _C, _locale_t _Locale);
	int isgraph(int _C);
	int _isgraph_l(int _C, _locale_t _Locale);
	int iscntrl(int _C);
	int _iscntrl_l(int _C, _locale_t _Locale);
	int toupper(int _C);
	int tolower(int _C);
	int _tolower(int _C);
	int _tolower_l(int _C, _locale_t _Locale);
	int _toupper(int _C);
	int _toupper_l(int _C, _locale_t _Locale);
	int __isascii(int _C);
	int __toascii(int _C);
	int __iscsymf(int _C);
	int __iscsym(int _C);
	int _chvalidator(int _Ch, int _Mask);
	int _chvalidator_l(_locale_t, int _Ch, int _Mask);
}
extern "C"
{
	struct lconv
	{
		char*decimal_point;
		char*thousands_sep;
		char*grouping;
		char*int_curr_symbol;
		char*currency_symbol;
		char*mon_decimal_point;
		char*mon_thousands_sep;
		char*mon_grouping;
		char*positive_sign;
		char*negative_sign;
		char int_frac_digits;
		char frac_digits;
		char p_cs_precedes;
		char p_sep_by_space;
		char n_cs_precedes;
		char n_sep_by_space;
		char p_sign_posn;
		char n_sign_posn;
	};
	int _configthreadlocale(int _Flag);
	char*setlocale(int _Category, const char*_Locale);
	struct lconv*localeconv(void);
	_locale_t _get_current_locale(void);
	_locale_t _create_locale(int _Category, const char*_Locale);
	void _free_locale(_locale_t _Locale);
	_locale_t __get_current_locale(void);
	_locale_t __create_locale(int _Category, const char*_Locale);
	void __free_locale(_locale_t _Locale);
}
extern "C"
{
	typedef struct _Collvec
	{
		unsigned long _Hand;
		unsigned int _Page;
	}
	_Collvec;
	typedef struct _Ctypevec
	{
		unsigned long _Hand;
		unsigned int _Page;
		const short*_Table;
		int _Delfl;
	}
	_Ctypevec;
	typedef struct _Cvtvec
	{
		unsigned long _Hand;
		unsigned int _Page;
	}
	_Cvtvec;
	_Collvec _Getcoll();
	_Ctypevec _Getctype();
	_Cvtvec _Getcvt();
	int _Getdateorder();
	int _Mbrtowc(wchar_t*, const char*, size_t, mbstate_t*, const _Cvtvec*);
	float _Stof(const char*, char**, long);
	double _Stod(const char*, char**, long);
	long double _Stold(const char*, char**, long);
	int _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*);
	size_t _Strxfrm(char*_String1, char*_End1, const char*, const char*, const _Collvec*);
	int _Tolower(int, const _Ctypevec*);
	int _Toupper(int, const _Ctypevec*);
	int _Wcrtomb(char*, wchar_t, mbstate_t*, const _Cvtvec*);
	int _Wcscoll(const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*);
	size_t _Wcsxfrm(wchar_t*_String1, wchar_t*_End1, const wchar_t*, const wchar_t*, const _Collvec*);
	short _Getwctype(wchar_t, const _Ctypevec*);
	const wchar_t*_Getwctypes(const wchar_t*, const wchar_t*, short*, const _Ctypevec*);
	wchar_t _Towlower(wchar_t, const _Ctypevec*);
	wchar_t _Towupper(wchar_t, const _Ctypevec*);
}
extern "C"
{
	void*_Gettnames();
	char*_Getdays();
	char*_Getmonths();
	size_t _Strftime(char*, size_t _Maxsize, const char*, const struct tm*, void*);
}
extern "C"
{
	_locale_t _GetLocaleForCP(unsigned int);
}
namespace std
{
	class _Timevec
	{
	public:
		_Timevec(void*_Ptr=0): _Timeptr(_Ptr)
		{
		}
		_Timevec(const _Timevec&_Right)
		{
			*this=_Right;
		}
		~_Timevec()
		{
			free(_Timeptr);
		}
		_Timevec&operator=(const _Timevec&_Right)
		{
			_Timeptr=_Right._Timeptr;
			((_Timevec*)&_Right)->_Timeptr=0;
			return (*this);
		}
		void*_Getptr()const
		{
			return (_Timeptr);
		}
	private:
		void*_Timeptr;
	};
	class _Locinfo
	{
	public:
		typedef ::_Collvec _Collvec;
		typedef ::_Ctypevec _Ctypevec;
		typedef ::_Cvtvec _Cvtvec;
		typedef std::_Timevec _Timevec;
		static void _Locinfo_ctor(_Locinfo*, const char*);
		static void _Locinfo_ctor(_Locinfo*, int, const char*);
		static void _Locinfo_dtor(_Locinfo*);
		static _Locinfo&_Locinfo_Addcats(_Locinfo*, int, const char*);
		_Locinfo(const char*_Pch="C"): _Lock(0)
		{
			if(_Pch==0)throw runtime_error("bad locale name");
			_Locinfo_ctor(this, _Pch);
		}
		_Locinfo(int _I, const char*_Pch): _Lock(0)
		{
			if(_Pch==0)throw runtime_error("bad locale name");
			_Locinfo_ctor(this, _I, _Pch);
		}
		~_Locinfo()
		{
			_Locinfo_dtor(this);
		}
		_Locinfo&_Addcats(int _I, const char*_Pch)
		{
			if(_Pch==0)throw runtime_error("bad locale name");
			return _Locinfo_Addcats(this, _I, _Pch);
		}
		string _Getname()const
		{
			return (_Newlocname);
		}
		_Collvec _Getcoll()const
		{
			return (::_Getcoll());
		}
		_Ctypevec _Getctype()const
		{
			return (::_Getctype());
		}
		_Cvtvec _Getcvt()const
		{
			return (::_Getcvt());
		}
		const lconv*_Getlconv()const
		{
			return (localeconv());
		}
		_Timevec _Gettnames()const
		{
			return (_Timevec(::_Gettnames()));
		}
		const char*_Getdays()const
		{
			const char*_Ptr=::_Getdays();
			if(_Ptr!=0)
			{
				((_Locinfo*)this)->_Days=_Ptr;
				free((void*)_Ptr);
			}
			return (_Days.size()!=0?_Days.c_str(): ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday" ":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}
		const char*_Getmonths()const
		{
			const char*_Ptr=::_Getmonths();
			if(_Ptr!=0)
			{
				((_Locinfo*)this)->_Months=_Ptr;
				free((void*)_Ptr);
			}
			return (_Months.size()!=0?_Months.c_str(): ":Jan:January:Feb:February:Mar:March" ":Apr:April:May:May:Jun:June" ":Jul:July:Aug:August:Sep:September" ":Oct:October:Nov:November:Dec:December");
		}
		const char*_Getfalse()const
		{
			return ("false");
		}
		const char*_Gettrue()const
		{
			return ("true");
		}
		int _Getdateorder()const
		{
			return ::_Getdateorder();
		}
	private:
		_Lockit _Lock;
		string _Days;
		string _Months;
		string _Oldlocname;
		string _Newlocname;
	};
	template<class _Elem>
	inline int _LStrcoll(const _Elem*_First1, const _Elem*_Last1, const _Elem*_First2, const _Elem*_Last2, const _Locinfo::_Collvec*)
	{
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_First1, ++_First2)if(*_First1<*_First2)return (-1);
		else if(*_First2<*_First1)return (+1);
		return (_First2!=_Last2?-1: _First1!=_Last1?+1: 0);
	}
	template<>
	inline int _LStrcoll(const char*_First1, const char*_Last1, const char*_First2, const char*_Last2, const _Locinfo::_Collvec*_Vector)
	{
		return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}
	template<>
	inline int _LStrcoll(const wchar_t*_First1, const wchar_t*_Last1, const wchar_t*_First2, const wchar_t*_Last2, const _Locinfo::_Collvec*_Vector)
	{
		return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}
	template<class _Elem>
	inline size_t _LStrxfrm(_Elem*_First1, _Elem*_Last1, const _Elem*_First2, const _Elem*_Last2, const _Locinfo::_Collvec*)
	{
		size_t _Count=_Last2-_First2;
		if(_Count<=(size_t)(_Last1-_First1))::memcpy_s((_First1), ((_Last1-_First1)*sizeof(_Elem)), (_First2), (_Count*sizeof(_Elem)));
		return (_Count);
	}
	template<>
	inline size_t _LStrxfrm(char*_First1, char*_Last1, const char*_First2, const char*_Last2, const _Locinfo::_Collvec*_Vector)
	{
		return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
	template<>
	inline size_t _LStrxfrm(wchar_t*_First1, wchar_t*_Last1, const wchar_t*_First2, const wchar_t*_Last2, const _Locinfo::_Collvec*_Vector)
	{
		return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
namespace std
{
	template<class _Elem>
	class collate;
	template<class _Dummy>
	class _Locbase
	{
	public:
		static const int collate=((1<<(1))>>1);
		static const int ctype=((1<<(2))>>1);
		static const int monetary=((1<<(3))>>1);
		static const int numeric=((1<<(4))>>1);
		static const int time=((1<<(5))>>1);
		static const int messages=((1<<(6))>>1);
		static const int all=(((1<<(7))>>1)-1);
		static const int none=0;
	};
	template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
	template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
	template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
	template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
	template<class _Dummy>
	const int _Locbase<_Dummy>::time;
	template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
	template<class _Dummy>
	const int _Locbase<_Dummy>::all;
	template<class _Dummy>
	const int _Locbase<_Dummy>::none;
	class locale;
	template<class _Facet>
	const _Facet&use_facet(const locale&);
	class locale: public _Locbase<int>
	{
	public:
		typedef int category;
		class id
		{
		public:
			id(size_t _Val=0): _Id(_Val)
			{
			}
			operator size_t()
			{
				if(_Id==0)
				{

					{
						::std::_Lockit _Lock(0);
						if(_Id==0)_Id=++_Id_cnt;
					}
				}
				return (_Id);
			}
		private:
			id(const id&);
			id&operator=(const id&);
			size_t _Id;
			static int&_Id_cnt_func();
			static int _Id_cnt;
		};
		class _Locimp;
		class facet
		{
			friend class locale;
			friend class _Locimp;
		public:
			static size_t _Getcat(const facet** =0)
			{
				return ((size_t)(-1));
			}
			void _Incref()
			{

				{
					::std::_Lockit _Lock(0);
					if(_Refs<(size_t)(-1))++_Refs;
				}
			}
			facet*_Decref()
			{

				{
					::std::_Lockit _Lock(0);
					if(0<_Refs&&_Refs<(size_t)(-1))--_Refs;
					return (_Refs==0?this: 0);
				}
			}
			void _Register()
			{
				facet_Register(this);
			}
			void*operator new(size_t _Size)
			{
				return (operator new(_Size, std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 144));
			}
			void*operator new(size_t _Size, const std::_DebugHeapTag_t&_Tag, char*_File, int _Line)
			{
				return (::operator new(_Size, _Tag, _File, _Line));
			}
			void operator delete(void*_Ptr, const std::_DebugHeapTag_t&, char*, int)
			{
				operator delete(_Ptr);
			}
			void operator delete(void*_Ptr)
			{
				std::_DebugHeapDelete((facet*)_Ptr);
			}
			virtual~facet()
			{
			}
			protected: explicit facet(size_t _Initrefs=0): _Refs(_Initrefs)
			{
			}
		private:
			static void facet_Register(facet*);
			facet(const facet&);
			facet&operator=(const facet&);
			size_t _Refs;
		};
		class _Locimp: public facet
		{
			protected: ~_Locimp()
			{
				_Locimp_dtor(this);
			}
		private:
			static void _Locimp_dtor(_Locimp*);
			static void _Locimp_ctor(_Locimp*, const _Locimp&);
			static void _Locimp_Addfac(_Locimp*, facet*, size_t);
			friend class locale;
			_Locimp(bool _Transparent=false): locale::facet(1), _Facetvec(0), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*")
			{
			}
			_Locimp(const _Locimp&_Right): locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name(_Right._Name)
			{
				_Locimp_ctor(this, _Right);
			}
			void _Addfac(facet*_Pfacet, size_t _Id)
			{
				_Locimp_Addfac(this, _Pfacet, _Id);
			}
			static _Locimp*_Makeloc(const _Locinfo&, category, _Locimp*, const locale*);
			static void _Makewloc(const _Locinfo&, category, _Locimp*, const locale*);
			static void _Makeushloc(const _Locinfo&, category, _Locimp*, const locale*);
			static void _Makexloc(const _Locinfo&, category, _Locimp*, const locale*);
			facet**_Facetvec;
			size_t _Facetcount;
			category _Catmask;
			bool _Xparent;
			_DebugHeapString _Name;
			static _Locimp*&_Clocptr_func();
			static _Locimp*_Clocptr;
		private:
			_Locimp&operator=(const _Locimp&);
		};
		locale&_Addfac(facet*_Fac, size_t _Id, size_t _Catmask)
		{
			if(1<this->_Ptr->_Refs)
			{
				this->_Ptr->_Decref();
				this->_Ptr=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 256)_Locimp(*this->_Ptr);
			}
			this->_Ptr->_Addfac(_Fac, _Id);
			if(_Catmask!=0)this->_Ptr->_Name="*";
			return (*this);
		}
		template<class _Elem, class _Traits, class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)const
		{
			const std::collate<_Elem>&_Coll_fac=std::use_facet<std::collate<_Elem> >(*this);
			return (_Coll_fac.compare(_Left.c_str(), _Left.c_str()+_Left.size(), _Right.c_str(), _Right.c_str()+_Right.size())<0);
		}
		template<class _Facet>
		locale combine(const locale&_Loc)const
		{
			_Facet*_Facptr;
			try
			{
				_Facptr=(_Facet*)&std::use_facet<_Facet>(_Loc);
			}
			catch(...)
			{
				throw runtime_error("locale::combine facet missing");
			}
			_Locimp*_Newimp=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 289)_Locimp(*_Ptr);
			_Newimp->_Addfac(_Facptr, _Facet::id);
			_Newimp->_Catmask=0;
			_Newimp->_Name="*";
			return (locale(_Newimp));
		}
		template<class _Facet>
		locale(const locale&_Loc, const _Facet*_Facptr): _Ptr(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 298)_Locimp(*_Loc._Ptr))
		{
			if(_Facptr!=0)
			{
				_Ptr->_Addfac((_Facet*)_Facptr, _Facet::id);
				if(_Facet::_Getcat()!=(size_t)(-1))_Ptr->_Catmask=0, _Ptr->_Name="*";
			}
		}
		locale()throw(): _Ptr(_Init())
		{
			_Getgloballocale()->_Incref();
		}
		locale(_Uninitialized)
		{
		}
		locale(const locale&_Right)throw(): _Ptr(_Right._Ptr)
		{
			_Ptr->_Incref();
		}
		locale(const locale&_Loc, const locale&_Other, category _Cat): _Ptr(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 327)_Locimp(*_Loc._Ptr))
		{
			try
			{

				{
					_Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
					_Locimp::_Makeloc(_Lobj._Addcats(_Cat&_Other._Ptr->_Catmask, _Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
				}
			}
			catch(...)
			{
				std::_DebugHeapDelete(_Ptr->_Decref());
				throw;
			}
		}
		explicit locale(const char*_Locname, category _Cat=all): _Ptr(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 342)_Locimp)
		{
			try
			{
				_Init();

				{
					_Locinfo _Lobj(_Cat, _Locname);
					if(_Lobj._Getname().compare("*")==0)throw runtime_error("bad locale name");
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
				}
			}
			catch(...)
			{
				std::_DebugHeapDelete(_Ptr->_Decref());
				throw;
			}
		}
		locale(const locale&_Loc, const char*_Locname, category _Cat): _Ptr(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 359)_Locimp(*_Loc._Ptr))
		{
			try
			{

				{
					_Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
					bool _Hadname=_Lobj._Getname().compare("*")!=0;
					_Lobj._Addcats(_Cat, _Locname);
					if(_Hadname&&_Lobj._Getname().compare("*")==0)throw runtime_error("bad locale name");
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
				}
			}
			catch(...)
			{
				std::_DebugHeapDelete(_Ptr->_Decref());
				throw;
			}
		}
		~locale()throw()
		{
			if(_Ptr!=0)std::_DebugHeapDelete(_Ptr->_Decref());
		}
		locale&operator=(const locale&_Right)throw()
		{
			if(_Ptr!=_Right._Ptr)
			{
				std::_DebugHeapDelete(_Ptr->_Decref());
				_Ptr=_Right._Ptr;
				_Ptr->_Incref();
			}
			return (*this);
		}
		string name()const
		{
			return (_Ptr->_Name);
		}
		const facet*_Getfacet(size_t _Id)const
		{
			const facet*_Facptr=_Id<_Ptr->_Facetcount?_Ptr->_Facetvec[_Id]: 0;
			if(_Facptr!=0||!_Ptr->_Xparent)return (_Facptr);
			else
			{
				locale::_Locimp*_Ptr=_Getgloballocale();
				return (_Id<_Ptr->_Facetcount?_Ptr->_Facetvec[_Id]: 0);
			}
		}
		bool operator==(const locale&_Loc)const
		{
			return (_Ptr==_Loc._Ptr||name().compare("*")!=0&&name().compare(_Loc.name())==0);
		}
		bool operator!=(const locale&_Right)const
		{
			return (!(*this==_Right));
		}
		static const locale&classic();
		static locale global(const locale&);
		static locale empty();
	private:
		locale(_Locimp*_Ptrimp): _Ptr(_Ptrimp)
		{
		}
		static _Locimp*_Getgloballocale();
		static _Locimp*_Init();
		static void _Setgloballocale(void*);
		_Locimp*_Ptr;
	};
	template<class _Facet>
	struct _Facetptr
	{
		static const locale::facet*_Psave;
	};
	template<class _Facet>
	const locale::facet*_Facetptr<_Facet>::_Psave=0;
	template<class _Facet>
	inline locale _Addfac(locale _Loc, const _Facet*_Facptr)
	{
		return (_Loc._Addfac((_Facet*)_Facptr, _Facet::id, _Facet::_Getcat()));
	}
	template<class _Facet>
	inline const _Facet&use_facet(const locale&_Loc)
	{

		{
			::std::_Lockit _Lock(0);
			const locale::facet*_Psave=_Facetptr<_Facet>::_Psave;
			size_t _Id=_Facet::id;
			const locale::facet*_Pf=_Loc._Getfacet(_Id);
			if(_Pf!=0);
			else if(_Psave!=0)_Pf=_Psave;
			else if(_Facet::_Getcat(&_Psave)==(size_t)(-1))throw bad_cast();
			else
			{
				_Pf=_Psave;
				_Facetptr<_Facet>::_Psave=_Psave;
				locale::facet*_Pfmod=(_Facet*)_Psave;
				_Pfmod->_Incref();
				_Pfmod->_Register();
			}
			return ((const _Facet&)(*_Pf));
		}
	}
	template<class _Facet>
	inline const _Facet&use_facet(const locale&_Loc, const _Facet*, bool=false)
	{
		return use_facet<_Facet>(_Loc);
	}
	template<class _Elem, class _InIt>
	inline int _Getloctxt(_InIt&_First, _InIt&_Last, size_t _Numfields, const _Elem*_Ptr)
	{
		for(size_t _Off=0;
		_Ptr[_Off]!=(_Elem)0;
		++_Off)if(_Ptr[_Off]==_Ptr[0])++_Numfields;
		string _Str(_Numfields, '\0');
		int _Ans=-2;
		for(size_t _Column=1;
		;
		++_Column, ++_First, _Ans=-1)
		{
			bool _Prefix=false;
			size_t _Off=0;
			size_t _Field=0;
			for(;
			_Field<_Numfields;
			++_Field)
			{
				for(;
				_Ptr[_Off]!=(_Elem)0&&_Ptr[_Off]!=_Ptr[0];
				++_Off);
				if(_Str[_Field]!='\0')_Off+=_Str[_Field];
				else if(_Ptr[_Off+=_Column]==_Ptr[0]||_Ptr[_Off]==(_Elem)0)
				{
					_Str[_Field]=(char)(_Column<127?_Column: 127);
					_Ans=(int)_Field;
				}
				else if(_First==_Last||_Ptr[_Off]!=*_First)_Str[_Field]=(char)(_Column<127?_Column: 127);
				else _Prefix=true;
			}
			if(!_Prefix||_First==_Last)break;
		}
		return (_Ans);
	}
	template<class _Elem>
	inline char _Maklocbyte(_Elem _Char, const _Locinfo::_Cvtvec&)
	{
		return ((char)(unsigned char)_Char);
	}
	template<>
	inline char _Maklocbyte(wchar_t _Char, const _Locinfo::_Cvtvec&_Cvt)
	{
		char _Byte='\0';
		mbstate_t _Mbst1=
		{
			0
		};
		_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
		return (_Byte);
	}
	template<class _Elem>
	inline _Elem _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&)
	{
		return ((_Elem)(unsigned char)_Byte);
	}
	template<>
	inline wchar_t _Maklocchr(char _Byte, wchar_t*, const _Locinfo::_Cvtvec&_Cvt)
	{
		wchar_t _Wc=L'\0';
		mbstate_t _Mbst1=
		{
			0
		};
		_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
		return (_Wc);
	}
	template<class _Elem>
	inline _Elem*_Maklocstr(const char*_Ptr, _Elem*, const _Locinfo::_Cvtvec&)
	{
		size_t _Count=::strlen(_Ptr)+1;
		_Elem*_Ptrdest=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 609)_Elem[_Count];
		for(_Elem*_Ptrnext=_Ptrdest;
		0<_Count;
		--_Count, ++_Ptrnext, ++_Ptr)*_Ptrnext=(_Elem)(unsigned char)*_Ptr;
		return (_Ptrdest);
	}
	template<>
	inline wchar_t*_Maklocstr(const char*_Ptr, wchar_t*, const _Locinfo::_Cvtvec&_Cvt)
	{
		size_t _Count, _Count1;
		size_t _Wchars;
		const char*_Ptr1;
		int _Bytes;
		wchar_t _Wc;
		mbstate_t _Mbst1=
		{
			0
		};
		_Count1=::strlen(_Ptr)+1;
		for(_Count=_Count1, _Wchars=0, _Ptr1=_Ptr;
		0<_Count;
		_Count-=_Bytes, _Ptr1+=_Bytes, ++_Wchars)if((_Bytes=_Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt))<=0)break;
		++_Wchars;
		wchar_t*_Ptrdest=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 638)wchar_t[_Wchars];
		wchar_t*_Ptrnext=_Ptrdest;
		mbstate_t _Mbst2=
		{
			0
		};
		for(;
		0<_Wchars;
		_Count-=_Bytes, _Ptr+=_Bytes, --_Wchars, ++_Ptrnext)if((_Bytes=_Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt))<=0)break;
		*_Ptrnext=L'\0';
		return (_Ptrdest);
	}
	class codecvt_base: public locale::facet
	{
	public:
		enum
		{
			ok, partial, error, noconv
		};
		typedef int result;
		codecvt_base(size_t _Refs=0): locale::facet(_Refs)
		{
		}
		bool always_noconv()const throw()
		{
			return (do_always_noconv());
		}
		int max_length()const throw()
		{
			return (do_max_length());
		}
		int encoding()const throw()
		{
			return (do_encoding());
		}
		~codecvt_base()
		{
		}
		protected: virtual bool do_always_noconv()const throw()
		{
			return (true);
		}
		virtual int do_max_length()const throw()
		{
			return (1);
		}
		virtual int do_encoding()const throw()
		{
			return (1);
		}
	};
	template<class _Elem, class _Byte, class _Statype>
	class codecvt: public codecvt_base
	{
	public:
		typedef _Elem intern_type;
		typedef _Byte extern_type;
		typedef _Statype state_type;
		result in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			return (do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_unshift(_State, _First2, _Last2, _Mid2));
		}
		int length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			return (do_length(_State, _First1, _Last1, _Count));
		}
		static locale::id id;
		explicit codecvt(size_t _Refs=0): codecvt_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		codecvt(const _Locinfo&_Lobj, size_t _Refs=0): codecvt_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 764)codecvt<_Elem, _Byte, _Statype>;
			return (2);
		}
		protected: virtual~codecvt()
		{
		}
		protected: void _Init(const _Locinfo&)
		{
		}
		virtual result do_in(_Statype&, const _Byte*_First1, const _Byte*, const _Byte*&_Mid1, _Elem*_First2, _Elem*, _Elem*&_Mid2)const
		{
			_Mid1=_First1, _Mid2=_First2;
			return (noconv);
		}
		virtual result do_out(_Statype&, const _Elem*_First1, const _Elem*, const _Elem*&_Mid1, _Byte*_First2, _Byte*, _Byte*&_Mid2)const
		{
			_Mid1=_First1, _Mid2=_First2;
			return (noconv);
		}
		virtual result do_unshift(_Statype&, _Byte*_First2, _Byte*, _Byte*&_Mid2)const
		{
			_Mid2=_First2;
			return (noconv);
		}
		virtual int do_length(const _Statype&, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			return ((int)(_Count<(size_t)(_Last1-_First1)?_Count: _Last1-_First1));
		}
	};
	template<class _Elem, class _Byte, class _Statype>
	locale::id codecvt<_Elem, _Byte, _Statype>::id;
	template<>
	class codecvt<wchar_t, char, _Mbstatet>: public codecvt_base
	{
	public:
		typedef wchar_t _Elem;
		typedef char _Byte;
		typedef _Mbstatet _Statype;
		typedef _Elem intern_type;
		typedef _Byte extern_type;
		typedef _Statype state_type;
		result in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			return (do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_unshift(_State, _First2, _Last2, _Mid2));
		}
		int length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			return (do_length(_State, _First1, _Last1, _Count));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit codecvt(size_t _Refs=0): codecvt_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		codecvt(const _Locinfo&_Lobj, size_t _Refs=0): codecvt_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 880)codecvt<_Elem, _Byte, _Statype>;
			return (2);
		}
		protected: virtual~codecvt()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		virtual result do_in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 899);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 900);
			_Mid1=_First1, _Mid2=_First2;
			result _Ans=_Mid1==_Last1?ok: partial;
			int _Bytes;
			while(_Mid1!=_Last1&&_Mid2!=_Last2)switch(_Bytes=_Mbrtowc(_Mid2, _Mid1, _Last1-_Mid1, &_State, &_Cvt))
			{
				case-2: _Mid1=_Last1;
				return (_Ans);
				case-1: return (error);
				case 0: if(*_Mid2==(_Elem)0)_Bytes=(int)::strlen(_Mid1)+1;
				default: if(_Bytes==-3)_Bytes=0;
				_Mid1+=_Bytes;
				++_Mid2;
				_Ans=ok;
			}
			return (_Ans);
		}
		virtual result do_out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 935);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 936);
			_Mid1=_First1, _Mid2=_First2;
			result _Ans=_Mid1==_Last1?ok: partial;
			int _Bytes;
			while(_Mid1!=_Last1&&_Mid2!=_Last2)if(5<=_Last2-_Mid2)if((_Bytes=_Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt))<0)return (error);
			else++_Mid1, _Mid2+=_Bytes, _Ans=ok;
			else
			{
				_Byte _Buf[5];
				_Statype _Stsave=_State;
				if((_Bytes=_Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt))<0)return (error);
				else if(_Last2-_Mid2<_Bytes)
				{
					_State=_Stsave;
					return (_Ans);
				}
				else
				{
					::memcpy_s((_Mid2), (_Last2-_Mid2), (_Buf), (_Bytes));
					++_Mid1, _Mid2+=_Bytes, _Ans=ok;
				}
			}
			return (_Ans);
		}
		virtual result do_unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 973);
			_Mid2=_First2;
			result _Ans=ok;
			int _Bytes;
			_Byte _Buf[5];
			_Statype _Stsave=_State;
			if((_Bytes=_Wcrtomb(_Buf, L'\0', &_State, &_Cvt))<=0)_Ans=error;
			else if(_Last2-_Mid2<--_Bytes)
			{
				_State=_Stsave;
				_Ans=partial;
			}
			else if(0<_Bytes)
			{
				::memcpy_s((_Mid2), (_Last2-_Mid2), (_Buf), (_Bytes));
				_Mid2+=_Bytes;
			}
			return (_Ans);
		}
		virtual int do_length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 998);
			int _Wchars;
			const _Byte*_Mid1;
			_Statype _Mystate=_State;
			for(_Wchars=0, _Mid1=_First1;
			(size_t)_Wchars<_Count&&_Mid1!=_Last1;
			)
			{
				int _Bytes;
				_Elem _Ch;
				switch(_Bytes=_Mbrtowc(&_Ch, _Mid1, _Last1-_Mid1, &_Mystate, &_Cvt))
				{
					case-2: return (_Wchars);
					case-1: return (_Wchars);
					case 0: if(_Ch==(_Elem)0)_Bytes=(int)::strlen(_Mid1)+1;
					default: if(_Bytes==-3)_Bytes=0;
					_Mid1+=_Bytes;
					++_Wchars;
				}
			}
			return (_Wchars);
		}
		virtual bool do_always_noconv()const throw()
		{
			return (false);
		}
		virtual int do_max_length()const throw()
		{
			return (5);
		}
		virtual int do_encoding()const throw()
		{
			return (0);
		}
	private:
		_Locinfo::_Cvtvec _Cvt;
	};
	template<>
	class codecvt<unsigned short, char, _Mbstatet>: public codecvt_base
	{
	public:
		typedef unsigned short _Elem;
		typedef char _Byte;
		typedef _Mbstatet _Statype;
		typedef _Elem intern_type;
		typedef _Byte extern_type;
		typedef _Statype state_type;
		result in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			return (do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_unshift(_State, _First2, _Last2, _Mid2));
		}
		int length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			return (do_length(_State, _First1, _Last1, _Count));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit codecvt(size_t _Refs=0): codecvt_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		codecvt(const _Locinfo&_Lobj, size_t _Refs=0): codecvt_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1118)codecvt<_Elem, _Byte, _Statype>;
			return (2);
		}
		protected: virtual~codecvt()
		{
		}
		protected: codecvt(const char*_Locname, size_t _Refs=0): codecvt_base(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		virtual result do_in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1145);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1146);
			_Mid1=_First1, _Mid2=_First2;
			result _Ans=_Mid1==_Last1?ok: partial;
			int _Bytes;
			while(_Mid1!=_Last1&&_Mid2!=_Last2)switch(_Bytes=_Mbrtowc((wchar_t*)_Mid2, _Mid1, _Last1-_Mid1, &_State, &_Cvt))
			{
				case-2: _Mid1=_Last1;
				return (_Ans);
				case-1: return (error);
				case 0: if(*_Mid2==(_Elem)0)_Bytes=(int)::strlen(_Mid1)+1;
				default: if(_Bytes==-3)_Bytes=0;
				_Mid1+=_Bytes;
				++_Mid2;
				_Ans=ok;
			}
			return (_Ans);
		}
		virtual result do_out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1181);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1182);
			_Mid1=_First1, _Mid2=_First2;
			result _Ans=_Mid1==_Last1?ok: partial;
			int _Bytes;
			while(_Mid1!=_Last1&&_Mid2!=_Last2)if(5<=_Last2-_Mid2)if((_Bytes=_Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt))<0)return (error);
			else++_Mid1, _Mid2+=_Bytes, _Ans=ok;
			else
			{
				_Byte _Buf[5];
				_Statype _Stsave=_State;
				if((_Bytes=_Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt))<0)return (error);
				else if(_Last2-_Mid2<_Bytes)
				{
					_State=_Stsave;
					return (_Ans);
				}
				else
				{
					::memcpy_s((_Mid2), (_Last2-_Mid2), (_Buf), (_Bytes));
					++_Mid1, _Mid2+=_Bytes, _Ans=ok;
				}
			}
			return (_Ans);
		}
		virtual result do_unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1219);
			_Mid2=_First2;
			result _Ans=ok;
			int _Bytes;
			_Byte _Buf[5];
			_Statype _Stsave=_State;
			if((_Bytes=_Wcrtomb(_Buf, L'\0', &_State, &_Cvt))<=0)_Ans=error;
			else if(_Last2-_Mid2<--_Bytes)
			{
				_State=_Stsave;
				_Ans=partial;
			}
			else if(0<_Bytes)
			{
				::memcpy_s((_Mid2), (_Last2-_Mid2), (_Buf), (_Bytes));
				_Mid2+=_Bytes;
			}
			return (_Ans);
		}
		virtual int do_length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1244);
			int _Wchars;
			const _Byte*_Mid1;
			_Statype _Mystate=_State;
			for(_Wchars=0, _Mid1=_First1;
			(size_t)_Wchars<_Count&&_Mid1!=_Last1;
			)
			{
				int _Bytes;
				_Elem _Ch;
				switch(_Bytes=_Mbrtowc((wchar_t*)&_Ch, _Mid1, _Last1-_Mid1, &_Mystate, &_Cvt))
				{
					case-2: return (_Wchars);
					case-1: return (_Wchars);
					case 0: if(_Ch==(_Elem)0)_Bytes=(int)::strlen(_Mid1)+1;
					default: if(_Bytes==-3)_Bytes=0;
					_Mid1+=_Bytes;
					++_Wchars;
				}
			}
			return (_Wchars);
		}
		virtual bool do_always_noconv()const throw()
		{
			return (false);
		}
		virtual int do_max_length()const throw()
		{
			return (5);
		}
		virtual int do_encoding()const throw()
		{
			return (0);
		}
	private:
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem, class _Byte, class _Statype>
	class codecvt_byname: public codecvt<_Elem, _Byte, _Statype>
	{
	public:
		explicit codecvt_byname(const char*_Locname, size_t _Refs=0): codecvt<_Elem, _Byte, _Statype>(_Locname, _Refs)
		{
		}
		protected: virtual~codecvt_byname()
		{
		}
	};
	struct ctype_base: public locale::facet
	{
		enum
		{
			alnum=0x4|0x2|0x1|0x100, alpha=0x2|0x1|0x100, cntrl=0x20, digit=0x4, graph=0x4|0x2|0x10|0x1|0x100, lower=0x2, print=0x4|0x2|0x10|0x40|0x1|0x100|0x80, punct=0x10, space=0x8|0x40|0x000, upper=0x1, xdigit=0x80
		};
		typedef short mask;
		ctype_base(size_t _Refs=0): locale::facet(_Refs)
		{
		}
		~ctype_base()
		{
		}
		protected: static void _Xran()
		{
			throw out_of_range("out_of_range in ctype<T>");
		}
	};
	template<class _Elem>
	class ctype: public ctype_base
	{
	public:
		typedef _Elem char_type;
		bool is(mask _Maskval, _Elem _Ch)const
		{
			return (do_is(_Maskval, _Ch));
		}
		const _Elem*is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			return (do_is(_First, _Last, _Dest));
		}
		const _Elem*scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_is(_Maskval, _First, _Last));
		}
		const _Elem*scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_not(_Maskval, _First, _Last));
		}
		_Elem tolower(_Elem _Ch)const
		{
			return (do_tolower(_Ch));
		}
		const _Elem*tolower(_Elem*_First, const _Elem*_Last)const
		{
			return (do_tolower(_First, _Last));
		}
		_Elem toupper(_Elem _Ch)const
		{
			return (do_toupper(_Ch));
		}
		const _Elem*toupper(_Elem*_First, const _Elem*_Last)const
		{
			return (do_toupper(_First, _Last));
		}
		_Elem widen(char _Byte)const
		{
			return (do_widen(_Byte));
		}
		const char*widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return (do_widen(_First, _Last, _Dest));
		}
		const char*_Widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}
		char narrow(_Elem _Ch, char _Dflt='\0')const
		{
			return (do_narrow(_Ch, _Dflt));
		}
		const _Elem*narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return (do_narrow(_First, _Last, _Dflt, _Dest));
		}
		const _Elem*_Narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}
		static locale::id id;
		explicit ctype(size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		ctype(const _Locinfo&_Lobj, size_t _Refs=0): ctype_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1460)ctype<_Elem>;
			return (2);
		}
		protected: virtual~ctype()
		{
			if(_Ctype._Delfl)free((void*)_Ctype._Table);
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Ctype=_Lobj._Getctype();
		}
		virtual bool do_is(mask _Maskval, _Elem _Ch)const
		{
			return ((_Ctype._Table[(unsigned char)narrow(_Ch)]&_Maskval)!=0);
		}
		virtual const _Elem*do_is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1486);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1487);
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Ctype._Table[(unsigned char)narrow(*_First)];
			return (_First);
		}
		virtual const _Elem*do_scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1496);
			for(;
			_First!=_Last&&!is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual const _Elem*do_scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1505);
			for(;
			_First!=_Last&&is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual _Elem do_tolower(_Elem _Ch)const
		{
			unsigned char _Byte=(unsigned char)narrow(_Ch, '\0');
			if(_Byte=='\0')return (_Ch);
			else return (widen((char)_Tolower(_Byte, &_Ctype)));
		}
		virtual const _Elem*do_tolower(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1522);
			for(;
			_First!=_Last;
			++_First)
			{
				unsigned char _Byte=(unsigned char)narrow(*_First, '\0');
				if(_Byte!='\0')*_First=(widen((char)_Tolower(_Byte, &_Ctype)));
			}
			return ((const _Elem*)_First);
		}
		virtual _Elem do_toupper(_Elem _Ch)const
		{
			unsigned char _Byte=(unsigned char)narrow(_Ch, '\0');
			if(_Byte=='\0')return (_Ch);
			else return (widen((char)_Toupper(_Byte, &_Ctype)));
		}
		virtual const _Elem*do_toupper(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1543);
			for(;
			_First!=_Last;
			++_First)
			{
				unsigned char _Byte=(unsigned char)narrow(*_First, '\0');
				if(_Byte!='\0')*_First=(widen((char)_Toupper(_Byte, &_Ctype)));
			}
			return ((const _Elem*)_First);
		}
		virtual _Elem do_widen(char _Byte)const
		{
			return (_Maklocchr(_Byte, (_Elem*)0, _Cvt));
		}
		virtual const char*do_widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return _Do_widen_s(_First, _Last, _Dest, _Last-_First);
		}
		virtual const char*_Do_widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1569);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1570);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1571, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1571, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Maklocchr(*_First, (_Elem*)0, _Cvt);
			return (_First);
		}
		char _Donarrow(_Elem _Ch, char _Dflt)const
		{
			char _Byte;
			if(_Ch==(_Elem)0)return ('\0');
			else if((_Byte=_Maklocbyte((_Elem)_Ch, _Cvt))=='\0')return (_Dflt);
			else return (_Byte);
		}
		virtual char do_narrow(_Elem _Ch, char _Dflt)const
		{
			return (_Donarrow(_Ch, _Dflt));
		}
		virtual const _Elem*do_narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1606);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1607);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1608, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1608, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Donarrow(*_First, _Dflt);
			return (_First);
		}
	private:
		_Locinfo::_Ctypevec _Ctype;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem>
	locale::id ctype<_Elem>::id;
	template<>
	class ctype<char>: public ctype_base
	{
		typedef ctype<char>_Myt;
	public:
		typedef char _Elem;
		typedef _Elem char_type;
		bool is(mask _Maskval, _Elem _Ch)const
		{
			return ((_Ctype._Table[(unsigned char)_Ch]&_Maskval)!=0);
		}
		const _Elem*is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1641);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1642);
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Ctype._Table[(unsigned char)*_First];
			return (_First);
		}
		const _Elem*scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1651);
			for(;
			_First!=_Last&&!is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		const _Elem*scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1660);
			for(;
			_First!=_Last&&is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		_Elem tolower(_Elem _Ch)const
		{
			return (do_tolower(_Ch));
		}
		const _Elem*tolower(_Elem*_First, const _Elem*_Last)const
		{
			return (do_tolower(_First, _Last));
		}
		_Elem toupper(_Elem _Ch)const
		{
			return (do_toupper(_Ch));
		}
		const _Elem*toupper(_Elem*_First, const _Elem*_Last)const
		{
			return (do_toupper(_First, _Last));
		}
		_Elem widen(char _Byte)const
		{
			return (do_widen(_Byte));
		}
		const _Elem*widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return (do_widen(_First, _Last, _Dest));
		}
		const _Elem*_Widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}
		_Elem narrow(_Elem _Ch, char _Dflt='\0')const
		{
			return (do_narrow(_Ch, _Dflt));
		}
		const _Elem*narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return (do_narrow(_First, _Last, _Dflt, _Dest));
		}
		const _Elem*_Narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit ctype(const mask*_Table=0, bool _Deletetable=false, size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
			if(_Table!=0)
			{
				_Tidy();
				_Ctype._Table=_Table;
				_Ctype._Delfl=_Deletetable?-1: 0;
			}
		}
		ctype(const _Locinfo&_Lobj, size_t _Refs=0): ctype_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1763)ctype<_Elem>;
			return (2);
		}
		static const size_t table_size=1<<8;
		protected: virtual~ctype()
		{
			_Tidy();
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Ctype=_Lobj._Getctype();
		}
		void _Tidy()
		{
			if(0<_Ctype._Delfl)free((void*)_Ctype._Table);
			else if(_Ctype._Delfl<0)delete[](void*)_Ctype._Table;
		}
		virtual _Elem do_tolower(_Elem _Ch)const
		{
			return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}
		virtual const _Elem*do_tolower(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1797);
			for(;
			_First!=_Last;
			++_First)*_First=(_Elem)_Tolower((unsigned char)*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		virtual _Elem do_toupper(_Elem _Ch)const
		{
			return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}
		virtual const _Elem*do_toupper(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1811);
			for(;
			_First!=_Last;
			++_First)*_First=(_Elem)_Toupper((unsigned char)*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		virtual _Elem do_widen(char _Byte)const
		{
			return (_Byte);
		}
		virtual const _Elem*do_widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return _Do_widen_s(_First, _Last, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1833);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1834);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1835, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1835, 0);
				}
			};
			::memcpy_s((_Dest), (_Dest_size), (_First), (_Last-_First));
			return (_Last);
		}
		virtual _Elem do_narrow(_Elem _Ch, char)const
		{
			return (_Ch);
		}
		virtual const _Elem*do_narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_narrow_s(const _Elem*_First, const _Elem*_Last, char, char*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1858);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1859);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1860, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1860, 0);
				}
			};
			::memcpy_s((_Dest), (_Dest_size), (_First), (_Last-_First));
			return (_Last);
		}
		const mask*table()const throw()
		{
			return (_Ctype._Table);
		}
		static const mask*classic_table()throw()
		{
			const _Myt&_Ctype_fac=use_facet<_Myt>(locale::classic());
			return (_Ctype_fac.table());
		}
	private:
		_Locinfo::_Ctypevec _Ctype;
	};
	template<>
	class ctype<wchar_t>: public ctype_base
	{
		typedef ctype<wchar_t>_Myt;
	public:
		typedef wchar_t _Elem;
		typedef _Elem char_type;
		bool is(mask _Maskval, _Elem _Ch)const
		{
			return (do_is(_Maskval, _Ch));
		}
		const _Elem*is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			return (do_is(_First, _Last, _Dest));
		}
		const _Elem*scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_is(_Maskval, _First, _Last));
		}
		const _Elem*scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_not(_Maskval, _First, _Last));
		}
		_Elem tolower(_Elem _Ch)const
		{
			return (do_tolower(_Ch));
		}
		const _Elem*tolower(_Elem*_First, const _Elem*_Last)const
		{
			return (do_tolower(_First, _Last));
		}
		_Elem toupper(_Elem _Ch)const
		{
			return (do_toupper(_Ch));
		}
		const _Elem*toupper(_Elem*_First, const _Elem*_Last)const
		{
			return (do_toupper(_First, _Last));
		}
		_Elem widen(char _Byte)const
		{
			return (do_widen(_Byte));
		}
		const char*widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return (do_widen(_First, _Last, _Dest));
		}
		const char*_Widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}
		char narrow(_Elem _Ch, char _Dflt='\0')const
		{
			return (do_narrow(_Ch, _Dflt));
		}
		const _Elem*narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return (do_narrow(_First, _Last, _Dflt, _Dest));
		}
		const _Elem*_Narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit ctype(size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		ctype(const _Locinfo&_Lobj, size_t _Refs=0): ctype_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2002)ctype<_Elem>;
			return (2);
		}
		protected: virtual~ctype()
		{
			if(_Ctype._Delfl)free((void*)_Ctype._Table);
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Ctype=_Lobj._Getctype();
			_Cvt=_Lobj._Getcvt();
		}
		virtual bool do_is(mask _Maskval, _Elem _Ch)const
		{
			return ((::_Getwctype(_Ch, &_Ctype)&_Maskval)!=0);
		}
		virtual const wchar_t*do_is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2028);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2029);
			return (::_Getwctypes(_First, _Last, _Dest, &_Ctype));
		}
		virtual const _Elem*do_scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2036);
			for(;
			_First!=_Last&&!is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual const _Elem*do_scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2045);
			for(;
			_First!=_Last&&is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual _Elem do_tolower(_Elem _Ch)const
		{
			return (_Towlower(_Ch, &_Ctype));
		}
		virtual const _Elem*do_tolower(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2059);
			for(;
			_First!=_Last;
			++_First)*_First=_Towlower(*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		virtual _Elem do_toupper(_Elem _Ch)const
		{
			return (_Towupper(_Ch, &_Ctype));
		}
		virtual const _Elem*do_toupper(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2073);
			for(;
			_First!=_Last;
			++_First)*_First=_Towupper(*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		_Elem _Dowiden(char _Byte)const
		{
			mbstate_t _Mbst=
			{
				0
			};
			wchar_t _Wc;
			return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt)<0?(wchar_t)(wint_t)(0xFFFF): _Wc);
		}
		virtual _Elem do_widen(char _Byte)const
		{
			return (_Dowiden(_Byte));
		}
		virtual const char*do_widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return _Do_widen_s(_First, _Last, _Dest, _Last-_First);
		}
		virtual const char*_Do_widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2103);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2104);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2105, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2105, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Dowiden(*_First);
			return (_First);
		}
		char _Donarrow(_Elem _Ch, char _Dflt)const
		{
			char _Buf[5];
			mbstate_t _Mbst=
			{
				0
			};
			return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt)!=1?_Dflt: _Buf[0]);
		}
		virtual char do_narrow(_Elem _Ch, char _Dflt)const
		{
			return (_Donarrow(_Ch, _Dflt));
		}
		virtual const _Elem*do_narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2138);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2139);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2140, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2140, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Donarrow(*_First, _Dflt);
			return (_First);
		}
	private:
		_Locinfo::_Ctypevec _Ctype;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<>
	class ctype<unsigned short>: public ctype_base
	{
		typedef ctype<unsigned short>_Myt;
	public:
		typedef unsigned short _Elem;
		typedef _Elem char_type;
		bool is(mask _Maskval, _Elem _Ch)const
		{
			return (do_is(_Maskval, _Ch));
		}
		const _Elem*is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			return (do_is(_First, _Last, _Dest));
		}
		const _Elem*scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_is(_Maskval, _First, _Last));
		}
		const _Elem*scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_not(_Maskval, _First, _Last));
		}
		_Elem tolower(_Elem _Ch)const
		{
			return (do_tolower(_Ch));
		}
		const _Elem*tolower(_Elem*_First, const _Elem*_Last)const
		{
			return (do_tolower(_First, _Last));
		}
		_Elem toupper(_Elem _Ch)const
		{
			return (do_toupper(_Ch));
		}
		const _Elem*toupper(_Elem*_First, const _Elem*_Last)const
		{
			return (do_toupper(_First, _Last));
		}
		_Elem widen(char _Byte)const
		{
			return (do_widen(_Byte));
		}
		const char*widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return (do_widen(_First, _Last, _Dest));
		}
		const char*_Widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}
		char narrow(_Elem _Ch, char _Dflt='\0')const
		{
			return (do_narrow(_Ch, _Dflt));
		}
		const _Elem*narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return (do_narrow(_First, _Last, _Dflt, _Dest));
		}
		const _Elem*_Narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit ctype(size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		ctype(const _Locinfo&_Lobj, size_t _Refs=0): ctype_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2274)ctype<_Elem>;
			return (2);
		}
		protected: virtual~ctype()
		{
			if(_Ctype._Delfl)free((void*)_Ctype._Table);
		}
		protected: ctype(const char*_Locname, size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			_Ctype=_Lobj._Getctype();
			_Cvt=_Lobj._Getcvt();
		}
		virtual bool do_is(mask _Maskval, _Elem _Ch)const
		{
			return ((::_Getwctype(_Ch, &_Ctype)&_Maskval)!=0);
		}
		virtual const _Elem*do_is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2308);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2309);
			return ((const _Elem*)::_Getwctypes((const wchar_t*)_First, (const wchar_t*)_Last, _Dest, &_Ctype));
		}
		virtual const _Elem*do_scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2317);
			for(;
			_First!=_Last&&!is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual const _Elem*do_scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2326);
			for(;
			_First!=_Last&&is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual _Elem do_tolower(_Elem _Ch)const
		{
			return (_Towlower(_Ch, &_Ctype));
		}
		virtual const _Elem*do_tolower(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2340);
			for(;
			_First!=_Last;
			++_First)*_First=_Towlower(*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		virtual _Elem do_toupper(_Elem _Ch)const
		{
			return (_Towupper(_Ch, &_Ctype));
		}
		virtual const _Elem*do_toupper(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2354);
			for(;
			_First!=_Last;
			++_First)*_First=_Towupper(*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		_Elem _Dowiden(char _Byte)const
		{
			mbstate_t _Mbst=
			{
				0
			};
			unsigned short _Wc;
			return (_Mbrtowc((wchar_t*)&_Wc, &_Byte, 1, &_Mbst, &_Cvt)<0?(unsigned short)(wint_t)(0xFFFF): _Wc);
		}
		virtual _Elem do_widen(char _Byte)const
		{
			return (_Dowiden(_Byte));
		}
		virtual const char*do_widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return _Do_widen_s(_First, _Last, _Dest, _Last-_First);
		}
		virtual const char*_Do_widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2384);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2385);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2386, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2386, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Dowiden(*_First);
			return (_First);
		}
		char _Donarrow(_Elem _Ch, char _Dflt)const
		{
			char _Buf[5];
			mbstate_t _Mbst=
			{
				0
			};
			return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt)!=1?_Dflt: _Buf[0]);
		}
		virtual char do_narrow(_Elem _Ch, char _Dflt)const
		{
			return (_Donarrow(_Ch, _Dflt));
		}
		virtual const _Elem*do_narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2418);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2419);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2420, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2420, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Donarrow(*_First, _Dflt);
			return (_First);
		}
	private:
		_Locinfo::_Ctypevec _Ctype;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem>
	class ctype_byname: public ctype<_Elem>
	{
	public:
		explicit ctype_byname(const char*_Locname, size_t _Refs=0): ctype<_Elem>(_Locname, _Refs)
		{
		}
		protected: virtual~ctype_byname()
		{
		}
	};
	template<>
	class ctype_byname<char>: public ctype<char>
	{
	public:
		explicit ctype_byname(const char*_Locname, size_t _Refs=0): ctype<char>(_Locname, _Refs)
		{
		}
		protected: virtual~ctype_byname()
		{
		}
	};
}
namespace std
{
	template<class _Dummy>
	class _Iosb
	{
	public:
		enum _Dummy_enum
		{
			_Dummy_enum_val=1
		};
		enum _Fmtflags
		{
			_Fmtmask=0xffff, _Fmtzero=0
		};
		static const _Fmtflags skipws=(_Fmtflags)0x0001;
		static const _Fmtflags unitbuf=(_Fmtflags)0x0002;
		static const _Fmtflags uppercase=(_Fmtflags)0x0004;
		static const _Fmtflags showbase=(_Fmtflags)0x0008;
		static const _Fmtflags showpoint=(_Fmtflags)0x0010;
		static const _Fmtflags showpos=(_Fmtflags)0x0020;
		static const _Fmtflags left=(_Fmtflags)0x0040;
		static const _Fmtflags right=(_Fmtflags)0x0080;
		static const _Fmtflags internal=(_Fmtflags)0x0100;
		static const _Fmtflags dec=(_Fmtflags)0x0200;
		static const _Fmtflags oct=(_Fmtflags)0x0400;
		static const _Fmtflags hex=(_Fmtflags)0x0800;
		static const _Fmtflags scientific=(_Fmtflags)0x1000;
		static const _Fmtflags fixed=(_Fmtflags)0x2000;
		static const _Fmtflags boolalpha=(_Fmtflags)0x4000;
		static const _Fmtflags _Stdio=(_Fmtflags)0x8000;
		static const _Fmtflags adjustfield=(_Fmtflags)(0x0040|0x0080|0x0100);
		static const _Fmtflags basefield=(_Fmtflags)(0x0200|0x0400|0x0800);
		static const _Fmtflags floatfield=(_Fmtflags)(0x1000|0x2000);
		enum _Iostate
		{
			_Statmask=0x17
		};
		static const _Iostate goodbit=(_Iostate)0x0;
		static const _Iostate eofbit=(_Iostate)0x1;
		static const _Iostate failbit=(_Iostate)0x2;
		static const _Iostate badbit=(_Iostate)0x4;
		static const _Iostate _Hardfail=(_Iostate)0x10;
		enum _Openmode
		{
			_Openmask=0xff
		};
		static const _Openmode in=(_Openmode)0x01;
		static const _Openmode out=(_Openmode)0x02;
		static const _Openmode ate=(_Openmode)0x04;
		static const _Openmode app=(_Openmode)0x08;
		static const _Openmode trunc=(_Openmode)0x10;
		static const _Openmode _Nocreate=(_Openmode)0x40;
		static const _Openmode _Noreplace=(_Openmode)0x80;
		static const _Openmode binary=(_Openmode)0x20;
		enum _Seekdir
		{
			_Seekmask=0x3
		};
		static const _Seekdir beg=(_Seekdir)0;
		static const _Seekdir cur=(_Seekdir)1;
		static const _Seekdir end=(_Seekdir)2;
		enum
		{
			_Openprot=0x40
		};
	};
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::_Hardfail;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;
	class ios_base: public _Iosb<int>
	{
	public:
		typedef int fmtflags;
		typedef int iostate;
		typedef int openmode;
		typedef int seekdir;
		typedef std::streamoff streamoff;
		typedef std::streampos streampos;
		enum event
		{
			erase_event, imbue_event, copyfmt_event
		};
		typedef void(*event_callback)(event, ios_base&, int);
		typedef unsigned int io_state, open_mode, seek_dir;
		class failure: public runtime_error
		{
		public:
			explicit failure(const string&_Message): runtime_error(_Message)
			{
			}
			virtual~failure()throw()
			{
			}
		};
		class Init
		{
		public:
			Init()
			{
				_Init_ctor(this);
			}
			~Init()
			{
				_Init_dtor(this);
			}
		private:
			static void _Init_ctor(Init*);
			static void _Init_dtor(Init*);
			static int&_Init_cnt_func();
			static int _Init_cnt;
		};
		ios_base&operator=(const ios_base&_Right)
		{
			if(this!=&_Right)
			{
				_Mystate=_Right._Mystate;
				copyfmt(_Right);
			}
			return (*this);
		}
		operator void*()const
		{
			return (fail()?0: (void*)this);
		}
		bool operator!()const
		{
			return (fail());
		}
		void clear(iostate _State, bool _Reraise)
		{
			_Mystate=(iostate)(_State&_Statmask);
			if((_Mystate&_Except)==0);
			else if(_Reraise)throw;
			else if(_Mystate&_Except&badbit)throw failure("ios_base::badbit set");
			else if(_Mystate&_Except&failbit)throw failure("ios_base::failbit set");
			else throw failure("ios_base::eofbit set");
		}
		void clear(iostate _State=goodbit)
		{
			clear(_State, false);
		}
		void clear(io_state _State)
		{
			clear((iostate)_State);
		}
		iostate rdstate()const
		{
			return (_Mystate);
		}
		void setstate(iostate _State, bool _Exreraise)
		{
			if(_State!=goodbit)clear((iostate)((int)rdstate()|(int)_State), _Exreraise);
		}
		void setstate(iostate _State)
		{
			if(_State!=goodbit)clear((iostate)((int)rdstate()|(int)_State), false);
		}
		void setstate(io_state _State)
		{
			setstate((iostate)_State);
		}
		bool good()const
		{
			return (rdstate()==goodbit);
		}
		bool eof()const
		{
			return ((int)rdstate()&(int)eofbit);
		}
		bool fail()const
		{
			return (((int)rdstate()&((int)badbit|(int)failbit))!=0);
		}
		bool bad()const
		{
			return (((int)rdstate()&(int)badbit)!=0);
		}
		iostate exceptions()const
		{
			return (_Except);
		}
		void exceptions(iostate _Newexcept)
		{
			_Except=(iostate)((int)_Newexcept&(int)_Statmask);
			clear(_Mystate);
		}
		void exceptions(io_state _State)
		{
			exceptions((iostate)_State);
		}
		fmtflags flags()const
		{
			return (_Fmtfl);
		}
		fmtflags flags(fmtflags _Newfmtflags)
		{
			fmtflags _Oldfmtflags=_Fmtfl;
			_Fmtfl=(fmtflags)((int)_Newfmtflags&(int)_Fmtmask);
			return (_Oldfmtflags);
		}
		fmtflags setf(fmtflags _Newfmtflags)
		{
			ios_base::fmtflags _Oldfmtflags=_Fmtfl;
			_Fmtfl=(fmtflags)((int)_Fmtfl|(int)_Newfmtflags&(int)_Fmtmask);
			return (_Oldfmtflags);
		}
		fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{
			ios_base::fmtflags _Oldfmtflags=_Fmtfl;
			_Fmtfl=(fmtflags)(((int)_Fmtfl&(int)~_Mask)|((int)_Newfmtflags&(int)_Mask&(int)_Fmtmask));
			return (_Oldfmtflags);
		}
		void unsetf(fmtflags _Mask)
		{
			_Fmtfl=(fmtflags)((int)_Fmtfl&(int)~_Mask);
		}
		streamsize precision()const
		{
			return (_Prec);
		}
		streamsize precision(streamsize _Newprecision)
		{
			streamsize _Oldprecision=_Prec;
			_Prec=_Newprecision;
			return (_Oldprecision);
		}
		streamsize width()const
		{
			return (_Wide);
		}
		streamsize width(streamsize _Newwidth)
		{
			streamsize _Oldwidth=_Wide;
			_Wide=_Newwidth;
			return (_Oldwidth);
		}
		locale getloc()const
		{
			return (*_Ploc);
		}
		locale imbue(const locale&_Loc)
		{
			locale _Oldlocale=*_Ploc;
			*_Ploc=_Loc;
			_Callfns(imbue_event);
			return (_Oldlocale);
		}
		static int xalloc()
		{

			{
				::std::_Lockit _Lock(2);
				return (_Index++);
			}
		}
		long&iword(int _Idx)
		{
			return (_Findarr(_Idx)._Lo);
		}
		void*&pword(int _Idx)
		{
			return (_Findarr(_Idx)._Vp);
		}
		void register_callback(event_callback _Pfn, int _Idx)
		{
			_Calls=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xiosbase", 449)_Fnarray(_Idx, _Pfn, _Calls);
		}
		ios_base&copyfmt(const ios_base&_Other)
		{
			if(this!=&_Other)
			{
				_Tidy();
				*_Ploc=*_Other._Ploc;
				_Fmtfl=_Other._Fmtfl;
				_Prec=_Other._Prec;
				_Wide=_Other._Wide;
				_Iosarray*_Ptr=_Other._Arr;
				for(_Arr=0;
				_Ptr!=0;
				_Ptr=_Ptr->_Next)if(_Ptr->_Lo!=0||_Ptr->_Vp!=0)
				{
					iword(_Ptr->_Index)=_Ptr->_Lo;
					pword(_Ptr->_Index)=_Ptr->_Vp;
				}
				for(_Fnarray*_Q=_Other._Calls;
				_Q!=0;
				_Q=_Q->_Next)register_callback(_Q->_Pfn, _Q->_Index);
				_Callfns(copyfmt_event);
				exceptions(_Other._Except);
			}
			return (*this);
		}
		virtual~ios_base()
		{
			_Ios_base_dtor(this);
		}
		static bool sync_with_stdio(bool _Newsync=true)
		{

			{
				::std::_Lockit _Lock(2);
				const bool _Oldsync=_Sync;
				_Sync=_Newsync;
				return (_Oldsync);
			}
		}
		static void _Addstd(ios_base*);
		size_t _Stdstr;
		protected: ios_base()
		{
		}
		void _Init()
		{
			_Ploc=0;
			_Except=goodbit;
			_Fmtfl=skipws|dec;
			_Prec=6;
			_Wide=0;
			_Arr=0;
			_Calls=0;
			clear(goodbit);
			_Ploc=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xiosbase", 512)locale;
		}
	private:
		struct _Iosarray
		{
		public:
			_Iosarray(int _Idx, _Iosarray*_Link): _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{
			}
			_Iosarray*_Next;
			int _Index;
			long _Lo;
			void*_Vp;
		};
		struct _Fnarray
		{
			_Fnarray(int _Idx, event_callback _Pnew, _Fnarray*_Link): _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{
			}
			_Fnarray*_Next;
			int _Index;
			event_callback _Pfn;
		};
		void _Callfns(event _Ev)
		{
			for(_Fnarray*_Ptr=_Calls;
			_Ptr!=0;
			_Ptr=_Ptr->_Next)(*_Ptr->_Pfn)(_Ev, *this, _Ptr->_Index);
		}
		_Iosarray&_Findarr(int _Idx)
		{
			_Iosarray*_Ptr, *_Q;
			for(_Ptr=_Arr, _Q=0;
			_Ptr!=0;
			_Ptr=_Ptr->_Next)if(_Ptr->_Index==_Idx)return (*_Ptr);
			else if(_Q==0&&_Ptr->_Lo==0&&_Ptr->_Vp==0)_Q=_Ptr;
			if(_Q!=0)
			{
				_Q->_Index=_Idx;
				return (*_Q);
			}
			_Arr=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xiosbase", 566)_Iosarray(_Idx, _Arr);
			return (*_Arr);
		}
		void _Tidy()
		{
			_Callfns(erase_event);
			_Iosarray*_Q1, *_Q2;
			for(_Q1=_Arr;
			_Q1!=0;
			_Q1=_Q2)_Q2=_Q1->_Next, std::_DebugHeapDelete(_Q1);
			_Arr=0;
			_Fnarray*_Q3, *_Q4;
			for(_Q3=_Calls;
			_Q3!=0;
			_Q3=_Q4)_Q4=_Q3->_Next, std::_DebugHeapDelete(_Q3);
			_Calls=0;
		}
		static void _Ios_base_dtor(ios_base*);
		iostate _Mystate;
		iostate _Except;
		fmtflags _Fmtfl;
		streamsize _Prec;
		streamsize _Wide;
		_Iosarray*_Arr;
		_Fnarray*_Calls;
		locale*_Ploc;
		static int _Index;
		static bool _Sync;
		static int&_Index_func();
		static bool&_Sync_func();
	};
}
namespace std
{
	template<class _Elem, class _Traits>
	class basic_streambuf
	{
		basic_streambuf(const basic_streambuf<_Elem, _Traits>&);
		basic_streambuf<_Elem, _Traits>&operator=(const basic_streambuf<_Elem, _Traits>&);
		protected: basic_streambuf(): _Plocale(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\streambuf", 28)(locale))
		{
			_Init();
		}
		basic_streambuf(_Uninitialized)
		{
		}
	public:
		typedef basic_streambuf<_Elem, _Traits>_Myt;
		typedef _Elem char_type;
		typedef _Traits traits_type;
		virtual~basic_streambuf()
		{
			std::_DebugHeapDelete(_Plocale);
		}
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		pos_type pubseekoff(off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode=ios_base::in|ios_base::out)
		{
			return (seekoff(_Off, _Way, _Mode));
		}
		pos_type pubseekoff(off_type _Off, ios_base::seek_dir _Way, ios_base::open_mode _Mode)
		{
			return (pubseekoff(_Off, (ios_base::seekdir)_Way, (ios_base::openmode)_Mode));
		}
		pos_type pubseekpos(pos_type _Pos, ios_base::openmode _Mode=ios_base::in|ios_base::out)
		{
			return (seekpos(_Pos, _Mode));
		}
		pos_type pubseekpos(pos_type _Pos, ios_base::open_mode _Mode)
		{
			return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}
		_Myt*pubsetbuf(_Elem*_Buffer, streamsize _Count)
		{
			return (setbuf(_Buffer, _Count));
		}
		locale pubimbue(const locale&_Newlocale)
		{
			locale _Oldlocale=*_Plocale;
			imbue(_Newlocale);
			*_Plocale=_Newlocale;
			return (_Oldlocale);
		}
		locale getloc()const
		{
			return (*_Plocale);
		}
		streamsize in_avail()
		{
			streamsize _Res=_Gnavail();
			return (0<_Res?_Res: showmanyc());
		}
		int pubsync()
		{
			return (sync());
		}
		int_type sbumpc()
		{
			return (0<_Gnavail()?_Traits::to_int_type(*_Gninc()): uflow());
		}
		int_type sgetc()
		{
			return (0<_Gnavail()?_Traits::to_int_type(*gptr()): underflow());
		}
		streamsize _Sgetn_s(_Elem*_Ptr, size_t _Ptr_size, streamsize _Count)
		{
			return _Xsgetn_s(_Ptr, _Ptr_size, _Count);
		}
		streamsize sgetn(_Elem*_Ptr, streamsize _Count)
		{
			return xsgetn(_Ptr, _Count);
		}
		int_type snextc()
		{
			return (1<_Gnavail()?_Traits::to_int_type(*_Gnpreinc()): _Traits::eq_int_type(_Traits::eof(), sbumpc())?_Traits::eof(): sgetc());
		}
		int_type sputbackc(_Elem _Ch)
		{
			return (gptr()!=0&&eback()<gptr()&&_Traits::eq(_Ch, gptr()[-1])?_Traits::to_int_type(*_Gndec()): pbackfail(_Traits::to_int_type(_Ch)));
		}
		void stossc()
		{
			if(0<_Gnavail())_Gninc();
			else uflow();
		}
		int_type sungetc()
		{
			return (gptr()!=0&&eback()<gptr()?_Traits::to_int_type(*_Gndec()): pbackfail());
		}
		int_type sputc(_Elem _Ch)
		{
			return (0<_Pnavail()?_Traits::to_int_type(*_Pninc()=_Ch): overflow(_Traits::to_int_type(_Ch)));
		}
		streamsize sputn(const _Elem*_Ptr, streamsize _Count)
		{
			return (xsputn(_Ptr, _Count));
		}
		void _Lock()
		{
			_Mylock._Lock();
		}
		void _Unlock()
		{
			_Mylock._Unlock();
		}
		protected: _Elem*eback()const
		{
			return (*_IGfirst);
		}
		_Elem*gptr()const
		{
			return (*_IGnext);
		}
		_Elem*pbase()const
		{
			return (*_IPfirst);
		}
		_Elem*pptr()const
		{
			return (*_IPnext);
		}
		_Elem*egptr()const
		{
			return (*_IGnext+*_IGcount);
		}
		void gbump(int _Off)
		{
			*_IGcount-=_Off;
			*_IGnext+=_Off;
		}
		void setg(_Elem*_First, _Elem*_Next, _Elem*_Last)
		{
			*_IGfirst=_First;
			*_IGnext=_Next;
			*_IGcount=(int)(_Last-_Next);
		}
		_Elem*epptr()const
		{
			return (*_IPnext+*_IPcount);
		}
		_Elem*_Gndec()
		{
			++*_IGcount;
			return (--*_IGnext);
		}
		_Elem*_Gninc()
		{
			--*_IGcount;
			return ((*_IGnext)++);
		}
		_Elem*_Gnpreinc()
		{
			--*_IGcount;
			return (++(*_IGnext));
		}
		streamsize _Gnavail()const
		{
			return (*_IGnext!=0?*_IGcount: 0);
		}
		void pbump(int _Off)
		{
			*_IPcount-=_Off;
			*_IPnext+=_Off;
		}
		void setp(_Elem*_First, _Elem*_Last)
		{
			*_IPfirst=_First;
			*_IPnext=_First;
			*_IPcount=(int)(_Last-_First);
		}
		void setp(_Elem*_First, _Elem*_Next, _Elem*_Last)
		{
			*_IPfirst=_First;
			*_IPnext=_Next;
			*_IPcount=(int)(_Last-_Next);
		}
		_Elem*_Pninc()
		{
			--*_IPcount;
			return ((*_IPnext)++);
		}
		streamsize _Pnavail()const
		{
			return (*_IPnext!=0?*_IPcount: 0);
		}
		void _Init()
		{
			_IGfirst=&_Gfirst, _IPfirst=&_Pfirst;
			_IGnext=&_Gnext, _IPnext=&_Pnext;
			_IGcount=&_Gcount, _IPcount=&_Pcount;
			setp(0, 0), setg(0, 0, 0);
		}
		void _Init(_Elem**_Gf, _Elem**_Gn, int*_Gc, _Elem**_Pf, _Elem**_Pn, int*_Pc)
		{
			_IGfirst=_Gf, _IPfirst=_Pf;
			_IGnext=_Gn, _IPnext=_Pn;
			_IGcount=_Gc, _IPcount=_Pc;
		}
		virtual int_type overflow(int_type=_Traits::eof())
		{
			return (_Traits::eof());
		}
		virtual int_type pbackfail(int_type=_Traits::eof())
		{
			return (_Traits::eof());
		}
		virtual streamsize showmanyc()
		{
			return (0);
		}
		virtual int_type underflow()
		{
			return (_Traits::eof());
		}
		virtual int_type uflow()
		{
			return (_Traits::eq_int_type(_Traits::eof(), underflow())?_Traits::eof(): _Traits::to_int_type(*_Gninc()));
		}
		virtual streamsize xsgetn(_Elem*_Ptr, streamsize _Count)
		{
			return _Xsgetn_s(_Ptr, (size_t)-1, _Count);
		}
		virtual streamsize _Xsgetn_s(_Elem*_Ptr, size_t _Ptr_size, streamsize _Count)
		{
			int_type _Meta;
			streamsize _Stream_size, _Size, _Copied;
			for(_Copied=0;
			0<_Count;
			)if(0<(_Stream_size=_Gnavail()))
			{
				_Size=_Stream_size;
				if(_Count<_Size)_Size=_Count;
				_Traits_helper::copy_s<_Traits>(_Ptr, _Ptr_size, gptr(), _Size);
				_Ptr+=_Size;
				_Copied+=_Size;
				_Count-=_Size;
				gbump((int)_Size);
			}
			else if(_Traits::eq_int_type(_Traits::eof(), _Meta=uflow()))break;
			else
			{
				*_Ptr++=_Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
			}
			return (_Copied);
		}
		virtual streamsize xsputn(const _Elem*_Ptr, streamsize _Count)
		{
			streamsize _Stream_size, _Size, _Copied;
			for(_Copied=0;
			0<_Count;
			)if(0<(_Stream_size=_Pnavail()))
			{
				_Size=_Stream_size;
				if(_Count<_Size)_Size=_Count;
				_Traits_helper::copy_s<_Traits>(pptr(), _Stream_size, _Ptr, _Size);
				_Ptr+=_Size;
				_Copied+=_Size;
				_Count-=_Size;
				pbump((int)_Size);
			}
			else if(_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr))))break;
			else
			{
				++_Ptr;
				++_Copied;
				--_Count;
			}
			return (_Copied);
		}
		virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode=ios_base::in|ios_base::out)
		{
			return (streampos(_BADOFF));
		}
		virtual pos_type seekpos(pos_type, ios_base::openmode=ios_base::in|ios_base::out)
		{
			return (streampos(_BADOFF));
		}
		virtual _Myt*setbuf(_Elem*, streamsize)
		{
			return (this);
		}
		virtual int sync()
		{
			return (0);
		}
		virtual void imbue(const locale&)
		{
		}
	private:
		_Mutex _Mylock;
		_Elem*_Gfirst;
		_Elem*_Pfirst;
		_Elem**_IGfirst;
		_Elem**_IPfirst;
		_Elem*_Gnext;
		_Elem*_Pnext;
		_Elem**_IGnext;
		_Elem**_IPnext;
		int _Gcount;
		int _Pcount;
		int*_IGcount;
		int*_IPcount;
		locale*_Plocale;
	};
}
extern "C"
{
	extern long _Stolx(const char*, char**, int, int*);
	extern unsigned long _Stoulx(const char*, char**, int, int*);
	extern float _Stofx(const char*, char**, long, int*);
	extern double _Stodx(const char*, char**, long, int*);
	extern long double _Stoldx(const char*, char**, long, int*);
}
namespace std
{
	template<class _Elem>
	class numpunct: public locale::facet
	{
	public:
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >string_type;
		typedef _Elem char_type;
		static locale::id id;
		_Elem decimal_point()const
		{
			return (do_decimal_point());
		}
		_Elem thousands_sep()const
		{
			return (do_thousands_sep());
		}
		string grouping()const
		{
			return (do_grouping());
		}
		string_type falsename()const
		{
			return (do_falsename());
		}
		string_type truename()const
		{
			return (do_truename());
		}
		explicit numpunct(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
				if(_Kseparator==0)_Kseparator=_Maklocchr(',', (_Elem*)0, _Lobj._Getcvt());
			}
		}
		numpunct(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 103)numpunct<_Elem>;
			return (4);
		}
		protected: virtual~numpunct()
		{
			_Tidy();
		}
		protected: numpunct(const char*_Locname, size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			const lconv*_Ptr=_Lobj._Getlconv();
			_Grouping=0;
			_Falsename=0;
			_Truename=0;
			try
			{
				_Grouping=_Maklocstr(_Ptr->grouping, (char*)0, _Lobj._Getcvt());
				_Falsename=_Maklocstr(_Lobj._Getfalse(), (_Elem*)0, _Lobj._Getcvt());
				_Truename=_Maklocstr(_Lobj._Gettrue(), (_Elem*)0, _Lobj._Getcvt());
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
			_Dp=_Maklocchr(_Ptr->decimal_point[0], (_Elem*)0, _Lobj._Getcvt());
			_Kseparator=_Maklocchr(_Ptr->thousands_sep[0], (_Elem*)0, _Lobj._Getcvt());
		}
		virtual _Elem do_decimal_point()const
		{
			return (_Dp);
		}
		virtual _Elem do_thousands_sep()const
		{
			return (_Kseparator);
		}
		virtual string do_grouping()const
		{
			return (string(_Grouping));
		}
		virtual string_type do_falsename()const
		{
			return (string_type(_Falsename));
		}
		virtual string_type do_truename()const
		{
			return (string_type(_Truename));
		}
	private:
		void _Tidy()
		{
			std::_DebugHeapDelete((void*)(void*)_Grouping);
			std::_DebugHeapDelete((void*)(void*)_Falsename);
			std::_DebugHeapDelete((void*)(void*)_Truename);
		}
		const char*_Grouping;
		_Elem _Dp;
		_Elem _Kseparator;
		const _Elem*_Falsename;
		const _Elem*_Truename;
	};
	typedef numpunct<char>_Npc;
	typedef numpunct<wchar_t>_Npwc;
	template<class _Elem>
	class numpunct_byname: public numpunct<_Elem>
	{
	public:
		explicit numpunct_byname(const char*_Locname, size_t _Refs=0): numpunct<_Elem>(_Locname, _Refs)
		{
		}
		protected: virtual~numpunct_byname()
		{
		}
	};
	template<class _Elem>
	locale::id numpunct<_Elem>::id;
	template<class _Elem, class _InIt=istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get: public locale::facet
	{
	public:
		typedef numpunct<_Elem>_Mypunct;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >_Mystr;
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 222)num_get<_Elem, _InIt>;
			return (4);
		}
		static locale::id id;
		protected: virtual~num_get()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		_Locinfo::_Cvtvec _Cvt;
	public:
		explicit num_get(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		num_get(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		typedef _Elem char_type;
		typedef _InIt iter_type;
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, _Bool&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned short&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned int&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, long&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned long&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, __int64&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned __int64&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, float&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, double&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, long double&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, void*&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		protected: virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, _Bool&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 343);
			int _Ans=-1;
			if(_Iosbase.flags()&ios_base::boolalpha)
			{
				typedef typename _Mystr::size_type _Mystrsize;
				const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Iosbase.getloc());
				_Mystr _Str((_Mystrsize)1, (char_type)0);
				_Str+=_Punct_fac.falsename();
				_Str+=(char_type)0;
				_Str+=_Punct_fac.truename();
				_Ans=_Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
			else
			{
				char _Ac[32], *_Ep;
				int _Errno=0;
				const unsigned long _Ulo=::_Stoulx(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno);
				if(_Ep!=_Ac&&_Errno==0&&_Ulo<=1)_Ans=_Ulo;
			}
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ans<0)_State|=ios_base::failbit;
			else _Val=_Ans!=0;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned short&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 380);
			char _Ac[32], *_Ep;
			int _Errno=0;
			int _Base=_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
			char*_Ptr=_Ac[0]=='-'?_Ac+1: _Ac;
			const unsigned long _Ans=::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ptr||_Errno!=0||0xffff<_Ans)_State|=ios_base::failbit;
			else _Val=(unsigned short)(_Ac[0]=='-'?0-_Ans: _Ans);
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned int&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 403);
			char _Ac[32], *_Ep;
			int _Errno=0;
			int _Base=_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
			char*_Ptr=_Ac[0]=='-'?_Ac+1: _Ac;
			const unsigned long _Ans=::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ptr||_Errno!=0||0xffffffff<_Ans)_State|=ios_base::failbit;
			else _Val=_Ac[0]=='-'?0-_Ans: _Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, long&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 425);
			char _Ac[32], *_Ep;
			int _Errno=0;
			const long _Ans=::_Stolx(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned long&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 445);
			char _Ac[32], *_Ep;
			int _Errno=0;
			const unsigned long _Ans=::_Stoulx(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, __int64&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 466);
			char _Ac[32], *_Ep;
			int _Errno=0;
			const __int64 _Ans=::_strtoi64(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()));
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned __int64&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 486);
			char _Ac[32], *_Ep;
			int _Errno=0;
			const unsigned __int64 _Ans=::_strtoui64(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()));
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, float&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 507);
			char _Ac[8+36+16], *_Ep;
			int _Errno=0;
			const float _Ans=::_Stofx(_Ac, &_Ep, _Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, double&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 527);
			char _Ac[8+36+16], *_Ep;
			int _Errno=0;
			const double _Ans=::_Stodx(_Ac, &_Ep, _Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, long double&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 547);
			char _Ac[8+36+16], *_Ep;
			int _Errno=0;
			const long double _Ans=::_Stoldx(_Ac, &_Ep, _Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, void*&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 567);
			char _Ac[32], *_Ep;
			int _Errno=0;
			int _Base=_Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc());
			const unsigned __int64 _Ans=(sizeof(void*)==sizeof(unsigned long))?(unsigned __int64)::_Stoulx(_Ac, &_Ep, _Base, &_Errno): ::_strtoui64(_Ac, &_Ep, _Base);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=(void*)(uintptr_t)_Ans;
			return (_First);
		}
	private:
		int _Getifld(char*_Ac, _InIt&_First, _InIt&_Last, ios_base::fmtflags _Basefield, const locale&_Loc)const
		{
			const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Loc);
			const string _Grouping=_Punct_fac.grouping();
			const _Elem _Kseparator=_Punct_fac.thousands_sep();
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			char*_Ptr=_Ac;
			if(_First==_Last);
			else if(*_First==_Maklocchr('+', (_Elem*)0, _Cvt))*_Ptr++='+', ++_First;
			else if(*_First==_Maklocchr('-', (_Elem*)0, _Cvt))*_Ptr++='-', ++_First;
			_Basefield&=ios_base::basefield;
			int _Base=_Basefield==ios_base::oct?8: _Basefield==ios_base::hex?16: _Basefield==ios_base::_Fmtzero?0: 10;
			bool _Seendigit=false;
			bool _Nonzero=false;
			if(_First!=_Last&&*_First==_E0)
			{
				_Seendigit=true, ++_First;
				if(_First!=_Last&&(*_First==_Maklocchr('x', (_Elem*)0, _Cvt)||*_First==_Maklocchr('X', (_Elem*)0, _Cvt))&&(_Base==0||_Base==16))_Base=16, _Seendigit=false, ++_First;
				else if(_Base==0)_Base=8;
			}
			int _Dlen=_Base==0||_Base==10?10: _Base==8?8: 16+6;
			string _Groups((size_t)1, (char)_Seendigit);
			size_t _Group=0;
			for(char*const _Pe=&_Ac[32-1];
			_First!=_Last;
			++_First)if(::memchr("0123456789abcdefABCDEF", *_Ptr=_Maklocbyte((_Elem)*_First, _Cvt), _Dlen)!=0)
			{
				if((_Nonzero||*_Ptr!='0')&&_Ptr<_Pe)++_Ptr, _Nonzero=true;
				_Seendigit=true;
				if(_Groups[_Group]!=127)++_Groups[_Group];
			}
			else if(_Groups[_Group]=='\0'||_Kseparator==(_Elem)0||*_First!=_Kseparator)break;
			else
			{
				_Groups.append((string::size_type)1, '\0');
				++_Group;
			}
			if(_Group==0);
			else if('\0'<_Groups[_Group])++_Group;
			else _Seendigit=false;
			for(const char*_Pg=_Grouping.c_str();
			_Seendigit&&0<_Group;
			)if(*_Pg==127)break;
			else if(0<--_Group&&*_Pg!=_Groups[_Group]||0==_Group&&*_Pg<_Groups[_Group])_Seendigit=false;
			else if('\0'<_Pg[1])++_Pg;
			if(_Seendigit&&!_Nonzero)*_Ptr++='0';
			else if(!_Seendigit)_Ptr=_Ac;
			*_Ptr='\0';
			return (_Base);
		}
		int _Getffld(char*_Ac, _InIt&_First, _InIt&_Last, const locale&_Loc)const
		{
			const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Loc);
			const string _Grouping=_Punct_fac.grouping();
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			char*_Ptr=_Ac;
			bool _Bad=false;
			if(_First==_Last);
			else if(*_First==_Maklocchr('+', (_Elem*)0, _Cvt))*_Ptr++='+', ++_First;
			else if(*_First==_Maklocchr('-', (_Elem*)0, _Cvt))*_Ptr++='-', ++_First;
			bool _Seendigit=false;
			int _Significant=0;
			int _Pten=0;
			if(*_Grouping.c_str()==127||*_Grouping.c_str()<='\0')for(;
			_First!=_Last&&_E0<=*_First&&*_First<=_E0+9;
			_Seendigit=true, ++_First)if(36<=_Significant)++_Pten;
			else if(*_First==_E0&&_Significant==0);
			else
			{
				*_Ptr++=(char)((*_First-_E0)+'0');
				++_Significant;
			}
			else
			{
				const _Elem _Kseparator=_Punct_fac.thousands_sep();
				string _Groups((size_t)1, '\0');
				size_t _Group=0;
				for(;
				_First!=_Last;
				++_First)if(_E0<=*_First&&*_First<=_E0+9)
				{
					_Seendigit=true;
					if(36<=_Significant)++_Pten;
					else if(*_First==_E0&&_Significant==0);
					else
					{
						*_Ptr++=(char)((*_First-_E0)+'0');
						++_Significant;
					}
					if(_Groups[_Group]!=127)++_Groups[_Group];
				}
				else if(_Groups[_Group]=='\0'||_Kseparator==(_Elem)0||*_First!=_Kseparator)break;
				else
				{
					_Groups.append((size_t)1, '\0');
					++_Group;
				}
				if(_Group==0);
				else if('\0'<_Groups[_Group])++_Group;
				else _Bad=true;
				for(const char*_Pg=_Grouping.c_str();
				!_Bad&&0<_Group;
				)if(*_Pg==127)break;
				else if(0<--_Group&&*_Pg!=_Groups[_Group]||0==_Group&&*_Pg<_Groups[_Group])_Bad=true;
				else if('\0'<_Pg[1])++_Pg;
			}
			if(_Seendigit&&_Significant==0)*_Ptr++='0';
			if(_First!=_Last&&*_First==_Punct_fac.decimal_point())*_Ptr++=localeconv()->decimal_point[0], ++_First;
			if(_Significant==0)
			{
				for(;
				_First!=_Last&&*_First==_E0;
				_Seendigit=true, ++_First)--_Pten;
				if(_Pten<0)*_Ptr++='0', ++_Pten;
			}
			for(;
			_First!=_Last&&_E0<=*_First&&*_First<=_E0+9;
			_Seendigit=true, ++_First)if(_Significant<36)
			{
				*_Ptr++=(char)((*_First-_E0)+'0');
				++_Significant;
			}
			if(_Seendigit&&_First!=_Last&&(*_First==_Maklocchr('e', (_Elem*)0, _Cvt)||*_First==_Maklocchr('E', (_Elem*)0, _Cvt)))
			{
				*_Ptr++='e', ++_First;
				_Seendigit=false, _Significant=0;
				if(_First==_Last);
				else if(*_First==_Maklocchr('+', (_Elem*)0, _Cvt))*_Ptr++='+', ++_First;
				else if(*_First==_Maklocchr('-', (_Elem*)0, _Cvt))*_Ptr++='-', ++_First;
				for(;
				_First!=_Last&&*_First==_E0;
				)_Seendigit=true, ++_First;
				if(_Seendigit)*_Ptr++='0';
				for(;
				_First!=_Last&&_E0<=*_First&&*_First<=_E0+9;
				_Seendigit=true, ++_First)if(_Significant<8)
				{
					*_Ptr++=(char)((*_First-_E0)+'0');
					++_Significant;
				}
			}
			if(_Bad||!_Seendigit)_Ptr=_Ac;
			*_Ptr='\0';
			return (_Pten);
		}
	};
	template<class _Elem, class _InIt>
	locale::id num_get<_Elem, _InIt>::id;
	template<class _Elem, class _OutIt=ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put: public locale::facet
	{
	public:
		typedef numpunct<_Elem>_Mypunct;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >_Mystr;
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 840)num_put<_Elem, _OutIt>;
			return (4);
		}
		static locale::id id;
		protected: virtual~num_put()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		_Locinfo::_Cvtvec _Cvt;
	public:
		explicit num_put(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		num_put(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		typedef _Elem char_type;
		typedef _OutIt iter_type;
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, _Bool _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, long _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, unsigned long _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, __int64 _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, unsigned __int64 _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, double _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, long double _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const void*_Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		protected: virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, _Bool _Val)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 931);
			if(!(_Iosbase.flags()&ios_base::boolalpha))return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
			else
			{
				const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Iosbase.getloc());
				_Mystr _Str;
				if(_Val)_Str.assign(_Punct_fac.truename());
				else _Str.assign(_Punct_fac.falsename());
				size_t _Fillcount=_Iosbase.width()<=0||(size_t)_Iosbase.width()<=_Str.size()?0: (size_t)_Iosbase.width()-_Str.size();
				if((_Iosbase.flags()&ios_base::adjustfield)!=ios_base::left)
				{
					_Dest=_Rep(_Dest, _Fill, _Fillcount);
					_Fillcount=0;
				}
				_Dest=_Put(_Dest, _Str.c_str(), _Str.size());
				_Iosbase.width(0);
				return (_Rep(_Dest, _Fill, _Fillcount));
			}
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, long _Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size], _Fmt[6];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, unsigned long _Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size], _Fmt[6];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, __int64 _Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size], _Fmt[8];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, unsigned __int64 _Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size], _Fmt[8];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, double _Val)const
		{
			const size_t _Buf_size=8+36+64;
			char _Buf[_Buf_size], _Fmt[8];
			streamsize _Precision=_Iosbase.precision()<=0&&!(_Iosbase.flags()&ios_base::fixed)?6: _Iosbase.precision();
			int _Significance=36<_Precision?36: (int)_Precision;
			_Precision-=_Significance;
			size_t _Beforepoint=0;
			size_t _Afterpoint=0;
			if((_Iosbase.flags()&ios_base::floatfield)==ios_base::fixed)
			{
				bool _Signed=_Val<0;
				if(_Signed)_Val=-_Val;
				for(;
				1e35<=_Val&&_Beforepoint<5000;
				_Beforepoint+=10)_Val/=1e10;
				if(0<_Val)for(;
				10<=_Precision&&_Val<=1e-35&&_Afterpoint<5000;
				_Afterpoint+=10)
				{
					_Val*=1e10;
					_Precision-=10;
				}
				if(_Signed)_Val=-_Val;
			}
			return (_Fput(_Dest, _Iosbase, _Fill, _Buf, _Beforepoint, _Afterpoint, _Precision, ::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()), _Significance, _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, long double _Val)const
		{
			const size_t _Buf_size=8+36+64;
			char _Buf[_Buf_size], _Fmt[8];
			streamsize _Precision=_Iosbase.precision()<=0&&!(_Iosbase.flags()&ios_base::fixed)?6: _Iosbase.precision();
			int _Significance=36<_Precision?36: (int)_Precision;
			_Precision-=_Significance;
			size_t _Beforepoint=0;
			size_t _Afterpoint=0;
			if((_Iosbase.flags()&ios_base::floatfield)==ios_base::fixed)
			{
				bool _Signed=_Val<0;
				if(_Signed)_Val=-_Val;
				for(;
				1e35<=_Val&&_Beforepoint<5000;
				_Beforepoint+=10)_Val/=1e10;
				if(0<_Val)for(;
				10<=_Precision&&_Val<=1e-35&&_Afterpoint<5000;
				_Afterpoint+=10)
				{
					_Val*=1e10;
					_Precision-=10;
				}
				if(_Signed)_Val=-_Val;
			}
			return (_Fput(_Dest, _Iosbase, _Fill, _Buf, _Beforepoint, _Afterpoint, _Precision, ::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()), _Significance, _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const void*_Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, "%p", _Val)));
		}
	private:
		char*_Ffmt(char*_Fmt, char _Spec, ios_base::fmtflags _Flags)const
		{
			char*_Ptr=_Fmt;
			*_Ptr++='%';
			if(_Flags&ios_base::showpos)*_Ptr++='+';
			if(_Flags&ios_base::showpoint)*_Ptr++='#';
			*_Ptr++='.';
			*_Ptr++='*';
			if(_Spec!='\0')*_Ptr++=_Spec;
			ios_base::fmtflags _Ffl=_Flags&ios_base::floatfield;
			*_Ptr++=_Ffl==ios_base::fixed?'f': _Ffl==ios_base::scientific?'e': 'g';
			*_Ptr='\0';
			return (_Fmt);
		}
		_OutIt _Fput(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const char*_Buf, size_t _Beforepoint, size_t _Afterpoint, size_t _Trailing, size_t _Count)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 1119);
			const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Iosbase.getloc());
			const string _Grouping=_Punct_fac.grouping();
			const _Elem _Kseparator=_Punct_fac.thousands_sep();
			string _Groupstring;
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			size_t _Prefix=_Buf[0]=='+'||_Buf[0]=='-'?1: 0;
			char _Enders[3];
			_Enders[0]=::localeconv()->decimal_point[0];
			_Enders[1]='e';
			_Enders[2]='\0';
			const char*_Eptr=(const char*)::memchr(_Buf, 'e', _Count);
			const char*_Pointptr=(const char*)::memchr(_Buf, _Enders[0], _Count);
			if(_Pointptr==0)_Trailing=0;
			if(*_Grouping.c_str()!=127&&'\0'<*_Grouping.c_str())
			{
				_Groupstring.append(_Buf, _Count);
				if(_Eptr==0)_Groupstring.append(_Trailing, '0');
				else
				{
					if(_Pointptr==0)
					{
						_Groupstring.append(_Beforepoint, '0');
						_Beforepoint=0;
					}
					_Groupstring.insert(_Eptr-_Buf, _Trailing, '0');
				}
				_Trailing=0;
				if(_Pointptr==0)_Groupstring.append(_Beforepoint, '0');
				else
				{
					_Groupstring.insert(_Pointptr-_Buf+1, _Afterpoint, '0');
					_Groupstring.insert(_Pointptr-_Buf, _Beforepoint, '0');
					_Afterpoint=0;
				}
				_Beforepoint=0;
				const char*_Pg=_Grouping.c_str();
				size_t _Off=::strcspn(&_Groupstring[0], &_Enders[0]);
				while(*_Pg!=127&&'\0'<*_Pg&&(size_t)*_Pg<_Off-_Prefix)
				{
					_Groupstring.insert(_Off-=*_Pg, (size_t)1, '\0');
					if('\0'<_Pg[1])++_Pg;
				}
				_Buf=&_Groupstring[0];
				_Trailing=0;
				_Count=_Groupstring.size();
			}
			size_t _Fillcount=_Beforepoint+_Afterpoint+_Trailing+_Count;
			_Fillcount=_Iosbase.width()<=0||(size_t)_Iosbase.width()<=_Fillcount?0: (size_t)_Iosbase.width()-_Fillcount;
			ios_base::fmtflags _Adjustfield=_Iosbase.flags()&ios_base::adjustfield;
			if(_Adjustfield!=ios_base::left&&_Adjustfield!=ios_base::internal)
			{
				_Dest=_Rep(_Dest, _Fill, _Fillcount);
				_Fillcount=0;
			}
			else if(_Adjustfield==ios_base::internal)
			{
				if(0<_Prefix)
				{
					_Dest=_Putc(_Dest, _Buf, 1);
					++_Buf, --_Count;
				}
				_Dest=_Rep(_Dest, _Fill, _Fillcount);
				_Fillcount=0;
			}
			_Pointptr=(const char*)::memchr(_Buf, _Enders[0], _Count);
			if(_Pointptr!=0)
			{
				size_t _Fracoffset=_Pointptr-_Buf+1;
				_Dest=_Putgrouped(_Dest, _Buf, _Fracoffset-1, _Kseparator);
				_Dest=_Rep(_Dest, _E0, _Beforepoint);
				_Dest=_Rep(_Dest, _Punct_fac.decimal_point(), 1);
				_Dest=_Rep(_Dest, _E0, _Afterpoint);
				_Buf+=_Fracoffset, _Count-=_Fracoffset;
			}
			_Eptr=(const char*)::memchr(_Buf, 'e', _Count);
			if(_Eptr!=0)
			{
				size_t _Expoffset=_Eptr-_Buf+1;
				_Dest=_Putgrouped(_Dest, _Buf, _Expoffset-1, _Kseparator);
				_Dest=_Rep(_Dest, _E0, _Trailing), _Trailing=0;
				_Dest=_Putc(_Dest, _Iosbase.flags()&ios_base::uppercase?"E": "e", 1);
				_Buf+=_Expoffset, _Count-=_Expoffset;
			}
			_Dest=_Putgrouped(_Dest, _Buf, _Count, _Kseparator);
			_Dest=_Rep(_Dest, _E0, _Trailing);
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));
		}
		char*_Ifmt(char*_Fmt, const char*_Spec, ios_base::fmtflags _Flags)const
		{
			char*_Ptr=_Fmt;
			*_Ptr++='%';
			if(_Flags&ios_base::showpos)*_Ptr++='+';
			if(_Flags&ios_base::showbase)*_Ptr++='#';
			if(_Spec[0]!='L')*_Ptr++=_Spec[0];
			else
			{
				*_Ptr++='I';
				*_Ptr++='6';
				*_Ptr++='4';
			}
			ios_base::fmtflags _Basefield=_Flags&ios_base::basefield;
			*_Ptr++=_Basefield==ios_base::oct?'o': _Basefield!=ios_base::hex?_Spec[1]: _Flags&ios_base::uppercase?'X': 'x';
			*_Ptr='\0';
			return (_Fmt);
		}
		_OutIt _Iput(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, char*_Buf, size_t _Count)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 1264);
			const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Iosbase.getloc());
			const string _Grouping=_Punct_fac.grouping();
			const size_t _Prefix=*_Buf=='+'||*_Buf=='-'?1: *_Buf=='0'&&(_Buf[1]=='x'||_Buf[1]=='X')?2: 0;
			if(*_Grouping.c_str()!=127&&'\0'<*_Grouping.c_str())
			{
				const char*_Pg=_Grouping.c_str();
				size_t _Off=_Count;
				while(*_Pg!=127&&'\0'<*_Pg&&(size_t)*_Pg<_Off-_Prefix)
				{
					_Off-=*_Pg;
					::memmove_s((&_Buf[_Off+1]), (_Count+1-_Off), (&_Buf[_Off]), (_Count+1-_Off));
					_Buf[_Off]='\0', ++_Count;
					if('\0'<_Pg[1])++_Pg;
				}
			}
			size_t _Fillcount=_Iosbase.width()<=0||(size_t)_Iosbase.width()<=_Count?0: (size_t)_Iosbase.width()-_Count;
			ios_base::fmtflags _Adjustfield=_Iosbase.flags()&ios_base::adjustfield;
			if(_Adjustfield!=ios_base::left&&_Adjustfield!=ios_base::internal)
			{
				_Dest=_Rep(_Dest, _Fill, _Fillcount);
				_Fillcount=0;
			}
			else if(_Adjustfield==ios_base::internal)
			{
				_Dest=_Putc(_Dest, _Buf, _Prefix);
				_Buf+=_Prefix, _Count-=_Prefix;
				_Dest=_Rep(_Dest, _Fill, _Fillcount), _Fillcount=0;
			}
			_Dest=_Putgrouped(_Dest, _Buf, _Count, _Punct_fac.thousands_sep());
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));
		}
		_OutIt _Put(_OutIt _Dest, const _Elem*_Ptr, size_t _Count)const
		{
			for(;
			0<_Count;
			--_Count, ++_Dest, ++_Ptr)*_Dest=*_Ptr;
			return (_Dest);
		}
		_OutIt _Putc(_OutIt _Dest, const char*_Ptr, size_t _Count)const
		{
			for(;
			0<_Count;
			--_Count, ++_Dest, ++_Ptr)*_Dest=_Maklocchr(*_Ptr, (_Elem*)0, _Cvt);
			return (_Dest);
		}
		_OutIt _Putgrouped(_OutIt _Dest, const char*_Ptr, size_t _Count, _Elem _Kseparator)const
		{
			for(;
			;
			++_Ptr, --_Count)
			{
				const char*_Pend=(const char*)::memchr(_Ptr, '\0', _Count);
				size_t _Groupsize=_Pend!=0?_Pend-_Ptr: _Count;
				_Dest=_Putc(_Dest, _Ptr, _Groupsize);
				_Ptr+=_Groupsize, _Count-=_Groupsize;
				if(_Count==0)break;
				if(_Kseparator!=(_Elem)0)_Dest=_Rep(_Dest, _Kseparator, 1);
			}
			return (_Dest);
		}
		_OutIt _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count)const
		{
			for(;
			0<_Count;
			--_Count, ++_Dest)*_Dest=_Ch;
			return (_Dest);
		}
	};
	template<class _Elem, class _OutIt>
	locale::id num_put<_Elem, _OutIt>::id;
}
namespace std
{
	template<class _Elem, class _Traits>
	class basic_ios: public ios_base
	{
	public:
		typedef basic_ios<_Elem, _Traits>_Myt;
		typedef basic_ostream<_Elem, _Traits>_Myos;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef ctype<_Elem>_Ctype;
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		explicit basic_ios(_Mysb*_Strbuf)
		{
			init(_Strbuf);
		}
		virtual~basic_ios()
		{
		}
		void clear(iostate _State=goodbit, bool _Reraise=false)
		{
			ios_base::clear((iostate)(_Mystrbuf==0?(int)_State|(int)badbit: (int)_State), _Reraise);
		}
		void clear(io_state _State)
		{
			clear((iostate)_State);
		}
		void setstate(iostate _State, bool _Reraise=false)
		{
			if(_State!=goodbit)clear((iostate)((int)rdstate()|(int)_State), _Reraise);
		}
		void setstate(io_state _State)
		{
			setstate((iostate)_State);
		}
		_Myt&copyfmt(const _Myt&_Right)
		{
			_Tiestr=_Right.tie();
			_Fillch=_Right.fill();
			ios_base::copyfmt(_Right);
			return (*this);
		}
		_Myos*tie()const
		{
			return (_Tiestr);
		}
		_Myos*tie(_Myos*_Newtie)
		{
			_Myos*_Oldtie=_Tiestr;
			_Tiestr=_Newtie;
			return (_Oldtie);
		}
		_Mysb*rdbuf()const
		{
			return (_Mystrbuf);
		}
		_Mysb*rdbuf(_Mysb*_Strbuf)
		{
			_Mysb*_Oldstrbuf=_Mystrbuf;
			_Mystrbuf=_Strbuf;
			clear();
			return (_Oldstrbuf);
		}
		locale imbue(const locale&_Loc)
		{
			locale _Oldlocale=ios_base::imbue(_Loc);
			if(rdbuf()!=0)rdbuf()->pubimbue(_Loc);
			return (_Oldlocale);
		}
		_Elem fill()const
		{
			return (_Fillch);
		}
		_Elem fill(_Elem _Newfill)
		{
			_Elem _Oldfill=_Fillch;
			_Fillch=_Newfill;
			return (_Oldfill);
		}
		char narrow(_Elem _Ch, char _Dflt='\0')const
		{
			const _Ctype&_Ctype_fac=use_facet<_Ctype>(getloc());
			return (_Ctype_fac.narrow(_Ch, _Dflt));
		}
		_Elem widen(char _Byte)const
		{
			const _Ctype&_Ctype_fac=use_facet<_Ctype>(getloc());
			return (_Ctype_fac.widen(_Byte));
		}
		protected: void init(_Mysb*_Strbuf=0, bool _Isstd=false)
		{
			_Init();
			_Mystrbuf=_Strbuf;
			_Tiestr=0;
			_Fillch=widen(' ');
			if(_Mystrbuf==0)setstate(badbit);
			if(_Isstd)_Addstd(this);
			else _Stdstr=0;
		}
		basic_ios()
		{
		}
	private:
		basic_ios(const _Myt&);
		_Myt&operator=(const _Myt&);
		_Mysb*_Mystrbuf;
		_Myos*_Tiestr;
		_Elem _Fillch;
	};
	inline ios_base&boolalpha(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::boolalpha);
		return (_Iosbase);
	}
	inline ios_base&dec(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::dec, ios_base::basefield);
		return (_Iosbase);
	}
	inline ios_base&fixed(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
		return (_Iosbase);
	}
	inline ios_base&hex(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::hex, ios_base::basefield);
		return (_Iosbase);
	}
	inline ios_base&internal(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
		return (_Iosbase);
	}
	inline ios_base&left(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::left, ios_base::adjustfield);
		return (_Iosbase);
	}
	inline ios_base&noboolalpha(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::boolalpha);
		return (_Iosbase);
	}
	inline ios_base&noshowbase(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::showbase);
		return (_Iosbase);
	}
	inline ios_base&noshowpoint(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::showpoint);
		return (_Iosbase);
	}
	inline ios_base&noshowpos(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::showpos);
		return (_Iosbase);
	}
	inline ios_base&noskipws(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::skipws);
		return (_Iosbase);
	}
	inline ios_base&nounitbuf(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::unitbuf);
		return (_Iosbase);
	}
	inline ios_base&nouppercase(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::uppercase);
		return (_Iosbase);
	}
	inline ios_base&oct(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::oct, ios_base::basefield);
		return (_Iosbase);
	}
	inline ios_base&right(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::right, ios_base::adjustfield);
		return (_Iosbase);
	}
	inline ios_base&scientific(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
		return (_Iosbase);
	}
	inline ios_base&showbase(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::showbase);
		return (_Iosbase);
	}
	inline ios_base&showpoint(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::showpoint);
		return (_Iosbase);
	}
	inline ios_base&showpos(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::showpos);
		return (_Iosbase);
	}
	inline ios_base&skipws(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::skipws);
		return (_Iosbase);
	}
	inline ios_base&unitbuf(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::unitbuf);
		return (_Iosbase);
	}
	inline ios_base&uppercase(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::uppercase);
		return (_Iosbase);
	}
}
namespace std
{
	template<class _Elem, class _Traits>
	class basic_ostream: virtual public basic_ios<_Elem, _Traits>
	{
	public:
		typedef basic_ostream<_Elem, _Traits>_Myt;
		typedef basic_ios<_Elem, _Traits>_Myios;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef ostreambuf_iterator<_Elem, _Traits>_Iter;
		typedef num_put<_Elem, _Iter>_Nput;
		explicit basic_ostream(basic_streambuf<_Elem, _Traits>*_Strbuf, bool _Isstd=false)
		{
			_Myios::init(_Strbuf, _Isstd);
		}
		basic_ostream(_Uninitialized)
		{
			ios_base::_Addstd(this);
		}
		virtual~basic_ostream()
		{
		}
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		class _Sentry_base
		{
		public:
			_Sentry_base(_Myt&_Ostr): _Myostr(_Ostr)
			{
				if(_Myostr.rdbuf()!=0)_Myostr.rdbuf()->_Lock();
			}
			~_Sentry_base()
			{
				if(_Myostr.rdbuf()!=0)_Myostr.rdbuf()->_Unlock();
			}
			_Myt&_Myostr;
		};
		class sentry: public _Sentry_base
		{
		public:
			explicit sentry(_Myt&_Ostr): _Sentry_base(_Ostr)
			{
				if(_Ostr.good()&&_Ostr.tie()!=0)_Ostr.tie()->flush();
				_Ok=_Ostr.good();
			}
			~sentry()
			{
				if(!std::uncaught_exception())this->_Myostr._Osfx();
			}
			operator bool()const
			{
				return (_Ok);
			}
		private:
			sentry(const sentry&);
			sentry&operator=(const sentry&);
			bool _Ok;
		};
		bool opfx()
		{
			if(ios_base::good()&&_Myios::tie()!=0)_Myios::tie()->flush();
			return (ios_base::good());
		}
		void osfx()
		{
			_Osfx();
		}
		void _Osfx()
		{
			try
			{
				if(ios_base::flags()&ios_base::unitbuf)flush();
			}
			catch(...)
			{
			}
		}
		_Myt&operator<<(_Myt&(*_Pfn)(_Myt&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\ostream", 170);
			return ((*_Pfn)(*this));
		}
		_Myt&operator<<(_Myios&(*_Pfn)(_Myios&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\ostream", 176);
			(*_Pfn)(*(_Myios*)this);
			return (*this);
		}
		_Myt&operator<<(ios_base&(*_Pfn)(ios_base&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\ostream", 183);
			(*_Pfn)(*(ios_base*)this);
			return (*this);
		}
		_Myt&operator<<(_Bool _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(short _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				ios_base::fmtflags _Bfl=ios_base::flags()&ios_base::basefield;
				long _Tmp=(_Bfl==ios_base::oct||_Bfl==ios_base::hex)?(long)(unsigned short)_Val: (long)_Val;
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(unsigned short _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long)_Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(int _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				ios_base::fmtflags _Bfl=ios_base::flags()&ios_base::basefield;
				long _Tmp=(_Bfl==ios_base::oct||_Bfl==ios_base::hex)?(long)(unsigned int)_Val: (long)_Val;
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(unsigned int _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long)_Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(long _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(unsigned long _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long)_Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(__int64 _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(unsigned __int64 _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(float _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (double)_Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(double _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(long double _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(const void*_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(_Mysb*_Strbuf)
		{
			ios_base::iostate _State=ios_base::goodbit;
			bool _Copied=false;
			const sentry _Ok(*this);
			if(_Ok&&_Strbuf!=0)for(int_type _Meta=_Traits::eof();
			;
			_Copied=true)
			{
				try
				{
					_Meta=_Traits::eq_int_type(_Traits::eof(), _Meta)?_Strbuf->sgetc(): _Strbuf->snextc();
				}
				catch(...)
				{
					_Myios::setstate(ios_base::failbit);
					throw;
				}
				if(_Traits::eq_int_type(_Traits::eof(), _Meta))break;
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta))))
					{
						_State|=ios_base::badbit;
						break;
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			ios_base::width(0);
			_Myios::setstate(_Strbuf==0?ios_base::badbit: !_Copied?_State|ios_base::failbit: _State);
			return (*this);
		}
		_Myt&put(_Elem _Ch)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(!_Ok)_State|=ios_base::badbit;
			else
			{
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch)))_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&write(const _Elem*_Str, streamsize _Count)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\ostream", 528);
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(!_Ok)_State|=ios_base::badbit;
			else
			{
				try
				{
					if(_Myios::rdbuf()->sputn(_Str, _Count)!=_Count)_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&flush()
		{
			ios_base::iostate _State=ios_base::goodbit;
			if(!ios_base::fail()&&_Myios::rdbuf()->pubsync()==-1)_State|=ios_base::badbit;
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&seekp(pos_type _Pos)
		{
			if(!ios_base::fail()&&(off_type)_Myios::rdbuf()->pubseekpos(_Pos, ios_base::out)==_BADOFF)_Myios::setstate(ios_base::failbit);
			return (*this);
		}
		_Myt&seekp(off_type _Off, ios_base::seekdir _Way)
		{
			if(!ios_base::fail()&&(off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out)==_BADOFF)_Myios::setstate(ios_base::failbit);
			return (*this);
		}
		pos_type tellp()
		{
			if(!ios_base::fail())return (_Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out));
			else return (pos_type(_BADOFF));
		}
	};
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const char*_Val)
	{
		ios_base::iostate _State=ios_base::goodbit;
		streamsize _Count=(streamsize)::strlen(_Val);
		streamsize _Pad=_Ostr.width()<=0||_Ostr.width()<=_Count?0: _Ostr.width()-_Count;
		const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
		if(!_Ok)_State|=ios_base::badbit;
		else
		{
			try
			{
				const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Ostr.getloc());
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				for(;
				_State==ios_base::goodbit&&0<_Count;
				--_Count, ++_Val)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))_State|=ios_base::badbit;
				if(_State==ios_base::goodbit)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				_Ostr.width(0);
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, char _Ch)
	{
		ios_base::iostate _State=ios_base::goodbit;
		const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
		if(_Ok)
		{
			const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Ostr.getloc());
			streamsize _Pad=_Ostr.width()<=1?0: _Ostr.width()-1;
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
				if(_State==ios_base::goodbit&&_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))_State|=ios_base::badbit;
				for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.width(0);
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, const char*_Val)
	{
		typedef char _Elem;
		typedef basic_ostream<_Elem, _Traits>_Myos;
		ios_base::iostate _State=ios_base::goodbit;
		streamsize _Count=(streamsize)_Traits::length(_Val);
		streamsize _Pad=_Ostr.width()<=0||_Ostr.width()<=_Count?0: _Ostr.width()-_Count;
		const typename _Myos::sentry _Ok(_Ostr);
		if(!_Ok)_State|=ios_base::badbit;
		else
		{
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				if(_State==ios_base::goodbit&&_Ostr.rdbuf()->sputn(_Val, _Count)!=_Count)_State|=ios_base::badbit;
				if(_State==ios_base::goodbit)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				_Ostr.width(0);
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, char _Ch)
	{
		typedef char _Elem;
		typedef basic_ostream<_Elem, _Traits>_Myos;
		ios_base::iostate _State=ios_base::goodbit;
		const typename _Myos::sentry _Ok(_Ostr);
		if(_Ok)
		{
			streamsize _Pad=_Ostr.width()<=1?0: _Ostr.width()-1;
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
				if(_State==ios_base::goodbit&&_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch)))_State|=ios_base::badbit;
				for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.width(0);
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const _Elem*_Val)
	{
		typedef basic_ostream<_Elem, _Traits>_Myos;
		ios_base::iostate _State=ios_base::goodbit;
		streamsize _Count=(streamsize)_Traits::length(_Val);
		streamsize _Pad=_Ostr.width()<=0||_Ostr.width()<=_Count?0: _Ostr.width()-_Count;
		const typename _Myos::sentry _Ok(_Ostr);
		if(!_Ok)_State|=ios_base::badbit;
		else
		{
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				if(_State==ios_base::goodbit&&_Ostr.rdbuf()->sputn(_Val, _Count)!=_Count)_State|=ios_base::badbit;
				if(_State==ios_base::goodbit)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				_Ostr.width(0);
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, _Elem _Ch)
	{
		typedef basic_ostream<_Elem, _Traits>_Myos;
		ios_base::iostate _State=ios_base::goodbit;
		const typename _Myos::sentry _Ok(_Ostr);
		if(_Ok)
		{
			streamsize _Pad=_Ostr.width()<=1?0: _Ostr.width()-1;
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
				if(_State==ios_base::goodbit&&_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch)))_State|=ios_base::badbit;
				for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.width(0);
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, const signed char*_Val)
	{
		return (_Ostr<<(const char*)_Val);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, signed char _Ch)
	{
		return (_Ostr<<(char)_Ch);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, const unsigned char*_Val)
	{
		return (_Ostr<<(const char*)_Val);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, unsigned char _Ch)
	{
		return (_Ostr<<(char)_Ch);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&endl(basic_ostream<_Elem, _Traits>&_Ostr)
	{
		_Ostr.put(_Ostr.widen('\n'));
		_Ostr.flush();
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&ends(basic_ostream<_Elem, _Traits>&_Ostr)
	{
		_Ostr.put(_Elem());
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&flush(basic_ostream<_Elem, _Traits>&_Ostr)
	{
		_Ostr.flush();
		return (_Ostr);
	}
	inline basic_ostream<char, char_traits<char> >&endl(basic_ostream<char, char_traits<char> >&_Ostr)
	{
		_Ostr.put('\n');
		_Ostr.flush();
		return (_Ostr);
	}
	inline basic_ostream<wchar_t, char_traits<wchar_t> >&endl(basic_ostream<wchar_t, char_traits<wchar_t> >&_Ostr)
	{
		_Ostr.put('\n');
		_Ostr.flush();
		return (_Ostr);
	}
	inline basic_ostream<char, char_traits<char> >&ends(basic_ostream<char, char_traits<char> >&_Ostr)
	{
		_Ostr.put('\0');
		return (_Ostr);
	}
	inline basic_ostream<wchar_t, char_traits<wchar_t> >&ends(basic_ostream<wchar_t, char_traits<wchar_t> >&_Ostr)
	{
		_Ostr.put('\0');
		return (_Ostr);
	}
	inline basic_ostream<char, char_traits<char> >&flush(basic_ostream<char, char_traits<char> >&_Ostr)
	{
		_Ostr.flush();
		return (_Ostr);
	}
	inline basic_ostream<wchar_t, char_traits<wchar_t> >&flush(basic_ostream<wchar_t, char_traits<wchar_t> >&_Ostr)
	{
		_Ostr.flush();
		return (_Ostr);
	}
}
namespace std
{
	template<class _Elem, class _Traits>
	class basic_istream: virtual public basic_ios<_Elem, _Traits>
	{
	public:
		typedef basic_istream<_Elem, _Traits>_Myt;
		typedef basic_ios<_Elem, _Traits>_Myios;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef istreambuf_iterator<_Elem, _Traits>_Iter;
		typedef ctype<_Elem>_Ctype;
		typedef num_get<_Elem, _Iter>_Nget;
		explicit basic_istream(_Mysb*_Strbuf, bool _Isstd=false): _Chcount(0)
		{
			_Myios::init(_Strbuf, _Isstd);
		}
		basic_istream(_Uninitialized)
		{
			ios_base::_Addstd(this);
		}
		virtual~basic_istream()
		{
		}
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		class _Sentry_base
		{
		public:
			_Sentry_base(_Myt&_Istr): _Myistr(_Istr)
			{
				if(_Myistr.rdbuf()!=0)_Myistr.rdbuf()->_Lock();
			}
			~_Sentry_base()
			{
				if(_Myistr.rdbuf()!=0)_Myistr.rdbuf()->_Unlock();
			}
			_Myt&_Myistr;
		};
		class sentry: public _Sentry_base
		{
		public:
			explicit sentry(_Myt&_Istr, bool _Noskip=false): _Sentry_base(_Istr)
			{
				_Ok=this->_Myistr._Ipfx(_Noskip);
			}
			operator bool()const
			{
				return (_Ok);
			}
		private:
			sentry(const sentry&);
			sentry&operator=(const sentry&);
			bool _Ok;
		};
		bool _Ipfx(bool _Noskip=false)
		{
			if(ios_base::good())
			{
				if(_Myios::tie()!=0)_Myios::tie()->flush();
				if(!_Noskip&&ios_base::flags()&ios_base::skipws)
				{
					const _Ctype&_Ctype_fac=use_facet<_Ctype>(ios_base::getloc());
					try
					{
						int_type _Meta=_Myios::rdbuf()->sgetc();
						for(;
						;
						_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
						{
							_Myios::setstate(ios_base::eofbit);
							break;
						}
						else if(!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))break;
					}
					catch(...)
					{
						_Myios::setstate(ios_base::badbit, true);
					}
				}
				if(ios_base::good())return (true);
			}
			_Myios::setstate(ios_base::failbit);
			return (false);
		}
		bool ipfx(bool _Noskip=false)
		{
			return _Ipfx(_Noskip);
		}
		void isfx()
		{
		}
		_Myt&operator>>(_Myt&(*_Pfn)(_Myt&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 157);
			return ((*_Pfn)(*this));
		}
		_Myt&operator>>(_Myios&(*_Pfn)(_Myios&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 163);
			(*_Pfn)(*(_Myios*)this);
			return (*this);
		}
		_Myt&operator>>(ios_base&(*_Pfn)(ios_base&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 170);
			(*_Pfn)(*(ios_base*)this);
			return (*this);
		}
		_Myt&operator>>(_Bool&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(short&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				long _Tmp=0;
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Tmp);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
				if(_State&ios_base::failbit||_Tmp<(-32768)||32767<_Tmp)_State|=ios_base::failbit;
				else _Val=(short)_Tmp;
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(unsigned short&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(int&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				long _Tmp=0;
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Tmp);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
				if(_State&ios_base::failbit||_Tmp<(-2147483647-1)||2147483647<_Tmp)_State|=ios_base::failbit;
				else _Val=_Tmp;
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(unsigned int&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(long&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(unsigned long&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, (unsigned long)_Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(__int64&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(unsigned __int64&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(float&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(double&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(long double&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(void*&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(_Mysb*_Strbuf)
		{
			ios_base::iostate _State=ios_base::goodbit;
			bool _Copied=false;
			const sentry _Ok(*this);
			if(_Ok&&_Strbuf!=0)
			{
				try
				{
					int_type _Meta=_Myios::rdbuf()->sgetc();
					for(;
					;
					_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else
					{
						try
						{
							if(_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta))))break;
						}
						catch(...)
						{
							break;
						}
						_Copied=true;
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(!_Copied?_State|ios_base::failbit: _State);
			return (*this);
		}
		int_type get()
		{
			int_type _Meta=0;
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(!_Ok)_Meta=_Traits::eof();
			else
			{
				try
				{
					_Meta=_Myios::rdbuf()->sbumpc();
					if(_Traits::eq_int_type(_Traits::eof(), _Meta))_State|=ios_base::eofbit|ios_base::failbit;
					else++_Chcount;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (_Meta);
		}
		_Myt&get(_Elem*_Str, streamsize _Count)
		{
			return (get(_Str, _Count, _Myios::widen('\n')));
		}
		_Myt&get(_Elem*_Str, streamsize _Count, _Elem _Delim)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 509);
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok&&0<_Count)
			{
				try
				{
					int_type _Meta=_Myios::rdbuf()->sgetc();
					for(;
					0<--_Count;
					_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(_Traits::to_char_type(_Meta)==_Delim)break;
					else
					{
						*_Str++=_Traits::to_char_type(_Meta);
						++_Chcount;
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_Chcount==0?_State|ios_base::failbit: _State);
			*_Str=_Elem();
			return (*this);
		}
		_Myt&get(_Elem&_Ch)
		{
			int_type _Meta=get();
			if(!_Traits::eq_int_type(_Traits::eof(), _Meta))_Ch=_Traits::to_char_type(_Meta);
			return (*this);
		}
		_Myt&get(_Mysb&_Strbuf)
		{
			return (get(_Strbuf, _Myios::widen('\n')));
		}
		_Myt&get(_Mysb&_Strbuf, _Elem _Delim)
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok)
			{
				try
				{
					int_type _Meta=_Myios::rdbuf()->sgetc();
					for(;
					;
					_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else
					{
						try
						{
							_Elem _Ch=_Traits::to_char_type(_Meta);
							if(_Ch==_Delim||_Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch)))break;
						}
						catch(...)
						{
							break;
						}
						++_Chcount;
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			if(_Chcount==0)_State|=ios_base::failbit;
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&getline(_Elem*_Str, streamsize _Count)
		{
			return (getline(_Str, _Count, _Myios::widen('\n')));
		}
		_Myt&getline(_Elem*_Str, streamsize _Count, _Elem _Delim)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 601);
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok&&0<_Count)
			{
				int_type _Metadelim=_Traits::to_int_type(_Delim);
				try
				{
					int_type _Meta=_Myios::rdbuf()->sgetc();
					for(;
					;
					_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(_Meta==_Metadelim)
					{
						++_Chcount;
						_Myios::rdbuf()->sbumpc();
						break;
					}
					else if(--_Count<=0)
					{
						_State|=ios_base::failbit;
						break;
					}
					else
					{
						++_Chcount;
						*_Str++=_Traits::to_char_type(_Meta);
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			*_Str=_Elem();
			_Myios::setstate(_Chcount==0?_State|ios_base::failbit: _State);
			return (*this);
		}
		_Myt&ignore(streamsize _Count=1, int_type _Metadelim=_Traits::eof())
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok&&0<_Count)
			{
				try
				{
					for(;
					;
					)
					{
						int_type _Meta;
						if(_Count!=2147483647&&--_Count<0)break;
						else if(_Traits::eq_int_type(_Traits::eof(), _Meta=_Myios::rdbuf()->sbumpc()))
						{
							_State|=ios_base::eofbit;
							break;
						}
						else
						{
							++_Chcount;
							if(_Meta==_Metadelim)break;
						}
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&_Read_s(_Elem*_Str, size_t _Str_size, streamsize _Count)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 680);
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok)
			{
				try
				{
					const streamsize _Num=_Myios::rdbuf()->_Sgetn_s(_Str, _Str_size, _Count);
					_Chcount+=_Num;
					if(_Num!=_Count)_State|=ios_base::eofbit|ios_base::failbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&read(_Elem*_Str, streamsize _Count)
		{
			return _Read_s(_Str, (size_t)-1, _Count);
		}
		streamsize _Readsome_s(_Elem*_Str, size_t _Str_size, streamsize _Count)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 706);
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			streamsize _Num;
			if(!_Ok)_State|=ios_base::failbit;
			else if((_Num=_Myios::rdbuf()->in_avail())<0)_State|=ios_base::eofbit;
			else if(0<_Num)_Read_s(_Str, _Str_size, _Num<_Count?_Num: _Count);
			_Myios::setstate(_State);
			return (gcount());
		}
		streamsize readsome(_Elem*_Str, streamsize _Count)
		{
			return _Readsome_s(_Str, (size_t)-1, _Count);
		}
		int_type peek()
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			int_type _Meta=0;
			const sentry _Ok(*this, true);
			if(!_Ok)_Meta=_Traits::eof();
			else
			{
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Meta=_Myios::rdbuf()->sgetc()))_State|=ios_base::eofbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (_Meta);
		}
		_Myt&putback(_Elem _Ch)
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok)
			{
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch)))_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&unget()
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok)
			{
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc()))_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		streamsize gcount()const
		{
			return (_Chcount);
		}
		int sync()
		{
			ios_base::iostate _State=ios_base::goodbit;
			int _Ans;
			if(_Myios::rdbuf()==0)_Ans=-1;
			else if(_Myios::rdbuf()->pubsync()==-1)
			{
				_State|=ios_base::badbit;
				_Ans=-1;
			}
			else _Ans=0;
			_Myios::setstate(_State);
			return (_Ans);
		}
		_Myt&seekg(pos_type _Pos)
		{
			if(!ios_base::fail()&&(off_type)_Myios::rdbuf()->pubseekpos(_Pos, ios_base::in)==_BADOFF)_Myios::setstate(ios_base::failbit);
			return (*this);
		}
		_Myt&seekg(off_type _Off, ios_base::seekdir _Way)
		{
			if(!ios_base::fail()&&(off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)==_BADOFF)_Myios::setstate(ios_base::failbit);
			return (*this);
		}
		pos_type tellg()
		{
			if(!ios_base::fail())return (_Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in));
			else return (pos_type(_BADOFF));
		}
	private:
		streamsize _Chcount;
	};
	template<class _Elem, class _Traits>
	class basic_iostream: public basic_istream<_Elem, _Traits>, public basic_ostream<_Elem, _Traits>
	{
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		explicit basic_iostream(basic_streambuf<_Elem, _Traits>*_Strbuf): basic_istream<_Elem, _Traits>(_Strbuf, false), basic_ostream<_Elem, _Traits>(_Strbuf)
		{
		}
		virtual~basic_iostream()
		{
		}
	};
	template<class _Elem, class _Traits>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, _Elem*_Str)
	{
		_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 933);
		typedef basic_istream<_Elem, _Traits>_Myis;
		typedef ctype<_Elem>_Ctype;
		ios_base::iostate _State=ios_base::goodbit;
		_Elem*_Str0=_Str;
		const typename _Myis::sentry _Ok(_Istr);
		if(_Ok)
		{
			const _Ctype&_Ctype_fac=use_facet<_Ctype>(_Istr.getloc());
			try
			{
				streamsize _Count=0<_Istr.width()?_Istr.width(): 2147483647;
				typename _Myis::int_type _Meta=_Istr.rdbuf()->sgetc();
				_Elem _Ch;
				for(;
				0<--_Count;
				_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
					_State|=ios_base::eofbit;
					break;
				}
				else if(_Ctype_fac.is(_Ctype::space, _Ch=_Traits::to_char_type(_Meta))||_Ch==_Elem())break;
				else*_Str++=_Traits::to_char_type(_Meta);
			}
			catch(...)
			{
				(_Istr).setstate(ios_base::badbit, true);
			}
		}
		*_Str=_Elem();
		_Istr.width(0);
		_Istr.setstate(_Str==_Str0?_State|ios_base::failbit: _State);
		return (_Istr);
	}
	template<class _Elem, class _Traits>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, _Elem&_Ch)
	{
		typedef basic_istream<_Elem, _Traits>_Myis;
		typename _Myis::int_type _Meta;
		ios_base::iostate _State=ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr);
		if(_Ok)
		{
			try
			{
				_Meta=_Istr.rdbuf()->sbumpc();
				if(_Traits::eq_int_type(_Traits::eof(), _Meta))_State|=ios_base::eofbit|ios_base::failbit;
				else _Ch=_Traits::to_char_type(_Meta);
			}
			catch(...)
			{
				(_Istr).setstate(ios_base::badbit, true);
			}
		}
		_Istr.setstate(_State);
		return (_Istr);
	}
	template<class _Traits>
	inline basic_istream<char, _Traits>&operator>>(basic_istream<char, _Traits>&_Istr, signed char*_Str)
	{
		return (_Istr>>(char*)_Str);
	}
	template<class _Traits>
	inline basic_istream<char, _Traits>&operator>>(basic_istream<char, _Traits>&_Istr, signed char&_Ch)
	{
		return (_Istr>>(char&)_Ch);
	}
	template<class _Traits>
	inline basic_istream<char, _Traits>&operator>>(basic_istream<char, _Traits>&_Istr, unsigned char*_Str)
	{
		return (_Istr>>(char*)_Str);
	}
	template<class _Traits>
	inline basic_istream<char, _Traits>&operator>>(basic_istream<char, _Traits>&_Istr, unsigned char&_Ch)
	{
		return (_Istr>>(char&)_Ch);
	}
	template<class _Elem, class _Traits>
	inline basic_istream<_Elem, _Traits>&ws(basic_istream<_Elem, _Traits>&_Istr)
	{
		typedef basic_istream<_Elem, _Traits>_Myis;
		typedef ctype<_Elem>_Ctype;
		if(!_Istr.eof())
		{
			ios_base::iostate _State=ios_base::goodbit;
			const typename _Myis::sentry _Ok(_Istr, true);
			if(_Ok)
			{
				const _Ctype&_Ctype_fac=use_facet<_Ctype>(_Istr.getloc());
				try
				{
					for(typename _Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
					;
					_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))break;
				}
				catch(...)
				{
					(_Istr).setstate(ios_base::badbit, true);
				}
			}
			_Istr.setstate(_State);
		}
		return (_Istr);
	}
	inline basic_istream<char, char_traits<char> >&ws(basic_istream<char, char_traits<char> >&_Istr)
	{
		typedef char _Elem;
		typedef char_traits<_Elem>_Traits;
		if(!_Istr.eof())
		{
			ios_base::iostate _State=ios_base::goodbit;
			const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);
			if(_Ok)
			{
				const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Istr.getloc());
				try
				{
					for(_Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
					;
					_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta)))break;
				}
				catch(...)
				{
					(_Istr).setstate(ios_base::badbit, true);
				}
			}
			_Istr.setstate(_State);
		}
		return (_Istr);
	}
	inline basic_istream<wchar_t, char_traits<wchar_t> >&ws(basic_istream<wchar_t, char_traits<wchar_t> >&_Istr)
	{
		typedef wchar_t _Elem;
		typedef char_traits<_Elem>_Traits;
		if(!_Istr.eof())
		{
			ios_base::iostate _State=ios_base::goodbit;
			const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);
			if(_Ok)
			{
				const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Istr.getloc());
				try
				{
					for(_Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
					;
					_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta)))break;
				}
				catch(...)
				{
					(_Istr).setstate(ios_base::badbit, true);
				}
			}
			_Istr.setstate(_State);
		}
		return (_Istr);
	}
}
namespace std
{
	extern istream*_Ptr_cin;
	extern ostream*_Ptr_cout;
	extern ostream*_Ptr_cerr;
	extern ostream*_Ptr_clog;
	class _Winit
	{
	public:
		_Winit();
		~_Winit();
	private:
		static int _Init_cnt;
	};
	extern wistream*_Ptr_wcin;
	extern wostream*_Ptr_wcout;
	extern wostream*_Ptr_wcerr;
	extern wostream*_Ptr_wclog;
	extern istream cin;
	extern ostream cout;
	extern ostream cerr;
	extern ostream clog;
	extern wistream wcin;
	extern wostream wcout;
	extern wostream wcerr;
	extern wostream wclog;
}
namespace std
{
	template<class _Elem>
	struct _Fillobj
	{
		_Fillobj(_Elem _Ch): _Fill(_Ch)
		{
		}
		_Elem _Fill;
	};
	template<class _Elem>
	inline _Fillobj<_Elem>setfill(_Elem _Ch)
	{
		return (_Fillobj<_Elem>(_Ch));
	}
	template<class _Elem, class _Traits>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, const _Fillobj<_Elem>&_Manip)
	{
		_Istr.fill(_Manip._Fill);
		return (_Istr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const _Fillobj<_Elem>&_Manip)
	{
		_Ostr.fill(_Manip._Fill);
		return (_Ostr);
	}
	template<class _Arg>
	struct _Smanip
	{
		_Smanip(void(*_Left)(ios_base&, _Arg), _Arg _Val): _Pfun(_Left), _Manarg(_Val)
		{
		}
		void(*_Pfun)(ios_base&, _Arg);
		_Arg _Manarg;
	};
	template<class _Elem, class _Traits, class _Arg>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, const _Smanip<_Arg>&_Manip)
	{
		(*_Manip._Pfun)(_Istr, _Manip._Manarg);
		return (_Istr);
	}
	template<class _Elem, class _Traits, class _Arg>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const _Smanip<_Arg>&_Manip)
	{
		(*_Manip._Pfun)(_Ostr, _Manip._Manarg);
		return (_Ostr);
	}
	_Smanip<ios_base::fmtflags>resetiosflags(ios_base::fmtflags);
	_Smanip<ios_base::fmtflags>setiosflags(ios_base::fmtflags);
	_Smanip<int>setbase(int);
	_Smanip<streamsize>setprecision(streamsize);
	_Smanip<streamsize>setw(streamsize);
}
typedef __int64 CPUTime;
CPUTime getCPUTimeElapsed();
struct ProfileEntry
{
	const char*name;
	CPUTime elapsed;
	CPUTime elapsedChild;
	ProfileEntry(const char*name): name(name), elapsed(0), elapsedChild(0)
	{
	}
};
struct Timer
{
	CPUTime time;
	void start()
	{
		time=getCPUTimeElapsed();
	}
	CPUTime elapsed()const
	{
		return getCPUTimeElapsed()-time;
	}
};
struct Profiler
{
	static struct ProfileScope*scope;
};
struct ProfileScope
{
	ProfileScope(ProfileEntry&entry)
	{
	}
};
inline void dumpProfile(ProfileEntry&entry)
{
	std::cout<<std::setw(12)<<std::left<<entry.name<<std::setw(0)<<" "<<std::right<<std::setw(20)<<(entry.elapsed-entry.elapsedChild)<<std::setw(0)<<"\n";
}
extern ProfileEntry gProfileIo;
extern ProfileEntry gProfileWave;
extern ProfileEntry gProfileLexer;
extern ProfileEntry gProfileParser;
extern ProfileEntry gProfileLookup;
extern ProfileEntry gProfileDiagnose;
extern ProfileEntry gProfileAllocator;
extern ProfileEntry gProfileIdentifier;
extern ProfileEntry gProfileTemplateId;
template<typename T>
struct ArrayRange
{
	const T*first;
	const T*last;
	ArrayRange(const T*first, const T*last): first(first), last(last)
	{
	}
};
template<typename T>
ArrayRange<T>makeRange(const T*first, const T*last)
{
	return ArrayRange<T>(first, last);
}
struct TypeListEnd
{
};
template<typename ItemType, typename NextType>
struct TypeList
{
	typedef ItemType Item;
	typedef NextType Next;
};
template<typename Types, size_t N>
struct TypeListNth
{
	typedef typename TypeListNth<typename Types::Next, N-1>::Result Result;
};
template<typename Types>
struct TypeListNth<Types, 0>
{
	typedef typename Types::Item Result;
};
template<typename Types>
struct TypeListCount
{
	enum
	{
		RESULT=TypeListCount<typename Types::Next>::RESULT+1
	};
};
template<>
struct TypeListCount<TypeListEnd>
{
	enum
	{
		RESULT=0
	};
};
struct Callback0
{
	typedef void(*Function)(void*data);
	Function function;
	void*data;
	Callback0(): function(defaultThunk)
	{
	}
	Callback0(Function function, void*data): function(function), data(data)
	{
	}
	void operator()()const
	{
		function(data);
	}
	static void defaultThunk(void*)
	{
	}
};
template<typename A>
struct Callback1
{
	typedef void(*Function)(void*data, A);
	Function function;
	void*data;
	Callback1(): function(defaultThunk)
	{
	}
	Callback1(Function function, void*data): function(function), data(data)
	{
	}
	void operator()(A a)const
	{
		function(data, a);
	}
	static void defaultThunk(void*, A)
	{
	}
};
template<typename Object, void(Object::*member)()>
struct Member0
{
	void*object;
	Member0(Object&object): object(&object)
	{
	}
	typedef Callback0 Result;
	static void thunk(void*object)
	{
		((*static_cast<Object*>(object)).*member)();
	}
};
template<typename Object, typename A, void(Object::*member)(A)>
struct Member1
{
	void*object;
	Member1(Object&object): object(&object)
	{
	}
	typedef Callback1<A>Result;
	static void thunk(void*object, A a)
	{
		((*static_cast<Object*>(object)).*member)(a);
	}
};
template<typename Caller>
typename Caller::Result makeCallback(Caller caller)
{
	return typename Caller::Result(Caller::thunk, caller.object);
}
template<typename VisitorType, typename T>
struct VisitorThunk
{
	static void visit(void*context, T p)
	{
		static_cast<VisitorType*>(context)->visit(p);
	}
};
template<typename T>
struct VisitorFunc
{
	typedef T Type;
	typedef void(*Thunk)(void*context, T p);
	Thunk thunk;
	explicit VisitorFunc(Thunk thunk): thunk(thunk)
	{
	}
};
template<typename VisitorFuncTableType>
struct VisitorCallback
{
	void*context;
	VisitorFuncTableType*table;
	template<typename T>
	void visit(T p)const
	{
		static_cast<const VisitorFunc<T>*>(table)->thunk(context, p);
	}
};
template<typename T>
struct VisitorTypeId
{
	typedef T Type;
};
template<typename Types>
struct VisitorFuncGeneric: public VisitorFunc<typename Types::Item*>, public VisitorFuncGeneric<typename Types::Next>
{
	typedef VisitorFunc<typename Types::Item*>FuncType;
	typedef VisitorFuncGeneric<typename Types::Next>NextType;
	template<typename VisitorType>
	explicit VisitorFuncGeneric(const VisitorTypeId<VisitorType>&visitorType): FuncType(VisitorThunk<VisitorType, typename FuncType::Type>::visit), NextType(visitorType)
	{
	}
};
template<>
struct VisitorFuncGeneric<TypeListEnd>
{
	template<typename VisitorType>
	explicit VisitorFuncGeneric(const VisitorTypeId<VisitorType>&)
	{
	}
};
namespace stdext
{
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt unchecked_remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val);
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt checked_remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val);
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unchecked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred);
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt checked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred);
	template<class _InIt, class _OutIt>
	inline _OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest);
	template<class _InIt, class _OutIt>
	inline _OutIt checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest);
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred);
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred);
	template<class _BidIt, class _OutIt>
	inline _OutIt unchecked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest);
	template<class _BidIt, class _OutIt>
	inline _OutIt checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest);
	template<class _FwdIt, class _OutIt>
	inline _OutIt unchecked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest);
	template<class _FwdIt, class _OutIt>
	inline _OutIt checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest);
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest);
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred);
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred);
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count);
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count);
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred);
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
}
namespace std
{
	const int _ISORT_MAX=32;
	template<class _InIt, class _Fn1>
	inline _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 254);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 255);
		typename::std::_Checked_iterator_base_helper<_InIt>::_Checked_iterator_base_type _ChkFirst(::std::_Checked_base(_First));
		typename::std::_Checked_iterator_base_helper<_InIt>::_Checked_iterator_base_type _ChkLast(::std::_Checked_base(_Last));
		for(;
		_ChkFirst!=_ChkLast;
		++_ChkFirst)_Func(*_ChkFirst);
		return (_Func);
	}
	template<class _InIt, class _Ty>
	inline _InIt _Find(_InIt _First, _InIt _Last, const _Ty&_Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 268);
		for(;
		_First!=_Last;
		++_First)if(*_First==_Val)break;
		return (_First);
	}
	inline const char*_Find(const char*_First, const char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 277);
		_First=(const char*)::memchr(_First, _Val, _Last-_First);
		return (_First==0?_Last: _First);
	}
	inline const signed char*_Find(const signed char*_First, const signed char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 285);
		_First=(const signed char*)::memchr(_First, _Val, _Last-_First);
		return (_First==0?_Last: _First);
	}
	inline const unsigned char*_Find(const unsigned char*_First, const unsigned char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 294);
		_First=(const unsigned char*)::memchr(_First, _Val, _Last-_First);
		return (_First==0?_Last: _First);
	}
	template<class _InIt, class _Ty>
	inline _InIt find(_InIt _First, _InIt _Last, const _Ty&_Val)
	{
		::std::_Checked_assign_from_base(_First, _Find(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val));
		return (_First);
	}
	template<class _InIt, class _Pr>
	inline _InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 314);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 315);
		for(;
		_First!=_Last;
		++_First)if(_Pred(*_First))break;
		return (_First);
	}
	template<class _InIt, class _Pr>
	inline _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Find_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _FwdIt>
	inline _FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 335);
		for(_FwdIt _Firstb;
		(_Firstb=_First)!=_Last&&++_First!=_Last;
		)if(*_Firstb==*_First)return (_Firstb);
		return (_Last);
	}
	template<class _FwdIt>
	inline _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
	{
		::std::_Checked_assign_from_base(_First, _Adjacent_find(::std::_Checked_base(_First), ::std::_Checked_base(_Last)));
		return (_First);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 355);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 356);
		for(_FwdIt _Firstb;
		(_Firstb=_First)!=_Last&&++_First!=_Last;
		)if(_Pred(*_Firstb, *_First))return (_Firstb);
		return (_Last);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Adjacent_find(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _InIt, class _Ty>
	inline typename iterator_traits<_InIt>::difference_type _Count(_InIt _First, _InIt _Last, const _Ty&_Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 378);
		typename iterator_traits<_InIt>::difference_type _Cnt=0;
		for(;
		_First!=_Last;
		++_First)if(*_First==_Val)++_Cnt;
		return (_Cnt);
	}
	template<class _InIt, class _Ty>
	inline typename iterator_traits<_InIt>::difference_type count(_InIt _First, _InIt _Last, const _Ty&_Val)
	{
		return _Count(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val);
	}
	template<class _InIt, class _Pr>
	inline typename iterator_traits<_InIt>::difference_type _Count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 401);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 402);
		typename iterator_traits<_InIt>::difference_type _Count=0;
		for(;
		_First!=_Last;
		++_First)if(_Pred(*_First))++_Count;
		return (_Count);
	}
	template<class _InIt, class _Pr>
	inline typename iterator_traits<_InIt>::difference_type count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{
		return _Count_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred);
	}
	template<class _FwdIt1, class _FwdIt2, class _Diff1, class _Diff2>
	inline _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1*, _Diff2*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 427);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 428);
		_Diff1 _Count1=0;
		_Distance(_First1, _Last1, _Count1);
		_Diff2 _Count2=0;
		_Distance(_First2, _Last2, _Count2);
		for(;
		_Count2<=_Count1;
		++_First1, --_Count1)
		{
			_FwdIt1 _Mid1=_First1;
			for(_FwdIt2 _Mid2=_First2;
			;
			++_Mid1, ++_Mid2)if(_Mid2==_Last2)return (_First1);
			else if(!(*_Mid1==*_Mid2))break;
		}
		return (_Last1);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
	{
		::std::_Checked_assign_from_base(_First1, _Search(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dist_type(_First1), _Dist_type(_First2)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2, class _Diff1, class _Diff2, class _Pr>
	inline _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1*, _Diff2*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 467);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 468);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 469);
		_Diff1 _Count1=0;
		_Distance(_First1, _Last1, _Count1);
		_Diff2 _Count2=0;
		_Distance(_First2, _Last2, _Count2);
		for(;
		_Count2<=_Count1;
		++_First1, --_Count1)
		{
			_FwdIt1 _Mid1=_First1;
			for(_FwdIt2 _Mid2=_First2;
			;
			++_Mid1, ++_Mid2)if(_Mid2==_Last2)return (_First1);
			else if(!_Pred(*_Mid1, *_Mid2))break;
		}
		return (_Last1);
	}
	template<class _FwdIt1, class _FwdIt2, class _Pr>
	inline _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First1, _Search(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred, _Dist_type(_First1), _Dist_type(_First2)));
		return _First1;
	}
	template<class _FwdIt1, class _Diff2, class _Ty>
	inline _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, forward_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 507);
		_FwdIt1 _Mid1;
		if(_Count==0)return (_First1);
		for(;
		;
		_First1=++_Mid1)
		{
			_Diff2 _Count1=_Count;
			for(;
			_First1!=_Last1;
			++_First1)if(*_First1==_Val)break;
			for(_Mid1=_First1;
			;
			)if(--_Count1==0)return (_First1);
			else if(_Mid1==_Last1||!(*++_Mid1==_Val))break;
			if(_Mid1==_Last1)return (_Last1);
		}
	}
	template<class _FwdIt1, class _Diff2, class _Ty>
	inline _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, random_access_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 537);
		_FwdIt1 _Mid1;
		if(_Count==0)return (_First1);
		for(;
		;
		_First1=++_Mid1)
		{
			_FwdIt1 _Oldfirst1=_First1;
			_Diff2 _Count1=_Count;
			for(;
			;
			_First1+=_Count)if(_First1==_Last1)return (_Last1);
			else if(*_First1==_Val)break;
			else if(_Last1-_First1<_Count)return (_Last1);
			if(_Oldfirst1!=_First1)for(++_Oldfirst1;
			_Oldfirst1!=_First1;
			--_First1, --_Count1)if(!(_First1[-1]==_Val))break;
			for(_Mid1=_First1;
			;
			)if(--_Count1==0)return (_First1);
			else if(_Mid1==_Last1||!(*++_Mid1==_Val))break;
			if(_Mid1==_Last1)return (_Last1);
		}
	}
	template<class _FwdIt1, class _Diff2, class _Ty>
	inline _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val)
	{
		::std::_Checked_assign_from_base(_First1, _Search_n(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _Count, _Val, _Iter_cat(_First1)));
		return _First1;
	}
	template<class _FwdIt1, class _Diff2, class _Ty, class _Pr>
	inline _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, _Pr _Pred, forward_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 591);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 592);
		_FwdIt1 _Mid1;
		if(_Count==0)return (_First1);
		for(;
		;
		_First1=++_Mid1)
		{
			_Diff2 _Count1=_Count;
			for(;
			_First1!=_Last1;
			++_First1)if(_Pred(*_First1, _Val))break;
			for(_Mid1=_First1;
			;
			)if(--_Count1==0)return (_First1);
			else if(_Mid1==_Last1||!_Pred(*++_Mid1, _Val))break;
			if(_Mid1==_Last1)return (_Last1);
		}
	}
	template<class _FwdIt1, class _Diff2, class _Ty, class _Pr>
	inline _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, _Pr _Pred, random_access_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 623);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 624);
		_FwdIt1 _Mid1;
		if(_Count==0)return (_First1);
		for(;
		;
		_First1=++_Mid1)
		{
			_FwdIt1 _Oldfirst1=_First1;
			_Diff2 _Count1=_Count;
			for(;
			;
			_First1+=_Count)if(_First1==_Last1)return (_Last1);
			else if(_Pred(*_First1, _Val))break;
			else if(_Last1-_First1<_Count)return (_Last1);
			if(_Oldfirst1!=_First1)for(++_Oldfirst1;
			_Oldfirst1!=_First1;
			--_First1, --_Count1)if(!_Pred(_First1[-1], _Val))break;
			for(_Mid1=_First1;
			;
			)if(--_Count1==0)return (_First1);
			else if(_Mid1==_Last1||!_Pred(*++_Mid1, _Val))break;
			if(_Mid1==_Last1)return (_Last1);
		}
	}
	template<class _FwdIt1, class _Diff2, class _Ty, class _Pr>
	inline _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First1, _Search_n(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _Count, _Val, _Pred, _Iter_cat(_First1)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2, class _Diff1, class _Diff2>
	inline _FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1*, _Diff2*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 679);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 680);
		_Diff1 _Count1=0;
		_Distance(_First1, _Last1, _Count1);
		_Diff2 _Count2=0;
		_Distance(_First2, _Last2, _Count2);
		_FwdIt1 _Ans=_Last1;
		if(0<_Count2)for(;
		_Count2<=_Count1;
		++_First1, --_Count1)
		{
			_FwdIt1 _Mid1=_First1;
			for(_FwdIt2 _Mid2=_First2;
			;
			++_Mid1)if(!(*_Mid1==*_Mid2))break;
			else if(++_Mid2==_Last2)
			{
				_Ans=_First1;
				break;
			}
		}
		return (_Ans);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
	{
		::std::_Checked_assign_from_base(_First1, _Find_end(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dist_type(_First1), _Dist_type(_First2)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2, class _Diff1, class _Diff2, class _Pr>
	inline _FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1*, _Diff2*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 724);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 725);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 726);
		_Diff1 _Count1=0;
		_Distance(_First1, _Last1, _Count1);
		_Diff2 _Count2=0;
		_Distance(_First2, _Last2, _Count2);
		_FwdIt1 _Ans=_Last1;
		if(0<_Count2)for(;
		_Count2<=_Count1;
		++_First1, --_Count1)
		{
			_FwdIt1 _Mid1=_First1;
			for(_FwdIt2 _Mid2=_First2;
			;
			++_Mid1)if(!_Pred(*_Mid1, *_Mid2))break;
			else if(++_Mid2==_Last2)
			{
				_Ans=_First1;
				break;
			}
		}
		return (_Ans);
	}
	template<class _FwdIt1, class _FwdIt2, class _Pr>
	inline _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First1, _Find_end(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred, _Dist_type(_First1), _Dist_type(_First2)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 768);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 769);
		for(;
		_First1!=_Last1;
		++_First1)for(_FwdIt2 _Mid2=_First2;
		_Mid2!=_Last2;
		++_Mid2)if(*_First1==*_Mid2)return (_First1);
		return (_First1);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 782);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 783);
		::std::_Checked_assign_from_base(_First1, _Find_first_of(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2, class _Pr>
	inline _FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 797);
		for(;
		_First1!=_Last1;
		++_First1)for(_FwdIt2 _Mid2=_First2;
		_Mid2!=_Last2;
		++_Mid2)if(_Pred(*_First1, *_Mid2))return (_First1);
		return (_First1);
	}
	template<class _FwdIt1, class _FwdIt2, class _Pr>
	inline _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First1, _Find_first_of(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred));
		return (_First1);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{
		std::swap(*_Left, *_Right);
	}
	template<class _FwdIt1, class _FwdIt2, class _FwdItCats>
	inline _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdItCats, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 831);
		for(;
		_First1!=_Last1;
		++_First1, ++_First2)std::iter_swap(_First1, _First2);
		return (_First2);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_FwdIt2 _Result=_First2+(_Last1-_First1);
		_Swap_ranges(_First1, _Last1, ::std::_Checked_base(_First2), forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _FwdIt1, class _FwdIt2, class _FwdItCats>
	inline _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdItCats _Iter_cats, _Unchecked_iterator_tag)
	{
		return _Swap_ranges(_First1, _Last1, _First2, _Iter_cats, _Range_checked_iterator_tag());
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return _Swap_ranges(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
	template<class _InIt, class _OutIt, class _Fn1, class _InOutItCat>
	inline _OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 876);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 877);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 878);
		for(;
		_First!=_Last;
		++_First, ++_Dest)*_Dest=_Func(*_First);
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Fn1>
	inline _OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Transform(_First, _Last, ::std::_Checked_base(_Dest), _Func, forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _InIt, class _OutIt, class _Fn1, class _InOutItCat>
	inline _OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Transform(_First, _Last, _Dest, _Func, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Fn1>
	inline _OutIt transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
		return _Transform(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Func, _Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats, _InOutItCat, _Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 926);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 927);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 928);
		for(;
		_First1!=_Last1;
		++_First1, ++_First2, ++_Dest)*_Dest=_Func(*_First1, *_First2);
		return (_Dest);
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, random_access_iterator_tag, random_access_iterator_tag, _Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		_OutIt _Result=_Dest+(_Last1-_First1);
		_Transform(_First1, _Last1, ::std::_Checked_base(_First2), ::std::_Checked_base(_Dest), _Func, forward_iterator_tag(), forward_iterator_tag(), _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, random_access_iterator_tag, _InOutItCat, _Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		return _Transform(_First1, _Last1, ::std::_Checked_base(_First2), _Dest, _Func, forward_iterator_tag(), forward_iterator_tag(), _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats, random_access_iterator_tag, _Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last1-_First1);
		_Transform(_First1, _Last1, _First2, ::std::_Checked_base(_Dest), _Func, forward_iterator_tag(), forward_iterator_tag(), _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats _InIt_cats, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag, _Unchecked_iterator_tag)
	{
		return _Transform(_First1, _Last1, _First2, _Dest, _Func, _InIt_cats, _First_dest_cat, _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats _InIt_cats, _InOutItCat _First_dest_cat, _Range_checked_iterator_tag, _Unchecked_iterator_tag)
	{
		return _Transform(_First1, _Last1, _First2, _Dest, _Func, _InIt_cats, _First_dest_cat, _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats _InIt_cats, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag, _Range_checked_iterator_tag)
	{
		return _Transform(_First1, _Last1, _First2, _Dest, _Func, _InIt_cats, _First_dest_cat, _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
	inline _OutIt transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{
		return _Transform(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Dest, _Func, _Iter_random(_First1, _First2), _Iter_random(_First1, _Dest), ::std::_Checked_cat(_First2), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt, class _Ty>
	inline void _Replace(_FwdIt _First, _FwdIt _Last, const _Ty&_Oldval, const _Ty&_Newval)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1041);
		for(;
		_First!=_Last;
		++_First)if(*_First==_Oldval)*_First=_Newval;
	}
	template<class _FwdIt, class _Ty>
	inline void replace(_FwdIt _First, _FwdIt _Last, const _Ty&_Oldval, const _Ty&_Newval)
	{
		_Replace(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Oldval, _Newval);
	}
	template<class _FwdIt, class _Pr, class _Ty>
	inline void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty&_Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1061);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1062);
		for(;
		_First!=_Last;
		++_First)if(_Pred(*_First))*_First=_Val;
	}
	template<class _FwdIt, class _Pr, class _Ty>
	inline void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty&_Val)
	{
		_Replace_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred, _Val);
	}
	template<class _InIt, class _OutIt, class _Ty, class _InOutItCat>
	inline _OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1083);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1084);
		for(;
		_First!=_Last;
		++_First, ++_Dest)*_Dest=*_First==_Oldval?_Newval: *_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Replace_copy(_First, _Last, ::std::_Checked_base(_Dest), _Oldval, _Newval, forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _InIt, class _OutIt, class _Ty, class _InOutItCat>
	inline _OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Replace_copy(_First, _Last, _Dest, _Oldval, _Newval, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval)
	{
		return _Replace_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Oldval, _Newval, _Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty, class _InOutItCat>
	inline _OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1135);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1136);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1137);
		for(;
		_First!=_Last;
		++_First, ++_Dest)*_Dest=_Pred(*_First)?_Val: *_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty>
	inline _OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Replace_copy_if(_First, _Last, ::std::_Checked_base(_Dest), _Pred, _Val, forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty, class _InOutItCat>
	inline _OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Replace_copy_if(_First, _Last, _Dest, _Pred, _Val, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty>
	inline _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val)
	{
		return _Replace_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Val, _Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt, class _Fn0>
	inline void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1188);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1189);
		for(;
		_First!=_Last;
		++_First)*_First=_Func();
	}
	template<class _FwdIt, class _Fn0>
	inline void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{
		_Generate(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Func);
	}
	template<class _OutIt, class _Diff, class _Fn0, class _OutItCat>
	inline void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, _OutItCat, _Range_checked_iterator_tag)
	{
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1207);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1208);
		for(;
		0<_Count;
		--_Count, ++_Dest)*_Dest=_Func();
	}
	template<class _OutIt, class _Diff, class _Fn0>
	inline void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+_Count;
		_Generate_n(::std::_Checked_base(_Dest), _Count, _Func, forward_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Fn0, class _OutItCat>
	inline void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, _OutItCat _Dest_cat, _Unchecked_iterator_tag)
	{
		_Generate_n(_Dest, _Count, _Func, _Dest_cat, _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Fn0>
	inline void generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{
		_Generate_n(_Dest, _Count, _Func, _Iter_cat(_Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt _Remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1253);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1254);
		for(;
		_First!=_Last;
		++_First)if(!(*_First==_Val))*_Dest++=*_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt _Remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val, _Unchecked_iterator_tag)
	{
		return _Remove_copy(_First, _Last, _Dest, _Val, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val)
	{
		return _Remove_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Val, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt _Remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1287);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1288);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1289);
		for(;
		_First!=_Last;
		++_First)if(!_Pred(*_First))*_Dest++=*_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt _Remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Remove_copy_if(_First, _Last, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return _Remove_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt, class _Ty>
	inline _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		_First=find(_First, _Last, _Val);
		if(_First==_Last)return (_First);
		else
		{
			_FwdIt _First1=_First;
			return (::stdext::unchecked_remove_copy(++_First1, _Last, _First, _Val));
		}
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_First=std::find_if(_First, _Last, _Pred);
		if(_First==_Last)return (_First);
		else
		{
			_FwdIt _First1=_First;
			return (::stdext::unchecked_remove_copy_if(++_First1, _Last, _First, _Pred));
		}
	}
	template<class _FwdIt>
	inline _FwdIt _Unique(_FwdIt _First, _FwdIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1348);
		for(_FwdIt _Firstb;
		(_Firstb=_First)!=_Last&&++_First!=_Last;
		)if(*_Firstb==*_First)
		{
			for(;
			++_First!=_Last;
			)if(!(*_Firstb==*_First))*++_Firstb=*_First;
			return (++_Firstb);
		}
		return (_Last);
	}
	template<class _FwdIt>
	inline _FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{
		::std::_Checked_assign_from_base(_Last, _Unique(::std::_Checked_base(_First), ::std::_Checked_base(_Last)));
		return (_Last);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1373);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1374);
		for(_FwdIt _Firstb;
		(_Firstb=_First)!=_Last&&++_First!=_Last;
		)if(_Pred(*_Firstb, *_First))
		{
			for(;
			++_First!=_Last;
			)if(!_Pred(*_Firstb, *_First))*++_Firstb=*_First;
			return (++_Firstb);
		}
		return (_Last);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_Last, _Unique(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_Last);
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Ty*, _Range_checked_iterator_tag)
	{
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1401);
		_Ty _Val=*_First;
		for(*_Dest++=_Val;
		++_First!=_Last;
		)if(!(_Val==*_First))_Val=*_First, *_Dest++=_Val;
		return (_Dest);
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, input_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, _Val_type(_First), _Range_checked_iterator_tag()));
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest, forward_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1423);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1424);
		_FwdIt _Firstb=_First;
		for(*_Dest++=*_Firstb;
		++_First!=_Last;
		)if(!(*_Firstb==*_First))_Firstb=_First, *_Dest++=*_Firstb;
		return (_Dest);
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, bidirectional_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}
	template<class _RanIt, class _OutIt>
	inline _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}
	template<class _RanIt, class _OutIt, class _RanItCat>
	inline _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _RanItCat _First_cat, _Unchecked_iterator_tag)
	{
		return _Unique_copy(_First, _Last, _Dest, _First_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt>
	inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (_First==_Last?_Dest: _Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_cat(_First), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _OutIt, class _Ty, class _Pr>
	inline _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Ty*, _Range_checked_iterator_tag)
	{
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1475);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1476);
		_Ty _Val=*_First;
		for(*_Dest++=_Val;
		++_First!=_Last;
		)if(!_Pred(_Val, *_First))_Val=*_First, *_Dest++=_Val;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, input_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, _Pred, _Val_type(_First)), _Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _OutIt, class _Pr>
	inline _OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest, _Pr _Pred, forward_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1500);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1501);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1502);
		_FwdIt _Firstb=_First;
		for(*_Dest++=*_Firstb;
		++_First!=_Last;
		)if(!_Pred(*_Firstb, *_First))_Firstb=_First, *_Dest++=*_Firstb;
		return (_Dest);
	}
	template<class _BidIt, class _OutIt, class _Pr>
	inline _OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Pr _Pred, bidirectional_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, _Pred, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}
	template<class _RanIt, class _OutIt, class _Pr>
	inline _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _Pr _Pred, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, _Pred, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}
	template<class _RanIt, class _OutIt, class _Pr, class _RanItCat>
	inline _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _Pr _Pred, _RanItCat _First_cat, _Unchecked_iterator_tag)
	{
		return _Unique_copy(_First, _Last, _Dest, _Pred, _First_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return (_First==_Last?_Dest: _Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std::_Checked_cat(_Dest)));
	}
	template<class _BidIt>
	inline void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
	{
		for(;
		_First!=_Last&&_First!=--_Last;
		++_First)std::iter_swap(_First, _Last);
	}
	template<class _RanIt>
	inline void _Reverse(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1562);
		for(;
		_First<_Last;
		++_First)std::iter_swap(_First, --_Last);
	}
	template<class _BidIt>
	inline void reverse(_BidIt _First, _BidIt _Last)
	{
		_Reverse(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Iter_cat(_First));
	}
	template<class _BidIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1579);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1580);
		for(;
		_First!=_Last;
		++_Dest)*_Dest=*--_Last;
		return (_Dest);
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Reverse_copy(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _BidIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Reverse_copy(_First, _Last, _Dest, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{
		return _Reverse_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt>
	inline void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, forward_iterator_tag)
	{
		for(_FwdIt _Next=_Mid;
		;
		)
		{
			std::iter_swap(_First, _Next);
			if(++_First==_Mid)if(++_Next==_Last)break;
			else _Mid=_Next;
			else if(++_Next==_Last)_Next=_Mid;
		}
	}
	template<class _BidIt>
	inline void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last, bidirectional_iterator_tag)
	{
		std::reverse(_First, _Mid);
		std::reverse(_Mid, _Last);
		std::reverse(_First, _Last);
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff*, _Ty*)
	{
		_Debug_range(_First, _Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1651);
		_Debug_range(_Mid, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1652);
		_Diff _Shift=_Mid-_First;
		_Diff _Count=_Last-_First;
		for(_Diff _Factor=_Shift;
		_Factor!=0;
		)
		{
			_Diff _Tmp=_Count%_Factor;
			_Count=_Factor, _Factor=_Tmp;
		}
		if(_Count<_Last-_First)for(;
		0<_Count;
		--_Count)
		{
			_RanIt _Hole=_First+_Count;
			_RanIt _Next=_Hole;
			_Ty _Holeval=*_Hole;
			_RanIt _Next1=_Next+_Shift==_Last?_First: _Next+_Shift;
			while(_Next1!=_Hole)
			{
				*_Next=*_Next1;
				_Next=_Next1;
				_Next1=_Shift<_Last-_Next1?_Next1+_Shift: _First+(_Shift-(_Last-_Next1));
			}
			*_Next=_Holeval;
		}
	}
	template<class _RanIt>
	inline void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, random_access_iterator_tag)
	{
		_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
	}
	template<class _FwdIt>
	inline void rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{
		if(_First!=_Mid&&_Mid!=_Last)_Rotate(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Iter_cat(_First));
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt _Rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Dest=::stdext::unchecked_copy(_Mid, _Last, _Dest);
		return (::stdext::unchecked_copy(_First, _Mid, _Dest));
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt _Rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Rotate_copy(_First, _Mid, _Last, _Dest, _Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return _Rotate_copy(_First, _Mid, _Last, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _RanIt, class _Diff>
	inline void _Random_shuffle(_RanIt _First, _RanIt _Last, _Diff*)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1725);
		const int _RANDOM_BITS=15;
		const int _RANDOM_MAX=(1U<<_RANDOM_BITS)-1;
		_RanIt _Next=_First;
		for(unsigned long _Index=2;
		++_Next!=_Last;
		++_Index)
		{
			unsigned long _Rm=_RANDOM_MAX;
			unsigned long _Rn=::rand()&_RANDOM_MAX;
			for(;
			_Rm<_Index&&_Rm!=~0UL;
			_Rm=_Rm<<_RANDOM_BITS|_RANDOM_MAX)_Rn=_Rn<<_RANDOM_BITS|(::rand()&_RANDOM_MAX);
			std::iter_swap(_Next, _First+_Diff(_Rn%_Index));
		}
	}
	template<class _RanIt>
	inline void random_shuffle(_RanIt _First, _RanIt _Last)
	{
		if(_First!=_Last)_Random_shuffle(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dist_type(_First));
	}
	template<class _RanIt, class _Fn1, class _Diff>
	inline void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&_Func, _Diff*)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1756);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1757);
		_RanIt _Next=_First;
		for(_Diff _Index=2;
		++_Next!=_Last;
		++_Index)std::iter_swap(_Next, _First+_Diff(_Func(_Index)%_Index));
	}
	template<class _RanIt, class _Fn1>
	inline void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&_Func)
	{
		if(_First!=_Last)_Random_shuffle(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Func, _Dist_type(_First));
	}
	template<class _BidIt, class _Pr>
	inline _BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1777);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1778);
		for(;
		;
		++_First)
		{
			for(;
			_First!=_Last&&_Pred(*_First);
			++_First);
			if(_First==_Last)break;
			for(;
			_First!=--_Last&&!_Pred(*_Last);
			);
			if(_First==_Last)break;
			std::iter_swap(_First, _Last);
		}
		return (_First);
	}
	template<class _BidIt, class _Pr>
	inline _BidIt partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Partition(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _BidIt, class _Pr, class _Diff, class _Ty>
	inline _BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf)
	{
		if(_Count==0)return (_First);
		else if(_Count==1)return (_Pred(*_First)?_Last: _First);
		else if(_Count<=_Tempbuf._Maxlen())
		{
			_BidIt _Next=_First;
			for(_Tempbuf._Init();
			_First!=_Last;
			++_First)if(_Pred(*_First))*_Next++=*_First;
			else*_Tempbuf++=*_First;
			::stdext::unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _Next);
			return (_Next);
		}
		else
		{
			_BidIt _Mid=_First;
			std::advance(_Mid, _Count/2);
			_BidIt _Left=_Stable_partition(_First, _Mid, _Pred, _Count/2, _Tempbuf);
			_BidIt _Right=_Stable_partition(_Mid, _Last, _Pred, _Count-_Count/2, _Tempbuf);
			_Diff _Count1=0;
			_Distance(_Left, _Mid, _Count1);
			_Diff _Count2=0;
			_Distance(_Mid, _Right, _Count2);
			return (_Buffered_rotate(_Left, _Mid, _Right, _Count1, _Count2, _Tempbuf));
		}
	}
	template<class _BidIt, class _Pr, class _Diff, class _Ty>
	inline _BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred, _Diff*, _Ty*)
	{
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		_Temp_iterator<_Ty>_Tempbuf(_Count);
		return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
	}
	template<class _BidIt, class _Pr>
	inline _BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		if(_First!=_Last)
		{
			::std::_Checked_assign_from_base(_First, _Stable_partition(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred, _Dist_type(_First), _Val_type(_First)));
		}
		return _First;
	}
	template<class _RanIt>
	inline void _Debug_heap(_RanIt _First, _RanIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1884);
		if(_First!=_Last)for(_RanIt _Root=_First;
		++_First!=_Last;
		++_Root)if(_Debug_lt(*_Root, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1888))_Debug_message(L"invalid heap", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1889);
		else if(++_First==_Last)break;
		else if(_Debug_lt(*_Root, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1892))_Debug_message(L"invalid heap", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1893);
	}
	template<class _RanIt, class _Pr>
	inline void _Debug_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1901);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1902);
		if(_First!=_Last)for(_RanIt _Root=_First;
		++_First!=_Last;
		++_Root)if(_Debug_lt_pred(_Pred, *_Root, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1906))_Debug_message(L"invalid heap", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1907);
		else if(++_First==_Last)break;
		else if(_Debug_lt_pred(_Pred, *_Root, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1910))_Debug_message(L"invalid heap", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1911);
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Push_heap(_RanIt _First, _Diff _Hole, _Diff _Top, _Ty _Val)
	{
		for(_Diff _Idx=(_Hole-1)/2;
		_Top<_Hole&&_Debug_lt(*(_First+_Idx), _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1932);
		_Idx=(_Hole-1)/2)
		{
			*(_First+_Hole)=*(_First+_Idx);
			_Hole=_Idx;
		}
		*(_First+_Hole)=_Val;
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Push_heap_0(_RanIt _First, _RanIt _Last, _Diff*, _Ty*)
	{
		_Debug_heap(_First, _Last);
		_Diff _Count=_Last-_First;
		if(0<_Count)_Push_heap(_First, _Count, _Diff(0), _Ty(*_Last));
	}
	template<class _RanIt>
	inline void push_heap(_RanIt _First, _RanIt _Last)
	{
		if(_First==_Last)_Debug_message(L"empty push_heap sequence", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1959);
		else _Push_heap_0(::std::_Checked_base(_First), ::std::_Checked_base(--_Last), _Dist_type(_First), _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Push_heap(_RanIt _First, _Diff _Hole, _Diff _Top, _Ty _Val, _Pr _Pred)
	{
		for(_Diff _Idx=(_Hole-1)/2;
		_Top<_Hole&&_Debug_lt_pred(_Pred, *(_First+_Idx), _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1979);
		_Idx=(_Hole-1)/2)
		{
			*(_First+_Hole)=*(_First+_Idx);
			_Hole=_Idx;
		}
		*(_First+_Hole)=_Val;
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff*, _Ty*)
	{
		_Debug_heap(_First, _Last, _Pred);
		_Diff _Count=_Last-_First;
		if(0<_Count)_Push_heap(_First, _Count, _Diff(0), _Ty(*_Last), _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		if(_First==_Last)_Debug_message(L"empty push_heap sequence", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2008);
		else _Push_heap_0(::std::_Checked_base(_First), ::std::_Checked_base(--_Last), _Pred, _Dist_type(_First), _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom, _Ty _Val)
	{
		_Diff _Top=_Hole;
		_Diff _Idx=2*_Hole+2;
		for(;
		_Idx<_Bottom;
		_Idx=2*_Idx+2)
		{
			if(_Debug_lt(*(_First+_Idx), *(_First+(_Idx-1)), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2030))--_Idx;
			*(_First+_Hole)=*(_First+_Idx), _Hole=_Idx;
		}
		if(_Idx==_Bottom)
		{
			*(_First+_Hole)=*(_First+(_Bottom-1));
			_Hole=_Bottom-1;
		}
		_Push_heap(_First, _Hole, _Top, _Val);
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty _Val, _Diff*)
	{
		*_Dest=*_First;
		_Adjust_heap(_First, _Diff(0), _Diff(_Last-_First), _Val);
	}
	template<class _RanIt, class _Ty>
	inline void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Ty*)
	{
		_Pop_heap(_First, _Last-1, _Last-1, _Ty(*(_Last-1)), _Dist_type(_First));
	}
	template<class _RanIt>
	inline void pop_heap(_RanIt _First, _RanIt _Last)
	{
		_Debug_heap(_First, _Last);
		if(1<_Last-_First)_Pop_heap_0(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom, _Ty _Val, _Pr _Pred)
	{
		_Diff _Top=_Hole;
		_Diff _Idx=2*_Hole+2;
		for(;
		_Idx<_Bottom;
		_Idx=2*_Idx+2)
		{
			if(_Debug_lt_pred(_Pred, *(_First+_Idx), *(_First+(_Idx-1)), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2082))--_Idx;
			*(_First+_Hole)=*(_First+_Idx), _Hole=_Idx;
		}
		if(_Idx==_Bottom)
		{
			*(_First+_Hole)=*(_First+(_Bottom-1));
			_Hole=_Bottom-1;
		}
		_Push_heap(_First, _Hole, _Top, _Val, _Pred);
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty _Val, _Pr _Pred, _Diff*)
	{
		*_Dest=*_First;
		_Adjust_heap(_First, _Diff(0), _Diff(_Last-_First), _Val, _Pred);
	}
	template<class _RanIt, class _Ty, class _Pr>
	inline void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty*)
	{
		_Pop_heap(_First, _Last-1, _Last-1, _Ty(*(_Last-1)), _Pred, _Dist_type(_First));
	}
	template<class _RanIt, class _Pr>
	inline void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_Debug_heap(_First, _Last, _Pred);
		if(1<_Last-_First)_Pop_heap_0(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred, _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Make_heap(_RanIt _First, _RanIt _Last, _Diff*, _Ty*)
	{
		_Diff _Bottom=_Last-_First;
		for(_Diff _Hole=_Bottom/2;
		0<_Hole;
		)
		{
			--_Hole;
			_Adjust_heap(_First, _Hole, _Bottom, _Ty(*(_First+_Hole)));
		}
	}
	template<class _RanIt>
	inline void make_heap(_RanIt _First, _RanIt _Last)
	{
		if(1<_Last-_First)_Make_heap(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dist_type(_First), _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff*, _Ty*)
	{
		_Diff _Bottom=_Last-_First;
		for(_Diff _Hole=_Bottom/2;
		0<_Hole;
		)
		{
			--_Hole;
			_Adjust_heap(_First, _Hole, _Bottom, _Ty(*(_First+_Hole)), _Pred);
		}
	}
	template<class _RanIt, class _Pr>
	inline void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		if(1<_Last-_First)_Make_heap(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred, _Dist_type(_First), _Val_type(_First));
	}
	template<class _RanIt>
	inline void _Sort_heap(_RanIt _First, _RanIt _Last)
	{
		_Debug_heap(_First, _Last);
		for(;
		1<_Last-_First;
		--_Last)std::pop_heap(_First, _Last);
	}
	template<class _RanIt>
	inline void sort_heap(_RanIt _First, _RanIt _Last)
	{
		_Debug_heap(_First, _Last);
		_Sort_heap(::std::_Checked_base(_First), ::std::_Checked_base(_Last));
	}
	template<class _RanIt, class _Pr>
	inline void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		for(;
		1<_Last-_First;
		--_Last)std::pop_heap(_First, _Last, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_Debug_heap(_First, _Last, _Pred);
		_Sort_heap(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred);
	}
	template<class _FwdIt, class _Ty, class _Diff>
	inline _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Diff*)
	{
		_Debug_order_single(_First, _Last, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2211);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2220);
			if(_Debug_lt(*_Mid, _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2222))_First=++_Mid, _Count-=_Count2+1;
			else _Count=_Count2;
		}
		return (_First);
	}
	template<class _FwdIt, class _Ty>
	inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		::std::_Checked_assign_from_base(_First, _Lower_bound(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Dist_type(_First)));
		return _First;
	}
	template<class _FwdIt, class _Ty, class _Diff, class _Pr>
	inline _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred, _Diff*)
	{
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2247);
		_Debug_order_single(_First, _Last, _Pred, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2248);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, _Pred, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2256);
			if(_Debug_lt_pred(_Pred, *_Mid, _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2258))_First=++_Mid, _Count-=_Count2+1;
			else _Count=_Count2;
		}
		return (_First);
	}
	template<class _FwdIt, class _Ty, class _Pr>
	inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Lower_bound(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Pred, _Dist_type(_First)));
		return _First;
	}
	template<class _FwdIt, class _Ty, class _Diff>
	inline _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Diff*)
	{
		_Debug_order_single(_First, _Last, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2283);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2291);
			if(!_Debug_lt(_Val, *_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2293))_First=++_Mid, _Count-=_Count2+1;
			else _Count=_Count2;
		}
		return (_First);
	}
	template<class _FwdIt, class _Ty>
	inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		::std::_Checked_assign_from_base(_First, _Upper_bound(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Dist_type(_First)));
		return _First;
	}
	template<class _FwdIt, class _Ty, class _Diff, class _Pr>
	inline _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred, _Diff*)
	{
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2318);
		_Debug_order_single(_First, _Last, _Pred, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2319);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, _Pred, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2327);
			if(!_Debug_lt_pred(_Pred, _Val, *_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2329))_First=++_Mid, _Count-=_Count2+1;
			else _Count=_Count2;
		}
		return (_First);
	}
	template<class _FwdIt, class _Ty, class _Pr>
	inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Upper_bound(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Pred, _Dist_type(_First)));
		return _First;
	}
	template<class _FwdIt, class _Ty, class _Diff>
	inline pair<_FwdIt, _FwdIt>_Equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Diff*)
	{
		_Debug_order_single(_First, _Last, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2355);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2364);
			if(_Debug_lt(*_Mid, _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2366))
			{
				_First=++_Mid;
				_Count-=_Count2+1;
			}
			else if(_Val<*_Mid)_Count=_Count2;
			else
			{
				_FwdIt _First2=lower_bound(_First, _Mid, _Val);
				std::advance(_First, _Count);
				_FwdIt _Last2=upper_bound(++_Mid, _First, _Val);
				return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}
		return (pair<_FwdIt, _FwdIt>(_First, _First));
	}
	template<class _FwdIt, class _Ty>
	inline pair<_FwdIt, _FwdIt>equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		return (_Equal_range(_First, _Last, _Val, _Dist_type(_First)));
	}
	template<class _FwdIt, class _Ty, class _Diff, class _Pr>
	inline pair<_FwdIt, _FwdIt>_Equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred, _Diff*)
	{
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2401);
		_Debug_order_single(_First, _Last, _Pred, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2402);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, _Pred, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2411);
			if(_Debug_lt_pred(_Pred, *_Mid, _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2413))
			{
				_First=++_Mid;
				_Count-=_Count2+1;
			}
			else if(_Pred(_Val, *_Mid))_Count=_Count2;
			else
			{
				_FwdIt _First2=lower_bound(_First, _Mid, _Val, _Pred);
				std::advance(_First, _Count);
				_FwdIt _Last2=upper_bound(++_Mid, _First, _Val, _Pred);
				return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}
		return (pair<_FwdIt, _FwdIt>(_First, _First));
	}
	template<class _FwdIt, class _Ty, class _Pr>
	inline pair<_FwdIt, _FwdIt>equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred)
	{
		return (_Equal_range(_First, _Last, _Val, _Pred, _Dist_type(_First)));
	}
	template<class _FwdIt, class _Ty>
	inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		_First=std::lower_bound(_First, _Last, _Val);
		return (_First!=_Last&&!(_Val<*_First));
	}
	template<class _FwdIt, class _Ty, class _Pr>
	inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred)
	{
		_First=std::lower_bound(_First, _Last, _Val, _Pred);
		return (_First!=_Last&&!_Pred(_Val, *_First));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _InOutItCat>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2468);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2469);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2470);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_Dest)if(_Debug_lt(*_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2472))*_Dest=*_First2, ++_First2;
		else*_Dest=*_First1, ++_First1;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last1-_First1)+(_Last2-_First2);
		_Merge(_First1, _Last1, _First2, _Last2, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _InOutItCat>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Merge(_First1, _Last1, _First2, _Last2, _Dest, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Iter_random(_First1, _First2, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr, class _InOutItCat>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2525);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2526);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2527);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_Dest)if(_Debug_lt_pred(_Pred, *_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2529))*_Dest=*_First2, ++_First2;
		else*_Dest=*_First1, ++_First1;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last1-_First1)+(_Last2-_First2);
		_Merge(_First1, _Last1, _First2, _Last2, ::std::_Checked_base(_Dest), _Pred, forward_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr, class _InOutItCat>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Merge(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, _Iter_random(_First1, _First2, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline _BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>&_Tempbuf)
	{
		if(_Count1<=_Count2&&_Count1<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_First, _Mid, _Tempbuf._Init());
			::stdext::unchecked_copy(_Mid, _Last, _First);
			return (::stdext::unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(), _Last));
		}
		else if(_Count2<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_Mid, _Last, _Tempbuf._Init());
			::stdext::unchecked_copy_backward(_First, _Mid, _Last);
			return (::stdext::unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));
		}
		else
		{
			std::rotate(_First, _Mid, _Last);
			std::advance(_First, _Count2);
			return (_First);
		}
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Range_checked_iterator_tag)
	{
		for(;
		;
		)if(_First1==_Last1)return (::stdext::unchecked_copy_backward(_First2, _Last2, _Dest));
		else if(_First2==_Last2)return (::stdext::unchecked_copy_backward(_First1, _Last1, _Dest));
		else if(_Debug_lt(*--_Last2, *--_Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2616))*--_Dest=*_Last1, ++_Last2;
		else*--_Dest=*_Last2, ++_Last1;
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Unchecked_iterator_tag)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>&_Tempbuf)
	{
		if(_Count1+_Count2==2)
		{
			if(_Debug_lt(*_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2650))std::iter_swap(_First, _Mid);
		}
		else if(_Count1<=_Count2&&_Count1<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_First, _Mid, _Tempbuf._Init());
			::stdext::unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);
		}
		else if(_Count2<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_Mid, _Last, _Tempbuf._Init());
			::stdext::_Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(), _Last);
		}
		else
		{
			_BidIt _Firstn, _Lastn;
			_Diff _Count1n, _Count2n;
			if(_Count2<_Count1)
			{
				_Count1n=_Count1/2, _Count2n=0;
				_Firstn=_First;
				std::advance(_Firstn, _Count1n);
				_Lastn=std::lower_bound(_Mid, _Last, *_Firstn);
				_Distance(_Mid, _Lastn, _Count2n);
			}
			else
			{
				_Count1n=0, _Count2n=_Count2/2;
				_Lastn=_Mid;
				std::advance(_Lastn, _Count2n);
				_Firstn=std::upper_bound(_First, _Mid, *_Lastn);
				_Distance(_First, _Firstn, _Count1n);
			}
			_BidIt _Midn=_Buffered_rotate(_Firstn, _Mid, _Lastn, _Count1-_Count1n, _Count2n, _Tempbuf);
			_Buffered_merge(_First, _Firstn, _Midn, _Count1n, _Count2n, _Tempbuf);
			_Buffered_merge(_Midn, _Lastn, _Last, _Count1-_Count1n, _Count2-_Count2n, _Tempbuf);
		}
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Diff*, _Ty*)
	{
		_Debug_order(_First, _Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2701);
		_Debug_order(_Mid, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2702);
		_Diff _Count1=0;
		_Distance(_First, _Mid, _Count1);
		_Diff _Count2=0;
		_Distance(_Mid, _Last, _Count2);
		_Temp_iterator<_Ty>_Tempbuf(_Count1<_Count2?_Count1: _Count2);
		_Buffered_merge(_First, _Mid, _Last, _Count1, _Count2, _Tempbuf);
	}
	template<class _BidIt>
	inline void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{
		if(_First!=_Mid&&_Mid!=_Last)_Inplace_merge(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Dist_type(_First), _Val_type(_First));
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		for(;
		;
		)if(_First1==_Last1)return (::stdext::unchecked_copy_backward(_First2, _Last2, _Dest));
		else if(_First2==_Last2)return (::stdext::unchecked_copy_backward(_First1, _Last1, _Dest));
		else if(_Debug_lt_pred(_Pred, *--_Last2, *--_Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2733))*--_Dest=*_Last1, ++_Last2;
		else*--_Dest=*_Last2, ++_Last1;
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Unchecked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>&_Tempbuf, _Pr _Pred)
	{
		if(_Count1+_Count2==2)
		{
			if(_Debug_lt_pred(_Pred, *_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2768))std::iter_swap(_First, _Mid);
		}
		else if(_Count1<=_Count2&&_Count1<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_First, _Mid, _Tempbuf._Init());
			::stdext::unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First, _Pred);
		}
		else if(_Count2<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_Mid, _Last, _Tempbuf._Init());
			::stdext::_Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
		}
		else
		{
			_BidIt _Firstn, _Lastn;
			_Diff _Count1n, _Count2n;
			if(_Count2<_Count1)
			{
				_Count1n=_Count1/2, _Count2n=0;
				_Firstn=_First;
				std::advance(_Firstn, _Count1n);
				_Lastn=lower_bound(_Mid, _Last, *_Firstn, _Pred);
				_Distance(_Mid, _Lastn, _Count2n);
			}
			else
			{
				_Count1n=0, _Count2n=_Count2/2;
				_Lastn=_Mid;
				std::advance(_Lastn, _Count2n);
				_Firstn=upper_bound(_First, _Mid, *_Lastn, _Pred);
				_Distance(_First, _Firstn, _Count1n);
			}
			_BidIt _Midn=_Buffered_rotate(_Firstn, _Mid, _Lastn, _Count1-_Count1n, _Count2n, _Tempbuf);
			_Buffered_merge(_First, _Firstn, _Midn, _Count1n, _Count2n, _Tempbuf, _Pred);
			_Buffered_merge(_Midn, _Lastn, _Last, _Count1-_Count1n, _Count2-_Count2n, _Tempbuf, _Pred);
		}
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred, _Diff*, _Ty*)
	{
		_Debug_order(_First, _Mid, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2819);
		_Debug_order(_Mid, _Last, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2820);
		_Diff _Count1=0;
		_Distance(_First, _Mid, _Count1);
		_Diff _Count2=0;
		_Distance(_Mid, _Last, _Count2);
		_Temp_iterator<_Ty>_Tempbuf(_Count1<_Count2?_Count1: _Count2);
		_Buffered_merge(_First, _Mid, _Last, _Count1, _Count2, _Tempbuf, _Pred);
	}
	template<class _BidIt, class _Pr>
	inline void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{
		if(_First!=_Mid&&_Mid!=_Last)_Inplace_merge(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Pred, _Dist_type(_First), _Val_type(_First));
	}
	template<class _BidIt, class _Ty>
	inline void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Ty*)
	{
		if(_First!=_Last)for(_BidIt _Next=_First;
		++_Next!=_Last;
		)
		{
			_BidIt _Next1=_Next;
			_Ty _Val=*_Next;
			if(_Debug_lt(_Val, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2850))
			{
				::stdext::unchecked_copy_backward(_First, _Next, ++_Next1);
				*_First=_Val;
			}
			else
			{
				for(_BidIt _First1=_Next1;
				_Debug_lt(_Val, *--_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2858);
				_Next1=_First1)*_Next1=*_First1;
				*_Next1=_Val;
			}
		}
	}
	template<class _BidIt>
	inline void _Insertion_sort(_BidIt _First, _BidIt _Last)
	{
		_Insertion_sort1(_First, _Last, _Val_type(_First));
	}
	template<class _RanIt>
	inline void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{
		if(_Debug_lt(*_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2875))std::iter_swap(_Mid, _First);
		if(_Debug_lt(*_Last, *_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2877))std::iter_swap(_Last, _Mid);
		if(_Debug_lt(*_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2879))std::iter_swap(_Mid, _First);
	}
	template<class _RanIt>
	inline void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{
		if(40<_Last-_First)
		{
			size_t _Step=(_Last-_First+1)/8;
			_Med3(_First, _First+_Step, _First+2*_Step);
			_Med3(_Mid-_Step, _Mid, _Mid+_Step);
			_Med3(_Last-2*_Step, _Last-_Step, _Last);
			_Med3(_First+_Step, _Mid, _Last-_Step);
		}
		else _Med3(_First, _Mid, _Last);
	}
	template<class _RanIt>
	inline pair<_RanIt, _RanIt>_Unguarded_partition(_RanIt _First, _RanIt _Last)
	{
		_RanIt _Mid=_First+(_Last-_First)/2;
		_Median(_First, _Mid, _Last-1);
		_RanIt _Pfirst=_Mid;
		_RanIt _Plast=_Pfirst+1;
		while(_First<_Pfirst&&!_Debug_lt(*(_Pfirst-1), *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2907)&&!(*_Pfirst<*(_Pfirst-1)))--_Pfirst;
		while(_Plast<_Last&&!_Debug_lt(*_Plast, *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2911)&&!(*_Pfirst<*_Plast))++_Plast;
		_RanIt _Gfirst=_Plast;
		_RanIt _Glast=_Pfirst;
		for(;
		;
		)
		{
			for(;
			_Gfirst<_Last;
			++_Gfirst)if(_Debug_lt(*_Pfirst, *_Gfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2921));
			else if(*_Gfirst<*_Pfirst)break;
			else std::iter_swap(_Plast++, _Gfirst);
			for(;
			_First<_Glast;
			--_Glast)if(_Debug_lt(*(_Glast-1), *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2928));
			else if(*_Pfirst<*(_Glast-1))break;
			else std::iter_swap(--_Pfirst, _Glast-1);
			if(_Glast==_First&&_Gfirst==_Last)return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
			if(_Glast==_First)
			{
				if(_Plast!=_Gfirst)std::iter_swap(_Pfirst, _Plast);
				++_Plast;
				std::iter_swap(_Pfirst++, _Gfirst++);
			}
			else if(_Gfirst==_Last)
			{
				if(--_Glast!=--_Pfirst)std::iter_swap(_Glast, _Pfirst);
				std::iter_swap(_Pfirst, --_Plast);
			}
			else std::iter_swap(_Gfirst++, --_Glast);
		}
	}
	template<class _RanIt, class _Diff>
	inline void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal)
	{
		_Diff _Count;
		for(;
		_ISORT_MAX<(_Count=_Last-_First)&&0<_Ideal;
		)
		{
			pair<_RanIt, _RanIt>_Mid=_Unguarded_partition(_First, _Last);
			_Ideal/=2, _Ideal+=_Ideal/2;
			if(_Mid.first-_First<_Last-_Mid.second)_Sort(_First, _Mid.first, _Ideal), _First=_Mid.second;
			else _Sort(_Mid.second, _Last, _Ideal), _Last=_Mid.first;
		}
		if(_ISORT_MAX<_Count)
		{
			std::make_heap(_First, _Last);
			std::sort_heap(_First, _Last);
		}
		else if(1<_Count)_Insertion_sort(_First, _Last);
	}
	template<class _RanIt>
	inline void sort(_RanIt _First, _RanIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2983);
		_Sort(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Last-_First);
	}
	template<class _BidIt, class _Pr>
	inline void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		if(_First!=_Last)for(_BidIt _Next=_First;
		++_Next!=_Last;
		)if(_Debug_lt_pred(_Pred, *_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2994))
		{
			_BidIt _Next1=_Next;
			std::rotate(_First, _Next, ++_Next1);
		}
		else
		{
			_BidIt _Dest=_Next;
			for(_BidIt _Dest0=_Dest;
			_Debug_lt_pred(_Pred, *_Next, *--_Dest0, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3003);
			)_Dest=_Dest0;
			if(_Dest!=_Next)
			{
				_BidIt _Next1=_Next;
				std::rotate(_Dest, _Next, ++_Next1);
			}
		}
	}
	template<class _RanIt, class _Pr>
	inline void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{
		if(_Debug_lt_pred(_Pred, *_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3017))std::iter_swap(_Mid, _First);
		if(_Debug_lt_pred(_Pred, *_Last, *_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3019))std::iter_swap(_Last, _Mid);
		if(_Debug_lt_pred(_Pred, *_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3021))std::iter_swap(_Mid, _First);
	}
	template<class _RanIt, class _Pr>
	inline void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{
		if(40<_Last-_First)
		{
			size_t _Step=(_Last-_First+1)/8;
			_Med3(_First, _First+_Step, _First+2*_Step, _Pred);
			_Med3(_Mid-_Step, _Mid, _Mid+_Step, _Pred);
			_Med3(_Last-2*_Step, _Last-_Step, _Last, _Pred);
			_Med3(_First+_Step, _Mid, _Last-_Step, _Pred);
		}
		else _Med3(_First, _Mid, _Last, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline pair<_RanIt, _RanIt>_Unguarded_partition(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_RanIt _Mid=_First+(_Last-_First)/2;
		_Median(_First, _Mid, _Last-1, _Pred);
		_RanIt _Pfirst=_Mid;
		_RanIt _Plast=_Pfirst+1;
		while(_First<_Pfirst&&!_Debug_lt_pred(_Pred, *(_Pfirst-1), *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3052)&&!_Pred(*_Pfirst, *(_Pfirst-1)))--_Pfirst;
		while(_Plast<_Last&&!_Debug_lt_pred(_Pred, *_Plast, *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3056)&&!_Pred(*_Pfirst, *_Plast))++_Plast;
		_RanIt _Gfirst=_Plast;
		_RanIt _Glast=_Pfirst;
		for(;
		;
		)
		{
			for(;
			_Gfirst<_Last;
			++_Gfirst)if(_Debug_lt_pred(_Pred, *_Pfirst, *_Gfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3066));
			else if(_Pred(*_Gfirst, *_Pfirst))break;
			else std::iter_swap(_Plast++, _Gfirst);
			for(;
			_First<_Glast;
			--_Glast)if(_Debug_lt_pred(_Pred, *(_Glast-1), *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3073));
			else if(_Pred(*_Pfirst, *(_Glast-1)))break;
			else std::iter_swap(--_Pfirst, _Glast-1);
			if(_Glast==_First&&_Gfirst==_Last)return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
			if(_Glast==_First)
			{
				if(_Plast!=_Gfirst)std::iter_swap(_Pfirst, _Plast);
				++_Plast;
				std::iter_swap(_Pfirst++, _Gfirst++);
			}
			else if(_Gfirst==_Last)
			{
				if(--_Glast!=--_Pfirst)std::iter_swap(_Glast, _Pfirst);
				std::iter_swap(_Pfirst, --_Plast);
			}
			else std::iter_swap(_Gfirst++, --_Glast);
		}
	}
	template<class _RanIt, class _Diff, class _Pr>
	inline void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
	{
		_Diff _Count;
		for(;
		_ISORT_MAX<(_Count=_Last-_First)&&0<_Ideal;
		)
		{
			pair<_RanIt, _RanIt>_Mid=_Unguarded_partition(_First, _Last, _Pred);
			_Ideal/=2, _Ideal+=_Ideal/2;
			if(_Mid.first-_First<_Last-_Mid.second)_Sort(_First, _Mid.first, _Ideal, _Pred), _First=_Mid.second;
			else _Sort(_Mid.second, _Last, _Ideal, _Pred), _Last=_Mid.first;
		}
		if(_ISORT_MAX<_Count)
		{
			std::make_heap(_First, _Last, _Pred);
			std::sort_heap(_First, _Last, _Pred);
		}
		else if(1<_Count)_Insertion_sort(_First, _Last, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3131);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3132);
		_Sort(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Last-_First, _Pred);
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Range_checked_iterator_tag)
	{
		for(_Diff _Chunk2=_Chunk*2;
		_Chunk2<=_Count;
		_Count-=_Chunk2)
		{
			_BidIt _Mid1=_First;
			std::advance(_Mid1, _Chunk);
			_BidIt _Mid2=_Mid1;
			std::advance(_Mid2, _Chunk);
			_Dest=::stdext::unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);
			_First=_Mid2;
		}
		if(_Count<=_Chunk)::stdext::unchecked_copy(_First, _Last, _Dest);
		else
		{
			_BidIt _Mid=_First;
			std::advance(_Mid, _Chunk);
			::stdext::unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);
		}
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Unchecked_iterator_tag)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf)
	{
		_BidIt _Mid=_First;
		for(_Diff _Nleft=_Count;
		_ISORT_MAX<=_Nleft;
		_Nleft-=_ISORT_MAX)
		{
			_BidIt _Midend=_Mid;
			std::advance(_Midend, (int)_ISORT_MAX);
			_Insertion_sort(_Mid, _Midend);
			_Mid=_Midend;
		}
		_Insertion_sort(_Mid, _Last);
		for(_Diff _Chunk=_ISORT_MAX;
		_Chunk<_Count;
		_Chunk*=2)
		{
			::stdext::_Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(), _Chunk, _Count);
			::stdext::_Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First, _Chunk*=2, _Count);
		}
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf)
	{
		if(_Count<=_ISORT_MAX)_Insertion_sort(_First, _Last);
		else
		{
			_Diff _Count2=(_Count+1)/2;
			_BidIt _Mid=_First;
			std::advance(_Mid, _Count2);
			if(_Count2<=_Tempbuf._Maxlen())
			{
				_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);
				_Buffered_merge_sort(_Mid, _Last, _Count-_Count2, _Tempbuf);
			}
			else
			{
				_Stable_sort(_First, _Mid, _Count2, _Tempbuf);
				_Stable_sort(_Mid, _Last, _Count-_Count2, _Tempbuf);
			}
			_Buffered_merge(_First, _Mid, _Last, _Count2, _Count-_Count2, _Tempbuf);
		}
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff*, _Ty*)
	{
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		_Temp_iterator<_Ty>_Tempbuf((_Count+1)/2);
		_Stable_sort(_First, _Last, _Count, _Tempbuf);
	}
	template<class _BidIt>
	inline void stable_sort(_BidIt _First, _BidIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3254);
		if(_First!=_Last)
		{
			_Stable_sort(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dist_type(_First), _Val_type(_First));
		}
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred, _Range_checked_iterator_tag)
	{
		for(_Diff _Chunk2=_Chunk*2;
		_Chunk2<=_Count;
		_Count-=_Chunk2)
		{
			_BidIt _Mid1=_First;
			std::advance(_Mid1, _Chunk);
			_BidIt _Mid2=_Mid1;
			std::advance(_Mid2, _Chunk);
			_Dest=::stdext::unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
			_First=_Mid2;
		}
		if(_Count<=_Chunk)::stdext::unchecked_copy(_First, _Last, _Dest);
		else
		{
			_BidIt _Mid1=_First;
			std::advance(_Mid1, _Chunk);
			::stdext::unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
		}
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred, _Unchecked_iterator_tag)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf, _Pr _Pred)
	{
		_BidIt _Mid=_First;
		for(_Diff _Nleft=_Count;
		_ISORT_MAX<=_Nleft;
		_Nleft-=_ISORT_MAX)
		{
			_BidIt _Midn=_Mid;
			std::advance(_Midn, (int)_ISORT_MAX);
			_Insertion_sort(_Mid, _Midn, _Pred);
			_Mid=_Midn;
		}
		_Insertion_sort(_Mid, _Last, _Pred);
		for(_Diff _Chunk=_ISORT_MAX;
		_Chunk<_Count;
		_Chunk*=2)
		{
			::stdext::_Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(), _Chunk, _Count, _Pred);
			::stdext::_Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First, _Chunk*=2, _Count, _Pred);
		}
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf, _Pr _Pred)
	{
		if(_Count<=_ISORT_MAX)_Insertion_sort(_First, _Last, _Pred);
		else
		{
			_Diff _Count2=(_Count+1)/2;
			_BidIt _Mid=_First;
			std::advance(_Mid, _Count2);
			if(_Count2<=_Tempbuf._Maxlen())
			{
				_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
				_Buffered_merge_sort(_Mid, _Last, _Count-_Count2, _Tempbuf, _Pred);
			}
			else
			{
				_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
				_Stable_sort(_Mid, _Last, _Count-_Count2, _Tempbuf, _Pred);
			}
			_Buffered_merge(_First, _Mid, _Last, _Count2, _Count-_Count2, _Tempbuf, _Pred);
		}
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff*, _Ty*, _Pr _Pred)
	{
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		_Temp_iterator<_Ty>_Tempbuf((_Count+1)/2);
		_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
	}
	template<class _BidIt, class _Pr>
	inline void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3385);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3386);
		if(_First!=_Last)
		{
			_Stable_sort(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dist_type(_First), _Val_type(_First), _Pred);
		}
	}
	template<class _RanIt, class _Ty>
	inline void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty*)
	{
		_Debug_range(_First, _Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3399);
		_Debug_range(_Mid, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3400);
		std::make_heap(_First, _Mid);
		for(_RanIt _Next=_Mid;
		_Next<_Last;
		++_Next)if(_Debug_lt(*_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3404))_Pop_heap(_First, _Mid, _Next, _Ty(*_Next), _Dist_type(_First));
		std::sort_heap(_First, _Mid);
	}
	template<class _RanIt>
	inline void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{
		_Partial_sort(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Val_type(_First));
	}
	template<class _RanIt, class _Ty, class _Pr>
	inline void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred, _Ty*)
	{
		_Debug_range(_First, _Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3423);
		_Debug_range(_Mid, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3424);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3425);
		std::make_heap(_First, _Mid, _Pred);
		for(_RanIt _Next=_Mid;
		_Next<_Last;
		++_Next)if(_Debug_lt_pred(_Pred, *_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3429))_Pop_heap(_First, _Mid, _Next, _Ty(*_Next), _Pred, _Dist_type(_First));
		std::sort_heap(_First, _Mid, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{
		_Partial_sort(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Pred, _Val_type(_First));
	}
	template<class _InIt, class _RanIt, class _Diff, class _Ty>
	inline _RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Diff*, _Ty*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3450);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3451);
		_RanIt _Mid2=_First2;
		for(;
		_First1!=_Last1&&_Mid2!=_Last2;
		++_First1, ++_Mid2)*_Mid2=*_First1;
		std::make_heap(_First2, _Mid2);
		for(;
		_First1!=_Last1;
		++_First1)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3458))_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2-_First2), _Ty(*_First1));
		std::sort_heap(_First2, _Mid2);
		return (_Mid2);
	}
	template<class _InIt, class _RanIt>
	inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2)
	{
		if(_First1!=_Last1&&_First2!=_Last2)::std::_Checked_assign_from_base(_First2, _Partial_sort_copy(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dist_type(_First2), _Val_type(_First1)));
		return (_First2);
	}
	template<class _InIt, class _RanIt, class _Diff, class _Ty, class _Pr>
	inline _RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff*, _Ty*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3487);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3488);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3489);
		_RanIt _Mid2=_First2;
		for(;
		_First1!=_Last1&&_Mid2!=_Last2;
		++_First1, ++_Mid2)*_Mid2=*_First1;
		std::make_heap(_First2, _Mid2, _Pred);
		for(;
		_First1!=_Last1;
		++_First1)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3496))_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2-_First2), _Ty(*_First1), _Pred);
		std::sort_heap(_First2, _Mid2, _Pred);
		return (_Mid2);
	}
	template<class _InIt, class _RanIt, class _Pr>
	inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{
		if(_First1!=_Last1&&_First2!=_Last2)::std::_Checked_assign_from_base(_First2, _Partial_sort_copy(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred, _Dist_type(_First2), _Val_type(_First1)));
		return (_First2);
	}
	template<class _RanIt>
	inline void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3521);
		for(;
		_ISORT_MAX<_Last-_First;
		)
		{
			pair<_RanIt, _RanIt>_Mid=_Unguarded_partition(_First, _Last);
			if(_Mid.second<=_Nth)_First=_Mid.second;
			else if(_Mid.first<=_Nth)return ;
			else _Last=_Mid.first;
		}
		_Insertion_sort(_First, _Last);
	}
	template<class _RanIt>
	inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{
		_Nth_element(::std::_Checked_base(_First), ::std::_Checked_base(_Nth), ::std::_Checked_base(_Last));
	}
	template<class _RanIt, class _Pr>
	inline void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3549);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3550);
		for(;
		_ISORT_MAX<_Last-_First;
		)
		{
			pair<_RanIt, _RanIt>_Mid=_Unguarded_partition(_First, _Last, _Pred);
			if(_Mid.second<=_Nth)_First=_Mid.second;
			else if(_Mid.first<=_Nth)return ;
			else _Last=_Mid.first;
		}
		_Insertion_sort(_First, _Last, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{
		_Nth_element(::std::_Checked_base(_First), ::std::_Checked_base(_Nth), ::std::_Checked_base(_Last), _Pred);
	}
	template<class _InIt1, class _InIt2>
	inline bool _Includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3580);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3581);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3583))return (false);
		else if(*_First1<*_First2)++_First1;
		else++_First1, ++_First2;
		return (_First2==_Last2);
	}
	template<class _InIt1, class _InIt2>
	inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{
		return _Includes(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool _Includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3608);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3609);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3611))return (false);
		else if(_Pred(*_First1, *_First2))++_First1;
		else++_First1, ++_First2;
		return (_First2==_Last2);
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
		return _Includes(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred);
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3637);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3638);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3639);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3641))*_Dest++=*_First1, ++_First1;
		else if(*_First2<*_First1)*_Dest++=*_First2, ++_First2;
		else*_Dest++=*_First1, ++_First1, ++_First2;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Set_union(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3681);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3682);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3683);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3685))*_Dest++=*_First1, ++_First1;
		else if(_Pred(*_First2, *_First1))*_Dest++=*_First2, ++_First2;
		else*_Dest++=*_First1, ++_First1, ++_First2;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Set_union(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3725);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3726);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3727);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3729))++_First1;
		else if(*_First2<*_First1)++_First2;
		else*_Dest++=*_First1++, ++_First2;
		return (_Dest);
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Set_intersection(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3768);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3769);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3770);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3772))++_First1;
		else if(_Pred(*_First2, *_First1))++_First2;
		else*_Dest++=*_First1++, ++_First2;
		return (_Dest);
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Set_intersection(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3811);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3812);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3813);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3815))*_Dest++=*_First1, ++_First1;
		else if(*_First2<*_First1)++_First2;
		else++_First1, ++_First2;
		return (::stdext::unchecked_copy(_First1, _Last1, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Set_difference(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3854);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3855);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3856);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3858))*_Dest++=*_First1, ++_First1;
		else if(_Pred(*_First2, *_First1))++_First2;
		else++_First1, ++_First2;
		return (::stdext::unchecked_copy(_First1, _Last1, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Set_difference(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3897);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3898);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3899);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3901))*_Dest++=*_First1, ++_First1;
		else if(*_First2<*_First1)*_Dest++=*_First2, ++_First2;
		else++_First1, ++_First2;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3941);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3942);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3943);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3945))*_Dest++=*_First1, ++_First1;
		else if(_Pred(*_First2, *_First1))*_Dest++=*_First2, ++_First2;
		else++_First1, ++_First2;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt>
	inline _FwdIt _Max_element(_FwdIt _First, _FwdIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3982);
		_FwdIt _Found=_First;
		if(_First!=_Last)for(;
		++_First!=_Last;
		)if(_Debug_lt(*_Found, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3986))_Found=_First;
		return (_Found);
	}
	template<class _FwdIt>
	inline _FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{
		::std::_Checked_assign_from_base(_First, _Max_element(::std::_Checked_base(_First), ::std::_Checked_base(_Last)));
		return (_First);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4004);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4005);
		_FwdIt _Found=_First;
		if(_First!=_Last)for(;
		++_First!=_Last;
		)if(_Debug_lt_pred(_Pred, *_Found, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4009))_Found=_First;
		return (_Found);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Max_element(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _FwdIt>
	inline _FwdIt _Min_element(_FwdIt _First, _FwdIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4027);
		_FwdIt _Found=_First;
		if(_First!=_Last)for(;
		++_First!=_Last;
		)if(_Debug_lt(*_First, *_Found, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4031))_Found=_First;
		return (_Found);
	}
	template<class _FwdIt>
	inline _FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{
		::std::_Checked_assign_from_base(_First, _Min_element(::std::_Checked_base(_First), ::std::_Checked_base(_Last)));
		return (_First);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4049);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4050);
		_FwdIt _Found=_First;
		if(_First!=_Last)for(;
		++_First!=_Last;
		)if(_Debug_lt_pred(_Pred, *_First, *_Found, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4054))_Found=_First;
		return (_Found);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Min_element(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _BidIt>
	inline bool _Next_permutation(_BidIt _First, _BidIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4072);
		_BidIt _Next=_Last;
		if(_First==_Last||_First==--_Next)return (false);
		for(;
		;
		)
		{
			_BidIt _Next1=_Next;
			if(_Debug_lt(*--_Next, *_Next1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4080))
			{
				_BidIt _Mid=_Last;
				for(;
				!_Debug_lt(*_Next, *--_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4083);
				);
				std::iter_swap(_Next, _Mid);
				std::reverse(_Next1, _Last);
				return (true);
			}
			if(_Next==_First)
			{
				std::reverse(_First, _Last);
				return (false);
			}
		}
	}
	template<class _BidIt>
	inline bool next_permutation(_BidIt _First, _BidIt _Last)
	{
		return _Next_permutation(::std::_Checked_base(_First), ::std::_Checked_base(_Last));
	}
	template<class _BidIt, class _Pr>
	inline bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4109);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4110);
		_BidIt _Next=_Last;
		if(_First==_Last||_First==--_Next)return (false);
		for(;
		;
		)
		{
			_BidIt _Next1=_Next;
			if(_Debug_lt_pred(_Pred, *--_Next, *_Next1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4118))
			{
				_BidIt _Mid=_Last;
				for(;
				!_Debug_lt_pred(_Pred, *_Next, *--_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4121);
				);
				std::iter_swap(_Next, _Mid);
				std::reverse(_Next1, _Last);
				return (true);
			}
			if(_Next==_First)
			{
				std::reverse(_First, _Last);
				return (false);
			}
		}
	}
	template<class _BidIt, class _Pr>
	inline bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		return _Next_permutation(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred);
	}
	template<class _BidIt>
	inline bool _Prev_permutation(_BidIt _First, _BidIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4147);
		_BidIt _Next=_Last;
		if(_First==_Last||_First==--_Next)return (false);
		for(;
		;
		)
		{
			_BidIt _Next1=_Next;
			if(_Debug_lt(*_Next1, *--_Next, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4154))
			{
				_BidIt _Mid=_Last;
				for(;
				!_Debug_lt(*--_Mid, *_Next, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4157);
				);
				std::iter_swap(_Next, _Mid);
				std::reverse(_Next1, _Last);
				return (true);
			}
			if(_Next==_First)
			{
				std::reverse(_First, _Last);
				return (false);
			}
		}
	}
	template<class _BidIt>
	inline bool prev_permutation(_BidIt _First, _BidIt _Last)
	{
		return _Prev_permutation(::std::_Checked_base(_First), ::std::_Checked_base(_Last));
	}
	template<class _BidIt, class _Pr>
	inline bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4183);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4184);
		_BidIt _Next=_Last;
		if(_First==_Last||_First==--_Next)return (false);
		for(;
		;
		)
		{
			_BidIt _Next1=_Next;
			if(_Debug_lt_pred(_Pred, *_Next1, *--_Next, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4192))
			{
				_BidIt _Mid=_Last;
				for(;
				!_Debug_lt_pred(_Pred, *--_Mid, *_Next, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4195);
				);
				std::iter_swap(_Next, _Mid);
				std::reverse(_Next1, _Last);
				return (true);
			}
			if(_Next==_First)
			{
				std::reverse(_First, _Last);
				return (false);
			}
		}
	}
	template<class _BidIt, class _Pr>
	inline bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		return _Prev_permutation(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred);
	}
}
namespace stdext
{
	template<class _InIt, class _OutIt, class _Fn1>
	inline _OutIt unchecked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
		return ::std::_Transform(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Func, ::std::_Iter_random(_First, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Fn1>
	inline _OutIt checked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
		return ::std::_Transform(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Func, ::std::_Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
	inline _OutIt unchecked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{
		return ::std::_Transform(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Dest, _Func, ::std::_Iter_random(_First1, _First2), ::std::_Iter_random(_First1, _Dest), ::std::_Range_checked_iterator_tag(), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
	inline _OutIt checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{
		return ::std::_Transform(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Dest, _Func, ::std::_Iter_random(_First1, _First2), ::std::_Iter_random(_First1, _Dest), ::std::_Checked_cat(_First2), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt2 unchecked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return ::std::_Swap_ranges(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt2 checked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return ::std::_Swap_ranges(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_Last1));
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt unchecked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval)
	{
		return ::std::_Replace_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Oldval, _Newval, ::std::_Iter_random(_First, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt checked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval)
	{
		return ::std::_Replace_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Oldval, _Newval, ::std::_Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty>
	inline _OutIt unchecked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val)
	{
		return ::std::_Replace_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Val, ::std::_Iter_random(_First, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty>
	inline _OutIt checked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val)
	{
		return ::std::_Replace_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Val, ::std::_Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _OutIt, class _Diff, class _Fn0>
	inline void unchecked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{
		::std::_Generate_n(_Dest, _Count, _Func, _Iter_cat(_Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Fn0>
	inline void checked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{
		::std::_Generate_n(_Dest, _Count, _Func, _Iter_cat(_Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt unchecked_remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val)
	{
		return ::std::_Remove_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Val, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt checked_remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val)
	{
		return ::std::_Remove_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Val, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unchecked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Remove_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt checked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Remove_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (_First==_Last?_Dest: ::std::_Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_cat(_First), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (_First==_Last?_Dest: ::std::_Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_cat(_First), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return (_First==_Last?_Dest: ::std::_Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return (_First==_Last?_Dest: ::std::_Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std::_Checked_cat(_Dest)));
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt unchecked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{
		return ::std::_Reverse_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{
		return ::std::_Reverse_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt unchecked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return ::std::_Rotate_copy(_First, _Mid, _Last, _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return ::std::_Rotate_copy(_First, _Mid, _Last, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Iter_random(_First1, _First2, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Merge(_First1, _Last1, _First2, _Last2, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Iter_random(_First1, _First2, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Iter_random(_First1, _First2, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return ::std::_Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return ::std::_Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return ::std::_Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return ::std::_Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count)
	{
		::std::_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count)
	{
		::std::_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		::std::_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		::std::_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
}
extern size_t gAllocatorFootprint;
template<class T>
class DebugAllocator: public std::allocator<T>
{
public:
	typedef std::allocator<T>Base;
	typedef typename Base::value_type value_type;
	typedef typename Base::pointer pointer;
	typedef typename Base::reference reference;
	typedef typename Base::const_pointer const_pointer;
	typedef typename Base::const_reference const_reference;
	typedef typename Base::size_type size_type;
	typedef typename Base::difference_type difference_type;
	template<class OtherT>
	struct rebind
	{
		typedef DebugAllocator<OtherT>other;
	};
	DebugAllocator()
	{
	}
	DebugAllocator(const DebugAllocator<T>&)
	{
	}
	template<class OtherT>
	DebugAllocator(const DebugAllocator<OtherT>&)
	{
	}
	template<class OtherT>
	DebugAllocator<T>&operator=(const DebugAllocator<OtherT>&)
	{
		return (*this);
	}
	void deallocate(pointer p, size_type count)
	{
		gAllocatorFootprint-=count*sizeof(T);
		return Base::deallocate(p, count);
	}
	pointer allocate(size_type count)
	{
		gAllocatorFootprint+=count*sizeof(T);
		return Base::allocate(count);
	}
	pointer allocate(size_type count, const void*hint)
	{
		gAllocatorFootprint+=count*sizeof(T);
		return Base::allocate(count, hint);
	}
};
template<class T, class OtherT>
inline bool operator==(const DebugAllocator<T>&, const DebugAllocator<OtherT>&)
{
	return (true);
}
template<class T, class OtherT>
inline bool operator!=(const DebugAllocator<T>&, const DebugAllocator<OtherT>&)
{
	return (false);
}
struct AllocatorError
{
	AllocatorError()
	{
		__debugbreak();
	}
};
struct IsAllocated
{
	bool operator()(char c)const
	{
		return c!=char(0xba);
	}
};
inline bool isAllocated(const char*first, const char*last)
{
	const char*p=std::find_if(first, last, IsAllocated());
	if(p!=last)
	{
		std::cout<<"allocation at: "<<static_cast<const void*>(p)<<": ";
		std::cout.write(p, 4);
		std::cout<<std::endl;
	}
	return p!=last;
}
struct IsDeallocated
{
	bool operator()(char c)const
	{
		return c==char(0xba);
	}
};
inline bool isDeallocated(const char*first, const char*last)
{
	const char*p=std::find_if(first, last, IsDeallocated());
	if(p!=last)
	{
		std::cout<<"deallocation at: "<<static_cast<const void*>(p)<<": ";
		std::cout.write(p, 4);
		std::cout<<std::endl;
	}
	return p!=last;
}
template<typename T>
inline bool isDeallocated(const T*p)
{
	return p!=0&&*reinterpret_cast<const size_t*>(p)==0xbabababa;
}
template<typename T>
inline void checkAllocated(const T*p)
{
	if(!(!isDeallocated(p)))
	{
		throw AllocatorError();
	};
}
template<typename T>
struct SafePtr
{
	typedef T Type;
	T*p;
	SafePtr()
	{
	}
	SafePtr(T*p): p(p)
	{
	}
	SafePtr(const SafePtr<T>&other): p(other.p)
	{
		checkAllocated(p);
	}
	SafePtr<T>&operator=(const SafePtr<T>&other)
	{
		p=other;
		checkAllocated(p);
		return *this;
	}
	SafePtr<T>&operator=(T*other)
	{
		p=other;
		checkAllocated(p);
		return *this;
	}
	T&operator*()const
	{
		checkAllocated(p);
		return *p;
	}
	T*operator->()const
	{
		checkAllocated(p);
		return p;
	}
	operator T*()const
	{
		checkAllocated(p);
		return p;
	}
};
template<typename T>
inline bool operator==(const SafePtr<T>&left, const SafePtr<T>&right)
{
	return left.p==right.p;
}
struct Page
{
	enum
	{
		SHIFT=17
	};
	enum
	{
		SIZE=1<<SHIFT
	};
	enum
	{
		MASK=SIZE-1
	};
	char buffer[SIZE];
	Page()
	{
		std::uninitialized_fill(buffer, buffer+SIZE, char(0xba));
	}
};
template<bool checked>
struct LinearAllocator
{
	typedef std::vector<Page*>Pages;
	Pages pages;
	size_t position;
	static void*debugAddress;
	static char debugValue[4];
	static size_t debugAllocationId;
	LinearAllocator(): position(0)
	{
	}
	~LinearAllocator()
	{
		ProfileScope profile(gProfileAllocator);
		for(Pages::iterator i=pages.begin();
		i!=pages.end();
		++i)
		{
			Page*p=*i;
			delete p;
		}
	}
	Page*getPage(size_t index)
	{
		if(index==pages.size())
		{
			ProfileScope profile(gProfileAllocator);
			pages.push_back(new Page);
		}
		return pages[index];
	}
	void*allocate(size_t size)
	{
		if(position==debugAllocationId)
		{
			std::cout<<"debug allocation!"<<std::endl;
		}
		size_t available=sizeof(Page)-(position&Page::MASK);
		if(size>available)
		{
			position+=available;
		}
		Page*page=getPage(position>>Page::SHIFT);
		void*p=page->buffer+(position&Page::MASK);
		if(!(!checked||!isAllocated(reinterpret_cast<char*>(p), reinterpret_cast<char*>(p)+size)))
		{
			throw AllocatorError();
		};
		std::uninitialized_fill(reinterpret_cast<char*>(p), reinterpret_cast<char*>(p)+size, char(0xcd));
		position+=size;
		return p;
	}
	void deallocate(void*p, size_t size)
	{
		std::uninitialized_fill(reinterpret_cast<char*>(p), reinterpret_cast<char*>(p)+size, char(0xba));
	}
	void backtrack(size_t original)
	{
		if(!(original<=position))
		{
			throw AllocatorError();
		};
		Pages::iterator first=pages.begin()+original/sizeof(Page);
		Pages::iterator last=pages.begin()+position/sizeof(Page);
		for(Pages::iterator i=first;
		i!=pages.end();
		++i)
		{
			if(!(!checked||!isAllocated((*i)->buffer+(i==first?original%sizeof(Page): 0), (*i)->buffer+(i==last?position%sizeof(Page): sizeof(Page)))))
			{
				throw AllocatorError();
			};
			if(i==last)
			{
				break;
			}
		}
		position=original;
	}
};
template<bool checked>
void*LinearAllocator<checked>::debugAddress;
template<bool checked>
char LinearAllocator<checked>::debugValue[4];
template<bool checked>
size_t LinearAllocator<checked>::debugAllocationId=0xffffffff;
typedef LinearAllocator<true>CheckedLinearAllocator;
inline CheckedLinearAllocator&NullAllocator()
{
	static CheckedLinearAllocator null;
	return null;
}
template<typename T, typename Instance=CheckedLinearAllocator>
class LinearAllocatorWrapper
{
public:
	Instance&instance;
	typedef T value_type;
	typedef T*pointer;
	typedef T&reference;
	typedef const T*const_pointer;
	typedef const T&const_reference;
	typedef std::size_t size_type;
	typedef std::ptrdiff_t difference_type;
	template<typename OtherT>
	struct rebind
	{
		typedef LinearAllocatorWrapper<OtherT, Instance>other;
	};
	LinearAllocatorWrapper(): instance(NullAllocator())
	{
		throw AllocatorError();
	}
	LinearAllocatorWrapper(Instance&instance): instance(instance)
	{
	}
	LinearAllocatorWrapper(const LinearAllocatorWrapper<T, Instance>&other): instance(other.instance)
	{
	}
	template<typename OtherT>
	LinearAllocatorWrapper(const LinearAllocatorWrapper<OtherT, Instance>&other): instance(other.instance)
	{
	}
	template<typename OtherT>
	LinearAllocatorWrapper<T>&operator=(const LinearAllocatorWrapper<OtherT, Instance>&other)
	{
		if(this!=&other)
		{
			this->~LinearAllocatorWrapper();
			new(this)LinearAllocatorWrapper(other);
		}
		return (*this);
	}
	void deallocate(pointer p, size_type count)
	{
		instance.deallocate(p, count*sizeof(T)+sizeof(size_t));
	}
	pointer allocate(size_type count)
	{
		pointer p=pointer(instance.allocate(count*sizeof(T)+sizeof(size_t)));
		return p;
	}
	pointer allocate(size_type count, const void*hint)
	{
		return allocate(count);
	}
	void construct(pointer p, const T&value)
	{
		new(p)T(value);
	}
	void destroy(pointer p)
	{
		p->~T();
	}
	size_type max_size()const
	{
		size_type _Count=size_type(-1)/sizeof(T);
		return (0<_Count?_Count: 1);
	}
};
template<typename T, typename Instance, typename OtherT>
inline bool operator==(const LinearAllocatorWrapper<T, Instance>&, const LinearAllocatorWrapper<OtherT, Instance>&)
{
	return true;
}
template<typename T, typename Instance, typename OtherT>
inline bool operator!=(const LinearAllocatorWrapper<T, Instance>&, const LinearAllocatorWrapper<OtherT, Instance>&)
{
	return false;
}
template<typename T>
inline void checkAllocation(LinearAllocatorWrapper<T>&a, T*p)
{
	if(CheckedLinearAllocator::debugAddress==p)
	{
		std::cout<<"debug allocation!"<<std::endl;
	}
	if(CheckedLinearAllocator::debugAddress>=p&&CheckedLinearAllocator::debugAddress<p+1)
	{
		if(memcmp(CheckedLinearAllocator::debugAddress, CheckedLinearAllocator::debugValue, 1)==0)
		{
			std::cout<<"debug allocation!"<<std::endl;
		}
	}
}
template<typename A, typename T>
inline void checkAllocation(A&a, T*p)
{
}
template<typename T, typename A>
inline T*allocatorNew(const A&a, const T&value)
{
	typename A::template rebind<T>::other tmp(a);
	T*p=tmp.allocate(1);
	tmp.construct(p, value);
	checkAllocation(tmp, p);
	return p;
}
template<typename T, typename A>
void allocatorDelete(const A&a, T*p)
{
	if(p!=0)
	{
		typename A::template rebind<T>::other tmp(a);
		tmp.destroy(p);
		tmp.deallocate(p, 1);
	}
}
template<typename T>
struct TypeTraits
{
	typedef T Value;
};
template<typename T>
struct TypeTraits<const T>
{
	typedef T Value;
};
struct TrueSized
{
	char m[1];
};
struct FalseSized
{
	char m[2];
};
template<typename T, typename Base>
struct IsConvertible
{
	static TrueSized test(Base*);
	static FalseSized test(...);
	static const bool RESULT=sizeof(IsConvertible<T, Base>::test(static_cast<T*>(0)))==sizeof(TrueSized);
};
template<bool b>
struct CompileTimeAssert;
template<>
struct CompileTimeAssert<true>
{
};
template<typename T>
struct ReferenceCounted: T
{
	size_t count;
	ReferenceCounted(): count(0)
	{
	}
	ReferenceCounted(const T&value): T(value), count(0)
	{
	}
	~ReferenceCounted()
	{
		if(!(count==0))
		{
			throw AllocatorError();
		};
	}
};
template<typename T>
inline ReferenceCounted<T>makeReferenceCounted(const T&t)
{
	return ReferenceCounted<T>(t);
}
template<typename T>
struct Reference
{
	typedef typename TypeTraits<T>::Value value_type;
	typedef ReferenceCounted<value_type>Value;
	void decrement()
	{
		if(p!=0)
		{
			--p->count;
		}
	}
	void increment()
	{
		if(p!=0)
		{
			++p->count;
		}
	}
	Value*p;
	Reference(): p(0)
	{
	}
	Reference(Value*p): p(p)
	{
		increment();
	}
	~Reference()
	{
		decrement();
	}
	Reference(const Reference&other): p(other.p)
	{
		increment();
	}
	Reference&operator=(Reference tmp)
	{
		tmp.swap(*this);
		return *this;
	}
	bool empty()const
	{
		return p==0;
	}
	void swap(Reference&other)
	{
		std::swap(p, other.p);
	}
	T&operator*()const
	{
		return *p;
	}
	T*operator->()const
	{
		return p;
	}
	T*get()const
	{
		return p;
	}
};
template<typename T, typename Other>
inline bool operator==(const Reference<T>&l, const Reference<Other>&r)
{
	return l.p==r.p;
}
template<typename T, typename Other>
inline bool operator!=(const Reference<T>&l, const Reference<Other>&r)
{
	return !(l==r);
}
namespace std
{
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(_Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(_Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(1, _Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(_Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem _Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(_Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator==(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Left.compare(_Right)==0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator==(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Right.compare(_Left)==0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator==(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (_Left.compare(_Right)==0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator!=(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Left.compare(_Right)<0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Right.compare(_Left)>0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (_Left.compare(_Right)<0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (_Right<_Left);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<=(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>=(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, basic_string<_Elem, _Traits, _Alloc>&_Str)
	{
		typedef ctype<_Elem>_Ctype;
		typedef basic_istream<_Elem, _Traits>_Myis;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystr;
		typedef typename _Mystr::size_type _Mysizt;
		ios_base::iostate _State=ios_base::goodbit;
		bool _Changed=false;
		const typename _Myis::sentry _Ok(_Istr);
		if(_Ok)
		{
			const _Ctype&_Ctype_fac=use_facet<_Ctype>(_Istr.getloc());
			_Str.erase();
			try
			{
				_Mysizt _Size=0<_Istr.width()&&(_Mysizt)_Istr.width()<_Str.max_size()?(_Mysizt)_Istr.width(): _Str.max_size();
				typename _Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
				for(;
				0<_Size;
				--_Size, _Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
					_State|=ios_base::eofbit;
					break;
				}
				else if(_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))break;
				else
				{
					_Str.append(1, _Traits::to_char_type(_Meta));
					_Changed=true;
				}
			}
			catch(...)
			{
				(_Istr).setstate(ios_base::badbit, true);
			}
		}
		_Istr.width(0);
		if(!_Changed)_State|=ios_base::failbit;
		_Istr.setstate(_State);
		return (_Istr);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_istream<_Elem, _Traits>&getline(basic_istream<_Elem, _Traits>&_Istr, basic_string<_Elem, _Traits, _Alloc>&_Str, const _Elem _Delim)
	{
		typedef basic_istream<_Elem, _Traits>_Myis;
		ios_base::iostate _State=ios_base::goodbit;
		bool _Changed=false;
		const typename _Myis::sentry _Ok(_Istr, true);
		if(_Ok)
		{
			try
			{
				_Str.erase();
				const typename _Traits::int_type _Metadelim=_Traits::to_int_type(_Delim);
				typename _Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
				for(;
				;
				_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
					_State|=ios_base::eofbit;
					break;
				}
				else if(_Traits::eq_int_type(_Meta, _Metadelim))
				{
					_Changed=true;
					_Istr.rdbuf()->sbumpc();
					break;
				}
				else if(_Str.max_size()<=_Str.size())
				{
					_State|=ios_base::failbit;
					break;
				}
				else
				{
					_Str+=_Traits::to_char_type(_Meta);
					_Changed=true;
				}
			}
			catch(...)
			{
				(_Istr).setstate(ios_base::badbit, true);
			}
		}
		if(!_Changed)_State|=ios_base::failbit;
		_Istr.setstate(_State);
		return (_Istr);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_istream<_Elem, _Traits>&getline(basic_istream<_Elem, _Traits>&_Istr, basic_string<_Elem, _Traits, _Alloc>&_Str)
	{
		return (getline(_Istr, _Str, _Istr.widen('\n')));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const basic_string<_Elem, _Traits, _Alloc>&_Str)
	{
		typedef basic_ostream<_Elem, _Traits>_Myos;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystr;
		typedef typename _Mystr::size_type _Mysizt;
		ios_base::iostate _State=ios_base::goodbit;
		_Mysizt _Size=_Str.size();
		_Mysizt _Pad=_Ostr.width()<=0||(_Mysizt)_Ostr.width()<=_Size?0: (_Mysizt)_Ostr.width()-_Size;
		const typename _Myos::sentry _Ok(_Ostr);
		if(!_Ok)_State|=ios_base::badbit;
		else
		{
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				if(_State==ios_base::goodbit)for(_Mysizt _Count=0;
				_Count<_Size;
				++_Count)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Str[_Count])))
				{
					_State|=ios_base::badbit;
					break;
				}
				if(_State==ios_base::goodbit)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				_Ostr.width(0);
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.setstate(_State);
		return (_Ostr);
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace exception_detail
	{
		template<class T>
		class refcount_ptr
		{
		public:
			refcount_ptr(): px_(0)
			{
			}
			~refcount_ptr()
			{
				release();
			}
			refcount_ptr(refcount_ptr const&x): px_(x.px_)
			{
				add_ref();
			}
			refcount_ptr&operator=(refcount_ptr const&x)
			{
				adopt(x.px_);
				return *this;
			}
			void adopt(T*px)
			{
				release();
				px_=px;
				add_ref();
			}
			T*get()const
			{
				return px_;
			}
		private:
			T*px_;
			void add_ref()
			{
				if(px_)px_->add_ref();
			}
			void release()
			{
				if(px_)px_->release();
			}
		};
	}
	template<class Tag, class T>
	class error_info;
	typedef error_info<struct throw_function_, char const*>throw_function;
	typedef error_info<struct throw_file_, char const*>throw_file;
	typedef error_info<struct throw_line_, int>throw_line;
	template<>
	class error_info<throw_function_, char const*>
	{
	public:
		typedef char const*value_type;
		value_type v_;
		explicit error_info(value_type v): v_(v)
		{
		}
	};
	template<>
	class error_info<throw_file_, char const*>
	{
	public:
		typedef char const*value_type;
		value_type v_;
		explicit error_info(value_type v): v_(v)
		{
		}
	};
	template<>
	class error_info<throw_line_, int>
	{
	public:
		typedef int value_type;
		value_type v_;
		explicit error_info(value_type v): v_(v)
		{
		}
	};
	template<class E, class Tag, class T>
	E const&operator<<(E const&, error_info<Tag, T>const&);
	class exception;
	template<class>
	class shared_ptr;
	namespace exception_detail
	{
		class error_info_base;
		struct type_info_;
		struct error_info_container
		{
			virtual char const*diagnostic_information(char const*)const=0;
			virtual shared_ptr<error_info_base>get(type_info_ const&)const=0;
			virtual void set(shared_ptr<error_info_base>const&, type_info_ const&)=0;
			virtual void add_ref()const=0;
			virtual void release()const=0;
			protected: virtual~error_info_container()throw()
			{
			}
		};
		template<class>
		struct get_info;
		template<>
		struct get_info<throw_function>;
		template<>
		struct get_info<throw_file>;
		template<>
		struct get_info<throw_line>;
		char const*get_diagnostic_information(exception const&, char const*);
	}
	class exception
	{
		protected: exception(): throw_function_(0), throw_file_(0), throw_line_(-1)
		{
		}
		virtual~exception()throw()=0;
	private:
		template<class E>
		friend E const&operator<<(E const&x, throw_function const&y)
		{
			x.throw_function_=y.v_;
			return x;
		}
		template<class E>
		friend E const&operator<<(E const&x, throw_file const&y)
		{
			x.throw_file_=y.v_;
			return x;
		}
		template<class E>
		friend E const&operator<<(E const&x, throw_line const&y)
		{
			x.throw_line_=y.v_;
			return x;
		}
		friend char const*exception_detail::get_diagnostic_information(exception const&, char const*);
		template<class E, class Tag, class T>
		friend E const&operator<<(E const&, error_info<Tag, T>const&);
		template<class>
		friend struct exception_detail::get_info;
		friend struct exception_detail::get_info<throw_function>;
		friend struct exception_detail::get_info<throw_file>;
		friend struct exception_detail::get_info<throw_line>;
		mutable exception_detail::refcount_ptr<exception_detail::error_info_container>data_;
		mutable char const*throw_function_;
		mutable char const*throw_file_;
		mutable int throw_line_;
	};
	inline exception::~exception()throw()
	{
	}
	namespace exception_detail
	{
		template<class T>
		struct error_info_injector: public T, public exception
		{
			explicit error_info_injector(T const&x): T(x)
			{
			}
			~error_info_injector()throw()
			{
			}
		};
		struct large_size
		{
			char c[256];
		};
		large_size dispatch(exception*);
		struct small_size
		{
		};
		small_size dispatch(void*);
		template<class, int>
		struct enable_error_info_helper;
		template<class T>
		struct enable_error_info_helper<T, sizeof(large_size)>
		{
			typedef T type;
		};
		template<class T>
		struct enable_error_info_helper<T, sizeof(small_size)>
		{
			typedef error_info_injector<T>type;
		};
		template<class T>
		struct enable_error_info_return_type
		{
			typedef typename enable_error_info_helper<T, sizeof(dispatch((T*)0))>::type type;
		};
	}
	template<class T>
	inline typename exception_detail::enable_error_info_return_type<T>::type enable_error_info(T const&x)
	{
		typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
		return rt(x);
	}
	namespace exception_detail
	{
		class clone_base
		{
		public:
			virtual clone_base const*clone()const=0;
			virtual void rethrow()const=0;
			virtual~clone_base()throw()
			{
			}
		};
		inline void copy_boost_exception(exception*a, exception const*b)
		{
			*a=*b;
		}
		inline void copy_boost_exception(void*, void const*)
		{
		}
		template<class T>
		class clone_impl: public T, public clone_base
		{
		public:
			explicit clone_impl(T const&x): T(x)
			{
				copy_boost_exception(this, &x);
			}
			~clone_impl()throw()
			{
			}
		private:
			clone_base const*clone()const
			{
				return new clone_impl(*this);
			}
			void rethrow()const
			{
				throw*this;
			}
		};
	}
	template<class T>
	inline exception_detail::clone_impl<T>enable_current_exception(T const&x)
	{
		return exception_detail::clone_impl<T>(x);
	}
}
namespace boost
{
	namespace detail
	{
		inline void current_function_helper()
		{
		}
	}
}
namespace boost
{
	void throw_exception(std::exception const&e);
}
namespace boost
{
	namespace detail
	{
		template<class Category, class T, class Distance, class Pointer, class Reference>
		struct iterator_base: std::iterator<Category, T, Distance, Pointer, Reference>
		{
		};
	}
	template<class Category, class T, class Distance=std::ptrdiff_t, class Pointer=T*, class Reference=T&>
	struct iterator: boost::detail::iterator_base<Category, T, Distance, Pointer, Reference>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<class T>
		struct addr_impl_ref
		{
			T&v_;
			inline addr_impl_ref(T&v): v_(v)
			{
			}
			inline operator T&()const
			{
				return v_;
			}
		private:
			addr_impl_ref&operator=(const addr_impl_ref&);
		};
		template<class T>
		struct addressof_impl
		{
			static inline T*f(T&v, long)
			{
				return reinterpret_cast<T*>(&const_cast<char&>(reinterpret_cast<const volatile char&>(v)));
			}
			static inline T*f(T*v, int)
			{
				return v;
			}
		};
	}
	template<class T>
	T*addressof(T&v)
	{
		return boost::detail::addressof_impl<T>::f(boost::detail::addr_impl_ref<T>(v), 0);
	}
}
namespace boost
{
	template<typename MemberType, int UniqueID=0>
	class base_from_member
	{
		protected: MemberType member;
		base_from_member(): member()
		{
		}
		template<typename T0>
		explicit base_from_member(T0 x0): member(x0)
		{
		}
		template<typename T0, typename T1>
		explicit base_from_member(T0 x0, T1 x1): member(x0, x1)
		{
		}
		template<typename T0, typename T1, typename T2>
		explicit base_from_member(T0 x0, T1 x1, T2 x2): member(x0, x1, x2)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3): member(x0, x1, x2, x3)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4): member(x0, x1, x2, x3, x4)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5): member(x0, x1, x2, x3, x4, x5)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6): member(x0, x1, x2, x3, x4, x5, x6)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7): member(x0, x1, x2, x3, x4, x5, x6, x7)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7, T8 x8): member(x0, x1, x2, x3, x4, x5, x6, x7, x8)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7, T8 x8, T9 x9): member(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
		{
		}
	};
}
namespace boost
{
	template<bool B, class T=void>
	struct enable_if_c
	{
		typedef T type;
	};
	template<class T>
	struct enable_if_c<false, T>
	{
	};
	template<class Cond, class T=void>
	struct enable_if: public enable_if_c<Cond::value, T>
	{
	};
	template<bool B, class T>
	struct lazy_enable_if_c
	{
		typedef typename T::type type;
	};
	template<class T>
	struct lazy_enable_if_c<false, T>
	{
	};
	template<class Cond, class T>
	struct lazy_enable_if: public lazy_enable_if_c<Cond::value, T>
	{
	};
	template<bool B, class T=void>
	struct disable_if_c
	{
		typedef T type;
	};
	template<class T>
	struct disable_if_c<true, T>
	{
	};
	template<class Cond, class T=void>
	struct disable_if: public disable_if_c<Cond::value, T>
	{
	};
	template<bool B, class T>
	struct lazy_disable_if_c
	{
		typedef typename T::type type;
	};
	template<class T>
	struct lazy_disable_if_c<true, T>
	{
	};
	template<class Cond, class T>
	struct lazy_disable_if: public lazy_disable_if_c<Cond::value, T>
	{
	};
}
namespace boost
{
	template<class T>
	inline void checked_delete(T*x)
	{
		typedef char type_must_be_complete[sizeof(T)?1: -1];
		(void)sizeof(type_must_be_complete);
		delete x;
	}
	template<class T>
	inline void checked_array_delete(T*x)
	{
		typedef char type_must_be_complete[sizeof(T)?1: -1];
		(void)sizeof(type_must_be_complete);
		delete[]x;
	}
	template<class T>
	struct checked_deleter
	{
		typedef void result_type;
		typedef T*argument_type;
		void operator()(T*x)const
		{
			boost::checked_delete(x);
		}
	};
	template<class T>
	struct checked_array_deleter
	{
		typedef void result_type;
		typedef T*argument_type;
		void operator()(T*x)const
		{
			boost::checked_array_delete(x);
		}
	};
}
namespace boost
{
	template<class T>
	inline T next(T x)
	{
		return ++x;
	}
	template<class T, class Distance>
	inline T next(T x, Distance n)
	{
		std::advance(x, n);
		return x;
	}
	template<class T>
	inline T prior(T x)
	{
		return --x;
	}
	template<class T, class Distance>
	inline T prior(T x, Distance n)
	{
		std::advance(x, -n);
		return x;
	}
}
namespace boost
{
	namespace noncopyable_
	{
		class noncopyable
		{
			protected: noncopyable()
			{
			}
			~noncopyable()
			{
			}
		private:
			noncopyable(const noncopyable&);
			const noncopyable&operator=(const noncopyable&);
		};
	}
	typedef noncopyable_::noncopyable noncopyable;
}
namespace boost
{
	template<bool x>
	struct STATIC_ASSERTION_FAILURE;
	template<>
	struct STATIC_ASSERTION_FAILURE<true>
	{
		enum
		{
			value=1
		};
	};
	template<int x>
	struct static_assert_test
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<class Iterator>
		struct iterator_traits: std::iterator_traits<Iterator>
		{
		};
		using std::distance;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct value_type_wknd
			{
				typedef typename T::value_type type;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		struct void_;
	}
}
namespace boost
{
	namespace mpl
	{
		template<bool C_>
		struct bool_;
		typedef bool_<true>true_;
		typedef bool_<false>false_;
	}
}
namespace boost
{
	namespace mpl
	{
		struct integral_c_tag
		{
			static const int value=0;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<bool C_>
		struct bool_
		{
			static const bool value=C_;
			typedef integral_c_tag tag;
			typedef bool_ type;
			typedef bool value_type;
			operator bool()const
			{
				return this->value;
			}
		};
		template<bool C_>
		bool const bool_<C_>::value;
	}
}
namespace boost
{
	namespace mpl
	{
		struct na
		{
			typedef na type;
			enum
			{
				value=0
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T>
		struct is_na: false_
		{
		};
		template<>
		struct is_na<na>: true_
		{
		};
		template<typename T>
		struct is_not_na: true_
		{
		};
		template<>
		struct is_not_na<na>: false_
		{
		};
		template<typename T, typename U>
		struct if_na
		{
			typedef T type;
		};
		template<typename U>
		struct if_na<na, U>
		{
			typedef U type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<int N>
		struct int_;
	}
}
namespace boost
{
	namespace mpl
	{
		template<int N>
		struct int_
		{
			static const int value=N;
			typedef int_ type;
			typedef int value_type;
			typedef integral_c_tag tag;
			typedef boost::mpl::int_<static_cast<int>((value+1))>next;
			typedef boost::mpl::int_<static_cast<int>((value-1))>prior;
			operator int()const
			{
				return static_cast<int>(this->value);
			}
		};
		template<int N>
		int const boost::mpl::int_<N>::value;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename F>
			struct template_arity;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na, typename Tag=void_>
		struct lambda;
	}
}
namespace boost
{
	namespace mpl
	{
		template<bool C, typename T1, typename T2>
		struct if_c
		{
			typedef T1 type;
		};
		template<typename T1, typename T2>
		struct if_c<false, T1, T2>
		{
			typedef T2 type;
		};
		template<typename T1=na, typename T2=na, typename T3=na>
		struct if_
		{
		private:
			typedef if_c<static_cast<bool>(T1::value), T2, T3>almost_type_;
		public:
			typedef typename almost_type_::type type;
		};
		template<>
		struct if_<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: if_<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<if_<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef if_<na, na, na>result_;
			typedef if_<na, na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename C=na, typename F1=na, typename F2=na>
		struct eval_if: if_<C, F1, F2>::type
		{
		};
		template<bool C, typename F1, typename F2>
		struct eval_if_c: if_c<C, F1, F2>::type
		{
		};
		template<>
		struct eval_if<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: eval_if<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<eval_if<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef eval_if<na, na, na>result_;
			typedef eval_if<na, na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na>
		struct identity
		{
			typedef T type;
		};
		template<typename T=na>
		struct make_identity
		{
			typedef identity<T>type;
		};
		template<>
		struct identity<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: identity<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<identity<na>, Tag>
		{
			typedef false_ is_le;
			typedef identity<na>result_;
			typedef identity<na>type;
		};
		template<>
		struct make_identity<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: make_identity<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<make_identity<na>, Tag>
		{
			typedef false_ is_le;
			typedef make_identity<na>result_;
			typedef make_identity<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<int N>
		struct arg;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<long C_>
			struct not_impl: bool_<!C_>
			{
			};
		}
		template<typename T=na>
		struct not_: aux::not_impl<T::type::value>
		{
		};
		template<>
		struct not_<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: not_<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<not_<na>, Tag>
		{
			typedef false_ is_le;
			typedef not_<na>result_;
			typedef not_<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			typedef char(&no_tag)[1];
			typedef char(&yes_tag)[2];
			template<bool C_>
			struct yes_no_tag
			{
				typedef no_tag type;
			};
			template<>
			struct yes_no_tag<true>
			{
				typedef yes_tag type;
			};
			template<long n>
			struct weighted_tag
			{
				typedef char(&type)[n];
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		struct failed
		{
		};
		template<bool C>
		struct assert
		{
			typedef void*type;
		};
		template<>
		struct assert<false>
		{
			typedef assert type;
		};
		template<bool C>
		int assertion_failed(typename assert<C>::type);
		template<bool C>
		struct assertion
		{
			static int failed(assert<false>);
		};
		template<>
		struct assertion<true>
		{
			static int failed(void*);
		};
		struct assert_
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na>
			struct types
			{
			};
			static assert_ const arg;
			enum relations
			{
				equal=1, not_equal, greater, greater_equal, less, less_equal
			};
		};
		bool operator==(failed, failed);
		bool operator!=(failed, failed);
		bool operator>(failed, failed);
		bool operator>=(failed, failed);
		bool operator<(failed, failed);
		bool operator<=(failed, failed);
		template<long x, long y, bool(*)(failed, failed)>
		struct assert_relation
		{
		};
		template<bool>
		struct assert_arg_pred_impl
		{
			typedef int type;
		};
		template<>
		struct assert_arg_pred_impl<true>
		{
			typedef void*type;
		};
		template<typename P>
		struct assert_arg_pred
		{
			typedef typename P::type p_type;
			typedef typename assert_arg_pred_impl<p_type::value>::type type;
		};
		template<typename P>
		struct assert_arg_pred_not
		{
			typedef typename P::type p_type;
			static const bool p=!p_type::value;
			typedef typename assert_arg_pred_impl<p>::type type;
		};
		template<typename Pred>
		failed************(Pred::************assert_arg(void(*)(Pred), typename assert_arg_pred<Pred>::type));
		template<typename Pred>
		failed************(boost::mpl::not_<Pred>::************assert_not_arg(void(*)(Pred), typename assert_arg_pred_not<Pred>::type));
		template<typename Pred>
		assert<false>assert_arg(void(*)(Pred), typename assert_arg_pred_not<Pred>::type);
		template<typename Pred>
		assert<false>assert_not_arg(void(*)(Pred), typename assert_arg_pred<Pred>::type);
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct arg<-1>
		{
			static const int value=-1;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U1 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<1>
		{
			static const int value=1;
			typedef arg<2>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U1 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<2>
		{
			static const int value=2;
			typedef arg<3>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U2 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<3>
		{
			static const int value=3;
			typedef arg<4>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U3 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<4>
		{
			static const int value=4;
			typedef arg<5>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U4 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<5>
		{
			static const int value=5;
			typedef arg<6>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U5 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<-1>_;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<1>_1;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_1;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<2>_2;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_2;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<3>_3;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_3;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<4>_4;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_4;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<5>_5;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_5;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<6>_6;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_6;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T, T N>
		struct integral_c;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T, T N>
		struct integral_c
		{
			static const T value=N;
			typedef integral_c type;
			typedef T value_type;
			typedef integral_c_tag tag;
			typedef integral_c<T, static_cast<T>((value+1))>next;
			typedef integral_c<T, static_cast<T>((value-1))>prior;
			operator T()const
			{
				return static_cast<T>(this->value);
			}
		};
		template<typename T, T N>
		T const integral_c<T, N>::value;
	}
}
namespace boost
{
	namespace mpl
	{
		template<bool C>
		struct integral_c<bool, C>
		{
			static const bool value=C;
			typedef integral_c_tag tag;
			typedef integral_c type;
			typedef bool value_type;
			operator bool()const
			{
				return this->value;
			}
		};
	}
}
namespace boost
{
	template<class T, T val>
	struct integral_constant: public mpl::integral_c<T, val>
	{
		typedef integral_constant<T, val>type;
	};
	template<>
	struct integral_constant<bool, true>: public mpl::true_
	{
		typedef integral_constant<bool, true>type;
	};
	template<>
	struct integral_constant<bool, false>: public mpl::false_
	{
		typedef integral_constant<bool, false>type;
	};
	typedef integral_constant<bool, true>true_type;
	typedef integral_constant<bool, false>false_type;
}
namespace boost
{
	template<typename T, typename U>
	struct is_same: ::boost::integral_constant<bool, false>
	{
	};
	template<typename T>
	struct is_same<T, T>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace type_traits
	{
		typedef char yes_type;
		struct no_type
		{
			char padding[8];
		};
	}
}
namespace boost
{
	template<typename T>
	struct is_array: ::boost::integral_constant<bool, false>
	{
	};
	template<typename T, std::size_t N>
	struct is_array<T[N]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, std::size_t N>
	struct is_array<T const[N]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, std::size_t N>
	struct is_array<T volatile[N]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, std::size_t N>
	struct is_array<T const volatile[N]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T>
	struct is_array<T[]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T>
	struct is_array<T const[]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T>
	struct is_array<T volatile[]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T>
	struct is_array<T const volatile[]>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_reference: ::boost::integral_constant<bool, false>
	{
	};
	template<typename T>
	struct is_reference<T&>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct add_reference_impl
		{
			typedef T&type;
		};
		template<typename T>
		struct add_reference_impl<T&>
		{
			typedef T&type;
		};
		template<>
		struct add_reference_impl<void>
		{
			typedef void type;
		};
		template<>
		struct add_reference_impl<void const>
		{
			typedef void const type;
		};
		template<>
		struct add_reference_impl<void volatile>
		{
			typedef void volatile type;
		};
		template<>
		struct add_reference_impl<void const volatile>
		{
			typedef void const volatile type;
		};
	}
	template<typename T>
	struct add_reference
	{
		typedef typename boost::detail::add_reference_impl<T>::type type;
	};
}
namespace boost
{
	namespace type_traits
	{
		template<bool b1, bool b2, bool b3=false, bool b4=false, bool b5=false, bool b6=false, bool b7=false>
		struct ice_or;
		template<bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
		struct ice_or
		{
			static const bool value=true;
		};
		template<>
		struct ice_or<false, false, false, false, false, false, false>
		{
			static const bool value=false;
		};
	}
}
namespace boost
{
	namespace type_traits
	{
		template<bool b1, bool b2, bool b3=true, bool b4=true, bool b5=true, bool b6=true, bool b7=true>
		struct ice_and;
		template<bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
		struct ice_and
		{
			static const bool value=false;
		};
		template<>
		struct ice_and<true, true, true, true, true, true, true>
		{
			static const bool value=true;
		};
	}
}
namespace boost
{
	namespace type_traits
	{
		template<bool b>
		struct ice_not
		{
			static const bool value=true;
		};
		template<>
		struct ice_not<true>
		{
			static const bool value=false;
		};
	}
}
namespace boost
{
	namespace type_traits
	{
		template<int b1, int b2>
		struct ice_eq
		{
			static const bool value=(b1==b2);
		};
		template<int b1, int b2>
		struct ice_ne
		{
			static const bool value=(b1!=b2);
		};
		template<int b1, int b2>
		bool const ice_eq<b1, b2>::value;
		template<int b1, int b2>
		bool const ice_ne<b1, b2>::value;
	}
}
namespace boost
{
	template<typename T>
	struct is_integral: ::boost::integral_constant<bool, false>
	{
	};
	template<>
	struct is_integral<unsigned char>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned char const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned char volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned char const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned short>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned short const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned short volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned short const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned int>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned int const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned int volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned int const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned long>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned long const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned long volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned long const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed char>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed char const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed char volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed char const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed short>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed short const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed short volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed short const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed int>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed int const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed int volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed int const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed long>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed long const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed long volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed long const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<bool>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<bool const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<bool volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<bool const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<char>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<char const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<char volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<char const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<wchar_t>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<wchar_t const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<wchar_t volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<wchar_t const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned __int64>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned __int64 const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned __int64 volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned __int64 const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<__int64>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<__int64 const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<__int64 volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<__int64 const volatile>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_float: ::boost::integral_constant<bool, false>
	{
	};
	template<>
	struct is_float<float>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<float const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<float volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<float const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<double>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<double const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<double volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<double const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<long double>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<long double const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<long double volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<long double const volatile>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_arithmetic_impl
		{
			static const bool value=(::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value>::value);
		};
	}
	template<typename T>
	struct is_arithmetic: ::boost::integral_constant<bool, ::boost::detail::is_arithmetic_impl<T>::value>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_void: ::boost::integral_constant<bool, false>
	{
	};
	template<>
	struct is_void<void>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_void<void const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_void<void volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_void<void const volatile>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<class T>
		struct is_abstract_imp
		{
			static const bool value=__is_abstract(T);
		};
	}
	template<typename T>
	struct is_abstract: ::boost::integral_constant<bool, ::boost::detail::is_abstract_imp<T>::value>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename From, typename To>
		struct is_convertible_basic_impl
		{
			static::boost::type_traits::no_type _m_check(...);
			static::boost::type_traits::yes_type _m_check(To);
			static From _m_from;
			static const bool value=sizeof(_m_check(_m_from))==sizeof(::boost::type_traits::yes_type);
		};
		template<typename From, typename To>
		struct is_convertible_impl
		{
			typedef typename add_reference<From>::type ref_type;
			static const bool value=(::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::detail::is_convertible_basic_impl<ref_type, To>::value, ::boost::is_void<To>::value>::value, ::boost::type_traits::ice_not< ::boost::is_array<To>::value>::value>::value);
		};
		template<bool trivial1, bool trivial2, bool abstract_target>
		struct is_convertible_impl_select
		{
			template<class From, class To>
			struct rebind
			{
				typedef is_convertible_impl<From, To>type;
			};
		};
		template<>
		struct is_convertible_impl_select<true, true, false>
		{
			template<class From, class To>
			struct rebind
			{
				typedef true_type type;
			};
		};
		template<>
		struct is_convertible_impl_select<false, false, true>
		{
			template<class From, class To>
			struct rebind
			{
				typedef false_type type;
			};
		};
		template<>
		struct is_convertible_impl_select<true, false, true>
		{
			template<class From, class To>
			struct rebind
			{
				typedef false_type type;
			};
		};
		template<typename From, typename To>
		struct is_convertible_impl_dispatch_base
		{
			typedef is_convertible_impl_select< ::boost::is_arithmetic<From>::value, ::boost::is_arithmetic<To>::value, ::boost::is_abstract<To>::value>selector;
			typedef typename selector::template rebind<From, To>isc_binder;
			typedef typename isc_binder::type type;
		};
		template<typename From, typename To>
		struct is_convertible_impl_dispatch: public is_convertible_impl_dispatch_base<From, To>::type
		{
		};
		template<>
		struct is_convertible_impl<void, void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void, void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void, void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void, void const volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const, void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const, void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const, void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const, void const volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void volatile, void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void volatile, void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void volatile, void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void volatile, void const volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const volatile, void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const volatile, void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const volatile, void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const volatile, void const volatile>
		{
			static const bool value=(true);
		};
		template<typename To>
		struct is_convertible_impl<void, To>
		{
			static const bool value=(false);
		};
		template<typename From>
		struct is_convertible_impl<From, void>
		{
			static const bool value=(true);
		};
		template<typename To>
		struct is_convertible_impl<void const, To>
		{
			static const bool value=(false);
		};
		template<typename To>
		struct is_convertible_impl<void volatile, To>
		{
			static const bool value=(false);
		};
		template<typename To>
		struct is_convertible_impl<void const volatile, To>
		{
			static const bool value=(false);
		};
		template<typename From>
		struct is_convertible_impl<From, void const>
		{
			static const bool value=(true);
		};
		template<typename From>
		struct is_convertible_impl<From, void volatile>
		{
			static const bool value=(true);
		};
		template<typename From>
		struct is_convertible_impl<From, void const volatile>
		{
			static const bool value=(true);
		};
	}
	template<typename From, typename To>
	struct is_convertible: ::boost::integral_constant<bool, (::boost::detail::is_convertible_impl_dispatch<From, To>::value)>
	{
	};
}
namespace boost
{
	struct no_traversal_tag
	{
	};
	struct incrementable_traversal_tag: no_traversal_tag
	{
	};
	struct single_pass_traversal_tag: incrementable_traversal_tag
	{
	};
	struct forward_traversal_tag: single_pass_traversal_tag
	{
	};
	struct bidirectional_traversal_tag: forward_traversal_tag
	{
	};
	struct random_access_traversal_tag: bidirectional_traversal_tag
	{
	};
	namespace detail
	{
		template<class Cat>
		struct old_category_to_traversal: mpl::eval_if<is_convertible<Cat, std::random_access_iterator_tag>, mpl::identity<random_access_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::bidirectional_iterator_tag>, mpl::identity<bidirectional_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::forward_iterator_tag>, mpl::identity<forward_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::input_iterator_tag>, mpl::identity<single_pass_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::output_iterator_tag>, mpl::identity<incrementable_traversal_tag>, void> > > > >
		{
		};
		template<class Traversal>
		struct pure_traversal_tag: mpl::eval_if<is_convertible<Traversal, random_access_traversal_tag>, mpl::identity<random_access_traversal_tag>, mpl::eval_if<is_convertible<Traversal, bidirectional_traversal_tag>, mpl::identity<bidirectional_traversal_tag>, mpl::eval_if<is_convertible<Traversal, forward_traversal_tag>, mpl::identity<forward_traversal_tag>, mpl::eval_if<is_convertible<Traversal, single_pass_traversal_tag>, mpl::identity<single_pass_traversal_tag>, mpl::eval_if<is_convertible<Traversal, incrementable_traversal_tag>, mpl::identity<incrementable_traversal_tag>, void> > > > >
		{
		};
	}
	template<class Cat>
	struct iterator_category_to_traversal: mpl::eval_if<is_convertible<Cat, incrementable_traversal_tag>, mpl::identity<Cat>, boost::detail::old_category_to_traversal<Cat> >
	{
	};
	template<class Iterator=mpl::_1>
	struct iterator_traversal: iterator_category_to_traversal<typename boost::detail::iterator_traits<Iterator>::iterator_category>
	{
	};
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<bool C_, typename T1, typename T2, typename T3, typename T4>
			struct or_impl: true_
			{
			};
			template<typename T1, typename T2, typename T3, typename T4>
			struct or_impl<false, T1, T2, T3, T4>: or_impl<T1::type::value, T2, T3, T4, false_>
			{
			};
			template<>
			struct or_impl<false, false_, false_, false_, false_>: false_
			{
			};
		}
		template<typename T1=na, typename T2=na, typename T3=false_, typename T4=false_, typename T5=false_>
		struct or_: aux::or_impl<T1::type::value, T2, T3, T4, T5>
		{
		};
		template<>
		struct or_<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: or_<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<or_<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef or_<na, na>result_;
			typedef or_<na, na>type;
		};
	}
}
namespace boost
{
	template<typename A, typename B>
	struct is_interoperable: mpl::or_<is_convertible<A, B>, is_convertible<B, A> >
	{
	};
}
namespace boost
{
	template<class Iterator>
	struct iterator_value
	{
		typedef typename boost::detail::iterator_traits<Iterator>::value_type type;
	};
	template<class Iterator>
	struct iterator_reference
	{
		typedef typename boost::detail::iterator_traits<Iterator>::reference type;
	};
	template<class Iterator>
	struct iterator_pointer
	{
		typedef typename boost::detail::iterator_traits<Iterator>::pointer type;
	};
	template<class Iterator>
	struct iterator_difference
	{
		typedef typename boost::detail::iterator_traits<Iterator>::difference_type type;
	};
	template<class Iterator>
	struct iterator_category
	{
		typedef typename boost::detail::iterator_traits<Iterator>::iterator_category type;
	};
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<bool C_, typename T1, typename T2, typename T3, typename T4>
			struct and_impl: false_
			{
			};
			template<typename T1, typename T2, typename T3, typename T4>
			struct and_impl<true, T1, T2, T3, T4>: and_impl<T1::type::value, T2, T3, T4, true_>
			{
			};
			template<>
			struct and_impl<true, true_, true_, true_, true_>: true_
			{
			};
		}
		template<typename T1=na, typename T2=na, typename T3=true_, typename T4=true_, typename T5=true_>
		struct and_: aux::and_impl<T1::type::value, T2, T3, T4, T5>
		{
		};
		template<>
		struct and_<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: and_<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<and_<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef and_<na, na>result_;
			typedef and_<na, na>type;
		};
	}
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct cv_traits_imp
		{
		};
		template<typename T>
		struct cv_traits_imp<T*>
		{
			static const bool is_const=false;
			static const bool is_volatile=false;
			typedef T unqualified_type;
		};
		template<typename T>
		struct cv_traits_imp<const T*>
		{
			static const bool is_const=true;
			static const bool is_volatile=false;
			typedef T unqualified_type;
		};
		template<typename T>
		struct cv_traits_imp<volatile T*>
		{
			static const bool is_const=false;
			static const bool is_volatile=true;
			typedef T unqualified_type;
		};
		template<typename T>
		struct cv_traits_imp<const volatile T*>
		{
			static const bool is_const=true;
			static const bool is_volatile=true;
			typedef T unqualified_type;
		};
	}
}
namespace boost
{
	template<typename T>
	struct is_const: ::boost::integral_constant<bool, ::boost::detail::cv_traits_imp<T*>::is_const>
	{
	};
	template<typename T>
	struct is_const<T&>: ::boost::integral_constant<bool, false>
	{
	};
}
namespace boost
{
	namespace type_traits
	{
		struct false_result
		{
			template<typename T>
			struct result_
			{
				static const bool value=false;
			};
		};
	}
}
namespace boost
{
	namespace type_traits
	{
		template<class R>
		struct is_function_ptr_helper
		{
			static const bool value=false;
		};
		template<class R>
		struct is_function_ptr_helper<R(*)()>
		{
			static const bool value=true;
		};
		template<class R>
		struct is_function_ptr_helper<R(*)(...)>
		{
			static const bool value=true;
		};
		template<class R, class T0>
		struct is_function_ptr_helper<R(*)(T0)>
		{
			static const bool value=true;
		};
		template<class R, class T0>
		struct is_function_ptr_helper<R(*)(T0...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1>
		struct is_function_ptr_helper<R(*)(T0, T1)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1>
		struct is_function_ptr_helper<R(*)(T0, T1...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2>
		struct is_function_ptr_helper<R(*)(T0, T1, T2)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2>
		struct is_function_ptr_helper<R(*)(T0, T1, T2...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)>
		{
			static const bool value=true;
		};
	}
}
namespace boost
{
	namespace detail
	{
		template<bool is_ref=true>
		struct is_function_chooser: ::boost::type_traits::false_result
		{
		};
		template<>
		struct is_function_chooser<false>
		{
			template<typename T>
			struct result_: ::boost::type_traits::is_function_ptr_helper<T*>
			{
			};
		};
		template<typename T>
		struct is_function_impl: is_function_chooser< ::boost::is_reference<T>::value>::template result_<T>
		{
		};
	}
	template<typename T>
	struct is_function: ::boost::integral_constant<bool, ::boost::detail::is_function_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace type_traits
	{
		template<typename T>
		struct is_mem_fun_pointer_impl
		{
			static const bool value=false;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)()>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)(...)>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)()const>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)()volatile>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)()const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)(...)const>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)(...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)(...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)const volatile>
		{
			static const bool value=true;
		};
	}
}
namespace boost
{
	template<typename T>
	struct remove_cv
	{
		typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type;
	};
	template<typename T>
	struct remove_cv<T&>
	{
		typedef T&type;
	};
	template<typename T, std::size_t N>
	struct remove_cv<T const[N]>
	{
		typedef T type[N];
	};
	template<typename T, std::size_t N>
	struct remove_cv<T volatile[N]>
	{
		typedef T type[N];
	};
	template<typename T, std::size_t N>
	struct remove_cv<T const volatile[N]>
	{
		typedef T type[N];
	};
}
namespace boost
{
	template<typename T>
	struct is_member_function_pointer: ::boost::integral_constant<bool, ::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_member_pointer: ::boost::integral_constant<bool, ::boost::is_member_function_pointer<T>::value>
	{
	};
	template<typename T, typename U>
	struct is_member_pointer<U T::*>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, typename U>
	struct is_member_pointer<U T::*const>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, typename U>
	struct is_member_pointer<U T::*volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, typename U>
	struct is_member_pointer<U T::*const volatile>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_pointer_helper
		{
			static const bool value=false;
		};
		template<typename T>
		struct is_pointer_helper<T*>
		{
			static const bool value=true;
		};
		template<typename T>
		struct is_pointer_impl
		{
			static const bool value=(::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value, ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value>::value>::value);
		};
	}
	template<typename T>
	struct is_pointer: ::boost::integral_constant<bool, ::boost::detail::is_pointer_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_class_impl
		{
			static const bool value=__is_class(T);
		};
	}
	template<typename T>
	struct is_class: ::boost::integral_constant<bool, ::boost::detail::is_class_impl<T>::value>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_volatile: ::boost::integral_constant<bool, ::boost::detail::cv_traits_imp<T*>::is_volatile>
	{
	};
	template<typename T>
	struct is_volatile<T&>: ::boost::integral_constant<bool, false>
	{
	};
}
namespace boost
{
	template<typename T>
	struct remove_reference
	{
		typedef T type;
	};
	template<typename T>
	struct remove_reference<T&>
	{
		typedef T type;
	};
}
namespace boost
{
	template<typename T>
	struct remove_pointer
	{
		typedef T type;
	};
	template<typename T>
	struct remove_pointer<T*>
	{
		typedef T type;
	};
	template<typename T>
	struct remove_pointer<T*const>
	{
		typedef T type;
	};
	template<typename T>
	struct remove_pointer<T*volatile>
	{
		typedef T type;
	};
	template<typename T>
	struct remove_pointer<T*const volatile>
	{
		typedef T type;
	};
}
namespace boost
{
	namespace detail
	{
		namespace indirect_traits
		{
			template<class T>
			struct is_reference_to_const: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_const<T const&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_function: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_function<T&>: is_function<T>
			{
			};
			template<class T>
			struct is_pointer_to_function: mpl::false_
			{
			};
			template<class T>
			struct is_pointer_to_function<T*>: is_function<T>
			{
			};
			template<class T>
			struct is_reference_to_member_function_pointer_impl: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_member_function_pointer_impl<T&>: is_member_function_pointer<typename remove_cv<T>::type>
			{
			};
			template<class T>
			struct is_reference_to_member_function_pointer: is_reference_to_member_function_pointer_impl<T>
			{
			};
			template<class T>
			struct is_reference_to_function_pointer_aux: mpl::and_<is_reference<T>, is_pointer_to_function<typename remove_cv<typename remove_reference<T>::type>::type> >
			{
			};
			template<class T>
			struct is_reference_to_function_pointer: mpl::if_<is_reference_to_function<T>, mpl::false_, is_reference_to_function_pointer_aux<T> >::type
			{
			};
			template<class T>
			struct is_reference_to_non_const: mpl::and_<is_reference<T>, mpl::not_<is_reference_to_const<T> > >
			{
			};
			template<class T>
			struct is_reference_to_volatile: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_volatile<T volatile&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_pointer: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_pointer<T*&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_pointer<T*const&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_pointer<T*volatile&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_pointer<T*const volatile&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_class: mpl::and_<is_reference<T>, is_class<typename remove_cv<typename remove_reference<T>::type>::type> >
			{
			};
			template<class T>
			struct is_pointer_to_class: mpl::and_<is_pointer<T>, is_class<typename remove_cv<typename remove_pointer<T>::type>::type> >
			{
			};
		}
		using namespace indirect_traits;
	}
}
namespace boost
{
	struct use_default;
}
namespace boost
{
	namespace detail
	{
		struct input_output_iterator_tag: std::input_iterator_tag
		{
			operator std::output_iterator_tag()const
			{
				return std::output_iterator_tag();
			}
		};
		template<class ValueParam, class Reference>
		struct iterator_writability_disabled: mpl::or_<is_const<Reference>, boost::detail::indirect_traits::is_reference_to_const<Reference>, is_const<ValueParam> >
		{
		};
		template<class Traversal, class ValueParam, class Reference>
		struct iterator_facade_default_category: mpl::eval_if<mpl::and_<is_reference<Reference>, is_convertible<Traversal, forward_traversal_tag> >, mpl::eval_if<is_convertible<Traversal, random_access_traversal_tag>, mpl::identity<std::random_access_iterator_tag>, mpl::if_<is_convertible<Traversal, bidirectional_traversal_tag>, std::bidirectional_iterator_tag, std::forward_iterator_tag> >, typename mpl::eval_if<mpl::and_<is_convertible<Traversal, single_pass_traversal_tag>, is_convertible<Reference, ValueParam> >, mpl::identity<std::input_iterator_tag>, mpl::identity<Traversal> > >
		{
		};
		template<class T>
		struct is_iterator_category: mpl::or_<is_convertible<T, std::input_iterator_tag>, is_convertible<T, std::output_iterator_tag> >
		{
		};
		template<class T>
		struct is_iterator_traversal: is_convertible<T, incrementable_traversal_tag>
		{
		};
		template<class Category, class Traversal>
		struct iterator_category_with_traversal: Category, Traversal
		{
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(is_convertible<typename iterator_category_to_traversal<Category>::type, Traversal>))0, 1)));
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_arg((void(*)(is_iterator_category<Category>))0, 1)));
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(is_iterator_category<Traversal>))0, 1)));
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(is_iterator_traversal<Category>))0, 1)));
		};
		template<class Traversal, class ValueParam, class Reference>
		struct facade_iterator_category_impl
		{
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(is_iterator_category<Traversal>))0, 1)));
			typedef typename iterator_facade_default_category<Traversal, ValueParam, Reference>::type category;
			typedef typename mpl::if_<is_same<Traversal, typename iterator_category_to_traversal<category>::type>, category, iterator_category_with_traversal<category, Traversal> >::type type;
		};
		template<class CategoryOrTraversal, class ValueParam, class Reference>
		struct facade_iterator_category: mpl::eval_if<is_iterator_category<CategoryOrTraversal>, mpl::identity<CategoryOrTraversal>, facade_iterator_category_impl<CategoryOrTraversal, ValueParam, Reference> >
		{
		};
	}
}
namespace boost
{
	namespace iterators
	{
		template<bool>
		struct enabled
		{
			template<typename T>
			struct base
			{
				typedef T type;
			};
		};
		template<>
		struct enabled<false>
		{
			template<typename T>
			struct base
			{
			};
		};
		template<class Cond, class Return>
		struct enable_if: enabled<(Cond::value)>::template base<Return>
		{
		};
	}
}
namespace boost
{
	template<typename T>
	inline T implicit_cast(typename mpl::identity<T>::type x)
	{
		return x;
	}
}
namespace boost
{
	template<typename T>
	struct add_const
	{
		typedef T const type;
	};
	template<typename T>
	struct add_const<T&>
	{
		typedef T&type;
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct add_pointer_impl
		{
			typedef typename remove_reference<T>::type no_ref_type;
			typedef no_ref_type*type;
		};
	}
	template<typename T>
	struct add_pointer
	{
		typedef typename boost::detail::add_pointer_impl<T>::type type;
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T, bool is_vol>
		struct remove_const_helper
		{
			typedef T type;
		};
		template<typename T>
		struct remove_const_helper<T, true>
		{
			typedef T volatile type;
		};
		template<typename T>
		struct remove_const_impl
		{
			typedef typename remove_const_helper<typename cv_traits_imp<T*>::unqualified_type, ::boost::is_volatile<T>::value>::type type;
		};
	}
	template<typename T>
	struct remove_const
	{
		typedef typename boost::detail::remove_const_impl<T>::type type;
	};
	template<typename T>
	struct remove_const<T&>
	{
		typedef T&type;
	};
	template<typename T, std::size_t N>
	struct remove_const<T const[N]>
	{
		typedef T type[N];
	};
	template<typename T, std::size_t N>
	struct remove_const<T const volatile[N]>
	{
		typedef T volatile type[N];
	};
}
namespace boost
{
	template<typename T>
	struct is_enum: ::boost::integral_constant<bool, __is_enum(T)>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_scalar_impl
		{
			static const bool value=(::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value>::value);
		};
		template<>
		struct is_scalar_impl<void>
		{
			static const bool value=false;
		};
		template<>
		struct is_scalar_impl<void const>
		{
			static const bool value=false;
		};
		template<>
		struct is_scalar_impl<void volatile>
		{
			static const bool value=false;
		};
		template<>
		struct is_scalar_impl<void const volatile>
		{
			static const bool value=false;
		};
	}
	template<typename T>
	struct is_scalar: ::boost::integral_constant<bool, ::boost::detail::is_scalar_impl<T>::value>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_POD;
	namespace detail
	{
		template<typename T>
		struct is_pod_impl
		{
			static const bool value=(::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, (__is_pod(T)&&__has_trivial_constructor(T))>::value);
		};
		template<typename T, std::size_t sz>
		struct is_pod_impl<T[sz]>: is_pod_impl<T>
		{
		};
		template<>
		struct is_pod_impl<void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl<void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl<void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl<void const volatile>
		{
			static const bool value=(true);
		};
	}
	template<typename T>
	struct is_POD: ::boost::integral_constant<bool, ::boost::detail::is_pod_impl<T>::value>
	{
	};
	template<typename T>
	struct is_pod: ::boost::integral_constant<bool, ::boost::detail::is_pod_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace mpl
	{
		template<typename Value>
		struct always
		{
			template<typename T, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply
			{
				typedef Value type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename F, typename T1=na, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
		struct apply;
		template<typename F>
		struct apply0;
		template<typename F, typename T1>
		struct apply1;
		template<typename F, typename T1, typename T2>
		struct apply2;
		template<typename F, typename T1, typename T2, typename T3>
		struct apply3;
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct apply4;
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct apply5;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct type_wrapper
			{
				typedef T type;
			};
			template<typename T>
			struct wrapped_type;
			template<typename T>
			struct wrapped_type<type_wrapper<T> >
			{
				typedef T type;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct has_apply_msvc_sfinae_helper
			{
				typedef void type;
			};
			template<typename T, typename U=void>
			struct has_apply_impl_
			{
				static const bool value=false;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T>
			struct has_apply_impl_<T, typename has_apply_msvc_sfinae_helper<typename T::apply>::type>
			{
				static const bool value=true;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T, typename fallback_=boost::mpl::bool_<false> >
			struct has_apply: has_apply_impl_<T>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename F, typename has_apply_=typename aux::has_apply<F>::type>
		struct apply_wrap0: F::template apply<>
		{
		};
		template<typename F>
		struct apply_wrap0<F, true_>: F::apply
		{
		};
		template<typename F, typename T1>
		struct apply_wrap1: F::template apply<T1>
		{
		};
		template<typename F, typename T1, typename T2>
		struct apply_wrap2: F::template apply<T1, T2>
		{
		};
		template<typename F, typename T1, typename T2, typename T3>
		struct apply_wrap3: F::template apply<T1, T2, T3>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct apply_wrap4: F::template apply<T1, T2, T3, T4>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct apply_wrap5: F::template apply<T1, T2, T3, T4, T5>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename F, typename T1=na, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
		struct bind;
		template<typename F>
		struct bind0;
		template<typename F, typename T1>
		struct bind1;
		template<typename F, typename T1, typename T2>
		struct bind2;
		template<typename F, typename T1, typename T2, typename T3>
		struct bind3;
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct bind4;
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct bind5;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na>
		struct next
		{
			typedef typename T::next type;
		};
		template<typename T=na>
		struct prior
		{
			typedef typename T::prior type;
		};
		template<>
		struct next<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: next<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<next<na>, Tag>
		{
			typedef false_ is_le;
			typedef next<na>result_;
			typedef next<na>type;
		};
		template<>
		struct prior<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: prior<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<prior<na>, Tag>
		{
			typedef false_ is_le;
			typedef prior<na>result_;
			typedef prior<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na, int not_le_=0>
		struct protect: T
		{
			typedef protect type;
		};
		template<>
		struct protect<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: protect<T1>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg
			{
				typedef T type;
			};
			template<typename T, typename Arg>
			struct replace_unnamed_arg
			{
				typedef Arg next;
				typedef T type;
			};
			template<typename Arg>
			struct replace_unnamed_arg<arg<-1>, Arg>
			{
				typedef typename Arg::next next;
				typedef Arg type;
			};
			template<int N, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<arg<N>, U1, U2, U3, U4, U5>
			{
				typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
			};
			template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>
			{
				typedef bind<F, T1, T2, T3, T4, T5>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F>
		struct bind0
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
			public:
				typedef typename apply_wrap0<f_>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind0<F>, U1, U2, U3, U4, U5>
			{
				typedef bind0<F>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F>
		struct bind<F, na, na, na, na, na>: bind0<F>
		{
		};
		template<typename F, typename T1>
		struct bind1
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
			public:
				typedef typename apply_wrap1<f_, typename t1::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind1<F, T1>, U1, U2, U3, U4, U5>
			{
				typedef bind1<F, T1>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1>
		struct bind<F, T1, na, na, na, na>: bind1<F, T1>
		{
		};
		template<typename F, typename T1, typename T2>
		struct bind2
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
			public:
				typedef typename apply_wrap2<f_, typename t1::type, typename t2::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename T2, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind2<F, T1, T2>, U1, U2, U3, U4, U5>
			{
				typedef bind2<F, T1, T2>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1, typename T2>
		struct bind<F, T1, T2, na, na, na>: bind2<F, T1, T2>
		{
		};
		template<typename F, typename T1, typename T2, typename T3>
		struct bind3
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
			public:
				typedef typename apply_wrap3<f_, typename t1::type, typename t2::type, typename t3::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename T2, typename T3, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind3<F, T1, T2, T3>, U1, U2, U3, U4, U5>
			{
				typedef bind3<F, T1, T2, T3>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1, typename T2, typename T3>
		struct bind<F, T1, T2, T3, na, na>: bind3<F, T1, T2, T3>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct bind4
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
				typedef aux::replace_unnamed_arg<T4, n4>r4;
				typedef typename r4::type a4;
				typedef typename r4::next n5;
				typedef aux::resolve_bind_arg<a4, U1, U2, U3, U4, U5>t4;
			public:
				typedef typename apply_wrap4<f_, typename t1::type, typename t2::type, typename t3::type, typename t4::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename T2, typename T3, typename T4, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind4<F, T1, T2, T3, T4>, U1, U2, U3, U4, U5>
			{
				typedef bind4<F, T1, T2, T3, T4>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct bind<F, T1, T2, T3, T4, na>: bind4<F, T1, T2, T3, T4>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct bind5
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
				typedef aux::replace_unnamed_arg<T4, n4>r4;
				typedef typename r4::type a4;
				typedef typename r4::next n5;
				typedef aux::resolve_bind_arg<a4, U1, U2, U3, U4, U5>t4;
				typedef aux::replace_unnamed_arg<T5, n5>r5;
				typedef typename r5::type a5;
				typedef typename r5::next n6;
				typedef aux::resolve_bind_arg<a5, U1, U2, U3, U4, U5>t5;
			public:
				typedef typename apply_wrap5<f_, typename t1::type, typename t2::type, typename t3::type, typename t4::type, typename t5::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind5<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>
			{
				typedef bind5<F, T1, T2, T3, T4, T5>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct bind: bind5<F, T1, T2, T3, T4, T5>
		{
		};
		template<template<typename T1, typename T2, typename T3>class F, typename Tag>
		struct quote3;
		template<typename T1, typename T2, typename T3>
		struct if_;
		template<typename Tag, typename T1, typename T2, typename T3>
		struct bind3<quote3<if_, Tag>, T1, T2, T3>
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef mpl::arg<1>n1;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
				typedef typename if_<typename t1::type, t2, t3>::type f_;
			public:
				typedef typename f_::type type;
			};
		};
		template<template<typename T1, typename T2, typename T3>class F, typename Tag>
		struct quote3;
		template<typename T1, typename T2, typename T3>
		struct eval_if;
		template<typename Tag, typename T1, typename T2, typename T3>
		struct bind3<quote3<eval_if, Tag>, T1, T2, T3>
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef mpl::arg<1>n1;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
				typedef typename eval_if<typename t1::type, t2, t3>::type f_;
			public:
				typedef typename f_::type type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		struct void_
		{
			typedef void_ type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T>
		struct is_void_: false_
		{
		};
		template<>
		struct is_void_<void_>: true_
		{
		};
		template<typename T>
		struct is_not_void_: true_
		{
		};
		template<>
		struct is_not_void_<void_>: false_
		{
		};
		template<>
		struct is_void_<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: is_void_<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<is_void_<na>, Tag>
		{
			typedef false_ is_le;
			typedef is_void_<na>result_;
			typedef is_void_<na>type;
		};
		template<>
		struct is_not_void_<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: is_not_void_<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<is_not_void_<na>, Tag>
		{
			typedef false_ is_le;
			typedef is_not_void_<na>result_;
			typedef is_not_void_<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct has_type_msvc_sfinae_helper
			{
				typedef void type;
			};
			template<typename T, typename U=void>
			struct has_type_impl_
			{
				static const bool value=false;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T>
			struct has_type_impl_<T, typename has_type_msvc_sfinae_helper<typename T::type>::type>
			{
				static const bool value=true;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T, typename fallback_=boost::mpl::bool_<true> >
			struct has_type: has_type_impl_<T>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T, bool has_type_>
		struct quote_impl: T
		{
		};
		template<typename T>
		struct quote_impl<T, false>
		{
			typedef T type;
		};
		template<template<typename P1>class F, typename Tag=void_>
		struct quote1
		{
			template<typename U1>
			struct apply: quote_impl<F<U1>, aux::has_type<F<U1> >::value>
			{
			};
		};
		template<template<typename P1, typename P2>class F, typename Tag=void_>
		struct quote2
		{
			template<typename U1, typename U2>
			struct apply: quote_impl<F<U1, U2>, aux::has_type<F<U1, U2> >::value>
			{
			};
		};
		template<template<typename P1, typename P2, typename P3>class F, typename Tag=void_>
		struct quote3
		{
			template<typename U1, typename U2, typename U3>
			struct apply: quote_impl<F<U1, U2, U3>, aux::has_type<F<U1, U2, U3> >::value>
			{
			};
		};
		template<template<typename P1, typename P2, typename P3, typename P4>class F, typename Tag=void_>
		struct quote4
		{
			template<typename U1, typename U2, typename U3, typename U4>
			struct apply: quote_impl<F<U1, U2, U3, U4>, aux::has_type<F<U1, U2, U3, U4> >::value>
			{
			};
		};
		template<template<typename P1, typename P2, typename P3, typename P4, typename P5>class F, typename Tag=void_>
		struct quote5
		{
			template<typename U1, typename U2, typename U3, typename U4, typename U5>
			struct apply: quote_impl<F<U1, U2, U3, U4, U5>, aux::has_type<F<U1, U2, U3, U4, U5> >::value>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<bool C1=false, bool C2=false, bool C3=false, bool C4=false, bool C5=false>
			struct lambda_or: true_
			{
			};
			template<>
			struct lambda_or<false, false, false, false, false>: false_
			{
			};
		}
		template<typename T, typename Tag>
		struct lambda
		{
			typedef false_ is_le;
			typedef T result_;
			typedef T type;
		};
		template<typename T>
		struct is_lambda_expression: lambda<T>::is_le
		{
		};
		template<int N, typename Tag>
		struct lambda<arg<N>, Tag>
		{
			typedef true_ is_le;
			typedef mpl::arg<N>result_;
			typedef mpl::protect<result_>type;
		};
		template<typename F, typename Tag>
		struct lambda<bind0<F>, Tag>
		{
			typedef false_ is_le;
			typedef bind0<F>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1>class F, typename L1>
			struct le_result1
			{
				typedef F<typename L1::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1>class F, typename L1>
			struct le_result1<true_, Tag, F, L1>
			{
				typedef bind1<quote1<F, Tag>, typename L1::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1>class F, typename T1, typename Tag>
		struct lambda<F<T1>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef typename l1::is_le is_le1;
			typedef typename aux::lambda_or<is_le1::value>::type is_le;
			typedef aux::le_result1<is_le, Tag, F, l1>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename Tag>
		struct lambda<bind1<F, T1>, Tag>
		{
			typedef false_ is_le;
			typedef bind1<F, T1>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1, typename P2>class F, typename L1, typename L2>
			struct le_result2
			{
				typedef F<typename L1::type, typename L2::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1, typename P2>class F, typename L1, typename L2>
			struct le_result2<true_, Tag, F, L1, L2>
			{
				typedef bind2<quote2<F, Tag>, typename L1::result_, typename L2::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1, typename P2>class F, typename T1, typename T2, typename Tag>
		struct lambda<F<T1, T2>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef lambda<T2, Tag>l2;
			typedef typename l1::is_le is_le1;
			typedef typename l2::is_le is_le2;
			typedef typename aux::lambda_or<is_le1::value, is_le2::value>::type is_le;
			typedef aux::le_result2<is_le, Tag, F, l1, l2>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename T2, typename Tag>
		struct lambda<bind2<F, T1, T2>, Tag>
		{
			typedef false_ is_le;
			typedef bind2<F, T1, T2>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1, typename P2, typename P3>class F, typename L1, typename L2, typename L3>
			struct le_result3
			{
				typedef F<typename L1::type, typename L2::type, typename L3::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1, typename P2, typename P3>class F, typename L1, typename L2, typename L3>
			struct le_result3<true_, Tag, F, L1, L2, L3>
			{
				typedef bind3<quote3<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1, typename P2, typename P3>class F, typename T1, typename T2, typename T3, typename Tag>
		struct lambda<F<T1, T2, T3>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef lambda<T2, Tag>l2;
			typedef lambda<T3, Tag>l3;
			typedef typename l1::is_le is_le1;
			typedef typename l2::is_le is_le2;
			typedef typename l3::is_le is_le3;
			typedef typename aux::lambda_or<is_le1::value, is_le2::value, is_le3::value>::type is_le;
			typedef aux::le_result3<is_le, Tag, F, l1, l2, l3>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename T2, typename T3, typename Tag>
		struct lambda<bind3<F, T1, T2, T3>, Tag>
		{
			typedef false_ is_le;
			typedef bind3<F, T1, T2, T3>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1, typename P2, typename P3, typename P4>class F, typename L1, typename L2, typename L3, typename L4>
			struct le_result4
			{
				typedef F<typename L1::type, typename L2::type, typename L3::type, typename L4::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1, typename P2, typename P3, typename P4>class F, typename L1, typename L2, typename L3, typename L4>
			struct le_result4<true_, Tag, F, L1, L2, L3, L4>
			{
				typedef bind4<quote4<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_, typename L4::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1, typename P2, typename P3, typename P4>class F, typename T1, typename T2, typename T3, typename T4, typename Tag>
		struct lambda<F<T1, T2, T3, T4>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef lambda<T2, Tag>l2;
			typedef lambda<T3, Tag>l3;
			typedef lambda<T4, Tag>l4;
			typedef typename l1::is_le is_le1;
			typedef typename l2::is_le is_le2;
			typedef typename l3::is_le is_le3;
			typedef typename l4::is_le is_le4;
			typedef typename aux::lambda_or<is_le1::value, is_le2::value, is_le3::value, is_le4::value>::type is_le;
			typedef aux::le_result4<is_le, Tag, F, l1, l2, l3, l4>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename Tag>
		struct lambda<bind4<F, T1, T2, T3, T4>, Tag>
		{
			typedef false_ is_le;
			typedef bind4<F, T1, T2, T3, T4>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1, typename P2, typename P3, typename P4, typename P5>class F, typename L1, typename L2, typename L3, typename L4, typename L5>
			struct le_result5
			{
				typedef F<typename L1::type, typename L2::type, typename L3::type, typename L4::type, typename L5::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1, typename P2, typename P3, typename P4, typename P5>class F, typename L1, typename L2, typename L3, typename L4, typename L5>
			struct le_result5<true_, Tag, F, L1, L2, L3, L4, L5>
			{
				typedef bind5<quote5<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_, typename L4::result_, typename L5::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1, typename P2, typename P3, typename P4, typename P5>class F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
		struct lambda<F<T1, T2, T3, T4, T5>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef lambda<T2, Tag>l2;
			typedef lambda<T3, Tag>l3;
			typedef lambda<T4, Tag>l4;
			typedef lambda<T5, Tag>l5;
			typedef typename l1::is_le is_le1;
			typedef typename l2::is_le is_le2;
			typedef typename l3::is_le is_le3;
			typedef typename l4::is_le is_le4;
			typedef typename l5::is_le is_le5;
			typedef typename aux::lambda_or<is_le1::value, is_le2::value, is_le3::value, is_le4::value, is_le5::value>::type is_le;
			typedef aux::le_result5<is_le, Tag, F, l1, l2, l3, l4, l5>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
		struct lambda<bind5<F, T1, T2, T3, T4, T5>, Tag>
		{
			typedef false_ is_le;
			typedef bind5<F, T1, T2, T3, T4, T5>result_;
			typedef result_ type;
		};
		template<typename T, typename Tag>
		struct lambda<mpl::protect<T>, Tag>
		{
			typedef false_ is_le;
			typedef mpl::protect<T>result_;
			typedef result_ type;
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
		struct lambda<bind<F, T1, T2, T3, T4, T5>, Tag>
		{
			typedef false_ is_le;
			typedef bind<F, T1, T2, T3, T4, T5>result_;
			typedef result_ type;
		};
		template<typename F, typename Tag1, typename Tag2>
		struct lambda<lambda<F, Tag1>, Tag2>
		{
			typedef lambda<F, Tag2>l1;
			typedef lambda<Tag1, Tag2>l2;
			typedef typename l1::is_le is_le;
			typedef aux::le_result2<is_le, Tag2, mpl::lambda, l1, l2>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<>
		struct lambda<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: lambda<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<lambda<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef lambda<na, na>result_;
			typedef lambda<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename F>
		struct apply0: apply_wrap0<typename lambda<F>::type>
		{
		};
		template<typename F>
		struct apply<F, na, na, na, na, na>: apply0<F>
		{
		};
		template<typename F, typename T1>
		struct apply1: apply_wrap1<typename lambda<F>::type, T1>
		{
		};
		template<typename F, typename T1>
		struct apply<F, T1, na, na, na, na>: apply1<F, T1>
		{
		};
		template<typename F, typename T1, typename T2>
		struct apply2: apply_wrap2<typename lambda<F>::type, T1, T2>
		{
		};
		template<typename F, typename T1, typename T2>
		struct apply<F, T1, T2, na, na, na>: apply2<F, T1, T2>
		{
		};
		template<typename F, typename T1, typename T2, typename T3>
		struct apply3: apply_wrap3<typename lambda<F>::type, T1, T2, T3>
		{
		};
		template<typename F, typename T1, typename T2, typename T3>
		struct apply<F, T1, T2, T3, na, na>: apply3<F, T1, T2, T3>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct apply4: apply_wrap4<typename lambda<F>::type, T1, T2, T3, T4>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct apply<F, T1, T2, T3, T4, na>: apply4<F, T1, T2, T3, T4>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct apply5: apply_wrap5<typename lambda<F>::type, T1, T2, T3, T4, T5>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct apply: apply5<F, T1, T2, T3, T4, T5>
		{
		};
	}
}
namespace boost
{
	template<class I, class V, class TC, class R, class D>
	class iterator_facade;
	namespace detail
	{
		struct always_bool2
		{
			template<class T, class U>
			struct apply
			{
				typedef bool type;
			};
		};
		template<class Facade1, class Facade2, class Return>
		struct enable_if_interoperable: ::boost::iterators::enable_if<mpl::or_<is_convertible<Facade1, Facade2>, is_convertible<Facade2, Facade1> >, Return>
		{
		};
		template<class ValueParam, class CategoryOrTraversal, class Reference, class Difference>
		struct iterator_facade_types
		{
			typedef typename facade_iterator_category<CategoryOrTraversal, ValueParam, Reference>::type iterator_category;
			typedef typename remove_const<ValueParam>::type value_type;
			typedef typename mpl::eval_if<boost::detail::iterator_writability_disabled<ValueParam, Reference>, add_pointer<const value_type>, add_pointer<value_type> >::type pointer;
		};
		template<class Iterator>
		class postfix_increment_proxy
		{
			typedef typename iterator_value<Iterator>::type value_type;
		public:
			explicit postfix_increment_proxy(Iterator const&x): stored_value(*x)
			{
			}
			value_type&operator*()const
			{
				return this->stored_value;
			}
		private:
			mutable value_type stored_value;
		};
		template<class Iterator>
		class writable_postfix_increment_proxy
		{
			typedef typename iterator_value<Iterator>::type value_type;
		public:
			explicit writable_postfix_increment_proxy(Iterator const&x): stored_value(*x), stored_iterator(x)
			{
			}
			writable_postfix_increment_proxy const&operator*()const
			{
				return *this;
			}
			operator value_type&()const
			{
				return stored_value;
			}
			template<class T>
			T const&operator=(T const&x)const
			{
				*this->stored_iterator=x;
				return x;
			}
			template<class T>
			T&operator=(T&x)const
			{
				*this->stored_iterator=x;
				return x;
			}
			operator Iterator const&()const
			{
				return stored_iterator;
			}
		private:
			mutable value_type stored_value;
			Iterator stored_iterator;
		};
		template<class Reference, class Value>
		struct is_non_proxy_reference: is_convertible<typename remove_reference<Reference>::type const volatile*, Value const volatile*>
		{
		};
		template<class Iterator, class Value, class Reference, class CategoryOrTraversal>
		struct postfix_increment_result: mpl::eval_if<mpl::and_<is_convertible<Reference, Value const&>, mpl::not_<is_convertible<typename iterator_category_to_traversal<CategoryOrTraversal>::type, forward_traversal_tag> > >, mpl::if_<is_non_proxy_reference<Reference, Value>, postfix_increment_proxy<Iterator>, writable_postfix_increment_proxy<Iterator> >, mpl::identity<Iterator> >
		{
		};
		template<class T>
		struct operator_arrow_proxy
		{
			operator_arrow_proxy(T const*px): m_value(*px)
			{
			}
			T*operator->()const
			{
				return &m_value;
			}
			operator T*()const
			{
				return &m_value;
			}
			mutable T m_value;
		};
		template<class ValueType, class Reference, class Pointer>
		struct operator_arrow_result
		{
			typedef typename mpl::if_<is_reference<Reference>, Pointer, operator_arrow_proxy<ValueType> >::type type;
			static type make(Reference x)
			{
				return implicit_cast<type>(&x);
			}
		};
		template<class Iterator>
		class operator_brackets_proxy
		{
			typedef typename Iterator::reference reference;
			typedef typename Iterator::value_type value_type;
		public:
			operator_brackets_proxy(Iterator const&iter): m_iter(iter)
			{
			}
			operator reference()const
			{
				return *m_iter;
			}
			operator_brackets_proxy&operator=(value_type const&val)
			{
				*m_iter=val;
				return *this;
			}
		private:
			Iterator m_iter;
		};
		template<class ValueType, class Reference>
		struct use_operator_brackets_proxy: mpl::not_<mpl::and_<boost::is_POD<ValueType>, iterator_writability_disabled<ValueType, Reference> > >
		{
		};
		template<class Iterator, class Value, class Reference>
		struct operator_brackets_result
		{
			typedef typename mpl::if_<use_operator_brackets_proxy<Value, Reference>, operator_brackets_proxy<Iterator>, Value>::type type;
		};
		template<class Iterator>
		operator_brackets_proxy<Iterator>make_operator_brackets_result(Iterator const&iter, mpl::true_)
		{
			return operator_brackets_proxy<Iterator>(iter);
		}
		template<class Iterator>
		typename Iterator::value_type make_operator_brackets_result(Iterator const&iter, mpl::false_)
		{
			return *iter;
		}
		struct choose_difference_type
		{
			template<class I1, class I2>
			struct apply: mpl::eval_if<is_convertible<I2, I1>, iterator_difference<I1>, iterator_difference<I2> >
			{
			};
		};
	}
	class iterator_core_access
	{
	public:
		template<class Facade>
		static typename Facade::reference dereference(Facade const&f)
		{
			return f.dereference();
		}
		template<class Facade>
		static void increment(Facade&f)
		{
			f.increment();
		}
		template<class Facade>
		static void decrement(Facade&f)
		{
			f.decrement();
		}
		template<class Facade1, class Facade2>
		static bool equal(Facade1 const&f1, Facade2 const&f2, mpl::true_)
		{
			return f1.equal(f2);
		}
		template<class Facade1, class Facade2>
		static bool equal(Facade1 const&f1, Facade2 const&f2, mpl::false_)
		{
			return f2.equal(f1);
		}
		template<class Facade>
		static void advance(Facade&f, typename Facade::difference_type n)
		{
			f.advance(n);
		}
		template<class Facade1, class Facade2>
		static typename Facade1::difference_type distance_from(Facade1 const&f1, Facade2 const&f2, mpl::true_)
		{
			return -f1.distance_to(f2);
		}
		template<class Facade1, class Facade2>
		static typename Facade2::difference_type distance_from(Facade1 const&f1, Facade2 const&f2, mpl::false_)
		{
			return f2.distance_to(f1);
		}
		template<class I, class V, class TC, class R, class D>
		static I&derived(iterator_facade<I, V, TC, R, D>&facade)
		{
			return *static_cast<I*>(&facade);
		}
		template<class I, class V, class TC, class R, class D>
		static I const&derived(iterator_facade<I, V, TC, R, D>const&facade)
		{
			return *static_cast<I const*>(&facade);
		}
	private:
		iterator_core_access();
	};
	template<class Derived, class Value, class CategoryOrTraversal, class Reference=Value&, class Difference=std::ptrdiff_t>
	class iterator_facade
	{
	private:
		Derived&derived()
		{
			return *static_cast<Derived*>(this);
		}
		Derived const&derived()const
		{
			return *static_cast<Derived const*>(this);
		}
		typedef boost::detail::iterator_facade_types<Value, CategoryOrTraversal, Reference, Difference>associated_types;
		protected: typedef iterator_facade<Derived, Value, CategoryOrTraversal, Reference, Difference>iterator_facade_;
	public:
		typedef typename associated_types::value_type value_type;
		typedef Reference reference;
		typedef Difference difference_type;
		typedef typename associated_types::pointer pointer;
		typedef typename associated_types::iterator_category iterator_category;
		reference operator*()const
		{
			return iterator_core_access::dereference(this->derived());
		}
		typename boost::detail::operator_arrow_result<value_type, reference, pointer>::type operator->()const
		{
			return boost::detail::operator_arrow_result<value_type, reference, pointer>::make(*this->derived());
		}
		typename boost::detail::operator_brackets_result<Derived, Value, reference>::type operator[](difference_type n)const
		{
			typedef boost::detail::use_operator_brackets_proxy<Value, Reference>use_proxy;
			return boost::detail::make_operator_brackets_result<Derived>(this->derived()+n, use_proxy());
		}
		Derived&operator++()
		{
			iterator_core_access::increment(this->derived());
			return this->derived();
		}
		Derived&operator--()
		{
			iterator_core_access::decrement(this->derived());
			return this->derived();
		}
		Derived operator--(int)
		{
			Derived tmp(this->derived());
			--*this;
			return tmp;
		}
		Derived&operator+=(difference_type n)
		{
			iterator_core_access::advance(this->derived(), n);
			return this->derived();
		}
		Derived&operator-=(difference_type n)
		{
			iterator_core_access::advance(this->derived(), -n);
			return this->derived();
		}
		Derived operator-(difference_type x)const
		{
			Derived result(this->derived());
			return result-=x;
		}
	};
	template<class I, class V, class TC, class R, class D>
	inline typename boost::detail::postfix_increment_result<I, V, R, TC>::type operator++(iterator_facade<I, V, TC, R, D>&i, int)
	{
		typename boost::detail::postfix_increment_result<I, V, R, TC>::type tmp(*static_cast<I*>(&i));
		++i;
		return tmp;
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator==(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return iterator_core_access::equal(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator!=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return !iterator_core_access::equal(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator<(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return 0>iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator>(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return 0<iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator<=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return 0>=iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator>=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return 0<=iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::choose_difference_type, Derived1, Derived2>::type>::type operator-(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived, class V, class TC, class R, class D>
	inline Derived operator+(iterator_facade<Derived, V, TC, R, D>const&i, typename Derived::difference_type n)
	{
		Derived tmp(static_cast<Derived const&>(i));
		return tmp+=n;
	}
	template<class Derived, class V, class TC, class R, class D>
	inline Derived operator+(typename Derived::difference_type n, iterator_facade<Derived, V, TC, R, D>const&i)
	{
		Derived tmp(static_cast<Derived const&>(i));
		return tmp+=n;
	}
}
namespace boost
{
	struct use_default;
	template<class To>
	struct is_convertible<use_default, To>: mpl::false_
	{
	};
	namespace detail
	{
		struct enable_type;
	}
	template<typename From, typename To>
	struct enable_if_convertible: iterators::enable_if<mpl::or_<is_same<From, To>, is_convertible<From, To> >, boost::detail::enable_type>
	{
	};
	namespace detail
	{
		template<class T, class DefaultNullaryFn>
		struct ia_dflt_help: mpl::eval_if<is_same<T, use_default>, DefaultNullaryFn, mpl::identity<T> >
		{
		};
		template<class Derived, class Base, class Value, class Traversal, class Reference, class Difference>
		struct iterator_adaptor_base
		{
			typedef iterator_facade<Derived, typename boost::detail::ia_dflt_help<Value, mpl::eval_if<is_same<Reference, use_default>, iterator_value<Base>, remove_reference<Reference> > >::type, typename boost::detail::ia_dflt_help<Traversal, iterator_traversal<Base> >::type, typename boost::detail::ia_dflt_help<Reference, mpl::eval_if<is_same<Value, use_default>, iterator_reference<Base>, add_reference<Value> > >::type, typename boost::detail::ia_dflt_help<Difference, iterator_difference<Base> >::type>type;
		};
		template<class Tr1, class Tr2>
		inline void iterator_adaptor_assert_traversal()
		{
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_convertible<Tr1, Tr2>::value))>)>boost_static_assert_typedef___COUNTER__;
		}
	}
	template<class Derived, class Base, class Value=use_default, class Traversal=use_default, class Reference=use_default, class Difference=use_default>
	class iterator_adaptor: public boost::detail::iterator_adaptor_base<Derived, Base, Value, Traversal, Reference, Difference>::type
	{
		friend class iterator_core_access;
		protected: typedef typename boost::detail::iterator_adaptor_base<Derived, Base, Value, Traversal, Reference, Difference>::type super_t;
	public:
		iterator_adaptor()
		{
		}
		explicit iterator_adaptor(Base const&iter): m_iterator(iter)
		{
		}
		typedef Base base_type;
		Base const&base()const
		{
			return m_iterator;
		}
		protected: typedef iterator_adaptor<Derived, Base, Value, Traversal, Reference, Difference>iterator_adaptor_;
		Base const&base_reference()const
		{
			return m_iterator;
		}
		Base&base_reference()
		{
			return m_iterator;
		}
	private:
		typename super_t::reference dereference()const
		{
			return *m_iterator;
		}
		template<class OtherDerived, class OtherIterator, class V, class C, class R, class D>
		bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D>const&x)const
		{
			return m_iterator==x.base();
		}
		typedef typename iterator_category_to_traversal<typename super_t::iterator_category>::type my_traversal;
		void advance(typename super_t::difference_type n)
		{
			boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
			m_iterator+=n;
		}
		void increment()
		{
			++m_iterator;
		}
		void decrement()
		{
			boost::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
			--m_iterator;
		}
		template<class OtherDerived, class OtherIterator, class V, class C, class R, class D>
		typename super_t::difference_type distance_to(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D>const&y)const
		{
			boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
			return y.base()-m_iterator;
		}
	private:
		Base m_iterator;
	};
}
namespace boost
{
	template<class Iterator>
	class reverse_iterator: public iterator_adaptor<reverse_iterator<Iterator>, Iterator>
	{
		typedef iterator_adaptor<reverse_iterator<Iterator>, Iterator>super_t;
		friend class iterator_core_access;
	public:
		reverse_iterator()
		{
		}
		explicit reverse_iterator(Iterator x): super_t(x)
		{
		}
		template<class OtherIterator>
		reverse_iterator(reverse_iterator<OtherIterator>const&r, typename enable_if_convertible<OtherIterator, Iterator>::type* =0): super_t(r.base())
		{
		}
	private:
		typename super_t::reference dereference()const
		{
			return *boost::prior(this->base());
		}
		void increment()
		{
			--this->base_reference();
		}
		void decrement()
		{
			++this->base_reference();
		}
		void advance(typename super_t::difference_type n)
		{
			this->base_reference()+=-n;
		}
		template<class OtherIterator>
		typename super_t::difference_type distance_to(reverse_iterator<OtherIterator>const&y)const
		{
			return this->base_reference()-y.base();
		}
	};
	template<class BidirectionalIterator>
	reverse_iterator<BidirectionalIterator>make_reverse_iterator(BidirectionalIterator x)
	{
		return reverse_iterator<BidirectionalIterator>(x);
	}
}
namespace std
{
	template<class _Arg, class _Result>
	struct unary_function
	{
		typedef _Arg argument_type;
		typedef _Result result_type;
	};
	template<class _Arg1, class _Arg2, class _Result>
	struct binary_function
	{
		typedef _Arg1 first_argument_type;
		typedef _Arg2 second_argument_type;
		typedef _Result result_type;
	};
	template<class _Ty>
	struct plus: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left+_Right);
		}
	};
	template<class _Ty>
	struct minus: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left-_Right);
		}
	};
	template<class _Ty>
	struct multiplies: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left*_Right);
		}
	};
	template<class _Ty>
	struct divides: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left/_Right);
		}
	};
	template<class _Ty>
	struct modulus: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left%_Right);
		}
	};
	template<class _Ty>
	struct negate: public unary_function<_Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left)const
		{
			return (-_Left);
		}
	};
	template<class _Ty>
	struct equal_to: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left==_Right);
		}
	};
	template<class _Ty>
	struct not_equal_to: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left!=_Right);
		}
	};
	template<class _Ty>
	struct greater: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left>_Right);
		}
	};
	template<class _Ty>
	struct less: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left<_Right);
		}
	};
	template<class _Ty>
	struct greater_equal: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left>=_Right);
		}
	};
	template<class _Ty>
	struct less_equal: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left<=_Right);
		}
	};
	template<class _Ty>
	struct logical_and: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left&&_Right);
		}
	};
	template<class _Ty>
	struct logical_or: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left||_Right);
		}
	};
	template<class _Ty>
	struct logical_not: public unary_function<_Ty, bool>
	{
		bool operator()(const _Ty&_Left)const
		{
			return (!_Left);
		}
	};
	template<class _Fn1>
	class unary_negate: public unary_function<typename _Fn1::argument_type, bool>
	{
	public:
		explicit unary_negate(const _Fn1&_Func): _Functor(_Func)
		{
		}
		bool operator()(const typename _Fn1::argument_type&_Left)const
		{
			return (!_Functor(_Left));
		}
		protected: _Fn1 _Functor;
	};
	template<class _Fn1>
	inline unary_negate<_Fn1>not1(const _Fn1&_Func)
	{
		return (std::unary_negate<_Fn1>(_Func));
	}
	template<class _Fn2>
	class binary_negate: public binary_function<typename _Fn2::first_argument_type, typename _Fn2::second_argument_type, bool>
	{
	public:
		explicit binary_negate(const _Fn2&_Func): _Functor(_Func)
		{
		}
		bool operator()(const typename _Fn2::first_argument_type&_Left, const typename _Fn2::second_argument_type&_Right)const
		{
			return (!_Functor(_Left, _Right));
		}
		protected: _Fn2 _Functor;
	};
	template<class _Fn2>
	inline binary_negate<_Fn2>not2(const _Fn2&_Func)
	{
		return (std::binary_negate<_Fn2>(_Func));
	}
	template<class _Fn2>
	class binder1st: public unary_function<typename _Fn2::second_argument_type, typename _Fn2::result_type>
	{
	public:
		typedef unary_function<typename _Fn2::second_argument_type, typename _Fn2::result_type>_Base;
		typedef typename _Base::argument_type argument_type;
		typedef typename _Base::result_type result_type;
		binder1st(const _Fn2&_Func, const typename _Fn2::first_argument_type&_Left): op(_Func), value(_Left)
		{
		}
		result_type operator()(const argument_type&_Right)const
		{
			return (op(value, _Right));
		}
		result_type operator()(argument_type&_Right)const
		{
			return (op(value, _Right));
		}
		protected: _Fn2 op;
		typename _Fn2::first_argument_type value;
	};
	template<class _Fn2, class _Ty>
	inline binder1st<_Fn2>bind1st(const _Fn2&_Func, const _Ty&_Left)
	{
		typename _Fn2::first_argument_type _Val(_Left);
		return (std::binder1st<_Fn2>(_Func, _Val));
	}
	template<class _Fn2>
	class binder2nd: public unary_function<typename _Fn2::first_argument_type, typename _Fn2::result_type>
	{
	public:
		typedef unary_function<typename _Fn2::first_argument_type, typename _Fn2::result_type>_Base;
		typedef typename _Base::argument_type argument_type;
		typedef typename _Base::result_type result_type;
		binder2nd(const _Fn2&_Func, const typename _Fn2::second_argument_type&_Right): op(_Func), value(_Right)
		{
		}
		result_type operator()(const argument_type&_Left)const
		{
			return (op(_Left, value));
		}
		result_type operator()(argument_type&_Left)const
		{
			return (op(_Left, value));
		}
		protected: _Fn2 op;
		typename _Fn2::second_argument_type value;
	};
	template<class _Fn2, class _Ty>
	inline binder2nd<_Fn2>bind2nd(const _Fn2&_Func, const _Ty&_Right)
	{
		typename _Fn2::second_argument_type _Val(_Right);
		return (std::binder2nd<_Fn2>(_Func, _Val));
	}
	template<class _Arg, class _Result, class _Fn=_Result(*)(_Arg)>
	class pointer_to_unary_function: public unary_function<_Arg, _Result>
	{
	public:
		explicit pointer_to_unary_function(_Fn _Left): _Pfun(_Left)
		{
		}
		_Result operator()(_Arg _Left)const
		{
			return (_Pfun(_Left));
		}
		protected: _Fn _Pfun;
	};
	template<class _Arg1, class _Arg2, class _Result, class _Fn=_Result(*)(_Arg1, _Arg2)>
	class pointer_to_binary_function: public binary_function<_Arg1, _Arg2, _Result>
	{
	public:
		explicit pointer_to_binary_function(_Fn _Left): _Pfun(_Left)
		{
		}
		_Result operator()(_Arg1 _Left, _Arg2 _Right)const
		{
			return (_Pfun(_Left, _Right));
		}
		protected: _Fn _Pfun;
	};
	template<class _Arg, class _Result>
	inline pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>ptr_fun(_Result(*_Left)(_Arg))
	{
		return (std::pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>(_Left));
	}
	template<class _Arg, class _Result>
	inline pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>ptr_fun(_Result(*_Left)(_Arg))
	{
		return (std::pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>(_Left));
	}
	template<class _Arg, class _Result>
	inline pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>ptr_fun(_Result(*_Left)(_Arg))
	{
		return (std::pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>(_Left));
	}
	template<class _Arg1, class _Arg2, class _Result>
	inline pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>ptr_fun(_Result(*_Left)(_Arg1, _Arg2))
	{
		return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>(_Left));
	}
	template<class _Arg1, class _Arg2, class _Result>
	inline pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>ptr_fun(_Result(*_Left)(_Arg1, _Arg2))
	{
		return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>(_Left));
	}
	template<class _Arg1, class _Arg2, class _Result>
	inline pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>ptr_fun(_Result(*_Left)(_Arg1, _Arg2))
	{
		return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>(_Left));
	}
	template<class _Result, class _Ty>
	class mem_fun_t: public unary_function<_Ty*, _Result>
	{
	public:
		explicit mem_fun_t(_Result(_Ty::*_Pm)()): _Pmemfun(_Pm)
		{
		}
		_Result operator()(_Ty*_Pleft)const
		{
			return ((_Pleft->*_Pmemfun)());
		}
	private:
		_Result(_Ty::*_Pmemfun)();
	};
	template<class _Result, class _Ty, class _Arg>
	class mem_fun1_t: public binary_function<_Ty*, _Arg, _Result>
	{
	public:
		explicit mem_fun1_t(_Result(_Ty::*_Pm)(_Arg)): _Pmemfun(_Pm)
		{
		}
		_Result operator()(_Ty*_Pleft, _Arg _Right)const
		{
			return ((_Pleft->*_Pmemfun)(_Right));
		}
	private:
		_Result(_Ty::*_Pmemfun)(_Arg);
	};
	template<class _Result, class _Ty>
	class const_mem_fun_t: public unary_function<const _Ty*, _Result>
	{
	public:
		explicit const_mem_fun_t(_Result(_Ty::*_Pm)()const): _Pmemfun(_Pm)
		{
		}
		_Result operator()(const _Ty*_Pleft)const
		{
			return ((_Pleft->*_Pmemfun)());
		}
	private:
		_Result(_Ty::*_Pmemfun)()const;
	};
	template<class _Result, class _Ty, class _Arg>
	class const_mem_fun1_t: public binary_function<const _Ty*, _Arg, _Result>
	{
	public:
		explicit const_mem_fun1_t(_Result(_Ty::*_Pm)(_Arg)const): _Pmemfun(_Pm)
		{
		}
		_Result operator()(const _Ty*_Pleft, _Arg _Right)const
		{
			return ((_Pleft->*_Pmemfun)(_Right));
		}
	private:
		_Result(_Ty::*_Pmemfun)(_Arg)const;
	};
	template<class _Result, class _Ty>
	inline mem_fun_t<_Result, _Ty>mem_fun(_Result(_Ty::*_Pm)())
	{
		return (std::mem_fun_t<_Result, _Ty>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline mem_fun1_t<_Result, _Ty, _Arg>mem_fun(_Result(_Ty::*_Pm)(_Arg))
	{
		return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty>
	inline const_mem_fun_t<_Result, _Ty>mem_fun(_Result(_Ty::*_Pm)()const)
	{
		return (std::const_mem_fun_t<_Result, _Ty>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline const_mem_fun1_t<_Result, _Ty, _Arg>mem_fun(_Result(_Ty::*_Pm)(_Arg)const)
	{
		return (std::const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline mem_fun1_t<_Result, _Ty, _Arg>mem_fun1(_Result(_Ty::*_Pm)(_Arg))
	{
		return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty>
	class mem_fun_ref_t: public unary_function<_Ty, _Result>
	{
	public:
		explicit mem_fun_ref_t(_Result(_Ty::*_Pm)()): _Pmemfun(_Pm)
		{
		}
		_Result operator()(_Ty&_Left)const
		{
			return ((_Left.*_Pmemfun)());
		}
	private:
		_Result(_Ty::*_Pmemfun)();
	};
	template<class _Result, class _Ty, class _Arg>
	class mem_fun1_ref_t: public binary_function<_Ty, _Arg, _Result>
	{
	public:
		explicit mem_fun1_ref_t(_Result(_Ty::*_Pm)(_Arg)): _Pmemfun(_Pm)
		{
		}
		_Result operator()(_Ty&_Left, _Arg _Right)const
		{
			return ((_Left.*_Pmemfun)(_Right));
		}
	private:
		_Result(_Ty::*_Pmemfun)(_Arg);
	};
	template<class _Result, class _Ty>
	class const_mem_fun_ref_t: public unary_function<_Ty, _Result>
	{
	public:
		explicit const_mem_fun_ref_t(_Result(_Ty::*_Pm)()const): _Pmemfun(_Pm)
		{
		}
		_Result operator()(const _Ty&_Left)const
		{
			return ((_Left.*_Pmemfun)());
		}
	private:
		_Result(_Ty::*_Pmemfun)()const;
	};
	template<class _Result, class _Ty, class _Arg>
	class const_mem_fun1_ref_t: public binary_function<_Ty, _Arg, _Result>
	{
	public:
		explicit const_mem_fun1_ref_t(_Result(_Ty::*_Pm)(_Arg)const): _Pmemfun(_Pm)
		{
		}
		_Result operator()(const _Ty&_Left, _Arg _Right)const
		{
			return ((_Left.*_Pmemfun)(_Right));
		}
	private:
		_Result(_Ty::*_Pmemfun)(_Arg)const;
	};
	template<class _Result, class _Ty>
	inline mem_fun_ref_t<_Result, _Ty>mem_fun_ref(_Result(_Ty::*_Pm)())
	{
		return (std::mem_fun_ref_t<_Result, _Ty>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline mem_fun1_ref_t<_Result, _Ty, _Arg>mem_fun_ref(_Result(_Ty::*_Pm)(_Arg))
	{
		return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty>
	inline const_mem_fun_ref_t<_Result, _Ty>mem_fun_ref(_Result(_Ty::*_Pm)()const)
	{
		return (std::const_mem_fun_ref_t<_Result, _Ty>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline const_mem_fun1_ref_t<_Result, _Ty, _Arg>mem_fun_ref(_Result(_Ty::*_Pm)(_Arg)const)
	{
		return (std::const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline mem_fun1_ref_t<_Result, _Ty, _Arg>mem_fun1_ref(_Result(_Ty::*_Pm)(_Arg))
	{
		return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
}
extern "C"
{
	typedef union
	{
		unsigned short _Word[8];
		float _Float;
		double _Double;
		long double _Long_double;
	}
	_Dconst;
	void _Feraise(int);
	double _Cosh(double, double);
	short _Dtest(double*);
	short _Exp(double*, double, short);
	double _Sinh(double, double);
	extern _Dconst _Denorm, _Hugeval, _Inf, _Nan, _Snan;
	float _FCosh(float, float);
	short _FDtest(float*);
	short _FExp(float*, float, short);
	float _FSinh(float, float);
	extern _Dconst _FDenorm, _FInf, _FNan, _FSnan;
	long double _LCosh(long double, long double);
	short _LDtest(long double*);
	short _LExp(long double*, long double, short);
	long double _LSinh(long double, long double);
	extern _Dconst _LDenorm, _LInf, _LNan, _LSnan;
}
extern "C"
{
	unsigned int _clearfp(void);
	unsigned int _controlfp(unsigned int _NewValue, unsigned int _Mask);
	void _set_controlfp(unsigned int _NewValue, unsigned int _Mask);
	errno_t _controlfp_s(unsigned int*_CurrentState, unsigned int _NewValue, unsigned int _Mask);
	unsigned int _statusfp(void);
	void _fpreset(void);
	void _statusfp2(unsigned int*_X86_status, unsigned int*_SSE2_status);
	unsigned int _control87(unsigned int _NewValue, unsigned int _Mask);
	int __control87_2(unsigned int _NewValue, unsigned int _Mask, unsigned int*_X86_cw, unsigned int*_Sse2_cw);
	extern int _fpecode;
	double _copysign(double _Number, double _Sign);
	double _chgsign(double _X);
	double _scalb(double _X, long _Y);
	double _logb(double _X);
	double _nextafter(double _X, double _Y);
	int _finite(double _X);
	int _isnan(double _X);
	int _fpclass(double _X);
}
extern "C"
{
	struct _exception
	{
		int type;
		char*name;
		double arg1;
		double arg2;
		double retval;
	};
	struct _complex
	{
		double x, y;
	};
	extern double _HUGE;
	double acos(double _X);
	double asin(double _X);
	double atan(double _X);
	double atan2(double _Y, double _X);
	double cos(double _X);
	double cosh(double _X);
	double exp(double _X);
	double fabs(double _X);
	double fmod(double _X, double _Y);
	double log(double _X);
	double log10(double _X);
	double pow(double _X, double _Y);
	double sin(double _X);
	double sinh(double _X);
	double tan(double _X);
	double tanh(double _X);
	double sqrt(double _X);
	double _cabs(struct _complex _Complex);
	double ceil(double _X);
	double floor(double _X);
	double frexp(double _X, int*_Y);
	double _hypot(double _X, double _Y);
	double _j0(double _X);
	double _j1(double _X);
	double _jn(int _X, double _Y);
	double ldexp(double _X, int _Y);
	int _matherr(struct _exception*_Except);
	double modf(double _X, double*_Y);
	double _y0(double _X);
	double _y1(double _X);
	double _yn(int _X, double _Y);
	int _set_SSE2_enable(int _Flag);
	float _hypotf(float _X, float _Y);
	inline long double acosl(long double _X)
	{
		return (acos((double)_X));
	}
	inline long double asinl(long double _X)
	{
		return (asin((double)_X));
	}
	inline long double atanl(long double _X)
	{
		return (atan((double)_X));
	}
	inline long double atan2l(long double _X, long double _Y)
	{
		return (atan2((double)_X, (double)_Y));
	}
	inline long double ceill(long double _X)
	{
		return (ceil((double)_X));
	}
	inline long double cosl(long double _X)
	{
		return (cos((double)_X));
	}
	inline long double coshl(long double _X)
	{
		return (cosh((double)_X));
	}
	inline long double expl(long double _X)
	{
		return (exp((double)_X));
	}
	inline long double fabsl(long double _X)
	{
		return (fabs((double)_X));
	}
	inline long double floorl(long double _X)
	{
		return (floor((double)_X));
	}
	inline long double fmodl(long double _X, long double _Y)
	{
		return (fmod((double)_X, (double)_Y));
	}
	inline long double frexpl(long double _X, int*_Y)
	{
		return (frexp((double)_X, _Y));
	}
	inline long double ldexpl(long double _X, int _Y)
	{
		return (ldexp((double)_X, _Y));
	}
	inline long double logl(long double _X)
	{
		return (log((double)_X));
	}
	inline long double log10l(long double _X)
	{
		return (log10((double)_X));
	}
	inline long double modfl(long double _X, long double*_Y)
	{
		double _Di, _Df=modf((double)_X, &_Di);
		*_Y=(long double)_Di;
		return (_Df);
	}
	inline long double powl(long double _X, long double _Y)
	{
		return (pow((double)_X, (double)_Y));
	}
	inline long double sinl(long double _X)
	{
		return (sin((double)_X));
	}
	inline long double sinhl(long double _X)
	{
		return (sinh((double)_X));
	}
	inline long double sqrtl(long double _X)
	{
		return (sqrt((double)_X));
	}
	inline long double tanl(long double _X)
	{
		return (tan((double)_X));
	}
	inline long double tanhl(long double _X)
	{
		return (tanh((double)_X));
	}
	inline long double _chgsignl(long double _Number)
	{
		return _chgsign(static_cast<double>(_Number));
	}
	inline long double _copysignl(long double _Number, long double _Sign)
	{
		return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign));
	}
	inline float frexpf(float _X, int*_Y)
	{
		return ((float)frexp((double)_X, _Y));
	}
	inline float fabsf(float _X)
	{
		return ((float)fabs((double)_X));
	}
	inline float ldexpf(float _X, int _Y)
	{
		return ((float)ldexp((double)_X, _Y));
	}
	inline float acosf(float _X)
	{
		return ((float)acos((double)_X));
	}
	inline float asinf(float _X)
	{
		return ((float)asin((double)_X));
	}
	inline float atanf(float _X)
	{
		return ((float)atan((double)_X));
	}
	inline float atan2f(float _X, float _Y)
	{
		return ((float)atan2((double)_X, (double)_Y));
	}
	inline float ceilf(float _X)
	{
		return ((float)ceil((double)_X));
	}
	inline float cosf(float _X)
	{
		return ((float)cos((double)_X));
	}
	inline float coshf(float _X)
	{
		return ((float)cosh((double)_X));
	}
	inline float expf(float _X)
	{
		return ((float)exp((double)_X));
	}
	inline float floorf(float _X)
	{
		return ((float)floor((double)_X));
	}
	inline float fmodf(float _X, float _Y)
	{
		return ((float)fmod((double)_X, (double)_Y));
	}
	inline float logf(float _X)
	{
		return ((float)log((double)_X));
	}
	inline float log10f(float _X)
	{
		return ((float)log10((double)_X));
	}
	inline float modff(float _X, float*_Y)
	{
		double _Di, _Df=modf((double)_X, &_Di);
		*_Y=(float)_Di;
		return ((float)_Df);
	}
	inline float powf(float _X, float _Y)
	{
		return ((float)pow((double)_X, (double)_Y));
	}
	inline float sinf(float _X)
	{
		return ((float)sin((double)_X));
	}
	inline float sinhf(float _X)
	{
		return ((float)sinh((double)_X));
	}
	inline float sqrtf(float _X)
	{
		return ((float)sqrt((double)_X));
	}
	inline float tanf(float _X)
	{
		return ((float)tan((double)_X));
	}
	inline float tanhf(float _X)
	{
		return ((float)tanh((double)_X));
	}
}
extern "C++"
{
	template<class _Ty>
	inline _Ty _Pow_int(_Ty _X, int _Y)
	{
		unsigned int _N;
		if(_Y>=0)_N=(unsigned int)_Y;
		else _N=(unsigned int)(-_Y);
		for(_Ty _Z=_Ty(1);
		;
		_X*=_X)
		{
			if((_N&1)!=0)_Z*=_X;
			if((_N>>=1)==0)return (_Y<0?_Ty(1)/_Z: _Z);
		}
	}
	inline long abs(long _X)
	{
		return (labs(_X));
	}
	inline double abs(double _X)
	{
		return (fabs(_X));
	}
	inline double pow(double _X, int _Y)
	{
		return (_Pow_int(_X, _Y));
	}
	inline float abs(float _X)
	{
		return (fabsf(_X));
	}
	inline float acos(float _X)
	{
		return (acosf(_X));
	}
	inline float asin(float _X)
	{
		return (asinf(_X));
	}
	inline float atan(float _X)
	{
		return (atanf(_X));
	}
	inline float atan2(float _Y, float _X)
	{
		return (atan2f(_Y, _X));
	}
	inline float ceil(float _X)
	{
		return (ceilf(_X));
	}
	inline float cos(float _X)
	{
		return (cosf(_X));
	}
	inline float cosh(float _X)
	{
		return (coshf(_X));
	}
	inline float exp(float _X)
	{
		return (expf(_X));
	}
	inline float fabs(float _X)
	{
		return (fabsf(_X));
	}
	inline float floor(float _X)
	{
		return (floorf(_X));
	}
	inline float fmod(float _X, float _Y)
	{
		return (fmodf(_X, _Y));
	}
	inline float frexp(float _X, int*_Y)
	{
		return (frexpf(_X, _Y));
	}
	inline float ldexp(float _X, int _Y)
	{
		return (ldexpf(_X, _Y));
	}
	inline float log(float _X)
	{
		return (logf(_X));
	}
	inline float log10(float _X)
	{
		return (log10f(_X));
	}
	inline float modf(float _X, float*_Y)
	{
		return (modff(_X, _Y));
	}
	inline float pow(float _X, float _Y)
	{
		return (powf(_X, _Y));
	}
	inline float pow(float _X, int _Y)
	{
		return (_Pow_int(_X, _Y));
	}
	inline float sin(float _X)
	{
		return (sinf(_X));
	}
	inline float sinh(float _X)
	{
		return (sinhf(_X));
	}
	inline float sqrt(float _X)
	{
		return (sqrtf(_X));
	}
	inline float tan(float _X)
	{
		return (tanf(_X));
	}
	inline float tanh(float _X)
	{
		return (tanhf(_X));
	}
	inline long double abs(long double _X)
	{
		return (fabsl(_X));
	}
	inline long double acos(long double _X)
	{
		return (acosl(_X));
	}
	inline long double asin(long double _X)
	{
		return (asinl(_X));
	}
	inline long double atan(long double _X)
	{
		return (atanl(_X));
	}
	inline long double atan2(long double _Y, long double _X)
	{
		return (atan2l(_Y, _X));
	}
	inline long double ceil(long double _X)
	{
		return (ceill(_X));
	}
	inline long double cos(long double _X)
	{
		return (cosl(_X));
	}
	inline long double cosh(long double _X)
	{
		return (coshl(_X));
	}
	inline long double exp(long double _X)
	{
		return (expl(_X));
	}
	inline long double fabs(long double _X)
	{
		return (fabsl(_X));
	}
	inline long double floor(long double _X)
	{
		return (floorl(_X));
	}
	inline long double fmod(long double _X, long double _Y)
	{
		return (fmodl(_X, _Y));
	}
	inline long double frexp(long double _X, int*_Y)
	{
		return (frexpl(_X, _Y));
	}
	inline long double ldexp(long double _X, int _Y)
	{
		return (ldexpl(_X, _Y));
	}
	inline long double log(long double _X)
	{
		return (logl(_X));
	}
	inline long double log10(long double _X)
	{
		return (log10l(_X));
	}
	inline long double modf(long double _X, long double*_Y)
	{
		return (modfl(_X, _Y));
	}
	inline long double pow(long double _X, long double _Y)
	{
		return (powl(_X, _Y));
	}
	inline long double pow(long double _X, int _Y)
	{
		return (_Pow_int(_X, _Y));
	}
	inline long double sin(long double _X)
	{
		return (sinl(_X));
	}
	inline long double sinh(long double _X)
	{
		return (sinhl(_X));
	}
	inline long double sqrt(long double _X)
	{
		return (sqrtl(_X));
	}
	inline long double tan(long double _X)
	{
		return (tanl(_X));
	}
	inline long double tanh(long double _X)
	{
		return (tanhl(_X));
	}
}
namespace std
{
	using::acosf;
	using::asinf;
	using::atanf;
	using::atan2f;
	using::ceilf;
	using::cosf;
	using::coshf;
	using::expf;
	using::fabsf;
	using::floorf;
	using::fmodf;
	using::frexpf;
	using::ldexpf;
	using::logf;
	using::log10f;
	using::modff;
	using::powf;
	using::sinf;
	using::sinhf;
	using::sqrtf;
	using::tanf;
	using::tanhf;
	using::acosl;
	using::asinl;
	using::atanl;
	using::atan2l;
	using::ceill;
	using::cosl;
	using::coshl;
	using::expl;
	using::fabsl;
	using::floorl;
	using::fmodl;
	using::frexpl;
	using::ldexpl;
	using::logl;
	using::log10l;
	using::modfl;
	using::powl;
	using::sinl;
	using::sinhl;
	using::sqrtl;
	using::tanl;
	using::tanhl;
	using::abs;
	using::acos;
	using::asin;
	using::atan;
	using::atan2;
	using::ceil;
	using::cos;
	using::cosh;
	using::exp;
	using::fabs;
	using::floor;
	using::fmod;
	using::frexp;
	using::ldexp;
	using::log;
	using::log10;
	using::modf;
	using::pow;
	using::sin;
	using::sinh;
	using::sqrt;
	using::tan;
	using::tanh;
}
namespace std
{
	typedef enum
	{
		denorm_indeterminate=-1, denorm_absent=0, denorm_present=1
	}
	float_denorm_style;
	typedef enum
	{
		round_indeterminate=-1, round_toward_zero=0, round_to_nearest=1, round_toward_infinity=2, round_toward_neg_infinity=3
	}
	float_round_style;
	struct _Num_base
	{
		static const float_denorm_style has_denorm=(float_denorm_style)(denorm_absent);
		static const bool has_denorm_loss=(bool)(false);
		static const bool has_infinity=(bool)(false);
		static const bool has_quiet_NaN=(bool)(false);
		static const bool has_signaling_NaN=(bool)(false);
		static const bool is_bounded=(bool)(false);
		static const bool is_exact=(bool)(false);
		static const bool is_iec559=(bool)(false);
		static const bool is_integer=(bool)(false);
		static const bool is_modulo=(bool)(false);
		static const bool is_signed=(bool)(false);
		static const bool is_specialized=(bool)(false);
		static const bool tinyness_before=(bool)(false);
		static const bool traps=(bool)(false);
		static const float_round_style round_style=(float_round_style)(round_toward_zero);
		static const int digits=(int)(0);
		static const int digits10=(int)(0);
		static const int max_exponent=(int)(0);
		static const int max_exponent10=(int)(0);
		static const int min_exponent=(int)(0);
		static const int min_exponent10=(int)(0);
		static const int radix=(int)(0);
	};
	const float_denorm_style _Num_base::has_denorm;
	const bool _Num_base::has_denorm_loss;
	const bool _Num_base::has_infinity;
	const bool _Num_base::has_quiet_NaN;
	const bool _Num_base::has_signaling_NaN;
	const bool _Num_base::is_bounded;
	const bool _Num_base::is_exact;
	const bool _Num_base::is_iec559;
	const bool _Num_base::is_integer;
	const bool _Num_base::is_modulo;
	const bool _Num_base::is_signed;
	const bool _Num_base::is_specialized;
	const bool _Num_base::tinyness_before;
	const bool _Num_base::traps;
	const float_round_style _Num_base::round_style;
	const int _Num_base::digits;
	const int _Num_base::digits10;
	const int _Num_base::max_exponent;
	const int _Num_base::max_exponent10;
	const int _Num_base::min_exponent;
	const int _Num_base::min_exponent10;
	const int _Num_base::radix;
	template<class _Ty>
	class numeric_limits: public _Num_base
	{
	public:
		static _Ty(min)()throw()
		{
			return (_Ty(0));
		}
		static _Ty(max)()throw()
		{
			return (_Ty(0));
		}
		static _Ty epsilon()throw()
		{
			return (_Ty(0));
		}
		static _Ty round_error()throw()
		{
			return (_Ty(0));
		}
		static _Ty denorm_min()throw()
		{
			return (_Ty(0));
		}
		static _Ty infinity()throw()
		{
			return (_Ty(0));
		}
		static _Ty quiet_NaN()throw()
		{
			return (_Ty(0));
		}
		static _Ty signaling_NaN()throw()
		{
			return (_Ty(0));
		}
	};
	struct _Num_int_base: public _Num_base
	{
		static const bool is_bounded=(bool)(true);
		static const bool is_exact=(bool)(true);
		static const bool is_integer=(bool)(true);
		static const bool is_modulo=(bool)(true);
		static const bool is_specialized=(bool)(true);
		static const int radix=(int)(2);
	};
	const bool _Num_int_base::is_bounded;
	const bool _Num_int_base::is_exact;
	const bool _Num_int_base::is_integer;
	const bool _Num_int_base::is_modulo;
	const bool _Num_int_base::is_specialized;
	const int _Num_int_base::radix;
	struct _Num_float_base: public _Num_base
	{
		static const float_denorm_style has_denorm=(float_denorm_style)(denorm_present);
		static const bool has_denorm_loss=(bool)(true);
		static const bool has_infinity=(bool)(true);
		static const bool has_quiet_NaN=(bool)(true);
		static const bool has_signaling_NaN=(bool)(true);
		static const bool is_bounded=(bool)(true);
		static const bool is_exact=(bool)(false);
		static const bool is_iec559=(bool)(true);
		static const bool is_integer=(bool)(false);
		static const bool is_modulo=(bool)(false);
		static const bool is_signed=(bool)(true);
		static const bool is_specialized=(bool)(true);
		static const bool tinyness_before=(bool)(true);
		static const bool traps=(bool)(true);
		static const float_round_style round_style=(float_round_style)(round_to_nearest);
		static const int radix=(int)(2);
	};
	const float_denorm_style _Num_float_base::has_denorm;
	const bool _Num_float_base::has_denorm_loss;
	const bool _Num_float_base::has_infinity;
	const bool _Num_float_base::has_quiet_NaN;
	const bool _Num_float_base::has_signaling_NaN;
	const bool _Num_float_base::is_bounded;
	const bool _Num_float_base::is_exact;
	const bool _Num_float_base::is_iec559;
	const bool _Num_float_base::is_integer;
	const bool _Num_float_base::is_modulo;
	const bool _Num_float_base::is_signed;
	const bool _Num_float_base::is_specialized;
	const bool _Num_float_base::tinyness_before;
	const bool _Num_float_base::traps;
	const float_round_style _Num_float_base::round_style;
	const int _Num_float_base::radix;
	template<>
	class numeric_limits<char>: public _Num_int_base
	{
	public:
		typedef char _Ty;
		static _Ty(min)()throw()
		{
			return ((-128));
		}
		static _Ty(max)()throw()
		{
			return (127);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)((-128)!=0);
		static const int digits=(int)(8-((-128)!=0?1: 0));
		static const int digits10=(int)((8-((-128)!=0?1: 0))*301L/1000);
	};
	const bool numeric_limits<char>::is_signed;
	const int numeric_limits<char>::digits;
	const int numeric_limits<char>::digits10;
	template<>
	class numeric_limits<wchar_t>: public _Num_int_base
	{
	public:
		typedef wchar_t _Ty;
		static _Ty(min)()throw()
		{
			return ((_Ty)0);
		}
		static _Ty(max)()throw()
		{
			return ((_Ty)0xffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(0!=0);
		static const int digits=(int)(8*sizeof(wchar_t)-(0!=0?1: 0));
		static const int digits10=(int)((8*sizeof(wchar_t)-(0!=0?1: 0))*301L/1000);
	};
	const bool numeric_limits<wchar_t>::is_signed;
	const int numeric_limits<wchar_t>::digits;
	const int numeric_limits<wchar_t>::digits10;
	template<>
	class numeric_limits<_Bool>: public _Num_int_base
	{
	public:
		typedef bool _Ty;
		static _Ty(min)()throw()
		{
			return (false);
		}
		static _Ty(max)()throw()
		{
			return (true);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_modulo=(bool)(false);
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(1);
		static const int digits10=(int)(0);
	};
	const bool numeric_limits<_Bool>::is_modulo;
	const bool numeric_limits<_Bool>::is_signed;
	const int numeric_limits<_Bool>::digits;
	const int numeric_limits<_Bool>::digits10;
	template<>
	class numeric_limits<signed char>: public _Num_int_base
	{
	public:
		typedef signed char _Ty;
		static _Ty(min)()throw()
		{
			return ((-128));
		}
		static _Ty(max)()throw()
		{
			return (127);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8-1);
		static const int digits10=(int)((8-1)*301L/1000);
	};
	const bool numeric_limits<signed char>::is_signed;
	const int numeric_limits<signed char>::digits;
	const int numeric_limits<signed char>::digits10;
	template<>
	class numeric_limits<unsigned char>: public _Num_int_base
	{
	public:
		typedef unsigned char _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8);
		static const int digits10=(int)((8)*301L/1000);
	};
	const bool numeric_limits<unsigned char>::is_signed;
	const int numeric_limits<unsigned char>::digits;
	const int numeric_limits<unsigned char>::digits10;
	template<>
	class numeric_limits<short>: public _Num_int_base
	{
	public:
		typedef short _Ty;
		static _Ty(min)()throw()
		{
			return ((-32768));
		}
		static _Ty(max)()throw()
		{
			return (32767);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8*sizeof(short)-1);
		static const int digits10=(int)((8*sizeof(short)-1)*301L/1000);
	};
	const bool numeric_limits<short>::is_signed;
	const int numeric_limits<short>::digits;
	const int numeric_limits<short>::digits10;
	template<>
	class numeric_limits<unsigned short>: public _Num_int_base
	{
	public:
		typedef unsigned short _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8*sizeof(unsigned short));
		static const int digits10=(int)((8*sizeof(unsigned short))*301L/1000);
	};
	const bool numeric_limits<unsigned short>::is_signed;
	const int numeric_limits<unsigned short>::digits;
	const int numeric_limits<unsigned short>::digits10;
	template<>
	class numeric_limits<int>: public _Num_int_base
	{
	public:
		typedef int _Ty;
		static _Ty(min)()throw()
		{
			return ((-2147483647-1));
		}
		static _Ty(max)()throw()
		{
			return (2147483647);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8*sizeof(int)-1);
		static const int digits10=(int)((8*sizeof(int)-1)*301L/1000);
	};
	const bool numeric_limits<int>::is_signed;
	const int numeric_limits<int>::digits;
	const int numeric_limits<int>::digits10;
	template<>
	class numeric_limits<unsigned int>: public _Num_int_base
	{
	public:
		typedef unsigned int _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xffffffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8*sizeof(unsigned int));
		static const int digits10=(int)((8*sizeof(unsigned int))*301L/1000);
	};
	const bool numeric_limits<unsigned int>::is_signed;
	const int numeric_limits<unsigned int>::digits;
	const int numeric_limits<unsigned int>::digits10;
	template<>
	class numeric_limits<long>: public _Num_int_base
	{
	public:
		typedef long _Ty;
		static _Ty(min)()throw()
		{
			return ((-2147483647L-1));
		}
		static _Ty(max)()throw()
		{
			return (2147483647L);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8*sizeof(long)-1);
		static const int digits10=(int)((8*sizeof(long)-1)*301L/1000);
	};
	const bool numeric_limits<long>::is_signed;
	const int numeric_limits<long>::digits;
	const int numeric_limits<long>::digits10;
	template<>
	class numeric_limits<unsigned long>: public _Num_int_base
	{
	public:
		typedef unsigned long _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xffffffffUL);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8*sizeof(unsigned long));
		static const int digits10=(int)((8*sizeof(unsigned long))*301L/1000);
	};
	const bool numeric_limits<unsigned long>::is_signed;
	const int numeric_limits<unsigned long>::digits;
	const int numeric_limits<unsigned long>::digits10;
	template<>
	class numeric_limits<__int64>: public _Num_int_base
	{
	public:
		typedef __int64 _Ty;
		static _Ty(min)()throw()
		{
			return (-0x7fffffffffffffff-1);
		}
		static _Ty(max)()throw()
		{
			return (0x7fffffffffffffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8*sizeof(__int64)-1);
		static const int digits10=(int)((8*sizeof(__int64)-1)*301L/1000);
	};
	const bool numeric_limits<__int64>::is_signed;
	const int numeric_limits<__int64>::digits;
	const int numeric_limits<__int64>::digits10;
	template<>
	class numeric_limits<unsigned __int64>: public _Num_int_base
	{
	public:
		typedef unsigned __int64 _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xffffffffffffffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8*sizeof(unsigned __int64));
		static const int digits10=(int)((8*sizeof(unsigned __int64))*301L/1000);
	};
	const bool numeric_limits<unsigned __int64>::is_signed;
	const int numeric_limits<unsigned __int64>::digits;
	const int numeric_limits<unsigned __int64>::digits10;
	template<>
	class numeric_limits<float>: public _Num_float_base
	{
	public:
		typedef float _Ty;
		static _Ty(min)()throw()
		{
			return (1.175494351e-38F);
		}
		static _Ty(max)()throw()
		{
			return (3.402823466e+38F);
		}
		static _Ty epsilon()throw()
		{
			return (1.192092896e-07F);
		}
		static _Ty round_error()throw()
		{
			return (0.5);
		}
		static _Ty denorm_min()throw()
		{
			return (_FDenorm._Float);
		}
		static _Ty infinity()throw()
		{
			return (_FInf._Float);
		}
		static _Ty quiet_NaN()throw()
		{
			return (_FNan._Float);
		}
		static _Ty signaling_NaN()throw()
		{
			return (_FSnan._Float);
		}
		static const int digits=(int)(24);
		static const int digits10=(int)(6);
		static const int max_exponent=(int)((int)128);
		static const int max_exponent10=(int)((int)38);
		static const int min_exponent=(int)((int)(-125));
		static const int min_exponent10=(int)((int)(-37));
	};
	const int numeric_limits<float>::digits;
	const int numeric_limits<float>::digits10;
	const int numeric_limits<float>::max_exponent;
	const int numeric_limits<float>::max_exponent10;
	const int numeric_limits<float>::min_exponent;
	const int numeric_limits<float>::min_exponent10;
	template<>
	class numeric_limits<double>: public _Num_float_base
	{
	public:
		typedef double _Ty;
		static _Ty(min)()throw()
		{
			return (2.2250738585072014e-308);
		}
		static _Ty(max)()throw()
		{
			return (1.7976931348623158e+308);
		}
		static _Ty epsilon()throw()
		{
			return (2.2204460492503131e-016);
		}
		static _Ty round_error()throw()
		{
			return (0.5);
		}
		static _Ty denorm_min()throw()
		{
			return (_Denorm._Double);
		}
		static _Ty infinity()throw()
		{
			return (_Inf._Double);
		}
		static _Ty quiet_NaN()throw()
		{
			return (_Nan._Double);
		}
		static _Ty signaling_NaN()throw()
		{
			return (_Snan._Double);
		}
		static const int digits=(int)(53);
		static const int digits10=(int)(15);
		static const int max_exponent=(int)((int)1024);
		static const int max_exponent10=(int)((int)308);
		static const int min_exponent=(int)((int)(-1021));
		static const int min_exponent10=(int)((int)(-307));
	};
	const int numeric_limits<double>::digits;
	const int numeric_limits<double>::digits10;
	const int numeric_limits<double>::max_exponent;
	const int numeric_limits<double>::max_exponent10;
	const int numeric_limits<double>::min_exponent;
	const int numeric_limits<double>::min_exponent10;
	template<>
	class numeric_limits<long double>: public _Num_float_base
	{
	public:
		typedef long double _Ty;
		static _Ty(min)()throw()
		{
			return (2.2250738585072014e-308);
		}
		static _Ty(max)()throw()
		{
			return (1.7976931348623158e+308);
		}
		static _Ty epsilon()throw()
		{
			return (2.2204460492503131e-016);
		}
		static _Ty round_error()throw()
		{
			return (0.5);
		}
		static _Ty denorm_min()throw()
		{
			return (_LDenorm._Long_double);
		}
		static _Ty infinity()throw()
		{
			return (_LInf._Long_double);
		}
		static _Ty quiet_NaN()throw()
		{
			return (_LNan._Long_double);
		}
		static _Ty signaling_NaN()throw()
		{
			return (_LSnan._Long_double);
		}
		static const int digits=(int)(53);
		static const int digits10=(int)(15);
		static const int max_exponent=(int)((int)1024);
		static const int max_exponent10=(int)((int)308);
		static const int min_exponent=(int)((int)(-1021));
		static const int min_exponent10=(int)((int)(-307));
	};
	const int numeric_limits<long double>::digits;
	const int numeric_limits<long double>::digits10;
	const int numeric_limits<long double>::max_exponent;
	const int numeric_limits<long double>::max_exponent10;
	const int numeric_limits<long double>::min_exponent;
	const int numeric_limits<long double>::min_exponent10;
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			namespace flex_string_details
			{
				template<class InIt, class OutIt>
				OutIt copy_n(InIt b, typename std::iterator_traits<InIt>::difference_type n, OutIt d)
				{
					for(;
					n!=0;
					--n, ++b, ++d)
					{
						*d=*b;
					}
					return d;
				}
				template<class Pod, class T>
				inline void pod_fill(Pod*b, Pod*e, T c)
				{
					switch((e-b)&7)
					{
						case 0: while(b!=e)
						{
							*b=c;
							++b;
							case 7: *b=c;
							++b;
							case 6: *b=c;
							++b;
							case 5: *b=c;
							++b;
							case 4: *b=c;
							++b;
							case 3: *b=c;
							++b;
							case 2: *b=c;
							++b;
							case 1: *b=c;
							++b;
						}
					}
				}
				template<class Pod>
				inline void pod_move(const Pod*b, const Pod*e, Pod*d)
				{
					using namespace std;
					memmove(d, b, (e-b)*sizeof(*b));
				}
				template<class Pod>
				inline Pod*pod_copy(const Pod*b, const Pod*e, Pod*d)
				{
					const std::size_t s=e-b;
					using namespace std;
					memcpy(d, b, s*sizeof(*b));
					return d+s;
				}
				template<typename T>
				struct get_unsigned
				{
					typedef T result;
				};
				template<>
				struct get_unsigned<char>
				{
					typedef unsigned char result;
				};
				template<>
				struct get_unsigned<signed char>
				{
					typedef unsigned char result;
				};
				template<>
				struct get_unsigned<short int>
				{
					typedef unsigned short int result;
				};
				template<>
				struct get_unsigned<int>
				{
					typedef unsigned int result;
				};
				template<>
				struct get_unsigned<long int>
				{
					typedef unsigned long int result;
				};
				enum Shallow
				{
				};
			}
			template<class T>
			class mallocator
			{
			public:
				typedef T value_type;
				typedef value_type*pointer;
				typedef const value_type*const_pointer;
				typedef value_type&reference;
				typedef const value_type&const_reference;
				typedef std::size_t size_type;
				typedef int difference_type;
				template<class U>
				struct rebind
				{
					typedef mallocator<U>other;
				};
				mallocator()
				{
				}
				mallocator(const mallocator&)
				{
				}
				~mallocator()
				{
				}
				pointer address(reference x)const
				{
					return &x;
				}
				const_pointer address(const_reference x)const
				{
					return x;
				}
				pointer allocate(size_type n, const_pointer=0)
				{
					using namespace std;
					void*p=malloc(n*sizeof(T));
					if(!p)boost::throw_exception(std::bad_alloc());
					return static_cast<pointer>(p);
				}
				void deallocate(pointer p, size_type)
				{
					using namespace std;
					free(p);
				}
				size_type max_size()const
				{
					return static_cast<size_type>(-1)/sizeof(T);
				}
				void construct(pointer p, const value_type&x)
				{
					new(p)value_type(x);
				}
				void destroy(pointer p)
				{
					p->~value_type();
				}
			private:
				void operator=(const mallocator&);
			};
			template<>
			class mallocator<void>
			{
				typedef void value_type;
				typedef void*pointer;
				typedef const void*const_pointer;
				template<class U>
				struct rebind
				{
					typedef mallocator<U>other;
				};
			};
			template<class T>
			inline bool operator==(const mallocator<T>&, const mallocator<T>&)
			{
				return true;
			}
			template<class T>
			inline bool operator!=(const mallocator<T>&, const mallocator<T>&)
			{
				return false;
			}
			template<class Allocator>
			typename Allocator::pointer Reallocate(Allocator&alloc, typename Allocator::pointer p, typename Allocator::size_type oldObjCount, typename Allocator::size_type newObjCount, void*)
			{
				return 0;
			}
			template<class Allocator>
			typename Allocator::pointer Reallocate(Allocator&alloc, typename Allocator::pointer p, typename Allocator::size_type oldObjCount, typename Allocator::size_type newObjCount, mallocator<void>*)
			{
				return 0;
			}
			template<typename E, class A=std::allocator<E> >
			class SimpleStringStorage
			{
			public:
				struct Data
				{
					Data(): pEnd_(buffer_), pEndOfMem_(buffer_)
					{
						buffer_[0]=E(0);
					}
					E*pEnd_;
					E*pEndOfMem_;
					E buffer_[1];
				};
				static const Data emptyString_;
				typedef typename A::size_type size_type;
			private:
				Data*pData_;
				void Init(size_type size, size_type capacity)
				{
					(void)((!!(size<=capacity))||(_wassert(L"size <= capacity", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 336), 0));
					if(capacity==0)
					{
						pData_=const_cast<Data*>(&emptyString_);
					}
					else
					{
						pData_=static_cast<Data*>(malloc(sizeof(Data)+capacity*sizeof(E)));
						if(!pData_)boost::throw_exception(std::bad_alloc());
						pData_->pEnd_=pData_->buffer_+size;
						pData_->pEndOfMem_=pData_->buffer_+capacity;
					}
				}
			private:
				SimpleStringStorage()
				{
				}
			public:
				typedef E value_type;
				typedef E*iterator;
				typedef const E*const_iterator;
				typedef A allocator_type;
				SimpleStringStorage(const SimpleStringStorage&rhs)
				{
					const size_type sz=rhs.size();
					Init(sz, sz);
					if(sz)flex_string_details::pod_copy(rhs.begin(), rhs.end(), begin());
				}
				SimpleStringStorage(const SimpleStringStorage&s, flex_string_details::Shallow): pData_(s.pData_)
				{
				}
				SimpleStringStorage(const A&)
				{
					pData_=const_cast<Data*>(&emptyString_);
				}
				SimpleStringStorage(const E*s, size_type len, const A&)
				{
					Init(len, len);
					flex_string_details::pod_copy(s, s+len, begin());
				}
				SimpleStringStorage(size_type len, E c, const A&)
				{
					Init(len, len);
					flex_string_details::pod_fill(begin(), end(), c);
				}
				SimpleStringStorage&operator=(const SimpleStringStorage&rhs)
				{
					const size_type sz=rhs.size();
					reserve(sz);
					flex_string_details::pod_copy(&*rhs.begin(), &*rhs.end(), begin());
					pData_->pEnd_=&*begin()+sz;
					return *this;
				}
				~SimpleStringStorage()
				{
					(void)((!!(begin()<=end()))||(_wassert(L"begin() <= end()", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 405), 0));
					if(pData_!=&emptyString_)free(pData_);
				}
				iterator begin()
				{
					return pData_->buffer_;
				}
				const_iterator begin()const
				{
					return pData_->buffer_;
				}
				iterator end()
				{
					return pData_->pEnd_;
				}
				const_iterator end()const
				{
					return pData_->pEnd_;
				}
				size_type size()const
				{
					return pData_->pEnd_-pData_->buffer_;
				}
				size_type max_size()const
				{
					return std::size_t(-1)/sizeof(E)-sizeof(Data)-1;
				}
				size_type capacity()const
				{
					return pData_->pEndOfMem_-pData_->buffer_;
				}
				void reserve(size_type res_arg)
				{
					if(res_arg<=capacity())
					{
						return ;
					}
					if(pData_==&emptyString_)
					{
						Init(0, res_arg);
					}
					else
					{
						const size_type sz=size();
						void*p=realloc(pData_, sizeof(Data)+res_arg*sizeof(E));
						if(!p)boost::throw_exception(std::bad_alloc());
						if(p!=pData_)
						{
							pData_=static_cast<Data*>(p);
							pData_->pEnd_=pData_->buffer_+sz;
						}
						pData_->pEndOfMem_=pData_->buffer_+res_arg;
					}
				}
				void append(const E*s, size_type sz)
				{
					const size_type neededCapacity=size()+sz;
					if(capacity()<neededCapacity)
					{
						const iterator b=begin();
						static std::less_equal<const E*>le;
						if(le(b, s)&&le(s, end()))
						{
							const size_type offset=s-b;
							reserve(neededCapacity);
							s=begin()+offset;
						}
						else
						{
							reserve(neededCapacity);
						}
					}
					flex_string_details::pod_copy(s, s+sz, end());
					pData_->pEnd_+=sz;
				}
				template<class InputIterator>
				void append(InputIterator b, InputIterator e)
				{
					for(;
					b!=e;
					++b)
					{
						*this+=*b;
					}
				}
				void resize(size_type newSize, E fill)
				{
					const int delta=int(newSize-size());
					if(delta==0)return ;
					if(delta>0)
					{
						if(newSize>capacity())
						{
							reserve(newSize);
						}
						E*e=&*end();
						flex_string_details::pod_fill(e, e+delta, fill);
					}
					pData_->pEnd_=pData_->buffer_+newSize;
				}
				void swap(SimpleStringStorage&rhs)
				{
					std::swap(pData_, rhs.pData_);
				}
				const E*c_str()const
				{
					if(pData_!=&emptyString_)*pData_->pEnd_=E();
					return pData_->buffer_;
				}
				const E*data()const
				{
					return pData_->buffer_;
				}
				A get_allocator()const
				{
					return A();
				}
			};
			template<typename E, class A>
			const typename SimpleStringStorage<E, A>::Data SimpleStringStorage<E, A>::emptyString_=typename SimpleStringStorage<E, A>::Data();
			template<typename E, class A=std::allocator<E> >
			class AllocatorStringStorage: public A
			{
				typedef typename A::size_type size_type;
				typedef typename SimpleStringStorage<E, A>::Data Data;
				void*Alloc(size_type sz, const void*p=0)
				{
					return A::allocate(1+(sz-1)/sizeof(E), static_cast<const char*>(p));
				}
				void*Realloc(void*p, size_type oldSz, size_type newSz)
				{
					void*r=Alloc(newSz);
					flex_string_details::pod_copy(p, p+Min(oldSz, newSz), r);
					Free(p, oldSz);
					return r;
				}
				void Free(void*p, size_type sz)
				{
					A::deallocate(static_cast<E*>(p), sz);
				}
				Data*pData_;
				void Init(size_type size, size_type cap)
				{
					(void)((!!(size<=cap))||(_wassert(L"size <= cap", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 568), 0));
					if(cap==0)
					{
						pData_=const_cast<Data*>(&SimpleStringStorage<E, A>::emptyString_);
					}
					else
					{
						pData_=static_cast<Data*>(Alloc(cap*sizeof(E)+sizeof(Data)));
						pData_->pEnd_=pData_->buffer_+size;
						pData_->pEndOfMem_=pData_->buffer_+cap;
					}
				}
			public:
				typedef E value_type;
				typedef E*iterator;
				typedef const E*const_iterator;
				typedef A allocator_type;
				AllocatorStringStorage(): A(), pData_(0)
				{
				}
				AllocatorStringStorage(const AllocatorStringStorage&rhs): A(rhs.get_allocator())
				{
					const size_type sz=rhs.size();
					Init(sz, sz);
					if(sz)flex_string_details::pod_copy(rhs.begin(), rhs.end(), begin());
				}
				AllocatorStringStorage(const AllocatorStringStorage&s, flex_string_details::Shallow): A(s.get_allocator())
				{
					pData_=s.pData_;
				}
				AllocatorStringStorage(const A&a): A(a)
				{
					pData_=const_cast<Data*>(&SimpleStringStorage<E, A>::emptyString_);
				}
				AllocatorStringStorage(const E*s, size_type len, const A&a): A(a)
				{
					Init(len, len);
					flex_string_details::pod_copy(s, s+len, begin());
				}
				AllocatorStringStorage(size_type len, E c, const A&a): A(a)
				{
					Init(len, len);
					flex_string_details::pod_fill(&*begin(), &*end(), c);
				}
				AllocatorStringStorage&operator=(const AllocatorStringStorage&rhs)
				{
					const size_type sz=rhs.size();
					reserve(sz);
					flex_string_details::pod_copy(&*rhs.begin(), &*rhs.end(), begin());
					pData_->pEnd_=&*begin()+rhs.size();
					return *this;
				}
				~AllocatorStringStorage()
				{
					if(capacity())
					{
						Free(pData_, sizeof(Data)+capacity()*sizeof(E));
					}
				}
				iterator begin()
				{
					return pData_->buffer_;
				}
				const_iterator begin()const
				{
					return pData_->buffer_;
				}
				iterator end()
				{
					return pData_->pEnd_;
				}
				const_iterator end()const
				{
					return pData_->pEnd_;
				}
				size_type size()const
				{
					return size_type(end()-begin());
				}
				size_type max_size()const
				{
					return A::max_size();
				}
				size_type capacity()const
				{
					return size_type(pData_->pEndOfMem_-pData_->buffer_);
				}
				void resize(size_type n, E c)
				{
					reserve(n);
					iterator newEnd=begin()+n;
					iterator oldEnd=end();
					if(newEnd>oldEnd)
					{
						flex_string_details::pod_fill(oldEnd, newEnd, c);
					}
					if(capacity())pData_->pEnd_=newEnd;
				}
				void reserve(size_type res_arg)
				{
					if(res_arg<=capacity())
					{
						return ;
					}
					A&myAlloc=*this;
					AllocatorStringStorage newStr(myAlloc);
					newStr.Init(size(), res_arg);
					flex_string_details::pod_copy(begin(), end(), newStr.begin());
					swap(newStr);
				}
				template<class ForwardIterator>
				void append(ForwardIterator b, ForwardIterator e)
				{
					const size_type sz=std::distance(b, e), neededCapacity=size()+sz;
					if(capacity()<neededCapacity)
					{
						reserve(neededCapacity);
					}
					std::copy(b, e, end());
					pData_->pEnd_+=sz;
				}
				void swap(AllocatorStringStorage&rhs)
				{
					std::swap(pData_, rhs.pData_);
				}
				const E*c_str()const
				{
					if(pData_!=&SimpleStringStorage<E, A>::emptyString_)
					{
						*pData_->pEnd_=E();
					}
					return &*begin();
				}
				const E*data()const
				{
					return &*begin();
				}
				A get_allocator()const
				{
					return *this;
				}
			};
			template<typename E, class A=std::allocator<E> >
			class VectorStringStorage: protected std::vector<E, A>
			{
				typedef std::vector<E, A>base;
			public:
				typedef E value_type;
				typedef typename base::iterator iterator;
				typedef typename base::const_iterator const_iterator;
				typedef A allocator_type;
				typedef typename A::size_type size_type;
				VectorStringStorage(const VectorStringStorage&s): base(s)
				{
				}
				VectorStringStorage(const A&a): base(1, E(), a)
				{
				}
				VectorStringStorage(const E*s, size_type len, const A&a): base(a)
				{
					base::reserve(len+1);
					base::insert(base::end(), s, s+len);
					base::insert(base::end(), E());
				}
				VectorStringStorage(size_type len, E c, const A&a): base(len+1, c, a)
				{
					base::back()=E();
				}
				VectorStringStorage&operator=(const VectorStringStorage&rhs)
				{
					base&v=*this;
					v=rhs;
					return *this;
				}
				iterator begin()
				{
					return base::begin();
				}
				const_iterator begin()const
				{
					return base::begin();
				}
				iterator end()
				{
					return base::end()-1;
				}
				const_iterator end()const
				{
					return base::end()-1;
				}
				size_type size()const
				{
					return base::size()-1;
				}
				size_type max_size()const
				{
					return base::max_size()-1;
				}
				size_type capacity()const
				{
					return base::capacity()-1;
				}
				void reserve(size_type res_arg)
				{
					(void)((!!(res_arg<max_size()))||(_wassert(L"res_arg < max_size()", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 809), 0));
					base::reserve(res_arg+1);
				}
				void append(const E*s, size_type sz)
				{
					static std::less_equal<const E*>le;
					if(!base::empty())
					{
						const E*start=&base::front();
						if(le(start, s)&&le(s, start+size()))
						{
							const size_type offset=s-start;
							reserve(size()+sz);
							s=&base::front()+offset;
						}
					}
					base::insert(end(), s, s+sz);
				}
				template<class InputIterator>
				void append(InputIterator b, InputIterator e)
				{
					base::insert(end(), b, e);
				}
				void resize(size_type n, E c)
				{
					base::reserve(n+1);
					base::back()=c;
					base::resize(n+1, c);
					base::back()=E();
				}
				void swap(VectorStringStorage&rhs)
				{
					base::swap(rhs);
				}
				const E*c_str()const
				{
					return &*begin();
				}
				const E*data()const
				{
					return &*begin();
				}
				A get_allocator()const
				{
					return base::get_allocator();
				}
			};
			template<class Storage, unsigned int threshold, typename Align=typename Storage::value_type*>
			class SmallStringOpt
			{
			public:
				typedef typename Storage::value_type value_type;
				typedef value_type*iterator;
				typedef const value_type*const_iterator;
				typedef typename Storage::allocator_type allocator_type;
				typedef typename allocator_type::size_type size_type;
			private:
				enum
				{
					temp1=threshold*sizeof(value_type)>sizeof(Storage)?threshold*sizeof(value_type): sizeof(Storage)
				};
				enum
				{
					temp2=temp1>sizeof(Align)?temp1: sizeof(Align)
				};
			public:
				enum
				{
					maxSmallString=(temp2+sizeof(value_type)-1)/sizeof(value_type)
				};
			private:
				enum
				{
					magic=maxSmallString+1
				};
				union
				{
					mutable value_type buf_[maxSmallString+1];
					Align align_;
				};
				Storage&GetStorage()
				{
					(void)((!!(buf_[maxSmallString]==magic))||(_wassert(L"buf_[maxSmallString] == magic", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 896), 0));
					Storage*p=reinterpret_cast<Storage*>(&buf_[0]);
					return *p;
				}
				const Storage&GetStorage()const
				{
					(void)((!!(buf_[maxSmallString]==magic))||(_wassert(L"buf_[maxSmallString] == magic", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 903), 0));
					const Storage*p=reinterpret_cast<const Storage*>(&buf_[0]);
					return *p;
				}
				bool Small()const
				{
					return buf_[maxSmallString]!=magic;
				}
			public:
				SmallStringOpt(const SmallStringOpt&s)
				{
					if(s.Small())
					{
						flex_string_details::pod_copy(s.buf_, s.buf_+s.size(), buf_);
					}
					else
					{
						new(buf_)Storage(s.GetStorage());
					}
					buf_[maxSmallString]=s.buf_[maxSmallString];
				}
				SmallStringOpt(const allocator_type&)
				{
					buf_[maxSmallString]=maxSmallString;
				}
				SmallStringOpt(const value_type*s, size_type len, const allocator_type&a)
				{
					if(len<=maxSmallString)
					{
						flex_string_details::pod_copy(s, s+len, buf_);
						buf_[maxSmallString]=value_type(maxSmallString-len);
					}
					else
					{
						new(buf_)Storage(s, len, a);
						buf_[maxSmallString]=magic;
					}
				}
				SmallStringOpt(size_type len, value_type c, const allocator_type&a)
				{
					if(len<=maxSmallString)
					{
						flex_string_details::pod_fill(buf_, buf_+len, c);
						buf_[maxSmallString]=value_type(maxSmallString-len);
					}
					else
					{
						new(buf_)Storage(len, c, a);
						buf_[maxSmallString]=magic;
					}
				}
				SmallStringOpt&operator=(const SmallStringOpt&rhs)
				{
					reserve(rhs.size());
					resize(0, 0);
					append(rhs.data(), rhs.size());
					return *this;
				}
				~SmallStringOpt()
				{
					if(!Small())GetStorage().~Storage();
				}
				iterator begin()
				{
					if(Small())return buf_;
					return &*GetStorage().begin();
				}
				const_iterator begin()const
				{
					if(Small())return buf_;
					return &*GetStorage().begin();
				}
				iterator end()
				{
					if(Small())return buf_+maxSmallString-buf_[maxSmallString];
					return &*GetStorage().end();
				}
				const_iterator end()const
				{
					if(Small())return buf_+maxSmallString-buf_[maxSmallString];
					return &*GetStorage().end();
				}
				size_type size()const
				{
					(void)((!!(!Small()||maxSmallString>=buf_[maxSmallString]))||(_wassert(L"!Small() || maxSmallString >= buf_[maxSmallString]", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1002), 0));
					return Small()?maxSmallString-buf_[maxSmallString]: GetStorage().size();
				}
				size_type max_size()const
				{
					return get_allocator().max_size();
				}
				size_type capacity()const
				{
					return Small()?maxSmallString: GetStorage().capacity();
				}
				void reserve(size_type res_arg)
				{
					if(Small())
					{
						if(res_arg<=maxSmallString)return ;
						SmallStringOpt temp(*this);
						this->~SmallStringOpt();
						new(buf_)Storage(temp.data(), temp.size(), temp.get_allocator());
						buf_[maxSmallString]=magic;
						GetStorage().reserve(res_arg);
					}
					else
					{
						GetStorage().reserve(res_arg);
					}
					(void)((!!(capacity()>=res_arg))||(_wassert(L"capacity() >= res_arg", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1030), 0));
				}
				void append(const value_type*s, size_type sz)
				{
					if(!Small())
					{
						GetStorage().append(s, sz);
					}
					else
					{
						const size_type neededCapacity=maxSmallString-buf_[maxSmallString]+sz;
						if(maxSmallString<neededCapacity)
						{
							allocator_type alloc;
							Storage temp(alloc);
							temp.reserve(neededCapacity);
							temp.append(buf_, maxSmallString-buf_[maxSmallString]);
							temp.append(s, sz);
							buf_[maxSmallString]=magic;
							new(buf_)Storage(temp.get_allocator());
							GetStorage().swap(temp);
						}
						else
						{
							flex_string_details::pod_move(s, s+sz, buf_+maxSmallString-buf_[maxSmallString]);
							buf_[maxSmallString]-=value_type(sz);
						}
					}
				}
				template<class InputIterator>
				void append(InputIterator b, InputIterator e)
				{
					for(;
					b!=e;
					++b)
					{
						*this+=*b;
					}
				}
				void resize(size_type n, value_type c)
				{
					if(Small())
					{
						if(n>maxSmallString)
						{
							SmallStringOpt temp(*this);
							Storage newString(temp.data(), temp.size(), temp.get_allocator());
							newString.resize(n, c);
							this->~SmallStringOpt();
							new(&buf_[0])Storage(temp.get_allocator());
							buf_[maxSmallString]=value_type(magic);
							GetStorage().swap(newString);
						}
						else
						{
							size_type toFill=n>size()?n-size(): 0;
							flex_string_details::pod_fill(end(), end()+toFill, c);
							buf_[maxSmallString]=value_type(maxSmallString-n);
						}
					}
					else
					{
						if(n>maxSmallString)
						{
							GetStorage().resize(n, c);
						}
						else
						{
							(void)((!!(capacity()>n))||(_wassert(L"capacity() > n", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1115), 0));
							SmallStringOpt newObj(data(), n, get_allocator());
							newObj.swap(*this);
						}
					}
				}
				void swap(SmallStringOpt&rhs)
				{
					if(Small())
					{
						if(rhs.Small())
						{
							std::swap_ranges(buf_, buf_+maxSmallString+1, rhs.buf_);
						}
						else
						{
							SmallStringOpt temp(*this);
							this->~SmallStringOpt();
							new(buf_)Storage(0, value_type(), rhs.get_allocator());
							buf_[maxSmallString]=magic;
							swap(rhs);
							rhs.~SmallStringOpt();
							new(&rhs)SmallStringOpt(temp);
						}
					}
					else
					{
						if(rhs.Small())
						{
							rhs.swap(*this);
						}
						else
						{
							GetStorage().swap(rhs.GetStorage());
						}
					}
				}
				const value_type*c_str()const
				{
					if(!Small())return GetStorage().c_str();
					buf_[maxSmallString-buf_[maxSmallString]]=value_type();
					return buf_;
				}
				const value_type*data()const
				{
					return Small()?buf_: GetStorage().data();
				}
				allocator_type get_allocator()const
				{
					return allocator_type();
				}
			};
			template<typename Storage, typename Align=typename Storage::value_type*>
			class CowString
			{
				typedef typename Storage::value_type E;
				typedef typename flex_string_details::get_unsigned<E>::result RefCountType;
			public:
				typedef E value_type;
				typedef typename Storage::iterator iterator;
				typedef typename Storage::const_iterator const_iterator;
				typedef typename Storage::allocator_type allocator_type;
				typedef typename allocator_type::size_type size_type;
				typedef typename Storage::reference reference;
			private:
				union
				{
					mutable char buf_[sizeof(Storage)];
					Align align_;
				};
				Storage&Data()const
				{
					Storage*p=reinterpret_cast<Storage*>(&buf_[0]);
					return *p;
				}
				RefCountType GetRefs()const
				{
					const Storage&d=Data();
					(void)((!!(d.size()>0))||(_wassert(L"d.size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1218), 0));
					(void)((!!(static_cast<RefCountType>(*d.begin())!=0))||(_wassert(L"static_cast<RefCountType>(*d.begin()) != 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1219), 0));
					return *d.begin();
				}
				RefCountType&Refs()
				{
					Storage&d=Data();
					(void)((!!(d.size()>0))||(_wassert(L"d.size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1226), 0));
					return reinterpret_cast<RefCountType&>(*d.begin());
				}
				void MakeUnique()const
				{
					(void)((!!(GetRefs()>=1))||(_wassert(L"GetRefs() >= 1", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1232), 0));
					if(GetRefs()==1)return ;
					union
					{
						char buf_[sizeof(Storage)];
						Align align_;
					}
					temp;
					--(*Data().begin());
					Storage*p=reinterpret_cast<Storage*>(&temp.buf_[0]);
					new(buf_)Storage(*new(p)Storage(Data()), flex_string_details::Shallow());
					*Data().begin()=1;
				}
			public:
				CowString(const CowString&s)
				{
					if(s.GetRefs()==(std::numeric_limits<RefCountType>::max)())
					{
						new(buf_)Storage(s.Data());
						Refs()=1;
					}
					else
					{
						new(buf_)Storage(s.Data(), flex_string_details::Shallow());
						++Refs();
					}
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1264), 0));
				}
				CowString(const allocator_type&a)
				{
					new(buf_)Storage(1, 1, a);
				}
				CowString(const E*s, size_type len, const allocator_type&a)
				{
					new(buf_)Storage(a);
					Data().reserve(len+1);
					Data().resize(1, 1);
					Data().append(s, s+len);
				}
				CowString(size_type len, E c, const allocator_type&a)
				{
					new(buf_)Storage(len+1, c, a);
					Refs()=1;
				}
				CowString&operator=(const CowString&rhs)
				{
					if(--Refs()==0)Data().~Storage();
					if(rhs.GetRefs()==(std::numeric_limits<RefCountType>::max)())
					{
						new(buf_)Storage(rhs.Data());
						Refs()=1;
					}
					else
					{
						new(buf_)Storage(rhs.Data(), flex_string_details::Shallow());
						++Refs();
					}
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1305), 0));
					return *this;
				}
				~CowString()
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1311), 0));
					if(--Refs()==0)Data().~Storage();
				}
				iterator begin()
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1318), 0));
					MakeUnique();
					return Data().begin()+1;
				}
				const_iterator begin()const
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1325), 0));
					return Data().begin()+1;
				}
				iterator end()
				{
					MakeUnique();
					return Data().end();
				}
				const_iterator end()const
				{
					return Data().end();
				}
				size_type size()const
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1342), 0));
					return Data().size()-1;
				}
				size_type max_size()const
				{
					(void)((!!(Data().max_size()>0))||(_wassert(L"Data().max_size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1348), 0));
					return Data().max_size()-1;
				}
				size_type capacity()const
				{
					(void)((!!(Data().capacity()>0))||(_wassert(L"Data().capacity() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1354), 0));
					return Data().capacity()-1;
				}
				void resize(size_type n, E c)
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1360), 0));
					MakeUnique();
					Data().resize(n+1, c);
				}
				template<class FwdIterator>
				void append(FwdIterator b, FwdIterator e)
				{
					MakeUnique();
					Data().append(b, e);
				}
				void reserve(size_type res_arg)
				{
					if(capacity()>res_arg)return ;
					MakeUnique();
					Data().reserve(res_arg+1);
				}
				void swap(CowString&rhs)
				{
					Data().swap(rhs.Data());
				}
				const E*c_str()const
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1386), 0));
					return Data().c_str()+1;
				}
				const E*data()const
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1392), 0));
					return Data().data()+1;
				}
				allocator_type get_allocator()const
				{
					return Data().get_allocator();
				}
			};
			template<typename E, class T=std::char_traits<E>, class A=std::allocator<E>, class Storage=AllocatorStringStorage<E, A> >
			class flex_string: private Storage
			{
				template<typename Exception>
				static inline void Enforce(bool condition, Exception*, const char*msg)
				{
					(void)((!!(condition&&msg))||(_wassert(L"condition && msg", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1421), 0));
				}
				bool Sane()const
				{
					return begin()<=end()&&empty()==(size()==0)&&empty()==(begin()==end())&&size()<=max_size()&&capacity()<=max_size()&&size()<=capacity();
				}
				struct Invariant;
				friend struct Invariant;
				struct Invariant
				{
					Invariant(const flex_string&s): s_(s)
					{
						(void)((!!(s_.Sane()))||(_wassert(L"s_.Sane()", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1442), 0));
					}
					~Invariant()
					{
						(void)((!!(s_.Sane()))||(_wassert(L"s_.Sane()", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1446), 0));
					}
				private:
					const flex_string&s_;
					Invariant&operator=(const Invariant&);
				};
			public:
				typedef T traits_type;
				typedef typename traits_type::char_type value_type;
				typedef A allocator_type;
				typedef typename A::size_type size_type;
				typedef typename A::difference_type difference_type;
				typedef typename A::reference reference;
				typedef typename A::const_reference const_reference;
				typedef typename A::pointer pointer;
				typedef typename A::const_pointer const_pointer;
				typedef typename Storage::iterator iterator;
				typedef typename Storage::const_iterator const_iterator;
				typedef boost::reverse_iterator<iterator>reverse_iterator;
				typedef boost::reverse_iterator<const_iterator>const_reverse_iterator;
				static const size_type npos;
			private:
				static size_type Min(size_type lhs, size_type rhs)
				{
					return lhs<rhs?lhs: rhs;
				}
				static void Procust(size_type&n, size_type nmax)
				{
					if(n>nmax)n=nmax;
				}
			public:
				explicit flex_string(const A&a=A()): Storage(a)
				{
				}
				flex_string(const flex_string&str): Storage(str)
				{
				}
				flex_string(const flex_string&str, size_type pos, size_type n=npos, const A&a=A()): Storage(a)
				{
					Enforce(pos<=str.size(), (std::out_of_range*)0, "");
					assign(str, pos, n);
				}
				flex_string(const value_type*s, const A&a=A()): Storage(s, traits_type::length(s), a)
				{
				}
				flex_string(const value_type*s, size_type n, const A&a=A()): Storage(s, n, a)
				{
				}
				flex_string(size_type n, value_type c, const A&a=A()): Storage(n, c, a)
				{
				}
				template<class InputIterator>
				flex_string(InputIterator begin, InputIterator end, const A&a=A()): Storage(a)
				{
					assign(begin, end);
				}
				~flex_string()
				{
				}
				flex_string&operator=(const flex_string&str)
				{
					if(this!=&str)
					{
						Storage&s=*this;
						s=str;
					}
					return *this;
				}
				flex_string&operator=(const value_type*s)
				{
					assign(s);
					return *this;
				}
				flex_string&operator=(value_type c)
				{
					assign(1, c);
					return *this;
				}
				iterator begin()
				{
					return Storage::begin();
				}
				const_iterator begin()const
				{
					return Storage::begin();
				}
				iterator end()
				{
					return Storage::end();
				}
				const_iterator end()const
				{
					return Storage::end();
				}
				reverse_iterator rbegin()
				{
					return reverse_iterator(end());
				}
				const_reverse_iterator rbegin()const
				{
					return const_reverse_iterator(end());
				}
				reverse_iterator rend()
				{
					return reverse_iterator(begin());
				}
				const_reverse_iterator rend()const
				{
					return const_reverse_iterator(begin());
				}
				size_type size()const
				{
					return Storage::size();
				}
				size_type length()const
				{
					return size();
				}
				size_type max_size()const
				{
					return Storage::max_size();
				}
				void resize(size_type n, value_type c)
				{
					Storage::resize(n, c);
				}
				void resize(size_type n)
				{
					resize(n, value_type());
				}
				size_type capacity()const
				{
					return Storage::capacity();
				}
				void reserve(size_type res_arg=0)
				{
					Enforce(res_arg<=max_size(), (std::length_error*)0, "");
					Storage::reserve(res_arg);
				}
				void clear()
				{
					resize(0);
				}
				bool empty()const
				{
					return size()==0;
				}
				const_reference operator[](size_type pos)const
				{
					return *(begin()+pos);
				}
				reference operator[](size_type pos)
				{
					return *(begin()+pos);
				}
				const_reference at(size_type n)const
				{
					Enforce(n<size(), (std::out_of_range*)0, "");
					return (*this)[n];
				}
				reference at(size_type n)
				{
					Enforce(n<size(), (std::out_of_range*)0, "");
					return (*this)[n];
				}
				flex_string&operator+=(const flex_string&str)
				{
					return append(str);
				}
				flex_string&operator+=(const value_type*s)
				{
					return append(s);
				}
				flex_string&operator+=(value_type c)
				{
					push_back(c);
					return *this;
				}
				flex_string&append(const flex_string&str)
				{
					return append(str, 0, npos);
				}
				flex_string&append(const flex_string&str, const size_type pos, size_type n)
				{
					const size_type sz=str.size();
					Enforce(pos<=sz, (std::out_of_range*)0, "");
					Procust(n, sz-pos);
					return append(str.c_str()+pos, n);
				}
				flex_string&append(const value_type*s, const size_type n)
				{
					Invariant checker(*this);
					if(IsAliasedRange(s, s+n))
					{
						const size_type offset=s-&*begin();
						Storage::reserve(size()+n);
						s=&*begin()+offset;
					}
					Storage::append(s, s+n);
					return *this;
				}
				flex_string&append(const value_type*s)
				{
					return append(s, traits_type::length(s));
				}
				flex_string&append(size_type n, value_type c)
				{
					resize(size()+n, c);
					return *this;
				}
				template<class InputIterator>
				flex_string&append(InputIterator first, InputIterator last)
				{
					insert(end(), first, last);
					return *this;
				}
				void push_back(value_type c)
				{
					const size_type cap=capacity();
					if(size()==cap)
					{
						reserve(cap<<1u);
					}
					Storage::append(&c, &c+1);
				}
				flex_string&assign(const flex_string&str)
				{
					if(&str==this)return *this;
					return assign(str.data(), str.size());
				}
				flex_string&assign(const flex_string&str, size_type pos, size_type n)
				{
					const size_type sz=str.size();
					Enforce(pos<=str.size(), (std::out_of_range*)0, "");
					Procust(n, sz-pos);
					return assign(str.data()+pos, n);
				}
				flex_string&assign(const value_type*s, size_type n)
				{
					Invariant checker(*this);
					if(size()>=n)
					{
						std::copy(s, s+n, begin());
						resize(n);
					}
					else
					{
						const value_type*const s2=s+size();
						std::copy(s, s2, begin());
						append(s2, n-size());
					}
					return *this;
				}
				flex_string&assign(const value_type*s)
				{
					return assign(s, traits_type::length(s));
				}
				template<class ItOrLength, class ItOrChar>
				flex_string&assign(ItOrLength first_or_n, ItOrChar last_or_c)
				{
					return replace(begin(), end(), first_or_n, last_or_c);
				}
				flex_string&insert(size_type pos1, const flex_string&str)
				{
					return insert(pos1, str.data(), str.size());
				}
				flex_string&insert(size_type pos1, const flex_string&str, size_type pos2, size_type n)
				{
					Enforce(pos2<=str.length(), (std::out_of_range*)0, "");
					Procust(n, str.length()-pos2);
					return insert(pos1, str.data()+pos2, n);
				}
				flex_string&insert(size_type pos, const value_type*s, size_type n)
				{
					Enforce(pos<=length(), (std::out_of_range*)0, "");
					insert(begin()+pos, s, s+n);
					return *this;
				}
				flex_string&insert(size_type pos, const value_type*s)
				{
					return insert(pos, s, traits_type::length(s));
				}
				flex_string&insert(size_type pos, size_type n, value_type c)
				{
					Enforce(pos<=length(), (std::out_of_range*)0, "");
					insert(begin()+pos, n, c);
					return *this;
				}
				iterator insert(iterator p, value_type c=value_type())
				{
					const size_type pos=p-begin();
					insert(pos, &c, 1);
					return begin()+pos;
				}
			private:
				template<class Iterator>
				const typename std::iterator_traits<Iterator>::value_type*DereferenceValidIterator(Iterator it)const
				{
					return &*it;
				}
				template<typename Iterator>
				const typename std::iterator_traits<Iterator>::value_type*DereferenceValidIterator(std::reverse_iterator<Iterator>it)const
				{
					return &*--it;
				}
				template<class Iterator>
				bool IsAliasedRange(Iterator beginIterator, Iterator endIterator)
				{
					if(!empty()&&beginIterator!=endIterator)
					{
						typedef const typename std::iterator_traits<Iterator>::value_type*pointer;
						pointer myBegin(&*begin());
						pointer myEnd(&*begin()+size());
						pointer rangeBegin(DereferenceValidIterator(beginIterator));
						const std::less_equal<pointer>less_equal=std::less_equal<pointer>();
						if(less_equal(myBegin, rangeBegin)&&less_equal(rangeBegin, myEnd))return true;
					}
					return false;
				}
				template<int i>
				class Selector
				{
				};
				flex_string&InsertImplDiscr(iterator p, size_type n, value_type c, Selector<1>)
				{
					Invariant checker(*this);
					(void)((!!(begin()<=p&&p<=end()))||(_wassert(L"begin() <= p && p <= end()", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1821), 0));
					const size_type insertOffset(p-begin());
					const size_type originalSize(size());
					if(n<originalSize-insertOffset)
					{
						append(n, value_type(0));
						value_type*begin(&*begin());
						flex_string_details::pod_move(begin+insertOffset, begin+originalSize, begin+insertOffset+n);
						std::fill(begin+insertOffset, begin+insertOffset+n, c);
					}
					else
					{
						append(n, c);
						value_type*begin(&*begin());
						flex_string_details::pod_copy(begin+insertOffset, begin+originalSize, begin+insertOffset+n);
						std::fill(begin+insertOffset, begin+originalSize, c);
					}
					return *this;
				}
				template<class InputIterator>
				flex_string&InsertImplDiscr(iterator i, InputIterator b, InputIterator e, Selector<0>)
				{
					InsertImpl(i, b, e, typename std::iterator_traits<InputIterator>::iterator_category());
					return *this;
				}
				template<class FwdIterator>
				void InsertImpl(iterator i, FwdIterator s1, FwdIterator s2, std::forward_iterator_tag)
				{
					if(s1==s2)
					{
						return ;
					}
					if(IsAliasedRange(s1, s2))
					{
						const flex_string temporary(s1, s2);
						InsertImpl(i, temporary.begin(), temporary.end(), typename std::iterator_traits<FwdIterator>::iterator_category());
						return ;
					}
					Invariant checker(*this);
					const size_type pos=i-begin();
					const typename std::iterator_traits<FwdIterator>::difference_type n2=std::distance(s1, s2);
					(void)((!!(n2>=0))||(_wassert(L"n2 >= 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1887), 0));
					using namespace flex_string_details;
					(void)((!!(pos<=size()))||(_wassert(L"pos <= size()", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1889), 0));
					const typename std::iterator_traits<FwdIterator>::difference_type maxn2=capacity()-size();
					if(maxn2<n2)
					{
						(void)((!!(!IsAliasedRange(s1, s2)))||(_wassert(L"!IsAliasedRange(s1, s2)", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1896), 0));
						reserve(size()+n2);
						i=begin()+pos;
					}
					if(pos+n2<=size())
					{
						const iterator tailBegin=end()-n2;
						Storage::append(tailBegin, tailBegin+n2);
						std::copy(reverse_iterator(tailBegin), reverse_iterator(i), reverse_iterator(tailBegin+n2));
						std::copy(s1, s2, i);
					}
					else
					{
						FwdIterator t=s1;
						const size_type old_size=size();
						std::advance(t, old_size-pos);
						(void)((!!(std::distance(t, s2)>=0))||(_wassert(L"std::distance(t, s2) >= 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 1913), 0));
						Storage::append(t, s2);
						Storage::append(data()+pos, data()+old_size);
						std::copy(s1, t, i);
					}
				}
				template<class InputIterator>
				void InsertImpl(iterator insertPosition, InputIterator inputBegin, InputIterator inputEnd, std::input_iterator_tag)
				{
					flex_string temporary(begin(), insertPosition);
					for(;
					inputBegin!=inputEnd;
					++inputBegin)
					{
						temporary.push_back(*inputBegin);
					}
					temporary.append(insertPosition, end());
					swap(temporary);
				}
			public:
				template<class ItOrLength, class ItOrChar>
				void insert(iterator p, ItOrLength first_or_n, ItOrChar last_or_c)
				{
					Selector<std::numeric_limits<ItOrLength>::is_specialized>sel;
					InsertImplDiscr(p, first_or_n, last_or_c, sel);
				}
				flex_string&erase(size_type pos=0, size_type n=npos)
				{
					Invariant checker(*this);
					Enforce(pos<=length(), (std::out_of_range*)0, "");
					Procust(n, length()-pos);
					std::copy(begin()+pos+n, end(), begin()+pos);
					resize(length()-n);
					return *this;
				}
				iterator erase(iterator position)
				{
					const size_type pos(position-begin());
					erase(pos, 1);
					return begin()+pos;
				}
				iterator erase(iterator first, iterator last)
				{
					const size_type pos(first-begin());
					erase(pos, last-first);
					return begin()+pos;
				}
				flex_string&replace(size_type pos1, size_type n1, const flex_string&str)
				{
					return replace(pos1, n1, str, 0, npos);
				}
				flex_string&replace(size_type pos1, size_type n1, const flex_string&str, size_type pos2, size_type n2)
				{
					Enforce(pos2<=str.length(), (std::out_of_range*)0, "");
					return replace(pos1, n1, str.data()+pos2, Min(n2, str.size()-pos2));
				}
				flex_string&replace(size_type pos, size_type n1, const value_type*s)
				{
					return replace(pos, n1, s, traits_type::length(s));
				}
				template<class StrOrLength, class NumOrChar>
				flex_string&replace(size_type pos, size_type n1, StrOrLength s_or_n2, NumOrChar n_or_c)
				{
					Invariant checker(*this);
					Enforce(pos<=size(), (std::out_of_range*)0, "");
					Procust(n1, length()-pos);
					const iterator b=begin()+pos;
					return replace(b, b+n1, s_or_n2, n_or_c);
				}
				flex_string&replace(iterator i1, iterator i2, const flex_string&str)
				{
					return replace(i1, i2, str.c_str(), str.length());
				}
				flex_string&replace(iterator i1, iterator i2, const value_type*s)
				{
					return replace(i1, i2, s, traits_type::length(s));
				}
			private:
				flex_string&ReplaceImplDiscr(iterator i1, iterator i2, const value_type*s, size_type n, Selector<2>)
				{
					(void)((!!(i1<=i2))||(_wassert(L"i1 <= i2", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 2014), 0));
					(void)((!!(begin()<=i1&&i1<=end()))||(_wassert(L"begin() <= i1 && i1 <= end()", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 2015), 0));
					(void)((!!(begin()<=i2&&i2<=end()))||(_wassert(L"begin() <= i2 && i2 <= end()", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 2016), 0));
					return replace(i1, i2, s, s+n);
				}
				flex_string&ReplaceImplDiscr(iterator i1, iterator i2, size_type n2, value_type c, Selector<1>)
				{
					const size_type n1=i2-i1;
					if(n1>n2)
					{
						std::fill(i1, i1+n2, c);
						erase(i1+n2, i2);
					}
					else
					{
						std::fill(i1, i2, c);
						insert(i2, n2-n1, c);
					}
					return *this;
				}
				template<class InputIterator>
				flex_string&ReplaceImplDiscr(iterator i1, iterator i2, InputIterator b, InputIterator e, Selector<0>)
				{
					ReplaceImpl(i1, i2, b, e, typename std::iterator_traits<InputIterator>::iterator_category());
					return *this;
				}
				template<class FwdIterator>
				void ReplaceImpl(iterator i1, iterator i2, FwdIterator s1, FwdIterator s2, std::forward_iterator_tag)
				{
					Invariant checker(*this);
					const typename std::iterator_traits<iterator>::difference_type n1=i2-i1;
					(void)((!!(n1>=0))||(_wassert(L"n1 >= 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 2055), 0));
					const typename std::iterator_traits<FwdIterator>::difference_type n2=std::distance(s1, s2);
					(void)((!!(n2>=0))||(_wassert(L"n2 >= 0", L"D:\\dev\\external\\boost\\boost\\wave\\util\\flex_string.hpp", 2058), 0));
					if(IsAliasedRange(s1, s2))
					{
						flex_string temporary;
						temporary.reserve(size()-n1+n2);
						temporary.append(begin(), i1).append(s1, s2).append(i2, end());
						swap(temporary);
						return ;
					}
					if(n1>n2)
					{
						std::copy(s1, s2, i1);
						erase(i1+n2, i2);
					}
					else
					{
						flex_string_details::copy_n(s1, n1, i1);
						std::advance(s1, n1);
						insert(i2, s1, s2);
					}
				}
				template<class InputIterator>
				void ReplaceImpl(iterator i1, iterator i2, InputIterator b, InputIterator e, std::input_iterator_tag)
				{
					flex_string temp(begin(), i1);
					temp.append(b, e).append(i2, end());
					swap(temp);
				}
			public:
				template<class T1, class T2>
				flex_string&replace(iterator i1, iterator i2, T1 first_or_n_or_s, T2 last_or_c_or_n)
				{
					const bool num1=std::numeric_limits<T1>::is_specialized, num2=std::numeric_limits<T2>::is_specialized;
					return ReplaceImplDiscr(i1, i2, first_or_n_or_s, last_or_c_or_n, Selector<num1?(num2?1: -1): (num2?2: 0)>());
				}
				size_type copy(value_type*s, size_type n, size_type pos=0)const
				{
					Enforce(pos<=size(), (std::out_of_range*)0, "");
					n=Min(n, size()-pos);
					flex_string_details::pod_copy(&*begin()+pos, &*begin()+pos+n, s);
					return n;
				}
				void swap(flex_string&rhs)
				{
					Storage&srhs=rhs;
					this->Storage::swap(srhs);
				}
				const value_type*c_str()const
				{
					return Storage::c_str();
				}
				const value_type*data()const
				{
					return Storage::data();
				}
				allocator_type get_allocator()const
				{
					return Storage::get_allocator();
				}
				size_type find(const flex_string&str, size_type pos=0)const
				{
					return find(str.data(), pos, str.length());
				}
				size_type find(const value_type*s, size_type pos, size_type n)const
				{
					const size_type size_(size());
					if(n+pos>size_)return npos;
					for(;
					pos<size_;
					++pos)
					{
						if(traits_type::compare(&*begin()+pos, s, n)==0)
						{
							return pos;
						}
					}
					return npos;
				}
				size_type find(const value_type*s, size_type pos=0)const
				{
					return find(s, pos, traits_type::length(s));
				}
				size_type find(value_type c, size_type pos=0)const
				{
					return find(&c, pos, 1);
				}
				size_type rfind(const flex_string&str, size_type pos=npos)const
				{
					return rfind(str.c_str(), pos, str.length());
				}
				size_type rfind(const value_type*s, size_type pos, size_type n)const
				{
					if(n>length())return npos;
					pos=Min(pos, length()-n);
					if(n==0)return pos;
					const_iterator i(begin()+pos);
					for(;
					;
					--i)
					{
						if(traits_type::eq(*i, *s)&&traits_type::compare(&*i, s, n)==0)
						{
							return i-begin();
						}
						if(i==begin())break;
					}
					return npos;
				}
				size_type rfind(const value_type*s, size_type pos=npos)const
				{
					return rfind(s, pos, traits_type::length(s));
				}
				size_type rfind(value_type c, size_type pos=npos)const
				{
					return rfind(&c, pos, 1);
				}
				size_type find_first_of(const flex_string&str, size_type pos=0)const
				{
					return find_first_of(str.c_str(), pos, str.length());
				}
				size_type find_first_of(const value_type*s, size_type pos, size_type n)const
				{
					if(pos>length()||n==0)return npos;
					const_iterator i(begin()+pos), finish(end());
					for(;
					i!=finish;
					++i)
					{
						if(traits_type::find(s, n, *i)!=0)
						{
							return i-begin();
						}
					}
					return npos;
				}
				size_type find_first_of(const value_type*s, size_type pos=0)const
				{
					return find_first_of(s, pos, traits_type::length(s));
				}
				size_type find_first_of(value_type c, size_type pos=0)const
				{
					return find_first_of(&c, pos, 1);
				}
				size_type find_last_of(const flex_string&str, size_type pos=npos)const
				{
					return find_last_of(str.c_str(), pos, str.length());
				}
				size_type find_last_of(const value_type*s, size_type pos, size_type n)const
				{
					if(!empty()&&n>0)
					{
						pos=Min(pos, length()-1);
						const_iterator i(begin()+pos);
						for(;
						;
						--i)
						{
							if(traits_type::find(s, n, *i)!=0)
							{
								return i-begin();
							}
							if(i==begin())break;
						}
					}
					return npos;
				}
				size_type find_last_of(const value_type*s, size_type pos=npos)const
				{
					return find_last_of(s, pos, traits_type::length(s));
				}
				size_type find_last_of(value_type c, size_type pos=npos)const
				{
					return find_last_of(&c, pos, 1);
				}
				size_type find_first_not_of(const flex_string&str, size_type pos=0)const
				{
					return find_first_not_of(str.data(), pos, str.size());
				}
				size_type find_first_not_of(const value_type*s, size_type pos, size_type n)const
				{
					if(pos<length())
					{
						const_iterator i(begin()+pos), finish(end());
						for(;
						i!=finish;
						++i)
						{
							if(traits_type::find(s, n, *i)==0)
							{
								return i-begin();
							}
						}
					}
					return npos;
				}
				size_type find_first_not_of(const value_type*s, size_type pos=0)const
				{
					return find_first_not_of(s, pos, traits_type::length(s));
				}
				size_type find_first_not_of(value_type c, size_type pos=0)const
				{
					return find_first_not_of(&c, pos, 1);
				}
				size_type find_last_not_of(const flex_string&str, size_type pos=npos)const
				{
					return find_last_not_of(str.c_str(), pos, str.length());
				}
				size_type find_last_not_of(const value_type*s, size_type pos, size_type n)const
				{
					if(!empty())
					{
						pos=Min(pos, size()-1);
						const_iterator i(begin()+pos);
						for(;
						;
						--i)
						{
							if(traits_type::find(s, n, *i)==0)
							{
								return i-begin();
							}
							if(i==begin())break;
						}
					}
					return npos;
				}
				size_type find_last_not_of(const value_type*s, size_type pos=npos)const
				{
					return find_last_not_of(s, pos, traits_type::length(s));
				}
				size_type find_last_not_of(value_type c, size_type pos=npos)const
				{
					return find_last_not_of(&c, pos, 1);
				}
				flex_string substr(size_type pos=0, size_type n=npos)const
				{
					Enforce(pos<=size(), (std::out_of_range*)0, "");
					return flex_string(data()+pos, Min(n, size()-pos));
				}
				std::ptrdiff_t compare(const flex_string&str)const
				{
					return compare(0, size(), str);
				}
				std::ptrdiff_t compare(size_type pos1, size_type n1, const flex_string&str)const
				{
					return compare(pos1, n1, str.data(), str.size());
				}
				std::ptrdiff_t compare(size_type pos1, size_type n1, const value_type*s)const
				{
					return compare(pos1, n1, s, traits_type::length(s));
				}
				std::ptrdiff_t compare(size_type pos1, size_type n1, const value_type*s, size_type n2)const
				{
					Enforce(pos1<=size(), (std::out_of_range*)0, "");
					Procust(n1, size()-pos1);
					const int r=traits_type::compare(pos1+data(), s, Min(n1, n2));
					return r!=0?r: n1>n2?1: n1<n2?-1: 0;
				}
				std::ptrdiff_t compare(size_type pos1, size_type n1, const flex_string&str, size_type pos2, size_type n2)const
				{
					Enforce(pos2<=str.size(), (std::out_of_range*)0, "");
					return compare(pos1, n1, str.data()+pos2, Min(n2, str.size()-pos2));
				}
				std::ptrdiff_t compare(const value_type*s)const
				{
					const size_type n1(size()), n2(traits_type::length(s));
					const int r=traits_type::compare(data(), s, Min(n1, n2));
					return r!=0?r: n1>n2?1: n1<n2?-1: 0;
				}
			};
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				flex_string<E, T, A, S>result;
				result.reserve(lhs.size()+rhs.size());
				result.append(lhs).append(rhs);
				return result;
			}
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				flex_string<E, T, A, S>result;
				const typename flex_string<E, T, A, S>::size_type len=flex_string<E, T, A, S>::traits_type::length(lhs);
				result.reserve(len+rhs.size());
				result.append(lhs, len).append(rhs);
				return result;
			}
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(typename flex_string<E, T, A, S>::value_type lhs, const flex_string<E, T, A, S>&rhs)
			{
				flex_string<E, T, A, S>result;
				result.reserve(1+rhs.size());
				result.push_back(lhs);
				result.append(rhs);
				return result;
			}
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				typedef typename flex_string<E, T, A, S>::size_type size_type;
				typedef typename flex_string<E, T, A, S>::traits_type traits_type;
				flex_string<E, T, A, S>result;
				const size_type len=traits_type::length(rhs);
				result.reserve(lhs.size()+len);
				result.append(lhs).append(rhs, len);
				return result;
			}
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(const flex_string<E, T, A, S>&lhs, typename flex_string<E, T, A, S>::value_type rhs)
			{
				flex_string<E, T, A, S>result;
				result.reserve(lhs.size()+1);
				result.append(lhs);
				result.push_back(rhs);
				return result;
			}
			template<typename E, class T, class A, class S>
			inline bool operator==(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return lhs.compare(rhs)==0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator==(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return rhs==lhs;
			}
			template<typename E, class T, class A, class S>
			inline bool operator==(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return lhs.compare(rhs)==0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator!=(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(lhs==rhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator!=(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(lhs==rhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator!=(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return !(lhs==rhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator<(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return lhs.compare(rhs)<0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator<(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return lhs.compare(rhs)<0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator<(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return rhs.compare(lhs)>0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator>(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return rhs<lhs;
			}
			template<typename E, class T, class A, class S>
			inline bool operator>(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return rhs<lhs;
			}
			template<typename E, class T, class A, class S>
			bool operator>(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return rhs<lhs;
			}
			template<typename E, class T, class A, class S>
			inline bool operator<=(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(rhs<lhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator<=(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return !(rhs<lhs);
			}
			template<typename E, class T, class A, class S>
			bool operator<=(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(rhs<lhs);
			}
			template<typename E, class T, class A, class S>
			bool operator>=(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(lhs<rhs);
			}
			template<typename E, class T, class A, class S>
			bool operator>=(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return !(lhs<rhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator>=(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(lhs<rhs);
			}
			template<typename E, class T, class A, class S>
			void swap(flex_string<E, T, A, S>&lhs, flex_string<E, T, A, S>&rhs)
			{
				lhs.swap(rhs);
			}
			template<typename E, class T, class A, class S>
			inline std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&operator>>(std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&is, flex_string<E, T, A, S>&str);
			template<typename E, class T, class A, class S>
			std::basic_ostream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&operator<<(std::basic_ostream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&os, const flex_string<E, T, A, S>&str)
			{
				return os<<str.c_str();
			}
			template<typename E, class T, class A, class S>
			std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&getline(std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&is, flex_string<E, T, A, S>&str, typename flex_string<E, T, A, S>::value_type delim)
			{
				size_t nread=0;
				typename std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>::sentry sentry(is, true);
				if(sentry)
				{
					std::basic_streambuf<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>*buf=is.rdbuf();
					str.clear();
					while(nread<str.max_size())
					{
						int c1=buf->sbumpc();
						if(flex_string<E, T, A, S>::traits_type::eq_int_type(c1, flex_string<E, T, A, S>::traits_type::eof()))
						{
							is.setstate(std::ios_base::eofbit);
							break;
						}
						else
						{
							++nread;
							typename flex_string<E, T, A, S>::value_type c=flex_string<E, T, A, S>::traits_type::to_char_type(c1);
							if(!flex_string<E, T, A, S>::traits_type::eq(c, delim))str.push_back(c);
							else break;
						}
					}
				}
				if(nread==0||nread>=str.max_size())is.setstate(std::ios_base::failbit);
				return is;
			}
			template<typename E, class T, class A, class S>
			std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&getline(std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&is, flex_string<E, T, A, S>&str)
			{
				return getline(is, str, is.widen('\n'));
			}
			template<typename E1, class T, class A, class S>
			const typename flex_string<E1, T, A, S>::size_type flex_string<E1, T, A, S>::npos=(typename flex_string<E1, T, A, S>::size_type)(-1);
		}
	}
}
namespace boost
{
	namespace wave
	{
		typedef long int_literal_type;
		typedef unsigned long uint_literal_type;
	}
}
namespace boost
{
	namespace wave
	{
		enum token_category
		{
			IdentifierTokenType=0x10000000, ParameterTokenType=0x11000000, ExtParameterTokenType=0x11100000, KeywordTokenType=0x20000000, OperatorTokenType=0x30000000, LiteralTokenType=0x40000000, IntegerLiteralTokenType=0x41000000, FloatingLiteralTokenType=0x42000000, StringLiteralTokenType=0x43000000, CharacterLiteralTokenType=0x44000000, BoolLiteralTokenType=0x45000000, PPTokenType=0x50000000, PPConditionalTokenType=0x50800000, UnknownTokenType=0xA0000000, EOLTokenType=0xB0000000, EOFTokenType=0xC0000000, WhiteSpaceTokenType=0xD0000000, InternalTokenType=0xE0000000, TokenTypeMask=0xFF000000, AltTokenType=0x00100000, TriGraphTokenType=0x00200000, AltExtTokenType=0x00500000, ExtTokenTypeMask=0xFFF00000, ExtTokenOnlyMask=0x00F00000, TokenValueMask=0x000FFFFF, MainTokenMask=0xFF0FFFFF
		};
		enum token_id
		{
			T_UNKNOWN=0, T_FIRST_TOKEN=256, T_AND=((T_FIRST_TOKEN)|(OperatorTokenType)), T_AND_ALT=((T_FIRST_TOKEN)|(OperatorTokenType|AltExtTokenType)), T_ANDAND=((257)|(OperatorTokenType)), T_ANDAND_ALT=((257)|(OperatorTokenType|AltExtTokenType)), T_ASSIGN=((258)|(OperatorTokenType)), T_ANDASSIGN=((259)|(OperatorTokenType)), T_ANDASSIGN_ALT=((259)|(OperatorTokenType|AltExtTokenType)), T_OR=((260)|(OperatorTokenType)), T_OR_ALT=((260)|(OperatorTokenType|AltExtTokenType)), T_OR_TRIGRAPH=((260)|(OperatorTokenType|TriGraphTokenType)), T_ORASSIGN=((261)|(OperatorTokenType)), T_ORASSIGN_ALT=((261)|(OperatorTokenType|AltExtTokenType)), T_ORASSIGN_TRIGRAPH=((261)|(OperatorTokenType|TriGraphTokenType)), T_XOR=((262)|(OperatorTokenType)), T_XOR_ALT=((262)|(OperatorTokenType|AltExtTokenType)), T_XOR_TRIGRAPH=((262)|(OperatorTokenType|TriGraphTokenType)), T_XORASSIGN=((263)|(OperatorTokenType)), T_XORASSIGN_ALT=((263)|(OperatorTokenType|AltExtTokenType)), T_XORASSIGN_TRIGRAPH=((263)|(OperatorTokenType|TriGraphTokenType)), T_COMMA=((264)|(OperatorTokenType)), T_COLON=((265)|(OperatorTokenType)), T_DIVIDE=((266)|(OperatorTokenType)), T_DIVIDEASSIGN=((267)|(OperatorTokenType)), T_DOT=((268)|(OperatorTokenType)), T_DOTSTAR=((269)|(OperatorTokenType)), T_ELLIPSIS=((270)|(OperatorTokenType)), T_EQUAL=((271)|(OperatorTokenType)), T_GREATER=((272)|(OperatorTokenType)), T_GREATEREQUAL=((273)|(OperatorTokenType)), T_LEFTBRACE=((274)|(OperatorTokenType)), T_LEFTBRACE_ALT=((274)|(OperatorTokenType|AltTokenType)), T_LEFTBRACE_TRIGRAPH=((274)|(OperatorTokenType|TriGraphTokenType)), T_LESS=((275)|(OperatorTokenType)), T_LESSEQUAL=((276)|(OperatorTokenType)), T_LEFTPAREN=((277)|(OperatorTokenType)), T_LEFTBRACKET=((278)|(OperatorTokenType)), T_LEFTBRACKET_ALT=((278)|(OperatorTokenType|AltTokenType)), T_LEFTBRACKET_TRIGRAPH=((278)|(OperatorTokenType|TriGraphTokenType)), T_MINUS=((279)|(OperatorTokenType)), T_MINUSASSIGN=((280)|(OperatorTokenType)), T_MINUSMINUS=((281)|(OperatorTokenType)), T_PERCENT=((282)|(OperatorTokenType)), T_PERCENTASSIGN=((283)|(OperatorTokenType)), T_NOT=((284)|(OperatorTokenType)), T_NOT_ALT=((284)|(OperatorTokenType|AltExtTokenType)), T_NOTEQUAL=((285)|(OperatorTokenType)), T_NOTEQUAL_ALT=((285)|(OperatorTokenType|AltExtTokenType)), T_OROR=((286)|(OperatorTokenType)), T_OROR_ALT=((286)|(OperatorTokenType|AltExtTokenType)), T_OROR_TRIGRAPH=((286)|(OperatorTokenType|TriGraphTokenType)), T_PLUS=((287)|(OperatorTokenType)), T_PLUSASSIGN=((288)|(OperatorTokenType)), T_PLUSPLUS=((289)|(OperatorTokenType)), T_ARROW=((290)|(OperatorTokenType)), T_ARROWSTAR=((291)|(OperatorTokenType)), T_QUESTION_MARK=((292)|(OperatorTokenType)), T_RIGHTBRACE=((293)|(OperatorTokenType)), T_RIGHTBRACE_ALT=((293)|(OperatorTokenType|AltTokenType)), T_RIGHTBRACE_TRIGRAPH=((293)|(OperatorTokenType|TriGraphTokenType)), T_RIGHTPAREN=((294)|(OperatorTokenType)), T_RIGHTBRACKET=((295)|(OperatorTokenType)), T_RIGHTBRACKET_ALT=((295)|(OperatorTokenType|AltTokenType)), T_RIGHTBRACKET_TRIGRAPH=((295)|(OperatorTokenType|TriGraphTokenType)), T_COLON_COLON=((296)|(OperatorTokenType)), T_SEMICOLON=((297)|(OperatorTokenType)), T_SHIFTLEFT=((298)|(OperatorTokenType)), T_SHIFTLEFTASSIGN=((299)|(OperatorTokenType)), T_SHIFTRIGHT=((300)|(OperatorTokenType)), T_SHIFTRIGHTASSIGN=((301)|(OperatorTokenType)), T_STAR=((302)|(OperatorTokenType)), T_COMPL=((303)|(OperatorTokenType)), T_COMPL_ALT=((303)|(OperatorTokenType|AltExtTokenType)), T_COMPL_TRIGRAPH=((303)|(OperatorTokenType|TriGraphTokenType)), T_STARASSIGN=((304)|(OperatorTokenType)), T_ASM=((305)|(KeywordTokenType)), T_AUTO=((306)|(KeywordTokenType)), T_BOOL=((307)|(KeywordTokenType)), T_FALSE=((308)|(BoolLiteralTokenType)), T_TRUE=((309)|(BoolLiteralTokenType)), T_BREAK=((310)|(KeywordTokenType)), T_CASE=((311)|(KeywordTokenType)), T_CATCH=((312)|(KeywordTokenType)), T_CHAR=((313)|(KeywordTokenType)), T_CLASS=((314)|(KeywordTokenType)), T_CONST=((315)|(KeywordTokenType)), T_CONSTCAST=((316)|(KeywordTokenType)), T_CONTINUE=((317)|(KeywordTokenType)), T_DEFAULT=((318)|(KeywordTokenType)), T_DELETE=((319)|(KeywordTokenType)), T_DO=((320)|(KeywordTokenType)), T_DOUBLE=((321)|(KeywordTokenType)), T_DYNAMICCAST=((322)|(KeywordTokenType)), T_ELSE=((323)|(KeywordTokenType)), T_ENUM=((324)|(KeywordTokenType)), T_EXPLICIT=((325)|(KeywordTokenType)), T_EXPORT=((326)|(KeywordTokenType)), T_EXTERN=((327)|(KeywordTokenType)), T_FLOAT=((328)|(KeywordTokenType)), T_FOR=((329)|(KeywordTokenType)), T_FRIEND=((330)|(KeywordTokenType)), T_GOTO=((331)|(KeywordTokenType)), T_IF=((332)|(KeywordTokenType)), T_INLINE=((333)|(KeywordTokenType)), T_INT=((334)|(KeywordTokenType)), T_LONG=((335)|(KeywordTokenType)), T_MUTABLE=((336)|(KeywordTokenType)), T_NAMESPACE=((337)|(KeywordTokenType)), T_NEW=((338)|(KeywordTokenType)), T_OPERATOR=((339)|(KeywordTokenType)), T_PRIVATE=((340)|(KeywordTokenType)), T_PROTECTED=((341)|(KeywordTokenType)), T_PUBLIC=((342)|(KeywordTokenType)), T_REGISTER=((343)|(KeywordTokenType)), T_REINTERPRETCAST=((344)|(KeywordTokenType)), T_RETURN=((345)|(KeywordTokenType)), T_SHORT=((346)|(KeywordTokenType)), T_SIGNED=((347)|(KeywordTokenType)), T_SIZEOF=((348)|(KeywordTokenType)), T_STATIC=((349)|(KeywordTokenType)), T_STATICCAST=((350)|(KeywordTokenType)), T_STRUCT=((351)|(KeywordTokenType)), T_SWITCH=((352)|(KeywordTokenType)), T_TEMPLATE=((353)|(KeywordTokenType)), T_THIS=((354)|(KeywordTokenType)), T_THROW=((355)|(KeywordTokenType)), T_TRY=((356)|(KeywordTokenType)), T_TYPEDEF=((357)|(KeywordTokenType)), T_TYPEID=((358)|(KeywordTokenType)), T_TYPENAME=((359)|(KeywordTokenType)), T_UNION=((360)|(KeywordTokenType)), T_UNSIGNED=((361)|(KeywordTokenType)), T_USING=((362)|(KeywordTokenType)), T_VIRTUAL=((363)|(KeywordTokenType)), T_VOID=((364)|(KeywordTokenType)), T_VOLATILE=((365)|(KeywordTokenType)), T_WCHART=((366)|(KeywordTokenType)), T_WHILE=((367)|(KeywordTokenType)), T_PP_DEFINE=((368)|(PPTokenType)), T_PP_IF=((369)|(PPConditionalTokenType)), T_PP_IFDEF=((370)|(PPConditionalTokenType)), T_PP_IFNDEF=((371)|(PPConditionalTokenType)), T_PP_ELSE=((372)|(PPConditionalTokenType)), T_PP_ELIF=((373)|(PPConditionalTokenType)), T_PP_ENDIF=((374)|(PPConditionalTokenType)), T_PP_ERROR=((375)|(PPTokenType)), T_PP_LINE=((376)|(PPTokenType)), T_PP_PRAGMA=((377)|(PPTokenType)), T_PP_UNDEF=((378)|(PPTokenType)), T_PP_WARNING=((379)|(PPTokenType)), T_IDENTIFIER=((380)|(IdentifierTokenType)), T_OCTALINT=((381)|(IntegerLiteralTokenType)), T_DECIMALINT=((382)|(IntegerLiteralTokenType)), T_HEXAINT=((383)|(IntegerLiteralTokenType)), T_INTLIT=((384)|(IntegerLiteralTokenType)), T_LONGINTLIT=((385)|(IntegerLiteralTokenType)), T_FLOATLIT=((386)|(FloatingLiteralTokenType)), T_FIXEDPOINTLIT=((386)|(FloatingLiteralTokenType|AltTokenType)), T_CCOMMENT=((387)|(WhiteSpaceTokenType|AltTokenType)), T_CPPCOMMENT=((388)|(WhiteSpaceTokenType|AltTokenType)), T_CHARLIT=((389)|(CharacterLiteralTokenType)), T_STRINGLIT=((390)|(StringLiteralTokenType)), T_CONTLINE=((391)|(EOLTokenType)), T_SPACE=((392)|(WhiteSpaceTokenType)), T_SPACE2=((393)|(WhiteSpaceTokenType)), T_NEWLINE=((394)|(EOLTokenType)), T_GENERATEDNEWLINE=((394)|(EOLTokenType|AltTokenType)), T_POUND_POUND=((395)|(OperatorTokenType)), T_POUND_POUND_ALT=((395)|(OperatorTokenType|AltTokenType)), T_POUND_POUND_TRIGRAPH=((395)|(OperatorTokenType|TriGraphTokenType)), T_POUND=((396)|(OperatorTokenType)), T_POUND_ALT=((396)|(OperatorTokenType|AltTokenType)), T_POUND_TRIGRAPH=((396)|(OperatorTokenType|TriGraphTokenType)), T_ANY=((397)|(UnknownTokenType)), T_ANY_TRIGRAPH=((397)|(UnknownTokenType|TriGraphTokenType)), T_PP_INCLUDE=((398)|(PPTokenType)), T_PP_QHEADER=((399)|(PPTokenType)), T_PP_HHEADER=((400)|(PPTokenType)), T_PP_INCLUDE_NEXT=((398)|(PPTokenType|AltTokenType)), T_PP_QHEADER_NEXT=((399)|(PPTokenType|AltTokenType)), T_PP_HHEADER_NEXT=((400)|(PPTokenType|AltTokenType)), T_EOF=((401)|(EOFTokenType)), T_EOI=((402)|(EOFTokenType)), T_PP_NUMBER=((403)|(InternalTokenType)), T_MSEXT_INT8=((404)|(KeywordTokenType)), T_MSEXT_INT16=((405)|(KeywordTokenType)), T_MSEXT_INT32=((406)|(KeywordTokenType)), T_MSEXT_INT64=((407)|(KeywordTokenType)), T_MSEXT_BASED=((408)|(KeywordTokenType)), T_MSEXT_DECLSPEC=((409)|(KeywordTokenType)), T_MSEXT_CDECL=((410)|(KeywordTokenType)), T_MSEXT_FASTCALL=((411)|(KeywordTokenType)), T_MSEXT_STDCALL=((412)|(KeywordTokenType)), T_MSEXT_TRY=((413)|(KeywordTokenType)), T_MSEXT_EXCEPT=((414)|(KeywordTokenType)), T_MSEXT_FINALLY=((415)|(KeywordTokenType)), T_MSEXT_LEAVE=((416)|(KeywordTokenType)), T_MSEXT_INLINE=((417)|(KeywordTokenType)), T_MSEXT_ASM=((418)|(KeywordTokenType)), T_MSEXT_PP_REGION=((419)|(PPTokenType)), T_MSEXT_PP_ENDREGION=((420)|(PPTokenType)), T_IMPORT=((421)|(KeywordTokenType)), T_HAS_NOTHROW_CONSTRUCTOR=((422)|(KeywordTokenType)), T_HAS_NOTHROW_COPY=((423)|(KeywordTokenType)), T_HAS_TRIVIAL_ASSIGN=((424)|(KeywordTokenType)), T_HAS_TRIVIAL_CONSTRUCTOR=((425)|(KeywordTokenType)), T_HAS_TRIVIAL_COPY=((426)|(KeywordTokenType)), T_HAS_TRIVIAL_DESTRUCTOR=((427)|(KeywordTokenType)), T_HAS_VIRTUAL_DESTRUCTOR=((428)|(KeywordTokenType)), T_IS_ABSTRACT=((429)|(KeywordTokenType)), T_IS_BASE_OF=((430)|(KeywordTokenType)), T_IS_CLASS=((431)|(KeywordTokenType)), T_IS_CONVERTIBLE_TO=((432)|(KeywordTokenType)), T_IS_EMPTY=((433)|(KeywordTokenType)), T_IS_ENUM=((434)|(KeywordTokenType)), T_IS_POD=((435)|(KeywordTokenType)), T_IS_POLYMORPHIC=((436)|(KeywordTokenType)), T_IS_UNION=((437)|(KeywordTokenType)), T_IS_TRIVIAL=((438)|(KeywordTokenType)), T_IS_TRIVIALLY_CONSTRUCTIBLE=((439)|(KeywordTokenType)), T_IS_TRIVIALLY_ASSIGNABLE=((440)|(KeywordTokenType)), T_IS_TRIVIALLY_COPYABLE=((441)|(KeywordTokenType)), T_IS_STANDARD_LAYOUT=((442)|(KeywordTokenType)), T_IS_LITERAL_TYPE=((443)|(KeywordTokenType)), T_UNDERLYING_TYPE=((444)|(KeywordTokenType)), T_LAST_TOKEN_ID, T_LAST_TOKEN=((T_LAST_TOKEN_ID)&~TokenTypeMask), T_NONREPLACABLE_IDENTIFIER=((T_LAST_TOKEN+1)|(IdentifierTokenType)), T_PLACEHOLDER=((T_LAST_TOKEN+2)|(WhiteSpaceTokenType)), T_PLACEMARKER=((T_LAST_TOKEN+3)|(InternalTokenType)), T_PARAMETERBASE=((T_LAST_TOKEN+4)|(ParameterTokenType)), T_EXTPARAMETERBASE=((T_LAST_TOKEN+4)|(ExtParameterTokenType))
		};
		boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >get_token_name(token_id tokid);
		char const*get_token_value(token_id tokid);
	}
}
struct Name
{
	const char*value;
	Name(): value(0)
	{
	}
	explicit Name(const char*value): value(value)
	{
	}
	bool empty()const
	{
		return value==0;
	}
	const char*c_str()const
	{
		return value;
	}
	void clear()
	{
		value=0;
	}
};
inline bool operator==(const Name&left, const Name&right)
{
	return left.value==right.value;
}
inline bool operator!=(const Name&left, const Name&right)
{
	return left.value!=right.value;
}
inline bool operator<(const Name&left, const Name&right)
{
	return left.value<right.value;
}
typedef Name TokenValue;
const TokenValue TOKENVALUE_NULL;
typedef boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >Filename;
struct FilePosition
{
	Filename file;
	unsigned int line;
	unsigned int column;
};
inline bool operator==(const FilePosition&left, const FilePosition&right)
{
	return left.file==right.file&&left.line==right.line&&left.column==right.column;
}
struct IncludeEvents
{
	unsigned short push;
	unsigned short pop;
	IncludeEvents(): push(0), pop(0)
	{
	}
};
struct Path
{
	Name relative;
	Name absolute;
	Path()
	{
	}
	Path(Name relative, Name absolute): relative(relative), absolute(absolute)
	{
	}
	const char*c_str()const
	{
		return absolute.c_str();
	}
};
inline bool operator==(const Path&left, const Path&right)
{
	return left.absolute==right.absolute;
}
inline bool operator!=(const Path&left, const Path&right)
{
	return left.absolute!=right.absolute;
}
inline bool operator<(const Path&left, const Path&right)
{
	return left.absolute<right.absolute;
}
struct Source: Path
{
	unsigned int line;
	unsigned int column;
	Source()
	{
	}
	Source(Path path, unsigned int line, unsigned int column): Path(path), line(line), column(column)
	{
	}
};
inline bool operator==(const Source&left, const Source&right)
{
	return left.absolute==right.absolute&&left.line==right.line&&left.column==right.column;
}
inline bool operator!=(const Source&left, const Source&right)
{
	return !operator==(left, right);
}
typedef boost::wave::token_id LexTokenId;
struct DeclarationInstance;
struct TypeElement;
template<typename Walker>
class ParserGeneric;
struct CvQualifiers
{
	bool isConst;
	bool isVolatile;
	CvQualifiers(): isConst(false), isVolatile(false)
	{
	}
	CvQualifiers(bool isConst, bool isVolatile): isConst(isConst), isVolatile(isVolatile)
	{
	}
};
inline bool operator==(const CvQualifiers&l, const CvQualifiers&r)
{
	return l.isConst==r.isConst&&l.isVolatile==r.isVolatile;
}
inline bool operator!=(const CvQualifiers&l, const CvQualifiers&r)
{
	return !operator==(l, r);
}
inline bool operator<(const CvQualifiers&l, const CvQualifiers&r)
{
	return l.isConst!=r.isConst?l.isConst<r.isConst: l.isVolatile!=r.isVolatile?l.isVolatile<r.isVolatile: false;
}
struct UniqueType: CvQualifiers
{
	const TypeElement*p;
	UniqueType()
	{
	}
	UniqueType(const TypeElement*p): p(p)
	{
	}
	const TypeElement*getPointer()const
	{
		return p;
	}
	void setQualifiers(CvQualifiers qualifiers)
	{
		*static_cast<CvQualifiers*>(this)=qualifiers;
	}
	void addQualifiers(CvQualifiers qualifiers)
	{
		isConst|=qualifiers.isConst;
		isVolatile|=qualifiers.isVolatile;
	}
	CvQualifiers getQualifiers()const
	{
		return *this;
	}
	uintptr_t getBits()const
	{
		return uintptr_t(p)|(uintptr_t(isConst)<<0)|(uintptr_t(isVolatile)<<1);
	}
	bool operator<(const UniqueType&other)const
	{
		return getBits()<other.getBits();
	}
	bool operator==(const UniqueType&other)const
	{
		return getBits()==other.getBits();
	}
	const TypeElement&operator*()const
	{
		return *getPointer();
	}
	const TypeElement*operator->()const
	{
		return getPointer();
	}
};
inline bool operator!=(const UniqueType&left, const UniqueType&right)
{
	return !left.operator==(right);
}
namespace cpp
{
	template<LexTokenId id>
	struct terminal
	{
		static const LexTokenId ID=id;
		TokenValue value;
	};
	template<LexTokenId id>
	struct terminal_optional: public terminal<id>
	{
	};
	template<LexTokenId id>
	struct terminal_suffix: public terminal<id>
	{
	};
	template<typename T, bool required=true>
	struct symbol
	{
		typedef T Type;
		T*p;
		symbol(): p(0)
		{
		}
		explicit symbol(T*p): p(p)
		{
		}
		T*operator->()
		{
			if(!(!isDeallocated(p)))
			{
				throw AllocatorError();
			};
			return p;
		}
		operator T*()
		{
			if(!(!isDeallocated(p)))
			{
				throw AllocatorError();
			};
			return p;
		}
	};
	template<typename T, bool required>
	struct symbol_generic: public symbol<T>
	{
		symbol_generic()
		{
		}
		explicit symbol_generic(T*p): symbol<T>(p)
		{
		}
	};
	template<typename T>
	struct symbol_required: public symbol_generic<T, true>
	{
		symbol_required()
		{
		}
		explicit symbol_required(T*p): symbol_generic<T, true>(p)
		{
		}
	};
	template<typename T>
	struct symbol_optional: public symbol_generic<T, false>
	{
		symbol_optional()
		{
		}
		explicit symbol_optional(T*p): symbol_generic<T, false>(p)
		{
		}
	};
	template<typename T>
	struct symbol_sequence: public symbol<T>
	{
		symbol_sequence()
		{
		}
		explicit symbol_sequence(T*p): symbol<T>(p)
		{
		}
	};
	template<typename T>
	struct symbol_next: public symbol<T>
	{
		symbol_next()
		{
		}
		explicit symbol_next(T*p): symbol<T>(p)
		{
		}
	};
	template<typename T>
	struct choice
	{
	};
	struct terminal_choice
	{
	};
	struct terminal_choice2
	{
		LexTokenId id;
		TokenValue value;
	};
	struct decoration
	{
		SafePtr<const DeclarationInstance>p;
		bool deferred;
		decoration(): p(0), deferred(false)
		{
		}
	};
	struct type_decoration
	{
		UniqueType p;
		type_decoration(): p(0)
		{
		}
	};
	struct terminal_identifier
	{
		TokenValue value;
		Source source;
		decoration dec;
	};
	struct terminal_string
	{
		TokenValue value;
	};
	struct template_argument: public choice<template_argument>
	{
		typedef TypeList<struct assignment_expression, TypeList<struct type_id, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct template_parameter: public choice<template_parameter>
	{
		typedef TypeList<struct type_parameter, TypeList<struct parameter_declaration, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct exception_declarator: public choice<exception_declarator>
	{
		typedef TypeList<struct declarator, TypeList<struct abstract_declarator, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct declarator: public choice<declarator>, public exception_declarator
	{
		virtual void acceptAbstract(const exception_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct declarator_ptr, TypeList<struct direct_declarator, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct direct_declarator_prefix: public choice<direct_declarator_prefix>
	{
		typedef TypeList<struct direct_declarator_parenthesis, TypeList<struct declarator_id, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct declarator_id: public choice<declarator_id>, public direct_declarator_prefix
	{
		virtual void acceptAbstract(const direct_declarator_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct id_expression, TypeListEnd>Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct condition: public choice<condition>
	{
		typedef TypeList<struct condition_init, TypeList<struct expression, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct expression: public choice<expression>, public condition
	{
		virtual void acceptAbstract(const condition::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct expression_list, TypeList<struct assignment_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
		type_decoration type;
		Source source;
	};
	struct initializer: public choice<initializer>
	{
		typedef TypeList<struct initializer_default, TypeList<struct initializer_parenthesis, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct initializer_clause: public choice<initializer_clause>
	{
		typedef TypeList<struct initializer_clause_empty, TypeList<struct initializer_clause_list, TypeList<struct assignment_expression, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct assignment_expression: public choice<assignment_expression>, public expression, public template_argument, public initializer_clause
	{
		virtual void acceptAbstract(const expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const template_argument::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const initializer_clause::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct throw_expression, TypeList<struct assignment_expression_default, TypeList<struct conditional_expression, TypeListEnd> > >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct constant_expression: public choice<constant_expression>
	{
		typedef TypeList<struct conditional_expression, TypeListEnd>Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct conditional_expression: public choice<conditional_expression>, public assignment_expression, public constant_expression
	{
		virtual void acceptAbstract(const assignment_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const constant_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct conditional_expression_default, TypeList<struct logical_or_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct logical_or_expression: public choice<logical_or_expression>, public conditional_expression
	{
		virtual void acceptAbstract(const conditional_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct logical_or_expression_default, TypeList<struct logical_and_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct logical_and_expression: public choice<logical_and_expression>, public logical_or_expression
	{
		virtual void acceptAbstract(const logical_or_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct logical_and_expression_default, TypeList<struct inclusive_or_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct inclusive_or_expression: public choice<inclusive_or_expression>, public logical_and_expression
	{
		virtual void acceptAbstract(const logical_and_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct inclusive_or_expression_default, TypeList<struct exclusive_or_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct exclusive_or_expression: public choice<exclusive_or_expression>, public inclusive_or_expression
	{
		virtual void acceptAbstract(const inclusive_or_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct exclusive_or_expression_default, TypeList<struct and_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct and_expression: public choice<and_expression>, public exclusive_or_expression
	{
		virtual void acceptAbstract(const exclusive_or_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct and_expression_default, TypeList<struct equality_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct equality_expression: public choice<equality_expression>, public and_expression
	{
		virtual void acceptAbstract(const and_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct equality_expression_default, TypeList<struct relational_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct relational_expression: public choice<relational_expression>, public equality_expression
	{
		virtual void acceptAbstract(const equality_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct relational_expression_default, TypeList<struct shift_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct shift_expression: public choice<shift_expression>, public relational_expression
	{
		virtual void acceptAbstract(const relational_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct shift_expression_default, TypeList<struct additive_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct additive_expression: public choice<additive_expression>, public shift_expression
	{
		virtual void acceptAbstract(const shift_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct additive_expression_default, TypeList<struct multiplicative_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct multiplicative_expression: public choice<multiplicative_expression>, public additive_expression
	{
		virtual void acceptAbstract(const additive_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct multiplicative_expression_default, TypeList<struct pm_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct pm_expression: public choice<pm_expression>, public multiplicative_expression
	{
		virtual void acceptAbstract(const multiplicative_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct pm_expression_default, TypeList<struct cast_expression, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct cast_expression: public choice<cast_expression>, public pm_expression
	{
		virtual void acceptAbstract(const pm_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct cast_expression_default, TypeList<struct unary_expression, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct unary_expression: public choice<unary_expression>, public cast_expression
	{
		virtual void acceptAbstract(const cast_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct postfix_expression, TypeList<struct unary_expression_sizeoftype, TypeList<struct unary_expression_sizeof, TypeList<struct unary_expression_op, TypeList<struct new_expression, TypeList<struct delete_expression, TypeListEnd> > > > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct postfix_expression: public choice<postfix_expression>, public unary_expression
	{
		virtual void acceptAbstract(const unary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct postfix_expression_default, TypeList<struct postfix_expression_prefix, TypeListEnd> >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct postfix_expression_prefix: public choice<postfix_expression_prefix>, public postfix_expression
	{
		virtual void acceptAbstract(const postfix_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct primary_expression, TypeList<struct postfix_expression_construct, TypeList<struct postfix_expression_cast, TypeList<struct postfix_expression_typeid, TypeList<struct postfix_expression_typeidtype, TypeList<struct postfix_expression_typetraits_unary, TypeList<struct postfix_expression_typetraits_binary, TypeListEnd> > > > > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct primary_expression: public choice<primary_expression>, public postfix_expression_prefix
	{
		virtual void acceptAbstract(const postfix_expression_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct id_expression, TypeList<struct literal, TypeList<struct primary_expression_builtin, TypeList<struct primary_expression_parenthesis, TypeListEnd> > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct id_expression: public choice<id_expression>, public declarator_id, public primary_expression
	{
		virtual void acceptAbstract(const declarator_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const primary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct qualified_id, TypeList<struct unqualified_id, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct unqualified_id: public choice<unqualified_id>, public id_expression
	{
		virtual void acceptAbstract(const id_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct template_id, TypeList<struct identifier, TypeList<struct operator_function_id, TypeList<struct conversion_function_id, TypeList<struct destructor_id, TypeListEnd> > > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct qualified_id: public choice<qualified_id>, public id_expression
	{
		virtual void acceptAbstract(const id_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct qualified_id_default, TypeList<struct qualified_id_global, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct qualified_id_suffix: public choice<qualified_id_suffix>
	{
		typedef TypeList<struct identifier, TypeList<struct template_id, TypeList<struct operator_function_id, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct template_id: public choice<template_id>, public unqualified_id, public qualified_id_suffix
	{
		virtual void acceptAbstract(const unqualified_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const qualified_id_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct simple_template_id, TypeList<struct template_id_operator_function, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct nested_name: public choice<nested_name>
	{
		typedef TypeList<struct type_name, TypeList<struct namespace_name, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct type_name: public choice<type_name>, public nested_name
	{
		virtual void acceptAbstract(const nested_name::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct class_name, TypeListEnd>Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct class_name: public choice<class_name>, public type_name
	{
		virtual void acceptAbstract(const type_name::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct simple_template_id, TypeList<struct identifier, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct namespace_name: public choice<namespace_name>, public nested_name
	{
		virtual void acceptAbstract(const nested_name::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct identifier, TypeListEnd>Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct mem_initializer_id: public choice<mem_initializer_id>
	{
		typedef TypeList<struct mem_initializer_id_base, TypeList<struct identifier, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct identifier: public class_name, public namespace_name, public unqualified_id, public qualified_id_suffix, public mem_initializer_id
	{
		virtual void acceptAbstract(const class_name::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const namespace_name::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const unqualified_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const qualified_id_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const mem_initializer_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_identifier value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct template_argument_list
	{
		symbol_required<template_argument>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<template_argument_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct template_argument_clause_disambiguate: public choice<template_argument_clause_disambiguate>
	{
		typedef TypeList<struct template_argument_clause, TypeListEnd>Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct template_argument_clause
	{
		terminal<boost::wave::T_LESS>lb;
		symbol_optional<template_argument_list>args;
		terminal<boost::wave::T_GREATER>rb;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lb);
			visitor.visit(args);
			visitor.visit(rb);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lb)&&parser.parse(args)&&parser.parse(rb);
		};
	};
	struct simple_template_id: public template_id, public class_name
	{
		virtual void acceptAbstract(const class_name::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const template_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<identifier>id;
		symbol_required<template_argument_clause>args;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(id);
			visitor.visit(args);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(id)&&parser.parse(args);
		};
	};
	struct nested_name_specifier_prefix
	{
		symbol_required<nested_name>id;
		terminal<boost::wave::T_COLON_COLON>scope;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(id);
			visitor.visit(scope);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(id)&&parser.parse(scope);
		};
	};
	struct nested_name_specifier_suffix: public choice<nested_name_specifier_suffix>
	{
		typedef TypeList<struct nested_name_specifier_suffix_template, TypeList<struct nested_name_specifier_suffix_default, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct nested_name_specifier_suffix_default: public nested_name_specifier_suffix
	{
		virtual void acceptAbstract(const nested_name_specifier_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<identifier>id;
		terminal<boost::wave::T_COLON_COLON>scope;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(id);
			visitor.visit(scope);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(id)&&parser.parse(scope);
		};
	};
	struct nested_name_specifier_suffix_template: public nested_name_specifier_suffix
	{
		virtual void acceptAbstract(const nested_name_specifier_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_TEMPLATE>isTemplate;
		symbol_required<simple_template_id>id;
		terminal<boost::wave::T_COLON_COLON>scope;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isTemplate);
			visitor.visit(id);
			visitor.visit(scope);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isTemplate)&&parser.parse(id)&&parser.parse(scope);
		};
	};
	struct nested_name_specifier_suffix_seq
	{
		symbol_required<nested_name_specifier_suffix>item;
		symbol_optional<nested_name_specifier_suffix_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct nested_name_specifier
	{
		symbol_required<nested_name_specifier_prefix>prefix;
		symbol_optional<nested_name_specifier_suffix_seq>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(prefix);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(prefix)&&parser.parse(suffix);
		};
	};
	struct type_specifier: public choice<type_specifier>
	{
		typedef TypeList<struct type_specifier_noncv, TypeList<struct cv_qualifier, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct type_specifier_noncv: public choice<type_specifier_noncv>, public type_specifier
	{
		virtual void acceptAbstract(const type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct typename_specifier, TypeList<struct simple_type_specifier, TypeList<struct class_specifier, TypeList<struct enum_specifier, TypeList<struct elaborated_type_specifier, TypeListEnd> > > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct decl_specifier_suffix: public choice<decl_specifier_suffix>
	{
		typedef TypeList<struct decl_specifier_nontype, TypeList<struct simple_type_specifier_builtin, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct decl_specifier_nontype: public choice<decl_specifier_nontype>, public decl_specifier_suffix
	{
		virtual void acceptAbstract(const decl_specifier_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct storage_class_specifier, TypeList<struct decl_specifier_default, TypeList<struct function_specifier, TypeList<struct cv_qualifier, TypeListEnd> > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct decl_specifier_prefix_seq
	{
		symbol_required<decl_specifier_nontype>item;
		symbol_optional<decl_specifier_prefix_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct decl_specifier_suffix_seq
	{
		symbol_required<decl_specifier_suffix>item;
		symbol_optional<decl_specifier_suffix_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct decl_specifier_seq
	{
		symbol_optional<decl_specifier_prefix_seq>prefix;
		symbol_required<type_specifier_noncv>type;
		symbol_optional<decl_specifier_suffix_seq>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(prefix);
			visitor.visit(type);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(prefix)&&parser.parse(type)&&parser.parse(suffix);
		};
	};
	struct postfix_expression_type_specifier: public choice<postfix_expression_type_specifier>
	{
		typedef TypeList<struct simple_type_specifier, TypeList<struct typename_specifier, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct simple_type_specifier: public choice<simple_type_specifier>, public type_specifier_noncv, public postfix_expression_type_specifier
	{
		virtual void acceptAbstract(const postfix_expression_type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const type_specifier_noncv::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct simple_type_specifier_builtin, TypeList<struct simple_type_specifier_template, TypeList<struct simple_type_specifier_name, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct overloadable_operator: public choice<overloadable_operator>
	{
		typedef TypeList<struct overloadable_operator_default, TypeList<struct new_operator, TypeList<struct delete_operator, TypeList<struct function_operator, TypeList<struct array_operator, TypeListEnd> > > > >Types;
		typedef TypeListEnd Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct overloadable_operator_default: public terminal_choice, public overloadable_operator
	{
		virtual void acceptAbstract(const overloadable_operator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			ASSIGN, STARASSIGN, DIVIDEASSIGN, PERCENTASSIGN, PLUSASSIGN, MINUSASSIGN, SHIFTRIGHTASSIGN, SHIFTLEFTASSIGN, ANDASSIGN, XORASSIGN, ORASSIGN, EQUAL, NOTEQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL, ANDAND, OROR, PLUSPLUS, MINUSMINUS, STAR, DIVIDE, PERCENT, PLUS, MINUS, SHIFTLEFT, SHIFTRIGHT, AND, OR, XOR, NOT, COMPL, ARROW, ARROWSTAR, COMMA
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct bitwise_operator: public terminal_choice
	{
		enum
		{
			AND, OR, XOR
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct logical_operator: public terminal_choice
	{
		enum
		{
			AND, OR
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct array_operator: public overloadable_operator
	{
		virtual void acceptAbstract(const overloadable_operator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTBRACKET>ls;
		terminal<boost::wave::T_RIGHTBRACKET>rs;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(ls);
			visitor.visit(rs);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(ls)&&parser.parse(rs);
		};
	};
	struct function_operator: public overloadable_operator
	{
		virtual void acceptAbstract(const overloadable_operator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(rp);
		};
	};
	struct new_operator: public overloadable_operator
	{
		virtual void acceptAbstract(const overloadable_operator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_NEW>key;
		symbol_optional<array_operator>array;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(array);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(array);
		};
	};
	struct delete_operator: public overloadable_operator
	{
		virtual void acceptAbstract(const overloadable_operator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_DELETE>key;
		symbol_optional<array_operator>array;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(array);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(array);
		};
	};
	struct operator_function_id: public unqualified_id, public qualified_id_suffix
	{
		virtual void acceptAbstract(const unqualified_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const qualified_id_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_OPERATOR>key;
		symbol_required<overloadable_operator>op;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(op);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(op);
		};
		terminal_identifier value;
	};
	struct template_id_operator_function: public template_id
	{
		virtual void acceptAbstract(const template_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<operator_function_id>id;
		symbol_required<template_argument_clause>args;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(id);
			visitor.visit(args);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(id)&&parser.parse(args);
		};
	};
	struct qualified_id_default: public qualified_id
	{
		virtual void acceptAbstract(const qualified_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_required<nested_name_specifier>context;
		terminal_optional<boost::wave::T_TEMPLATE>isTemplate;
		symbol_required<unqualified_id>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(isTemplate);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(isTemplate)&&parser.parse(id);
		};
	};
	struct qualified_id_global: public qualified_id
	{
		virtual void acceptAbstract(const qualified_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_COLON_COLON>isGlobal;
		symbol_required<qualified_id_suffix>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(id);
		};
	};
	struct elaborated_type_specifier_key: public choice<elaborated_type_specifier_key>
	{
		typedef TypeList<struct class_key, TypeList<struct enum_key, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct class_key: public terminal_choice, public elaborated_type_specifier_key
	{
		virtual void acceptAbstract(const class_key::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			CLASS, STRUCT, UNION
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct enum_key: public elaborated_type_specifier_key
	{
		virtual void acceptAbstract(const elaborated_type_specifier_key::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_ENUM>key;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key);
		};
	};
	struct access_specifier: public terminal_choice
	{
		enum
		{
			PRIVATE, PROTECTED, PUBLIC
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct base_specifier_prefix: public choice<base_specifier_prefix>
	{
		typedef TypeList<struct base_specifier_access_virtual, TypeList<struct base_specifier_virtual_access, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct base_specifier_access_virtual: public base_specifier_prefix
	{
		virtual void acceptAbstract(const base_specifier_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<access_specifier>access;
		terminal_optional<boost::wave::T_VIRTUAL>isVirtual;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(access);
			visitor.visit(isVirtual);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(access)&&parser.parse(isVirtual);
		};
	};
	struct base_specifier_virtual_access: public base_specifier_prefix
	{
		virtual void acceptAbstract(const base_specifier_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_VIRTUAL>isVirtual;
		symbol_optional<access_specifier>access;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isVirtual);
			visitor.visit(access);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isVirtual)&&parser.parse(access);
		};
	};
	struct base_specifier
	{
		symbol_optional<base_specifier_prefix>prefix;
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		terminal_optional<boost::wave::T_TEMPLATE>isTemplate;
		symbol_required<class_name>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(prefix);
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(isTemplate);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(prefix)&&parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(isTemplate)&&parser.parse(id);
		};
		type_decoration type;
		Source source;
	};
	struct base_specifier_list
	{
		symbol_required<base_specifier>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<base_specifier_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct base_clause
	{
		terminal<boost::wave::T_COLON>colon;
		symbol_required<base_specifier_list>list;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(colon);
			visitor.visit(list);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(colon)&&parser.parse(list);
		};
	};
	struct class_head: public choice<class_head>
	{
		typedef TypeList<struct class_head_default, TypeList<struct class_head_unnamed, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct class_head_unnamed: public class_head
	{
		virtual void acceptAbstract(const class_head::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<class_key>key;
		symbol_optional<base_clause>base;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(base);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(base);
		};
	};
	struct class_head_default: public class_head
	{
		virtual void acceptAbstract(const class_head::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<class_key>key;
		symbol_optional<nested_name_specifier>context;
		symbol_required<class_name>id;
		symbol_optional<base_clause>base;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(context);
			visitor.visit(id);
			visitor.visit(base);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(context)&&parser.parse(id)&&parser.parse(base);
		};
	};
	struct type_specifier_suffix: public choice<type_specifier_suffix>
	{
		typedef TypeList<struct cv_qualifier, TypeList<struct simple_type_specifier_builtin, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct cv_qualifier: public terminal_choice, public type_specifier, public decl_specifier_nontype, public type_specifier_suffix
	{
		virtual void acceptAbstract(const type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const decl_specifier_nontype::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const type_specifier_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			CONST, VOLATILE
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct cv_qualifier_seq
	{
		symbol_required<cv_qualifier>item;
		symbol_optional<cv_qualifier_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct ptr_operator_key: public terminal_choice
	{
		enum
		{
			PTR, REF
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct ptr_operator
	{
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		symbol_required<ptr_operator_key>key;
		symbol_optional<cv_qualifier_seq>qual;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(key);
			visitor.visit(qual);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(key)&&parser.parse(qual);
		};
	};
	struct type_specifier_prefix_seq
	{
		symbol_required<cv_qualifier>item;
		symbol_optional<type_specifier_prefix_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct type_specifier_suffix_seq
	{
		symbol_required<type_specifier_suffix>item;
		symbol_optional<type_specifier_suffix_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct type_specifier_seq
	{
		symbol_optional<type_specifier_prefix_seq>prefix;
		symbol_required<type_specifier_noncv>type;
		symbol_optional<type_specifier_suffix_seq>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(prefix);
			visitor.visit(type);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(prefix)&&parser.parse(type)&&parser.parse(suffix);
		};
	};
	struct abstract_declarator: public choice<abstract_declarator>, public exception_declarator
	{
		virtual void acceptAbstract(const exception_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct abstract_declarator_ptr, TypeList<struct direct_abstract_declarator, TypeList<struct direct_abstract_declarator_parenthesis, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct abstract_declarator_ptr: public abstract_declarator
	{
		virtual void acceptAbstract(const abstract_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<ptr_operator>op;
		symbol_optional<abstract_declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(decl);
		};
	};
	struct direct_abstract_declarator_parenthesis: public abstract_declarator
	{
		virtual void acceptAbstract(const abstract_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<abstract_declarator>decl;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(decl);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(decl)&&parser.parse(rp);
		};
	};
	struct declarator_suffix;
	struct direct_abstract_declarator: public abstract_declarator
	{
		virtual void acceptAbstract(const abstract_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_optional<direct_abstract_declarator_parenthesis>prefix;
		symbol_required<declarator_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(prefix);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(prefix)&&parser.parse(suffix);
		};
	};
	struct type_id: public template_argument
	{
		virtual void acceptAbstract(const template_argument::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<type_specifier_seq>spec;
		symbol_optional<abstract_declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(spec);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(spec)&&parser.parse(decl);
		};
		type_decoration type;
		Source source;
	};
	struct throw_expression: public assignment_expression
	{
		virtual void acceptAbstract(const assignment_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_THROW>key;
		symbol_optional<assignment_expression>expr;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(expr);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(expr);
		};
	};
	struct expression_list: public expression
	{
		virtual void acceptAbstract(const expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<assignment_expression>left;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(comma);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(comma)&&parser.parse(right);
		};
	};
	struct member_initializer: public choice<member_initializer>
	{
		typedef TypeList<struct constant_initializer, TypeList<struct pure_specifier, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct constant_initializer: public member_initializer
	{
		virtual void acceptAbstract(const member_initializer::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_ASSIGN>assign;
		symbol_required<constant_expression>expr;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(assign);
			visitor.visit(expr);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(assign)&&parser.parse(expr);
		};
	};
	struct literal: public choice<literal>, public primary_expression
	{
		virtual void acceptAbstract(const primary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct numeric_literal, TypeList<struct string_literal, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct numeric_literal: public terminal_choice, public literal
	{
		virtual void acceptAbstract(const literal::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			INTEGER, CHARACTER, FLOATING, BOOLEAN, UNKNOWN
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct string_literal: public literal
	{
		virtual void acceptAbstract(const literal::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_string value;
		symbol_optional<string_literal>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value)&&parser.parse(next);
		};
	};
	struct primary_expression_builtin: public primary_expression
	{
		virtual void acceptAbstract(const primary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_THIS>key;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key);
		};
	};
	struct primary_expression_parenthesis: public primary_expression
	{
		virtual void acceptAbstract(const primary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<expression>expr;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(expr);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(expr)&&parser.parse(rp);
		};
	};
	struct initializer_list
	{
		symbol_required<initializer_clause>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_optional<initializer_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct initializer_clause_list: public initializer_clause
	{
		virtual void acceptAbstract(const initializer_clause::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTBRACE>lb;
		symbol_required<initializer_list>list;
		terminal<boost::wave::T_RIGHTBRACE>rb;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lb);
			visitor.visit(list);
			visitor.visit(rb);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lb)&&parser.parse(list)&&parser.parse(rb);
		};
	};
	struct initializer_clause_empty: public initializer_clause
	{
		virtual void acceptAbstract(const initializer_clause::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTBRACE>lb;
		terminal<boost::wave::T_RIGHTBRACE>rb;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lb);
			visitor.visit(rb);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lb)&&parser.parse(rb);
		};
	};
	struct initializer_default: public initializer
	{
		virtual void acceptAbstract(const initializer::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_ASSIGN>assign;
		symbol_required<initializer_clause>clause;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(assign);
			visitor.visit(clause);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(assign)&&parser.parse(clause);
		};
	};
	struct initializer_parenthesis: public initializer
	{
		virtual void acceptAbstract(const initializer::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<expression_list>list;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(list);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(list)&&parser.parse(rp);
		};
	};
	struct postfix_expression_suffix: public choice<postfix_expression_suffix>
	{
		typedef TypeList<struct postfix_expression_subscript, TypeList<struct postfix_expression_call, TypeList<struct postfix_expression_member, TypeList<struct postfix_expression_destructor, TypeList<struct postfix_operator, TypeListEnd> > > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
		type_decoration type;
		Source source;
	};
	struct postfix_expression_suffix_seq
	{
		symbol_required<postfix_expression_suffix>item;
		symbol_optional<postfix_expression_suffix_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct postfix_expression_default: public postfix_expression
	{
		virtual void acceptAbstract(const postfix_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<postfix_expression_prefix>left;
		symbol_optional<postfix_expression_suffix_seq>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(right);
		};
	};
	struct postfix_expression_subscript: public postfix_expression_suffix
	{
		virtual void acceptAbstract(const postfix_expression_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTBRACKET>ls;
		symbol_required<expression>index;
		terminal<boost::wave::T_RIGHTBRACKET>rs;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(ls);
			visitor.visit(index);
			visitor.visit(rs);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(ls)&&parser.parse(index)&&parser.parse(rs);
		};
	};
	struct postfix_expression_call: public postfix_expression_suffix
	{
		virtual void acceptAbstract(const postfix_expression_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_optional<expression_list>args;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(args);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(args)&&parser.parse(rp);
		};
	};
	struct member_operator: public terminal_choice
	{
		enum
		{
			DOT, ARROW
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct postfix_expression_member: public postfix_expression_suffix
	{
		virtual void acceptAbstract(const postfix_expression_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<member_operator>op;
		terminal_optional<boost::wave::T_TEMPLATE>isTemplate;
		symbol_required<id_expression>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(isTemplate);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(isTemplate)&&parser.parse(id);
		};
	};
	struct postfix_expression_destructor: public postfix_expression_suffix
	{
		virtual void acceptAbstract(const postfix_expression_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<member_operator>op;
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		terminal<boost::wave::T_COMPL>compl_;
		symbol_required<type_name>type;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(compl_);
			visitor.visit(type);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(compl_)&&parser.parse(type);
		};
	};
	struct postfix_operator: public terminal_choice, public postfix_expression_suffix
	{
		virtual void acceptAbstract(const postfix_expression_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			PLUSPLUS, MINUSMINUS
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct postfix_expression_construct: public postfix_expression_prefix
	{
		virtual void acceptAbstract(const postfix_expression_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<postfix_expression_type_specifier>type;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_optional<expression_list>args;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(type);
			visitor.visit(lp);
			visitor.visit(args);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(type)&&parser.parse(lp)&&parser.parse(args)&&parser.parse(rp);
		};
	};
	struct cast_operator: public terminal_choice
	{
		enum
		{
			DYNAMIC, STATIC, REINTERPRET, CONST
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct postfix_expression_cast: public postfix_expression_prefix
	{
		virtual void acceptAbstract(const postfix_expression_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<cast_operator>op;
		terminal<boost::wave::T_LESS>lt;
		symbol_required<type_id>type;
		terminal<boost::wave::T_GREATER>gt;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<expression>expr;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(lt);
			visitor.visit(type);
			visitor.visit(gt);
			visitor.visit(lp);
			visitor.visit(expr);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(lt)&&parser.parse(type)&&parser.parse(gt)&&parser.parse(lp)&&parser.parse(expr)&&parser.parse(rp);
		};
	};
	struct postfix_expression_typeid: public postfix_expression_prefix
	{
		virtual void acceptAbstract(const postfix_expression_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_TYPEID>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<expression>expr;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(expr);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(expr)&&parser.parse(rp);
		};
	};
	struct postfix_expression_typeidtype: public postfix_expression_prefix
	{
		virtual void acceptAbstract(const postfix_expression_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_TYPEID>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<type_id>type;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(type);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(type)&&parser.parse(rp);
		};
	};
	struct typetraits_unary: public terminal_choice
	{
		enum
		{
			HAS_NOTHROW_CONSTRUCTOR, HAS_NOTHROW_COPY, HAS_TRIVIAL_ASSIGN, HAS_TRIVIAL_CONSTRUCTOR, HAS_TRIVIAL_COPY, HAS_TRIVIAL_DESTRUCTOR, HAS_VIRTUAL_DESTRUCTOR, IS_ABSTRACT, IS_CLASS, IS_EMPTY, IS_ENUM, IS_POD, IS_POLYMORPHIC, IS_UNION, IS_TRIVIALLY_COPYABLE, IS_STANDARD_LAYOUT, IS_LITERAL_TYPE, UNDERLYING_TYPE,
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct postfix_expression_typetraits_unary: public postfix_expression_prefix
	{
		virtual void acceptAbstract(const postfix_expression_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<typetraits_unary>trait;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<type_id>type;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(trait);
			visitor.visit(lp);
			visitor.visit(type);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(trait)&&parser.parse(lp)&&parser.parse(type)&&parser.parse(rp);
		};
	};
	struct typetraits_binary: public terminal_choice
	{
		enum
		{
			IS_BASE_OF, IS_CONVERTIBLE_TO, IS_TRIVIALLY_CONSTRUCTIBLE, IS_TRIVIALLY_ASSIGNABLE,
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct postfix_expression_typetraits_binary: public postfix_expression_prefix
	{
		virtual void acceptAbstract(const postfix_expression_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<typetraits_binary>trait;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<type_id>first;
		terminal<boost::wave::T_COMMA>comma;
		symbol_required<type_id>second;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(trait);
			visitor.visit(lp);
			visitor.visit(first);
			visitor.visit(comma);
			visitor.visit(second);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(trait)&&parser.parse(lp)&&parser.parse(first)&&parser.parse(comma)&&parser.parse(second)&&parser.parse(rp);
		};
	};
	struct new_type: public choice<new_type>
	{
		typedef TypeList<struct new_type_parenthesis, TypeList<struct new_type_default, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct new_declarator: public choice<new_declarator>
	{
		typedef TypeList<struct direct_new_declarator, TypeList<struct new_declarator_ptr, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct new_declarator_suffix
	{
		terminal<boost::wave::T_LEFTBRACKET>ls;
		symbol_required<constant_expression>expr;
		terminal<boost::wave::T_RIGHTBRACKET>rs;
		symbol_optional<new_declarator_suffix>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(ls);
			visitor.visit(expr);
			visitor.visit(rs);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(ls)&&parser.parse(expr)&&parser.parse(rs)&&parser.parse(next);
		};
	};
	struct direct_new_declarator: public new_declarator
	{
		virtual void acceptAbstract(const new_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTBRACKET>ls;
		symbol_required<expression>expr;
		terminal<boost::wave::T_RIGHTBRACKET>rs;
		symbol_optional<new_declarator_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(ls);
			visitor.visit(expr);
			visitor.visit(rs);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(ls)&&parser.parse(expr)&&parser.parse(rs)&&parser.parse(suffix);
		};
	};
	struct new_declarator_ptr: public new_declarator
	{
		virtual void acceptAbstract(const new_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<ptr_operator>op;
		symbol_optional<new_declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(decl);
		};
	};
	struct new_type_default: public new_type
	{
		virtual void acceptAbstract(const new_type::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<type_specifier_seq>spec;
		symbol_optional<new_declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(spec);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(spec)&&parser.parse(decl);
		};
	};
	struct new_type_parenthesis: public new_type
	{
		virtual void acceptAbstract(const new_type::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<type_id>id;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(id);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(id)&&parser.parse(rp);
		};
	};
	struct new_initializer
	{
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_optional<expression_list>expr;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(expr);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(expr)&&parser.parse(rp);
		};
	};
	struct new_expression: public choice<new_expression>, public unary_expression
	{
		virtual void acceptAbstract(const unary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct new_expression_placement, TypeList<struct new_expression_default, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct new_expression_placement: public new_expression
	{
		virtual void acceptAbstract(const new_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		terminal<boost::wave::T_NEW>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<expression_list>place;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		symbol_required<new_type>type;
		symbol_optional<new_initializer>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(place);
			visitor.visit(rp);
			visitor.visit(type);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(key)&&parser.parse(lp)&&parser.parse(place)&&parser.parse(rp)&&parser.parse(type)&&parser.parse(init);
		};
	};
	struct new_expression_default: public new_expression
	{
		virtual void acceptAbstract(const new_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		terminal<boost::wave::T_NEW>key;
		symbol_required<new_type>type;
		symbol_optional<new_initializer>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(key);
			visitor.visit(type);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(key)&&parser.parse(type)&&parser.parse(init);
		};
	};
	struct delete_expression: public unary_expression
	{
		virtual void acceptAbstract(const unary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		terminal<boost::wave::T_DELETE>key;
		symbol_optional<array_operator>op;
		symbol_required<cast_expression>expr;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(key);
			visitor.visit(op);
			visitor.visit(expr);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(key)&&parser.parse(op)&&parser.parse(expr);
		};
	};
	struct unary_operator: public terminal_choice
	{
		enum
		{
			PLUSPLUS, MINUSMINUS, STAR, AND, PLUS, MINUS, NOT, COMPL
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct unary_expression_op: public unary_expression
	{
		virtual void acceptAbstract(const unary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<unary_operator>op;
		symbol_required<cast_expression>expr;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(expr);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(expr);
		};
	};
	struct unary_expression_sizeof: public unary_expression
	{
		virtual void acceptAbstract(const unary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_SIZEOF>key;
		symbol_required<unary_expression>expr;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(expr);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(expr);
		};
	};
	struct unary_expression_sizeoftype: public unary_expression
	{
		virtual void acceptAbstract(const unary_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_SIZEOF>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<type_id>type;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(type);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(type)&&parser.parse(rp);
		};
	};
	struct cast_expression_default: public cast_expression
	{
		virtual void acceptAbstract(const cast_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<type_id>id;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		symbol_required<cast_expression>expr;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(id);
			visitor.visit(rp);
			visitor.visit(expr);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(id)&&parser.parse(rp)&&parser.parse(expr);
		};
	};
	struct pm_operator: public terminal_choice
	{
		enum
		{
			DOTSTAR, ARROWSTAR
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct pm_expression_default: public pm_expression
	{
		virtual void acceptAbstract(const pm_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<pm_expression>left;
		symbol_required<pm_operator>op;
		symbol_required<cast_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct multiplicative_operator: public terminal_choice
	{
		enum
		{
			STAR, DIVIDE, PERCENT
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct multiplicative_expression_default: public multiplicative_expression
	{
		virtual void acceptAbstract(const multiplicative_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<multiplicative_expression>left;
		symbol_required<multiplicative_operator>op;
		symbol_required<pm_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct additive_operator: public terminal_choice
	{
		enum
		{
			PLUS, MINUS
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct additive_expression_default: public additive_expression
	{
		virtual void acceptAbstract(const additive_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<additive_expression>left;
		symbol_required<additive_operator>op;
		symbol_required<multiplicative_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct shift_operator: public terminal_choice
	{
		enum
		{
			SHIFTLEFT, SHIFTRIGHT
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct shift_expression_default: public shift_expression
	{
		virtual void acceptAbstract(const shift_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<shift_expression>left;
		symbol_required<shift_operator>op;
		symbol_required<additive_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct relational_operator: public terminal_choice
	{
		enum
		{
			LESS, GREATER, LESSEQUAL, GREATEREQUAL
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct relational_expression_default: public relational_expression
	{
		virtual void acceptAbstract(const relational_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<relational_expression>left;
		symbol_required<relational_operator>op;
		symbol_required<shift_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct equality_operator: public terminal_choice
	{
		enum
		{
			EQUAL, NOTEQUAL
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct equality_expression_default: public equality_expression
	{
		virtual void acceptAbstract(const equality_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<equality_expression>left;
		symbol_required<equality_operator>op;
		symbol_required<relational_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct and_expression_default: public and_expression
	{
		virtual void acceptAbstract(const and_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<and_expression>left;
		terminal<boost::wave::T_AND>op;
		symbol_required<equality_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct exclusive_or_expression_default: public exclusive_or_expression
	{
		virtual void acceptAbstract(const exclusive_or_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<exclusive_or_expression>left;
		terminal<boost::wave::T_XOR>op;
		symbol_required<and_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct inclusive_or_expression_default: public inclusive_or_expression
	{
		virtual void acceptAbstract(const inclusive_or_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<inclusive_or_expression>left;
		terminal<boost::wave::T_OR>op;
		symbol_required<exclusive_or_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct logical_and_expression_default: public logical_and_expression
	{
		virtual void acceptAbstract(const logical_and_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<logical_and_expression>left;
		terminal<boost::wave::T_ANDAND>op;
		symbol_required<inclusive_or_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct logical_or_expression_default: public logical_or_expression
	{
		virtual void acceptAbstract(const logical_or_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<logical_or_expression>left;
		terminal<boost::wave::T_OROR>op;
		symbol_required<logical_and_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(op)&&parser.parse(right);
		};
	};
	struct conditional_or_assignment_expression_suffix: public choice<conditional_or_assignment_expression_suffix>
	{
		typedef TypeList<struct conditional_expression_suffix, TypeList<struct assignment_expression_suffix, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
		Source source;
	};
	struct conditional_expression_suffix: public conditional_or_assignment_expression_suffix
	{
		virtual void acceptAbstract(const conditional_or_assignment_expression_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_QUESTION_MARK>op;
		symbol_required<expression>mid;
		terminal<boost::wave::T_COLON>colon;
		symbol_required<assignment_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(mid);
			visitor.visit(colon);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(mid)&&parser.parse(colon)&&parser.parse(right);
		};
	};
	struct conditional_expression_default: public conditional_expression
	{
		virtual void acceptAbstract(const conditional_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<logical_or_expression>left;
		symbol_optional<conditional_expression_suffix>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(right);
		};
	};
	struct assignment_expression_default: public assignment_expression
	{
		virtual void acceptAbstract(const assignment_expression::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<logical_or_expression>left;
		symbol_optional<conditional_or_assignment_expression_suffix>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(left);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(left)&&parser.parse(right);
		};
	};
	struct assignment_operator: public terminal_choice
	{
		enum
		{
			ASSIGN, STAR, DIVIDE, PERCENT, PLUS, MINUS, SHIFTRIGHT, SHIFTLEFT, AND, XOR, OR
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct assignment_expression_suffix: public conditional_or_assignment_expression_suffix
	{
		virtual void acceptAbstract(const conditional_or_assignment_expression_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<assignment_operator>op;
		symbol_required<assignment_expression>right;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(right);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(right);
		};
	};
	struct conversion_declarator
	{
		symbol_required<ptr_operator>op;
		symbol_optional<conversion_declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(decl);
		};
	};
	struct conversion_function_id: public unqualified_id
	{
		virtual void acceptAbstract(const unqualified_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_OPERATOR>key;
		symbol_required<type_specifier_seq>spec;
		symbol_optional<conversion_declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(spec);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(spec)&&parser.parse(decl);
		};
		terminal_identifier value;
	};
	struct destructor_id: public unqualified_id
	{
		virtual void acceptAbstract(const unqualified_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_COMPL>compl_;
		symbol_required<identifier>name;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(compl_);
			visitor.visit(name);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(compl_)&&parser.parse(name);
		};
	};
	struct parameter_declaration_clause;
	struct exception_type_list: public choice<exception_type_list>
	{
		typedef TypeList<struct exception_type_all, TypeList<struct type_id_list, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct exception_type_all: public exception_type_list
	{
		virtual void acceptAbstract(const exception_type_list::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_ELLIPSIS>key;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key);
		};
	};
	struct type_id_list: public exception_type_list
	{
		virtual void acceptAbstract(const exception_type_list::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<type_id>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<type_id_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct exception_specification
	{
		terminal<boost::wave::T_THROW>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_optional<exception_type_list>types;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(types);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(types)&&parser.parse(rp);
		};
	};
	struct declarator_suffix: public choice<declarator_suffix>
	{
		typedef TypeList<struct declarator_suffix_array, TypeList<struct declarator_suffix_function, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct declarator_suffix_function: public declarator_suffix
	{
		virtual void acceptAbstract(const declarator_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_optional<parameter_declaration_clause>params;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		symbol_optional<cv_qualifier_seq>qual;
		symbol_optional<exception_specification>except;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(params);
			visitor.visit(rp);
			visitor.visit(qual);
			visitor.visit(except);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(params)&&parser.parse(rp)&&parser.parse(qual)&&parser.parse(except);
		};
	};
	struct declarator_suffix_array: public declarator_suffix
	{
		virtual void acceptAbstract(const declarator_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTBRACKET>ls;
		symbol_optional<constant_expression>size;
		terminal<boost::wave::T_RIGHTBRACKET>rs;
		symbol_optional<declarator_suffix_array>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(ls);
			visitor.visit(size);
			visitor.visit(rs);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(ls)&&parser.parse(size)&&parser.parse(rs)&&parser.parse(next);
		};
	};
	struct direct_declarator: public declarator
	{
		virtual void acceptAbstract(const declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<direct_declarator_prefix>prefix;
		symbol_optional<declarator_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(prefix);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(prefix)&&parser.parse(suffix);
		};
	};
	struct direct_declarator_parenthesis: public direct_declarator_prefix
	{
		virtual void acceptAbstract(const direct_declarator_prefix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<declarator>decl;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lp);
			visitor.visit(decl);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lp)&&parser.parse(decl)&&parser.parse(rp);
		};
	};
	struct declarator_ptr: public declarator
	{
		virtual void acceptAbstract(const declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<ptr_operator>op;
		symbol_required<declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(op);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(op)&&parser.parse(decl);
		};
	};
	struct statement: public choice<statement>
	{
		typedef TypeList<struct msext_asm_statement_braced, TypeList<struct msext_asm_statement, TypeList<struct compound_statement, TypeList<struct declaration_statement, TypeList<struct labeled_statement, TypeList<struct expression_statement, TypeList<struct selection_statement, TypeList<struct iteration_statement, TypeList<struct jump_statement, TypeList<struct try_block, TypeListEnd> > > > > > > > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct statement_seq
	{
		symbol_required<statement>item;
		symbol_next<statement_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct statement_seq_wrapper
	{
		symbol_sequence<statement_seq>wrapped;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(wrapped);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(wrapped);
		};
	};
	struct function_body: public choice<function_body>
	{
		typedef TypeList<struct compound_statement, TypeListEnd>Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct compound_statement: public statement, public function_body
	{
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const function_body::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTBRACE>lb;
		symbol_optional<statement_seq_wrapper>body;
		terminal<boost::wave::T_RIGHTBRACE>rb;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lb);
			visitor.visit(body);
			visitor.visit(rb);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lb)&&parser.parse(body)&&parser.parse(rb);
		};
	};
	struct exception_declaration: public choice<exception_declaration>
	{
		typedef TypeList<struct exception_declaration_all, TypeList<struct exception_declaration_default, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct exception_declaration_default: public exception_declaration
	{
		virtual void acceptAbstract(const exception_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<type_specifier_seq>type;
		symbol_optional<exception_declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(type);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(type)&&parser.parse(decl);
		};
	};
	struct exception_declaration_all: public exception_declaration
	{
		virtual void acceptAbstract(const exception_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_ELLIPSIS>key;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key);
		};
	};
	struct handler
	{
		terminal<boost::wave::T_CATCH>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<exception_declaration>decl;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		symbol_required<compound_statement>body;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(decl);
			visitor.visit(rp);
			visitor.visit(body);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(decl)&&parser.parse(rp)&&parser.parse(body);
		};
	};
	struct handler_seq
	{
		symbol_required<handler>item;
		symbol_optional<handler_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct linkage_specification_suffix: public choice<linkage_specification_suffix>
	{
		typedef TypeList<struct linkage_specification_compound, TypeList<struct declaration, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct declaration: public choice<declaration>, public linkage_specification_suffix
	{
		IncludeEvents events;
		Source source;
		virtual void acceptAbstract(const linkage_specification_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct linkage_specification, TypeList<struct explicit_instantiation, TypeList<struct template_declaration, TypeList<struct explicit_specialization, TypeList<struct namespace_definition, TypeList<struct general_declaration, TypeList<struct constructor_definition, TypeList<struct block_declaration, TypeListEnd> > > > > > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct mem_initializer_id_base: public mem_initializer_id
	{
		virtual void acceptAbstract(const mem_initializer_id::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		symbol_required<class_name>type;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(type);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(type);
		};
	};
	struct mem_initializer
	{
		symbol_required<mem_initializer_id>id;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_optional<expression_list>args;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(id);
			visitor.visit(lp);
			visitor.visit(args);
			visitor.visit(rp);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(id)&&parser.parse(lp)&&parser.parse(args)&&parser.parse(rp);
		};
	};
	struct mem_initializer_list
	{
		symbol_required<mem_initializer>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<mem_initializer_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct mem_initializer_clause
	{
		symbol_required<mem_initializer_list>list;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(list);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(list);
		};
	};
	struct ctor_initializer
	{
		terminal<boost::wave::T_COLON>colon;
		symbol_required<mem_initializer_clause>list;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(colon);
			visitor.visit(list);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(colon)&&parser.parse(list);
		};
	};
	struct general_declaration_suffix: public choice<general_declaration_suffix>
	{
		typedef TypeList<struct type_declaration_suffix, TypeList<struct simple_declaration_named, TypeList<struct function_definition, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct simple_declaration_suffix: public choice<simple_declaration_suffix>
	{
		typedef TypeList<struct type_declaration_suffix, TypeList<struct simple_declaration_named, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct member_declaration_suffix: public choice<member_declaration_suffix>
	{
		typedef TypeList<struct type_declaration_suffix, TypeList<struct member_declaration_bitfield, TypeList<struct member_declaration_named, TypeList<struct function_definition, TypeListEnd> > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct type_declaration_suffix: public general_declaration_suffix, public simple_declaration_suffix, public member_declaration_suffix
	{
		virtual void acceptAbstract(const general_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const simple_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const member_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(semicolon);
		};
	};
	struct general_declaration: public declaration
	{
		virtual void acceptAbstract(const declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_optional<decl_specifier_seq>spec;
		symbol_required<general_declaration_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(spec);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(spec)&&parser.parse(suffix);
		};
	};
	struct function_definition_suffix: public choice<function_definition_suffix>
	{
		typedef TypeList<struct function_try_block, TypeList<struct function_definition_suffix_default, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct function_definition_suffix_default: public function_definition_suffix
	{
		virtual void acceptAbstract(const function_definition_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_optional<ctor_initializer>init;
		symbol_required<function_body>body;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(init);
			visitor.visit(body);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(init)&&parser.parse(body);
		};
	};
	struct function_try_block: public function_definition_suffix
	{
		virtual void acceptAbstract(const function_definition_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_TRY>isTry;
		symbol_optional<ctor_initializer>init;
		symbol_required<function_body>body;
		symbol_required<handler_seq>handlers;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isTry);
			visitor.visit(init);
			visitor.visit(body);
			visitor.visit(handlers);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isTry)&&parser.parse(init)&&parser.parse(body)&&parser.parse(handlers);
		};
	};
	struct function_definition: public general_declaration_suffix, public member_declaration_suffix
	{
		virtual void acceptAbstract(const general_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const member_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<declarator>decl;
		symbol_required<function_definition_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(suffix);
		};
	};
	struct member_declarator: public choice<member_declarator>
	{
		typedef TypeList<struct member_declarator_bitfield, TypeList<struct member_declarator_default, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct pure_specifier: public member_initializer
	{
		virtual void acceptAbstract(const member_initializer::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_ASSIGN>assign;
		terminal<boost::wave::T_DECIMALINT>zero;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(assign);
			visitor.visit(zero);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(assign)&&parser.parse(zero);
		};
	};
	struct member_declarator_default: public member_declarator
	{
		virtual void acceptAbstract(const member_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<declarator>decl;
		symbol_optional<member_initializer>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(init);
		};
	};
	struct member_declarator_bitfield: public member_declarator
	{
		virtual void acceptAbstract(const member_declarator::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_optional<identifier>id;
		terminal<boost::wave::T_COLON>colon;
		symbol_required<constant_expression>width;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(id);
			visitor.visit(colon);
			visitor.visit(width);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(id)&&parser.parse(colon)&&parser.parse(width);
		};
	};
	struct member_declarator_list
	{
		symbol_required<member_declarator>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<member_declarator_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct member_declaration: public choice<member_declaration>
	{
		typedef TypeList<struct using_declaration, TypeList<struct member_template_declaration, TypeList<struct member_declaration_implicit, TypeList<struct member_declaration_default, TypeList<struct member_declaration_nested, TypeListEnd> > > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct member_declaration_default: public member_declaration
	{
		virtual void acceptAbstract(const member_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<decl_specifier_seq>spec;
		symbol_required<member_declaration_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(spec);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(spec)&&parser.parse(suffix);
		};
	};
	struct member_declaration_bitfield: public member_declaration_suffix
	{
		virtual void acceptAbstract(const member_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<member_declarator_bitfield>item;
		terminal_optional<boost::wave::T_COMMA>comma;
		symbol_required<member_declarator_list>next;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next)&&parser.parse(semicolon);
		};
	};
	struct member_declaration_named: public member_declaration_suffix
	{
		virtual void acceptAbstract(const member_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<member_declarator_list>decl;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(semicolon);
		};
	};
	struct member_declaration_nested: public member_declaration
	{
		virtual void acceptAbstract(const member_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_required<nested_name_specifier>context;
		terminal_optional<boost::wave::T_TEMPLATE>isTemplate;
		symbol_required<unqualified_id>id;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(isTemplate);
			visitor.visit(id);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(isTemplate)&&parser.parse(id)&&parser.parse(semicolon);
		};
	};
	struct function_specifier: public terminal_choice, public decl_specifier_nontype
	{
		virtual void acceptAbstract(const decl_specifier_nontype::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			INLINE, VIRTUAL, EXPLICIT
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct function_specifier_seq
	{
		symbol_required<function_specifier>item;
		symbol_optional<function_specifier_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct constructor_definition: public declaration
	{
		virtual void acceptAbstract(const declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_optional<function_specifier_seq>spec;
		symbol_required<function_definition>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(spec);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(spec)&&parser.parse(suffix);
		};
	};
	struct member_declaration_implicit: public member_declaration
	{
		virtual void acceptAbstract(const member_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_optional<function_specifier_seq>spec;
		symbol_required<member_declaration_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(spec);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(spec)&&parser.parse(suffix);
		};
	};
	struct member_specification: public choice<member_specification>
	{
		typedef TypeList<struct member_specification_access, TypeList<struct member_specification_list, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct member_specification_list: public member_specification
	{
		virtual void acceptAbstract(const member_specification::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<member_declaration>item;
		symbol_optional<member_specification>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct member_specification_access: public member_specification
	{
		virtual void acceptAbstract(const member_specification::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<access_specifier>access;
		terminal<boost::wave::T_COLON>colon;
		symbol_optional<member_specification>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(access);
			visitor.visit(colon);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(access)&&parser.parse(colon)&&parser.parse(next);
		};
	};
	struct class_specifier: public type_specifier_noncv
	{
		virtual void acceptAbstract(const type_specifier_noncv::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<class_head>head;
		terminal<boost::wave::T_LEFTBRACE>lb;
		symbol_optional<member_specification>members;
		terminal<boost::wave::T_RIGHTBRACE>rb;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(head);
			visitor.visit(lb);
			visitor.visit(members);
			visitor.visit(rb);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(head)&&parser.parse(lb)&&parser.parse(members)&&parser.parse(rb);
		};
	};
	struct enumerator_definition
	{
		symbol_required<identifier>id;
		terminal_suffix<boost::wave::T_ASSIGN>assign;
		symbol_required<constant_expression>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(id);
			visitor.visit(assign);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(id)&&parser.parse(assign)&&parser.parse(init);
		};
	};
	struct enumerator_list
	{
		symbol_required<enumerator_definition>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_optional<enumerator_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct enum_specifier: public type_specifier_noncv
	{
		virtual void acceptAbstract(const type_specifier_noncv::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_ENUM>key;
		symbol_optional<identifier>id;
		terminal<boost::wave::T_LEFTBRACE>lb;
		symbol_optional<enumerator_list>values;
		terminal<boost::wave::T_RIGHTBRACE>rb;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(id);
			visitor.visit(lb);
			visitor.visit(values);
			visitor.visit(rb);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(id)&&parser.parse(lb)&&parser.parse(values)&&parser.parse(rb);
		};
	};
	struct elaborated_type_specifier: public choice<elaborated_type_specifier>, public type_specifier_noncv
	{
		virtual void acceptAbstract(const type_specifier_noncv::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct elaborated_type_specifier_template, TypeList<struct elaborated_type_specifier_default, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct elaborated_type_specifier_default: public elaborated_type_specifier
	{
		virtual void acceptAbstract(const elaborated_type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<elaborated_type_specifier_key>key;
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		symbol_required<identifier>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(id);
		};
	};
	struct elaborated_type_specifier_template: public elaborated_type_specifier
	{
		virtual void acceptAbstract(const elaborated_type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<class_key>key;
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		terminal_optional<boost::wave::T_TEMPLATE>isTemplate;
		symbol_required<simple_template_id>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(isTemplate);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(isTemplate)&&parser.parse(id);
		};
	};
	struct typename_specifier: public type_specifier_noncv, public postfix_expression_type_specifier
	{
		virtual void acceptAbstract(const type_specifier_noncv::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const postfix_expression_type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_TYPENAME>key;
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		terminal_optional<boost::wave::T_TEMPLATE>isTemplate;
		symbol_required<type_name>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(isTemplate);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(isTemplate)&&parser.parse(id);
		};
	};
	struct parameter_declaration_suffix: public choice<parameter_declaration_suffix>
	{
		typedef TypeList<struct parameter_declaration_default, TypeList<struct parameter_declaration_abstract, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct parameter_declaration: public template_parameter
	{
		virtual void acceptAbstract(const template_parameter::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<decl_specifier_seq>spec;
		symbol_required<parameter_declaration_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(spec);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(spec)&&parser.parse(suffix);
		};
	};
	struct type_parameter: public choice<type_parameter>, public template_parameter
	{
		virtual void acceptAbstract(const template_parameter::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct type_parameter_default, TypeList<struct type_parameter_template, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct type_parameter_key: public terminal_choice
	{
		enum
		{
			CLASS, TYPENAME
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct type_parameter_default: public type_parameter
	{
		virtual void acceptAbstract(const type_parameter::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<type_parameter_key>key;
		symbol_optional<identifier>id;
		terminal_suffix<boost::wave::T_ASSIGN>assign;
		symbol_required<type_id>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(id);
			visitor.visit(assign);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(id)&&parser.parse(assign)&&parser.parse(init);
		};
	};
	struct template_parameter_list
	{
		symbol_required<template_parameter>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<template_parameter_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct template_parameter_clause
	{
		terminal<boost::wave::T_LESS>lt;
		symbol_required<template_parameter_list>params;
		terminal<boost::wave::T_GREATER>gt;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lt);
			visitor.visit(params);
			visitor.visit(gt);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lt)&&parser.parse(params)&&parser.parse(gt);
		};
	};
	struct type_parameter_template: public type_parameter
	{
		virtual void acceptAbstract(const type_parameter::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_TEMPLATE>key;
		symbol_required<template_parameter_clause>params;
		terminal<boost::wave::T_CLASS>key2;
		symbol_optional<identifier>id;
		terminal_suffix<boost::wave::T_ASSIGN>assign;
		symbol_required<id_expression>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(params);
			visitor.visit(key2);
			visitor.visit(id);
			visitor.visit(assign);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(params)&&parser.parse(key2)&&parser.parse(id)&&parser.parse(assign)&&parser.parse(init);
		};
	};
	struct default_argument
	{
		symbol_required<assignment_expression>expr;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(expr);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(expr);
		};
	};
	struct parameter_declaration_default: public parameter_declaration_suffix
	{
		virtual void acceptAbstract(const parameter_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<declarator>decl;
		terminal_suffix<boost::wave::T_ASSIGN>assign;
		symbol_required<default_argument>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(assign);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(assign)&&parser.parse(init);
		};
	};
	struct parameter_declaration_abstract: public parameter_declaration_suffix
	{
		virtual void acceptAbstract(const parameter_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_optional<abstract_declarator>decl;
		terminal_suffix<boost::wave::T_ASSIGN>assign;
		symbol_required<default_argument>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(assign);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(assign)&&parser.parse(init);
		};
	};
	struct parameter_declaration_list
	{
		symbol_required<parameter_declaration>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<parameter_declaration_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct parameter_declaration_clause
	{
		symbol_optional<parameter_declaration_list>list;
		terminal_optional<boost::wave::T_ELLIPSIS>isEllipsis;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(list);
			visitor.visit(isEllipsis);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(list)&&parser.parse(isEllipsis);
		};
	};
	struct direct_abstract_declarator_function: public direct_abstract_declarator
	{
		symbol_required<direct_abstract_declarator>decl;
		symbol_required<parameter_declaration_clause>params;
		symbol_required<cv_qualifier_seq>qual;
		symbol_required<exception_specification>except;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(params);
			visitor.visit(qual);
			visitor.visit(except);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(params)&&parser.parse(qual)&&parser.parse(except);
		};
	};
	struct direct_abstract_declarator_array: public direct_abstract_declarator
	{
		symbol_required<direct_abstract_declarator>decl;
		symbol_required<constant_expression>size;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(size);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(size);
		};
	};
	struct decl_specifier_default: public terminal_choice, public decl_specifier_nontype
	{
		virtual void acceptAbstract(const decl_specifier_nontype::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			FRIEND, TYPEDEF
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct storage_class_specifier: public terminal_choice, public decl_specifier_nontype
	{
		virtual void acceptAbstract(const decl_specifier_nontype::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			REGISTER, STATIC, EXTERN, MUTABLE
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct simple_type_specifier_name: public simple_type_specifier
	{
		virtual void acceptAbstract(const simple_type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		symbol_required<type_name>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(id);
		};
	};
	struct simple_type_specifier_template: public simple_type_specifier
	{
		virtual void acceptAbstract(const simple_type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_required<nested_name_specifier>context;
		terminal<boost::wave::T_TEMPLATE>key;
		symbol_required<simple_template_id>id;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(key);
			visitor.visit(id);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(key)&&parser.parse(id);
		};
	};
	struct simple_type_specifier_builtin: public terminal_choice, public simple_type_specifier, public decl_specifier_suffix, public type_specifier_suffix
	{
		virtual void acceptAbstract(const simple_type_specifier::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const decl_specifier_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const type_specifier_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		enum
		{
			CHAR, WCHAR_T, BOOL, SHORT, INT, LONG, SIGNED, UNSIGNED, FLOAT, DOUBLE, VOID, AUTO, INT64
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct declaration_statement: public choice<declaration_statement>, public statement
	{
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct block_declaration, TypeList<struct simple_declaration, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct block_declaration: public choice<block_declaration>, public declaration_statement, public declaration
	{
		virtual void acceptAbstract(const declaration_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct asm_definition, TypeList<struct namespace_alias_definition, TypeList<struct using_declaration, TypeList<struct using_directive, TypeListEnd> > > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct asm_definition: public block_declaration
	{
		virtual void acceptAbstract(const block_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_ASM>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<string_literal>str;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(str);
			visitor.visit(rp);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(str)&&parser.parse(rp)&&parser.parse(semicolon);
		};
	};
	struct msext_asm_element: public choice<msext_asm_element>
	{
		typedef TypeList<struct msext_asm_statement_braced, TypeList<struct msext_asm_statement, TypeList<struct msext_asm_terminal, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct msext_asm_terminal: public msext_asm_element
	{
		virtual void acceptAbstract(const msext_asm_element::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_identifier value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct msext_asm_element_list
	{
		symbol_required<msext_asm_element>item;
		symbol_optional<msext_asm_element_list>next;
		terminal_optional<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next)&&parser.parse(semicolon);
		};
	};
	struct msext_asm_element_list_inline
	{
		symbol_required<msext_asm_element>item;
		symbol_optional<msext_asm_element_list_inline>next;
		terminal_optional<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next)&&parser.parse(semicolon);
		};
	};
	struct msext_asm_statement: public msext_asm_element, public statement
	{
		virtual void acceptAbstract(const msext_asm_element::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_MSEXT_ASM>key;
		symbol_required<msext_asm_element_list_inline>list;
		terminal_optional<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(list);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(list)&&parser.parse(semicolon);
		};
	};
	struct msext_asm_statement_braced: public msext_asm_element, public statement
	{
		virtual void acceptAbstract(const msext_asm_element::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_MSEXT_ASM>key;
		terminal<boost::wave::T_LEFTBRACE>lb;
		symbol_required<msext_asm_element_list>list;
		terminal<boost::wave::T_RIGHTBRACE>rb;
		terminal_optional<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lb);
			visitor.visit(list);
			visitor.visit(rb);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lb)&&parser.parse(list)&&parser.parse(rb)&&parser.parse(semicolon);
		};
	};
	struct namespace_alias_definition: public block_declaration
	{
		virtual void acceptAbstract(const block_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_NAMESPACE>key;
		symbol_required<identifier>alias;
		terminal<boost::wave::T_ASSIGN>assign;
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		symbol_required<identifier>id;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(alias);
			visitor.visit(assign);
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(id);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(alias)&&parser.parse(assign)&&parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(id)&&parser.parse(semicolon);
		};
	};
	struct using_declaration: public choice<using_declaration>, public block_declaration, public member_declaration
	{
		virtual void acceptAbstract(const block_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const member_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct using_declaration_global, TypeList<struct using_declaration_nested, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct using_declaration_global: public using_declaration
	{
		virtual void acceptAbstract(const using_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_USING>key;
		terminal<boost::wave::T_COLON_COLON>scope;
		symbol_required<unqualified_id>id;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(scope);
			visitor.visit(id);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(scope)&&parser.parse(id)&&parser.parse(semicolon);
		};
	};
	struct using_declaration_nested: public using_declaration
	{
		virtual void acceptAbstract(const using_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_USING>key;
		terminal_optional<boost::wave::T_TYPENAME>isTypename;
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_required<nested_name_specifier>context;
		symbol_required<unqualified_id>id;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(isTypename);
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(id);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(isTypename)&&parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(id)&&parser.parse(semicolon);
		};
	};
	struct using_directive: public block_declaration
	{
		virtual void acceptAbstract(const block_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_USING>key;
		terminal<boost::wave::T_NAMESPACE>key2;
		terminal_optional<boost::wave::T_COLON_COLON>isGlobal;
		symbol_optional<nested_name_specifier>context;
		symbol_required<namespace_name>id;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(key2);
			visitor.visit(isGlobal);
			visitor.visit(context);
			visitor.visit(id);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(key2)&&parser.parse(isGlobal)&&parser.parse(context)&&parser.parse(id)&&parser.parse(semicolon);
		};
	};
	struct for_init_statement: public choice<for_init_statement>
	{
		typedef TypeList<struct expression_statement, TypeList<struct simple_declaration, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct init_declarator
	{
		symbol_required<declarator>decl;
		symbol_optional<initializer>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(init);
		};
	};
	struct init_declarator_list
	{
		symbol_required<init_declarator>item;
		terminal_suffix<boost::wave::T_COMMA>comma;
		symbol_required<init_declarator_list>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(comma);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(comma)&&parser.parse(next);
		};
	};
	struct simple_declaration_named: public general_declaration_suffix, public simple_declaration_suffix
	{
		virtual void acceptAbstract(const simple_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const general_declaration_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<init_declarator_list>decl;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(semicolon);
		};
	};
	struct simple_declaration: public declaration_statement, public for_init_statement
	{
		virtual void acceptAbstract(const declaration_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const for_init_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<decl_specifier_seq>spec;
		symbol_required<simple_declaration_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(spec);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(spec)&&parser.parse(suffix);
		};
	};
	struct labeled_statement: public choice<labeled_statement>, public statement
	{
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct labeled_statement_id, TypeList<struct labeled_statement_case, TypeList<struct labeled_statement_default, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct labeled_statement_id: public labeled_statement
	{
		virtual void acceptAbstract(const labeled_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<identifier>label;
		terminal<boost::wave::T_COLON>colon;
		symbol_required<statement>body;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(label);
			visitor.visit(colon);
			visitor.visit(body);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(label)&&parser.parse(colon)&&parser.parse(body);
		};
	};
	struct labeled_statement_case: public labeled_statement
	{
		virtual void acceptAbstract(const labeled_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_CASE>key;
		symbol_required<constant_expression>label;
		terminal<boost::wave::T_COLON>colon;
		symbol_required<statement>body;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(label);
			visitor.visit(colon);
			visitor.visit(body);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(label)&&parser.parse(colon)&&parser.parse(body);
		};
	};
	struct labeled_statement_default: public labeled_statement
	{
		virtual void acceptAbstract(const labeled_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_DEFAULT>key;
		terminal<boost::wave::T_COLON>colon;
		symbol_required<statement>body;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(colon);
			visitor.visit(body);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(colon)&&parser.parse(body);
		};
	};
	struct expression_statement: public statement, public for_init_statement
	{
		virtual void acceptAbstract(const for_init_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_optional<expression>expr;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(expr);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(expr)&&parser.parse(semicolon);
		};
	};
	struct selection_statement: public choice<selection_statement>, public statement
	{
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct selection_statement_if, TypeList<struct selection_statement_switch, TypeListEnd> >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct condition_declarator
	{
		symbol_required<declarator>decl;
		terminal<boost::wave::T_ASSIGN>assign;
		symbol_required<assignment_expression>init;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(decl);
			visitor.visit(assign);
			visitor.visit(init);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(decl)&&parser.parse(assign)&&parser.parse(init);
		};
	};
	struct condition_init: public condition
	{
		virtual void acceptAbstract(const condition::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<type_specifier_seq>type;
		symbol_required<condition_declarator>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(type);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(type)&&parser.parse(decl);
		};
	};
	struct selection_statement_if: public selection_statement
	{
		virtual void acceptAbstract(const selection_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_IF>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<condition>cond;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		symbol_required<statement>body;
		terminal_suffix<boost::wave::T_ELSE>key2;
		symbol_required<statement>fail;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(cond);
			visitor.visit(rp);
			visitor.visit(body);
			visitor.visit(key2);
			visitor.visit(fail);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(cond)&&parser.parse(rp)&&parser.parse(body)&&parser.parse(key2)&&parser.parse(fail);
		};
	};
	struct selection_statement_switch: public selection_statement
	{
		virtual void acceptAbstract(const selection_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_SWITCH>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<condition>cond;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		symbol_required<statement>body;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(cond);
			visitor.visit(rp);
			visitor.visit(body);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(cond)&&parser.parse(rp)&&parser.parse(body);
		};
	};
	struct iteration_statement: public choice<iteration_statement>, public statement
	{
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct iteration_statement_for, TypeList<struct iteration_statement_while, TypeList<struct iteration_statement_dowhile, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct iteration_statement_while: public iteration_statement
	{
		virtual void acceptAbstract(const iteration_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_WHILE>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<condition>cond;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		symbol_required<statement>body;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(cond);
			visitor.visit(rp);
			visitor.visit(body);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(cond)&&parser.parse(rp)&&parser.parse(body);
		};
	};
	struct iteration_statement_dowhile: public iteration_statement
	{
		virtual void acceptAbstract(const iteration_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_DO>key;
		symbol_required<statement>body;
		terminal<boost::wave::T_WHILE>key2;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<expression>cond;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(body);
			visitor.visit(key2);
			visitor.visit(lp);
			visitor.visit(cond);
			visitor.visit(rp);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(body)&&parser.parse(key2)&&parser.parse(lp)&&parser.parse(cond)&&parser.parse(rp)&&parser.parse(semicolon);
		};
	};
	struct iteration_statement_for: public iteration_statement
	{
		virtual void acceptAbstract(const iteration_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_FOR>key;
		terminal<boost::wave::T_LEFTPAREN>lp;
		symbol_required<for_init_statement>init;
		symbol_optional<condition>cond;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		symbol_optional<expression>incr;
		terminal<boost::wave::T_RIGHTPAREN>rp;
		symbol_required<statement>body;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lp);
			visitor.visit(init);
			visitor.visit(cond);
			visitor.visit(semicolon);
			visitor.visit(incr);
			visitor.visit(rp);
			visitor.visit(body);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lp)&&parser.parse(init)&&parser.parse(cond)&&parser.parse(semicolon)&&parser.parse(incr)&&parser.parse(rp)&&parser.parse(body);
		};
	};
	struct jump_statement: public choice<jump_statement>, public statement
	{
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		typedef TypeList<struct jump_statement_simple, TypeList<struct jump_statement_return, TypeList<struct jump_statement_goto, TypeListEnd> > >Types;
		typedef Types Choices;
		typedef VisitorFuncGeneric<Types>VisitorFuncTable;
		typedef VisitorCallback<VisitorFuncTable>Visitor;
		virtual void acceptAbstract(const Visitor&visitor)=0;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			static VisitorFuncTable table=VisitorFuncTable(VisitorTypeId<VisitorType>());
			Visitor callback=
			{
				&visitor, &table
			};
			acceptAbstract(callback);
		};
	};
	struct jump_statement_key: public terminal_choice
	{
		enum
		{
			BREAK, CONTINUE
		}
		id;
		terminal_choice2 value;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(value);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(value);
		};
	};
	struct jump_statement_simple: public jump_statement
	{
		virtual void acceptAbstract(const jump_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<jump_statement_key>key;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(semicolon);
		};
	};
	struct jump_statement_return: public jump_statement
	{
		virtual void acceptAbstract(const jump_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_RETURN>key;
		symbol_optional<expression>expr;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(expr);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(expr)&&parser.parse(semicolon);
		};
	};
	struct jump_statement_goto: public jump_statement
	{
		virtual void acceptAbstract(const jump_statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_GOTO>key;
		symbol_required<identifier>id;
		terminal<boost::wave::T_SEMICOLON>semicolon;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(id);
			visitor.visit(semicolon);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(id)&&parser.parse(semicolon);
		};
	};
	struct try_block: public statement
	{
		virtual void acceptAbstract(const statement::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_TRY>key;
		symbol_required<compound_statement>body;
		symbol_required<handler_seq>handlers;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(body);
			visitor.visit(handlers);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(body)&&parser.parse(handlers);
		};
	};
	struct declaration_seq
	{
		symbol_required<declaration>item;
		symbol_next<declaration_seq>next;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(item);
			visitor.visit(next);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(item)&&parser.parse(next);
		};
	};
	struct template_declaration_prefix
	{
		terminal_optional<boost::wave::T_EXPORT>isExport;
		terminal<boost::wave::T_TEMPLATE>key;
		symbol_required<template_parameter_clause>params;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isExport);
			visitor.visit(key);
			visitor.visit(params);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isExport)&&parser.parse(key)&&parser.parse(params);
		};
	};
	struct template_declaration: public declaration
	{
		virtual void acceptAbstract(const declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<template_declaration_prefix>prefix;
		symbol_required<declaration>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(prefix);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(prefix)&&parser.parse(decl);
		};
	};
	struct member_template_declaration: public member_declaration
	{
		virtual void acceptAbstract(const member_declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		symbol_required<template_declaration_prefix>prefix;
		symbol_required<member_declaration>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(prefix);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(prefix)&&parser.parse(decl);
		};
	};
	struct explicit_instantiation: public declaration
	{
		virtual void acceptAbstract(const declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal_optional<boost::wave::T_EXTERN>isExtern;
		terminal<boost::wave::T_TEMPLATE>key;
		symbol_required<declaration>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(isExtern);
			visitor.visit(key);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(isExtern)&&parser.parse(key)&&parser.parse(decl);
		};
	};
	struct explicit_specialization: public declaration
	{
		virtual void acceptAbstract(const declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_TEMPLATE>key;
		terminal<boost::wave::T_LESS>lt;
		terminal<boost::wave::T_GREATER>gt;
		symbol_required<declaration>decl;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(lt);
			visitor.visit(gt);
			visitor.visit(decl);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(lt)&&parser.parse(gt)&&parser.parse(decl);
		};
	};
	struct linkage_specification_compound: public linkage_specification_suffix
	{
		virtual void acceptAbstract(const linkage_specification_suffix::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_LEFTBRACE>lb;
		symbol_sequence<declaration_seq>decl;
		terminal<boost::wave::T_RIGHTBRACE>rb;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(lb);
			visitor.visit(decl);
			visitor.visit(rb);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(lb)&&parser.parse(decl)&&parser.parse(rb);
		};
	};
	struct linkage_specification: public declaration
	{
		virtual void acceptAbstract(const declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_EXTERN>key;
		symbol_required<string_literal>str;
		symbol_required<linkage_specification_suffix>suffix;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(str);
			visitor.visit(suffix);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(str)&&parser.parse(suffix);
		};
	};
	typedef declaration_seq namespace_body;
	struct namespace_definition: public declaration
	{
		virtual void acceptAbstract(const declaration::Visitor&visitor)
		{
			visitor.visit(this);
		};
		terminal<boost::wave::T_NAMESPACE>key;
		symbol_optional<identifier>id;
		terminal<boost::wave::T_LEFTBRACE>lb;
		symbol_sequence<namespace_body>body;
		terminal<boost::wave::T_RIGHTBRACE>rb;
		template<typename VisitorType>
		void accept(VisitorType&visitor)
		{
			visitor.visit(key);
			visitor.visit(id);
			visitor.visit(lb);
			visitor.visit(body);
			visitor.visit(rb);
		}
		typedef TypeListEnd Choices;
		template<typename Walker>
		bool parse(ParserGeneric<Walker>&parser)
		{
			return parser.parse(key)&&parser.parse(id)&&parser.parse(lb)&&parser.parse(body)&&parser.parse(rb);
		};
	};
}
template<typename T>
inline cpp::symbol<T>makeSymbol(T*p)
{
	return cpp::symbol<T>(p);
}
template<typename T, typename A>
class Copied: private A
{
	protected: T*p;
	A&getAllocator()
	{
		return *this;
	}
	const A&getAllocator()const
	{
		return *this;
	}
public:
	Copied(const A&allocator): A(allocator), p(0)
	{
	}
	~Copied()
	{
		allocatorDelete(getAllocator(), p);
	}
	Copied(const T&value, const A&allocator): A(allocator), p(allocatorNew(getAllocator(), value))
	{
	}
	Copied(const Copied&other): A(other), p(other.p==0?0: allocatorNew(getAllocator(), *other.p))
	{
	}
	Copied&operator=(const Copied&other)
	{
		Copied tmp(other);
		tmp.swap(*this);
		return *this;
	}
	Copied&operator=(const T&value)
	{
		Copied tmp(value, getAllocator());
		tmp.swap(*this);
		return *this;
	}
	void swap(Copied&other)
	{
		if(!(!isDeallocated(p)))
		{
			throw AllocatorError();
		};
		std::swap(p, other.p);
		if(!(!isDeallocated(p)))
		{
			throw AllocatorError();
		};
	}
	T*get()
	{
		if(!(!isDeallocated(p)))
		{
			throw AllocatorError();
		};
		return p;
	}
	const T*get()const
	{
		if(!(!isDeallocated(p)))
		{
			throw AllocatorError();
		};
		return p;
	}
	bool empty()const
	{
		return p==0;
	}
	T&back()
	{
		if(!(!isDeallocated(p)))
		{
			throw AllocatorError();
		};
		return *p;
	}
	const T&back()const
	{
		if(!(!isDeallocated(p)))
		{
			throw AllocatorError();
		};
		return *p;
	}
};
namespace std
{
	template<typename T, typename A>
	void swap(Copied<T, A>&left, Copied<T, A>&right)
	{
		left.swap(right);
	}
}
template<typename T, typename A>
class CopiedReference: private A
{
	Reference<T>p;
	A&getAllocator()
	{
		return *this;
	}
	const A&getAllocator()const
	{
		return *this;
	}
public:
	CopiedReference(const A&allocator): A(allocator), p(0)
	{
	}
	CopiedReference(const T&t, const A&allocator): A(allocator), p(allocatorNew(getAllocator(), makeReferenceCounted(t)))
	{
	}
	CopiedReference&operator=(const T&t)
	{
		CopiedReference tmp(t, getAllocator());
		tmp.swap(*this);
		return *this;
	}
	CopiedReference&operator=(CopiedReference tmp)
	{
		tmp.swap(*this);
		return *this;
	}
	void swap(CopiedReference&other)
	{
		p.swap(other.p);
	}
	const Reference<T>&get_ref()const
	{
		return p;
	}
	T*get()const
	{
		return p.get();
	}
	bool empty()const
	{
		return p.empty();
	}
	T&back()
	{
		return *p;
	}
	const T&back()const
	{
		return *p;
	}
};
struct ListError
{
	ListError()
	{
	}
};
template<typename T>
struct ListNode;
template<typename T>
struct ListNodeBase
{
	ListNode<T>*next;
};
template<typename T>
struct ListNode: ListNodeBase<T>
{
	T value;
	explicit ListNode(const T&value): value(value)
	{
	}
};
template<typename T>
struct ListIterator
{
	typedef std::forward_iterator_tag iterator_category;
	typedef typename TypeTraits<T>::Value value_type;
	typedef ptrdiff_t difference_type;
	typedef T*pointer;
	typedef T&reference;
	typedef ListNode<value_type>Node;
	Node*p;
	explicit ListIterator(Node*p): p(p)
	{
	}
	explicit ListIterator(const Node*p): p(const_cast<Node*>(p))
	{
	}
	ListIterator(const ListIterator<value_type>&other): p(other.p)
	{
	}
	reference operator*()const
	{
		if(!(!isDeallocated(p)))
		{
			throw AllocatorError();
		};
		return p->value;
	}
	pointer operator->()const
	{
		if(!(!isDeallocated(p)))
		{
			throw AllocatorError();
		};
		return &p->value;
	}
	ListIterator&operator++()
	{
		p=p->next;
		return *this;
	}
	ListIterator operator++(int)
	{
		ListIterator tmp=*this;
		++*this;
		return tmp;
	}
};
template<typename T, typename Other>
inline bool operator==(ListIterator<T>left, ListIterator<Other>right)
{
	return &(*left)==&(*right);
}
template<typename T, typename Other>
inline bool operator!=(ListIterator<T>left, ListIterator<Other>right)
{
	return &(*left)!=&(*right);
}
template<typename T, typename A>
struct List: protected A
{
	typedef ListNode<T>Node;
	ListNodeBase<T>head;
	Node*tail;
	typedef typename A::template rebind<Node>::other Allocator;
	A&getAllocator()
	{
		return *this;
	}
	const A&getAllocator()const
	{
		return *this;
	}
	List()
	{
		construct();
	}
	List(const A&allocator): A(allocator)
	{
		construct();
	}
	~List()
	{
		destroy();
	}
	void construct()
	{
		head.next=tail=static_cast<Node*>(&head);
	}
	void destroy()
	{
		for(Node*p=head.next;
		p!=&head;
		)
		{
			Node*next=p->next;
			allocatorDelete(getAllocator(), p);
			p=next;
		}
	}
	List(const List&other): A(other)
	{
		tail=static_cast<Node*>(&head);
		for(Node*p=other.head.next;
		p!=&other.head;
		p=p->next)
		{
			tail->next=allocatorNew(getAllocator(), Node(p->value));
			tail=tail->next;
		}
		tail->next=static_cast<Node*>(&head);
	}
	List&operator=(List other)
	{
		other.swap(*this);
		return *this;
	}
	typedef ListIterator<T>iterator;
	typedef ListIterator<const T>const_iterator;
	iterator begin()
	{
		return iterator(head.next);
	}
	const_iterator begin()const
	{
		return const_iterator(head.next);
	}
	iterator end()
	{
		return iterator(static_cast<Node*>(&head));
	}
	const_iterator end()const
	{
		return const_iterator(static_cast<const Node*>(&head));
	}
	bool empty()const
	{
		return begin()==end();
	}
	T&front()
	{
		return head.next->value;
	}
	T&back()
	{
		return tail->value;
	}
	void clear()
	{
		destroy();
		construct();
	}
	void push_back(const T&value)
	{
		if(!(empty()||!isDeallocated(head.next)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(tail)))
		{
			throw AllocatorError();
		};
		Node*node=allocatorNew(getAllocator(), Node(value));
		node->next=static_cast<Node*>(&head);
		tail->next=node;
		tail=node;
	}
	void push_front(const T&value)
	{
		if(!(empty()||!isDeallocated(head.next)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(tail)))
		{
			throw AllocatorError();
		};
		Node*node=allocatorNew(getAllocator(), Node(value));
		if(empty())
		{
			tail=node;
		}
		node->next=head.next;
		head.next=node;
	}
	void pop_front()
	{
		if(!(empty()||!isDeallocated(head.next)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(tail)))
		{
			throw AllocatorError();
		};
		if(!(!empty()))
		{
			throw ListError();
		};
		Node*p=head.next;
		head.next=p->next;
		allocatorDelete(getAllocator(), p);
	}
	void pop_back()
	{
		if(!(empty()||!isDeallocated(head.next)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(tail)))
		{
			throw AllocatorError();
		};
		if(!(!empty()))
		{
			throw ListError();
		};
		Node*p=static_cast<Node*>(&head);
		for(;
		p->next!=tail;
		)
		{
			p=p->next;
		}
		allocatorDelete(getAllocator(), tail);
		tail=p;
		tail->next=static_cast<Node*>(&head);
	}
	void erase(iterator first, iterator last)
	{
		if(!(first==begin()))
		{
			throw ListError();
		};
		for(Node*p=head.next;
		p!=last.p;
		)
		{
			Node*next=p->next;
			allocatorDelete(getAllocator(), p);
			p=next;
		}
		head.next=last.p;
	}
	void splice(iterator position, List&other)
	{
		if(!(empty()||!isDeallocated(head.next)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(tail)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(other.head.next)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(other.tail)))
		{
			throw AllocatorError();
		};
		if(!(&other!=this))
		{
			throw ListError();
		};
		if(!other.empty())
		{
			tail->next=other.head.next;
			tail=other.tail;
			tail->next=static_cast<Node*>(&head);
			other.construct();
		}
	}
	void swap(List&other)
	{
		if(!(empty()||!isDeallocated(head.next)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(tail)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(other.head.next)))
		{
			throw AllocatorError();
		};
		if(!(empty()||!isDeallocated(other.tail)))
		{
			throw AllocatorError();
		};
		std::swap(head, other.head);
		std::swap(tail, other.tail);
		if(head.next!=&other.head)
		{
			tail->next=static_cast<Node*>(&head);
		}
		else
		{
			construct();
		}
		if(other.head.next!=&head)
		{
			other.tail->next=static_cast<Node*>(&other.head);
		}
		else
		{
			other.construct();
		}
	}
};
template<typename T>
struct ListReferenceNode;
template<typename T>
struct ListReferenceNodeBase
{
	Reference<ListReferenceNode<T> >next;
};
template<typename T>
struct ListReferenceNode: ListReferenceNodeBase<T>
{
	T value;
	explicit ListReferenceNode(const T&value): value(value)
	{
	}
};
template<typename T>
struct ListReferenceIterator
{
	typedef std::forward_iterator_tag iterator_category;
	typedef typename TypeTraits<T>::Value value_type;
	typedef ptrdiff_t difference_type;
	typedef T*pointer;
	typedef T&reference;
	typedef ListReferenceNode<value_type>Node;
	typedef Reference<Node>Pointer;
	Pointer p;
	explicit ListReferenceIterator(Pointer p): p(p)
	{
	}
	ListReferenceIterator(const ListReferenceIterator<value_type>&other): p(other.p)
	{
	}
	reference operator*()const
	{
		return p->value;
	}
	pointer operator->()const
	{
		return &p->value;
	}
	ListReferenceIterator&operator++()
	{
		p=p->next;
		return *this;
	}
	ListReferenceIterator operator++(int)
	{
		ListReferenceIterator tmp=*this;
		++*this;
		return tmp;
	}
};
template<typename T, typename Other>
inline bool operator==(ListReferenceIterator<T>left, ListReferenceIterator<Other>right)
{
	return &(*left)==&(*right);
}
template<typename T, typename Other>
inline bool operator!=(ListReferenceIterator<T>left, ListReferenceIterator<Other>right)
{
	return &(*left)!=&(*right);
}
template<typename T, typename A>
struct ListReference: A
{
	typedef ListReferenceNode<T>Node;
	typedef Reference<Node>Pointer;
	ListReferenceNodeBase<T>head;
	Pointer tail;
	typedef typename A::template rebind<Node>::other Allocator;
	A&getAllocator()
	{
		return *this;
	}
	const A&getAllocator()const
	{
		return *this;
	}
	ListReference()
	{
		construct();
	}
	ListReference(const A&allocator): A(allocator)
	{
		construct();
	}
	ListReference&operator=(const ListReference&other)
	{
		head=other.head;
		tail=other.tail;
		return *this;
	}
	void construct()
	{
		head.next=tail=0;
	}
	typedef ListReferenceIterator<T>iterator;
	typedef ListReferenceIterator<const T>const_iterator;
	iterator begin()
	{
		return iterator(head.next);
	}
	const_iterator begin()const
	{
		return const_iterator(head.next);
	}
	iterator end()
	{
		return iterator(Pointer(0));
	}
	const_iterator end()const
	{
		return const_iterator(Pointer(0));
	}
	bool empty()const
	{
		return begin()==end();
	}
	T&front()
	{
		return head.next->value;
	}
	T&back()
	{
		return tail->value;
	}
	void clear()
	{
		construct();
	}
	void push_back(const T&value)
	{
		Pointer node=allocatorNew(getAllocator(), makeReferenceCounted(Node(value)));
		node->next=0;
		if(empty())
		{
			head.next=node;
		}
		else
		{
			tail->next=node;
		}
		tail=node;
	}
	void push_front(const T&value)
	{
		Pointer node=allocatorNew(getAllocator(), makeReferenceCounted(Node(value)));
		node->next=head.next;
		if(empty())
		{
			tail=node;
		}
		head.next=node;
	}
	void splice(iterator position, ListReference&other)
	{
		if(!(position==begin()))
		{
			throw ListError();
		};
		if(!(&other!=this))
		{
			throw ListError();
		};
		if(!other.empty())
		{
			if(empty())
			{
				tail=other.tail;
			}
			else
			{
				other.tail->next=head.next;
			}
			head=other.head;
			other.construct();
		}
	}
	void swap(ListReference&other)
	{
		head.next.swap(other.head.next);
		tail.swap(other.tail);
	}
};
namespace std
{
	extern _iobuf*_Fiopen(const char*, ios_base::openmode, int);
	extern _iobuf*_Fiopen(const wchar_t*, ios_base::openmode, int);
	extern _iobuf*_Fiopen(const unsigned short*, ios_base::openmode, int);
	template<class _Elem>
	inline bool _Fgetc(_Elem&_Ch, _iobuf*_File)
	{
		return (fread(&_Ch, sizeof(_Elem), 1, _File)==1);
	}
	template<>
	inline bool _Fgetc(char&_Byte, _iobuf*_File)
	{
		int _Meta;
		if((_Meta=fgetc(_File))==(-1))return (false);
		else
		{
			_Byte=(char)_Meta;
			return (true);
		}
	}
	template<>
	inline bool _Fgetc(wchar_t&_Wchar, _iobuf*_File)
	{
		wint_t _Meta;
		if((_Meta=::fgetwc(_File))==(wint_t)(0xFFFF))return (false);
		else
		{
			_Wchar=(wchar_t)_Meta;
			return (true);
		}
	}
	template<class _Elem>
	inline bool _Fputc(_Elem _Ch, _iobuf*_File)
	{
		return (fwrite(&_Ch, 1, sizeof(_Elem), _File)==sizeof(_Elem));
	}
	template<>
	inline bool _Fputc(char _Byte, _iobuf*_File)
	{
		return (fputc(_Byte, _File)!=(-1));
	}
	template<>
	inline bool _Fputc(wchar_t _Wchar, _iobuf*_File)
	{
		return (::fputwc(_Wchar, _File)!=(wint_t)(0xFFFF));
	}
	template<class _Elem>
	inline bool _Ungetc(const _Elem&_Ch, _iobuf*_File)
	{
		return (false);
	}
	template<>
	inline bool _Ungetc(const char&_Byte, _iobuf*_File)
	{
		return (ungetc((unsigned char)_Byte, _File)!=(-1));
	}
	template<>
	inline bool _Ungetc(const signed char&_Byte, _iobuf*_File)
	{
		return (ungetc((unsigned char)_Byte, _File)!=(-1));
	}
	template<>
	inline bool _Ungetc(const unsigned char&_Byte, _iobuf*_File)
	{
		return (ungetc(_Byte, _File)!=(-1));
	}
	template<>
	inline bool _Ungetc(const wchar_t&_Wchar, _iobuf*_File)
	{
		return (::ungetwc(_Wchar, _File)!=(wint_t)(0xFFFF));
	}
	template<class _Elem, class _Traits>
	class basic_filebuf: public basic_streambuf<_Elem, _Traits>
	{
	public:
		typedef basic_filebuf<_Elem, _Traits>_Myt;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef typename _Traits::state_type _Myst;
		typedef codecvt<_Elem, char, typename _Traits::state_type>_Cvt;
		virtual~basic_filebuf()
		{
			if(_Closef)close();
		}
		basic_filebuf(_iobuf*_File=0): _Mysb()
		{
			_Init(_File, _Newfl);
		}
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		basic_filebuf(_Uninitialized): _Mysb(_Noinit)
		{
		}
		enum _Initfl
		{
			_Newfl, _Openfl, _Closefl
		};
		bool is_open()const
		{
			return (_Myfile!=0);
		}
		_Myt*open(const char*_Filename, ios_base::openmode _Mode, int _Prot=(int)ios_base::_Openprot)
		{
			_iobuf*_File;
			if(_Myfile!=0||(_File=_Fiopen(_Filename, _Mode, _Prot))==0)return (0);
			_Init(_File, _Openfl);
			_Initcvt((_Cvt*)&use_facet<_Cvt>(_Mysb::getloc()));
			return (this);
		}
		_Myt*open(const char*_Filename, ios_base::open_mode _Mode)
		{
			return (open(_Filename, (ios_base::openmode)_Mode));
		}
		_Myt*open(const wchar_t*_Filename, ios_base::openmode _Mode, int _Prot=(int)ios_base::_Openprot)
		{
			_iobuf*_File;
			if(_Myfile!=0||(_File=_Fiopen(_Filename, _Mode, _Prot))==0)return (0);
			_Init(_File, _Openfl);
			_Initcvt((_Cvt*)&use_facet<_Cvt>(_Mysb::getloc()));
			return (this);
		}
		_Myt*open(const wchar_t*_Filename, ios_base::open_mode _Mode)
		{
			return (open(_Filename, (ios_base::openmode)_Mode));
		}
		_Myt*open(const unsigned short*_Filename, ios_base::openmode _Mode, int _Prot=(int)ios_base::_Openprot)
		{
			_iobuf*_File;
			if(_Myfile!=0||(_File=_Fiopen(_Filename, _Mode, _Prot))==0)return (0);
			_Init(_File, _Openfl);
			_Initcvt((_Cvt*)&use_facet<_Cvt>(_Mysb::getloc()));
			return (this);
		}
		_Myt*open(const unsigned short*_Filename, ios_base::open_mode _Mode)
		{
			return (open(_Filename, (ios_base::openmode)_Mode));
		}
		_Myt*close()
		{
			_Myt*_Ans=this;
			if(_Myfile==0)_Ans=0;
			else
			{
				if(!_Endwrite())_Ans=0;
				if(fclose(_Myfile)!=0)_Ans=0;
			}
			_Init(0, _Closefl);
			return (_Ans);
		}
		protected: virtual int_type overflow(int_type _Meta=_Traits::eof())
		{
			if(_Traits::eq_int_type(_Traits::eof(), _Meta))return (_Traits::not_eof(_Meta));
			else if(_Mysb::pptr()!=0&&_Mysb::pptr()<_Mysb::epptr())
			{
				*_Mysb::_Pninc()=_Traits::to_char_type(_Meta);
				return (_Meta);
			}
			else if(_Myfile==0)return (_Traits::eof());
			else if(_Pcvt==0)return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)?_Meta: _Traits::eof());
			else
			{
				const int _STRING_INC=8;
				const _Elem _Ch=_Traits::to_char_type(_Meta);
				const _Elem*_Src;
				char*_Dest;
				string _Str(_STRING_INC, '\0');
				for(;
				;
				)switch(_Pcvt->out(_State, &_Ch, &_Ch+1, _Src, &*_Str.begin(), &*_Str.begin()+_Str.size(), _Dest))
				{
					case codecvt_base::partial: case codecvt_base::ok:
					{
						size_t _Count=_Dest-&*_Str.begin();
						if(0<_Count&&_Count!=fwrite(&*_Str.begin(), 1, _Count, _Myfile))return (_Traits::eof());
						_Wrotesome=true;
						if(_Src!=&_Ch)return (_Meta);
						if(0<_Count);
						else if(_Str.size()<4*_STRING_INC)_Str.append(_STRING_INC, '\0');
						else return (_Traits::eof());
						break;
					}
					case codecvt_base::noconv: return (_Fputc(_Ch, _Myfile)?_Meta: _Traits::eof());
					default: return (_Traits::eof());
				}
			}
		}
		virtual int_type pbackfail(int_type _Meta=_Traits::eof())
		{
			if(_Mysb::gptr()!=0&&_Mysb::eback()<_Mysb::gptr()&&(_Traits::eq_int_type(_Traits::eof(), _Meta)||_Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]), _Meta)))
			{
				_Mysb::_Gndec();
				return (_Traits::not_eof(_Meta));
			}
			else if(_Myfile==0||_Traits::eq_int_type(_Traits::eof(), _Meta))return (_Traits::eof());
			else if(_Pcvt==0&&_Ungetc(_Traits::to_char_type(_Meta), _Myfile))return (_Meta);
			else if(1<sizeof(_Elem)&&_Mysb::gptr()!=&_Mychar)
			{
				_Mychar=_Traits::to_char_type(_Meta);
				_Mysb::setg(&_Mychar, &_Mychar, &_Mychar+1);
				return (_Meta);
			}
			else return (_Traits::eof());
		}
		virtual int_type underflow()
		{
			int_type _Meta;
			if(_Mysb::gptr()!=0&&_Mysb::gptr()<_Mysb::egptr())return (_Traits::to_int_type(*_Mysb::gptr()));
			else if(_Traits::eq_int_type(_Traits::eof(), _Meta=uflow()))return (_Meta);
			else
			{
				pbackfail(_Meta);
				return (_Meta);
			}
		}
		virtual int_type uflow()
		{
			if(_Mysb::gptr()!=0&&_Mysb::gptr()<_Mysb::egptr())return (_Traits::to_int_type(*_Mysb::_Gninc()));
			else if(_Myfile==0)return (_Traits::eof());
			else if(_Pcvt==0)
			{
				_Elem _Ch;
				return (_Fgetc(_Ch, _Myfile)?_Traits::to_int_type(_Ch): _Traits::eof());
			}
			else
			{
				string _Str;
				for(;
				;
				)
				{
					_Elem _Ch, *_Dest;
					const char*_Src;
					ptrdiff_t _Nleft;
					int _Meta=fgetc(_Myfile);
					if(_Meta==(-1))return (_Traits::eof());
					_Str.append(1, (char)_Meta);
					switch(_Pcvt->in(_State, &*_Str.begin(), &*_Str.begin()+_Str.size(), _Src, &_Ch, &_Ch+1, _Dest))
					{
						case codecvt_base::partial: case codecvt_base::ok: if(_Dest!=&_Ch)
						{
							for(_Nleft=&*_Str.begin()+_Str.size()-_Src;
							0<_Nleft;
							)ungetc(_Src[--_Nleft], _Myfile);
							return (_Traits::to_int_type(_Ch));
						}
						else _Str.erase((size_t)0, (size_t)(_Src-&*_Str.begin()));
						break;
						case codecvt_base::noconv: if(_Str.size()<sizeof(_Elem))break;
						::memcpy_s((&_Ch), (sizeof(_Elem)), (&*_Str.begin()), (sizeof(_Elem)));
						return (_Traits::to_int_type(_Ch));
						default: return (_Traits::eof());
					}
				}
			}
		}
		virtual pos_type seekoff(off_type _Off, ios_base::seekdir _Way, ios_base::openmode=(ios_base::openmode)(ios_base::in|ios_base::out))
		{
			fpos_t _Fileposition;
			if(_Mysb::gptr()==&_Mychar&&_Way==ios_base::cur&&_Pcvt==0)_Off-=(off_type)sizeof(_Elem);
			if(_Myfile==0||!_Endwrite()||(_Off!=0||_Way!=ios_base::cur)&&fseek(_Myfile, (long)_Off, _Way)!=0||fgetpos(_Myfile, &_Fileposition)!=0)return (pos_type(_BADOFF));
			if(_Mysb::gptr()==&_Mychar)_Mysb::setg(&_Mychar, &_Mychar+1, &_Mychar+1);
			return (pos_type(_State, _Fileposition));
		}
		virtual pos_type seekpos(pos_type _Pos, ios_base::openmode=(ios_base::openmode)(ios_base::in|ios_base::out))
		{
			fpos_t _Fileposition=_Pos.seekpos();
			off_type _Off=(off_type)_Pos-((long)(_Fileposition));
			if(_Myfile==0||!_Endwrite()||fsetpos(_Myfile, &_Fileposition)!=0||_Off!=0&&fseek(_Myfile, (long)_Off, 1)!=0||fgetpos(_Myfile, &_Fileposition)!=0)return (pos_type(_BADOFF));
			_State=_Pos.state();
			if(_Mysb::gptr()==&_Mychar)_Mysb::setg(&_Mychar, &_Mychar+1, &_Mychar+1);
			return (pos_type(_State, _Fileposition));
		}
		virtual _Mysb*setbuf(_Elem*_Buffer, streamsize _Count)
		{
			if(_Myfile==0||setvbuf(_Myfile, (char*)_Buffer, _Buffer==0&&_Count==0?0x0004: 0x0000, _Count*sizeof(_Elem))!=0)return (0);
			else
			{
				_Init(_Myfile, _Openfl);
				return (this);
			}
		}
		virtual int sync()
		{
			return (_Myfile==0||_Traits::eq_int_type(_Traits::eof(), overflow())||0<=fflush(_Myfile)?0: -1);
		}
		virtual void imbue(const locale&_Loc)
		{
			_Initcvt((_Cvt*)&use_facet<_Cvt>(_Loc));
		}
		void _Init(_iobuf*_File, _Initfl _Which)
		{
			static _Myst _Stinit;
			_Closef=_Which==_Openfl;
			_Wrotesome=false;
			_Mysb::_Init();
			if(_File!=0&&sizeof(_Elem)==1)
			{
				_Elem**_Pb=(_Elem**)&_File->_base;
				_Elem**_Pn=(_Elem**)&_File->_ptr;
				int*_Nr=(int*)&_File->_cnt;
				int*_Nw=(int*)&_File->_cnt;
				_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
			}
			_Myfile=_File;
			_State=_Stinit;
			_Pcvt=0;
		}
		bool _Endwrite()
		{
			if(_Pcvt==0||!_Wrotesome)return (true);
			else
			{
				const int _STRING_INC=8;
				char*_Dest;
				if(_Traits::eq_int_type(_Traits::eof(), overflow()))return (false);
				string _Str(_STRING_INC, '\0');
				for(;
				;
				)switch(_Pcvt->unshift(_State, &*_Str.begin(), &*_Str.begin()+_Str.size(), _Dest))
				{
					case codecvt_base::ok: _Wrotesome=false;
					case codecvt_base::partial:
					{
						size_t _Count=_Dest-&*_Str.begin();
						if(0<_Count&&_Count!=fwrite(&*_Str.begin(), 1, _Count, _Myfile))return (false);
						if(!_Wrotesome)return (true);
						if(_Count==0)_Str.append(_STRING_INC, '\0');
						break;
					}
					case codecvt_base::noconv: return (true);
					default: return (false);
				}
			}
		}
		void _Initcvt(_Cvt*_Newpcvt)
		{
			if(_Newpcvt->always_noconv())_Pcvt=0;
			else
			{
				_Pcvt=_Newpcvt;
				_Mysb::_Init();
			}
		}
	private:
		_Cvt*_Pcvt;
		_Elem _Mychar;
		bool _Wrotesome;
		typename _Traits::state_type _State;
		bool _Closef;
		_iobuf*_Myfile;
	};
	template<class _Elem, class _Traits>
	class basic_ifstream: public basic_istream<_Elem, _Traits>
	{
	public:
		typedef basic_ifstream<_Elem, _Traits>_Myt;
		typedef basic_filebuf<_Elem, _Traits>_Myfb;
		typedef basic_ios<_Elem, _Traits>_Myios;
		basic_ifstream(): basic_istream<_Elem, _Traits>(&_Filebuffer)
		{
		}
		explicit basic_ifstream(const char*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot): basic_istream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ifstream(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot): basic_istream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ifstream(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot): basic_istream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ifstream(_iobuf*_File): basic_istream<_Elem, _Traits>(&_Filebuffer), _Filebuffer(_File)
		{
		}
		void open(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const wchar_t*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void open(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const unsigned short*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		virtual~basic_ifstream()
		{
		}
		_Myfb*rdbuf()const
		{
			return ((_Myfb*)&_Filebuffer);
		}
		bool is_open()const
		{
			return (_Filebuffer.is_open());
		}
		void open(const char*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const char*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void close()
		{
			if(_Filebuffer.close()==0)_Myios::setstate(ios_base::failbit);
		}
	private:
		_Myfb _Filebuffer;
	};
	template<class _Elem, class _Traits>
	class basic_ofstream: public basic_ostream<_Elem, _Traits>
	{
	public:
		typedef basic_ofstream<_Elem, _Traits>_Myt;
		typedef basic_filebuf<_Elem, _Traits>_Myfb;
		typedef basic_ios<_Elem, _Traits>_Myios;
		basic_ofstream(): basic_ostream<_Elem, _Traits>(&_Filebuffer)
		{
		}
		explicit basic_ofstream(const char*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_ostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ofstream(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_ostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ofstream(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_ostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ofstream(_iobuf*_File): basic_ostream<_Elem, _Traits>(&_Filebuffer), _Filebuffer(_File)
		{
		}
		virtual~basic_ofstream()
		{
		}
		_Myfb*rdbuf()const
		{
			return ((_Myfb*)&_Filebuffer);
		}
		bool is_open()const
		{
			return (_Filebuffer.is_open());
		}
		void open(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const wchar_t*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void open(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const unsigned short*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void open(const char*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const char*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void close()
		{
			if(_Filebuffer.close()==0)_Myios::setstate(ios_base::failbit);
		}
	private:
		_Myfb _Filebuffer;
	};
	template<class _Elem, class _Traits>
	class basic_fstream: public basic_iostream<_Elem, _Traits>
	{
	public:
		typedef basic_fstream<_Elem, _Traits>_Myt;
		typedef basic_ios<_Elem, _Traits>_Myios;
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		basic_fstream(): basic_iostream<_Elem, _Traits>(&_Filebuffer)
		{
		}
		explicit basic_fstream(const char*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_iostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_fstream(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_iostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_fstream(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_iostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_fstream(_iobuf*_File): basic_iostream<_Elem, _Traits>(&_Filebuffer), _Filebuffer(_File)
		{
		}
		void open(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const wchar_t*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void open(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const unsigned short*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		virtual~basic_fstream()
		{
		}
		basic_filebuf<_Elem, _Traits>*rdbuf()const
		{
			return ((basic_filebuf<_Elem, _Traits>*)&_Filebuffer);
		}
		bool is_open()const
		{
			return (_Filebuffer.is_open());
		}
		void open(const char*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const char*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void close()
		{
			if(_Filebuffer.close()==0)_Myios::setstate(ios_base::failbit);
		}
	private:
		basic_filebuf<_Elem, _Traits>_Filebuffer;
	};
}
typedef boost::wave::token_id LexTokenId;
inline bool isSeparated(LexTokenId id)
{
	return ((((id)&boost::wave::TokenTypeMask)==(boost::wave::KeywordTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(boost::wave::IdentifierTokenType))?true: false)||(((id)&boost::wave::TokenTypeMask)&boost::wave::LiteralTokenType)!=0||id==boost::wave::T_PP_NUMBER;
}
template<typename OutputStreamType>
struct TokenPrinter
{
	OutputStreamType&out;
	size_t line;
	size_t braceDepth;
	LexTokenId prev;
	LexTokenId prevprev;
	size_t templateDeclarationDepth;
	TokenPrinter(OutputStreamType&out): out(out), line(1), braceDepth(0), prev(boost::wave::T_UNKNOWN), prevprev(boost::wave::T_UNKNOWN), templateDeclarationDepth(0)
	{
	}
	void nextLine(LexTokenId id)
	{
		out<<std::endl;
		prev=boost::wave::T_NEWLINE;
		templateDeclarationDepth=id==boost::wave::T_TEMPLATE;
		++line;
	}
	void formatToken(LexTokenId id)
	{
		if((prev==boost::wave::T_SEMICOLON&&id!=boost::wave::T_RIGHTBRACE)||(prev==boost::wave::T_LEFTBRACE&&id!=boost::wave::T_RIGHTBRACE)||(prev==boost::wave::T_RIGHTBRACE&&id!=boost::wave::T_RIGHTBRACE&&id!=boost::wave::T_SEMICOLON)||(id==boost::wave::T_MSEXT_ASM))
		{
			nextLine(id);
		}
		if((prevprev==boost::wave::T_PUBLIC||prevprev==boost::wave::T_PRIVATE)&&prev==boost::wave::T_COLON)
		{
			nextLine(id);
		}
		if(templateDeclarationDepth!=0)
		{
			if(prev==boost::wave::T_LESS)
			{
				++templateDeclarationDepth;
			}
			else if(prev==boost::wave::T_GREATER)
			{
				--templateDeclarationDepth;
				if(templateDeclarationDepth==1)
				{
					nextLine(id);
				}
			}
		}
		if(id==boost::wave::T_LEFTBRACE)
		{
			nextLine(id);
			++braceDepth;
		}
		else if(id==boost::wave::T_RIGHTBRACE)
		{
			--braceDepth;
			nextLine(id);
		}
		if(prev==boost::wave::T_NEWLINE&&braceDepth!=0)
		{
			size_t i=0;
			if(id==boost::wave::T_LEFTBRACE||id==boost::wave::T_PUBLIC||id==boost::wave::T_PRIVATE)
			{
				++i;
			}
			for(;
			i!=braceDepth;
			++i)
			{
				out<<'\t';
			}
		}
		if((isSeparated(prev)&&isSeparated(id))||prev==boost::wave::T_COMMA||prev==boost::wave::T_COLON||prev==boost::wave::T_RETURN||prev==boost::wave::T_TYPEDEF||(prev==boost::wave::T_GREATER&&id==boost::wave::T_GREATER)||(prev==boost::wave::T_AND&&id==boost::wave::T_ASSIGN)||(prev==boost::wave::T_STAR&&id==boost::wave::T_ASSIGN)||(prev==boost::wave::T_LESS&&id==boost::wave::T_COLON_COLON))
		{
			out<<" ";
		}
		prevprev=prev;
		prev=id;
	}
	void printToken(LexTokenId id, const char*value)
	{
		formatToken(id);
		out<<value;
	}
};
typedef boost::wave::token_id LexTokenId;
struct LexContext;
struct LexIterator;
struct LexToken;
struct LexError
{
	LexError()
	{
	}
};
LexContext&createContext(std::ifstream&instring, const char*input);
bool add_include_path(LexContext&context, const char*path);
bool add_sysinclude_path(LexContext&context, const char*path);
bool add_macro_definition(LexContext&context, const char*macroname, bool is_predefined);
void release(LexContext&context);
LexIterator&createBegin(LexContext&lexer);
LexIterator&createEnd(LexContext&lexer);
LexIterator&cloneIterator(LexIterator&i);
void assignIterator(LexIterator&i, LexIterator&other);
void release(LexIterator&i);
bool operator==(const LexIterator&l, const LexIterator&r);
inline bool operator!=(const LexIterator&l, const LexIterator&r)
{
	return !(l==r);
}
void increment(LexIterator&i);
const LexToken&dereference(const LexIterator&i);
namespace std
{
	template<class _Traits>
	class _Tree_nod: public _Traits
	{
		protected: struct _Node;
		friend struct _Node;
		typedef typename _Traits::allocator_type allocator_type;
		typedef typename _Traits::key_compare key_compare;
		typedef typename _Traits::value_type value_type;
		typedef typename allocator_type::template rebind<_Node>::other::pointer _Genptr;
		struct _Node
		{
			_Node(_Genptr _Larg, _Genptr _Parg, _Genptr _Rarg, const value_type&_Val, char _Carg): _Left(_Larg), _Parent(_Parg), _Right(_Rarg), _Myval(_Val), _Color(_Carg), _Isnil(false)
			{
			}
			_Genptr _Left;
			_Genptr _Parent;
			_Genptr _Right;
			value_type _Myval;
			char _Color;
			char _Isnil;
		};
		_Tree_nod(const key_compare&_Parg, allocator_type _Al): _Traits(_Parg), _Alnod(_Al)
		{
		}
		typename allocator_type::template rebind<_Node>::other _Alnod;
	};
	template<class _Traits>
	class _Tree_ptr: public _Tree_nod<_Traits>
	{
	public:
		typedef typename _Tree_nod<_Traits>::_Node _Node;
		typedef typename _Traits::allocator_type allocator_type;
		typedef typename _Traits::key_compare key_compare;
		typedef typename allocator_type::template rebind<_Node>::other::pointer _Nodeptr;
		_Tree_ptr(const key_compare&_Parg, allocator_type _Al): _Tree_nod<_Traits>(_Parg, _Al), _Alptr(_Al)
		{
		}
		typename allocator_type::template rebind<_Nodeptr>::other _Alptr;
	};
	template<class _Traits>
	class _Tree_val: public _Tree_ptr<_Traits>
	{
		protected: typedef typename _Traits::allocator_type allocator_type;
		typedef typename _Traits::key_compare key_compare;
		_Tree_val(const key_compare&_Parg, allocator_type _Al): _Tree_ptr<_Traits>(_Parg, _Al), _Alval(_Al)
		{
		}
		allocator_type _Alval;
	};
	template<class _Traits>
	class _Tree: public _Tree_val<_Traits>
	{
	public:
		typedef _Tree<_Traits>_Myt;
		typedef _Tree_val<_Traits>_Mybase;
		typedef typename _Traits::key_type key_type;
		typedef typename _Traits::key_compare key_compare;
		typedef typename _Traits::value_compare value_compare;
		typedef typename _Traits::value_type value_type;
		typedef typename _Traits::allocator_type allocator_type;
		typedef typename _Traits::_ITptr _ITptr;
		typedef typename _Traits::_IReft _IReft;
		protected: typedef typename _Tree_nod<_Traits>::_Genptr _Genptr;
		typedef typename _Tree_nod<_Traits>::_Node _Node;
		enum _Redbl
		{
			_Red, _Black
		};
		typedef typename allocator_type::template rebind<_Node>::other::pointer _Nodeptr;
		typedef typename allocator_type::template rebind<_Nodeptr>::other::reference _Nodepref;
		typedef typename allocator_type::template rebind<key_type>::other::const_reference _Keyref;
		typedef typename allocator_type::template rebind<char>::other::reference _Charref;
		typedef typename allocator_type::template rebind<value_type>::other::reference _Vref;
		static _Charref _Color(_Nodeptr _Pnode)
		{
			return ((_Charref)(*_Pnode)._Color);
		}
		static _Charref _Isnil(_Nodeptr _Pnode)
		{
			return ((_Charref)(*_Pnode)._Isnil);
		}
		static _Keyref _Key(_Nodeptr _Pnode)
		{
			return (_Mybase::_Kfn(_Myval(_Pnode)));
		}
		static _Nodepref _Left(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Left);
		}
		static _Nodepref _Parent(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Parent);
		}
		static _Nodepref _Right(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Right);
		}
		static _Vref _Myval(_Nodeptr _Pnode)
		{
			return ((_Vref)(*_Pnode)._Myval);
		}
	public:
		typedef typename allocator_type::size_type size_type;
		typedef typename allocator_type::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename allocator_type::template rebind<value_type>::other::pointer _Tptr;
		typedef typename allocator_type::template rebind<value_type>::other::const_pointer _Ctptr;
		typedef typename allocator_type::template rebind<value_type>::other::reference _Reft;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef _Reft reference;
		typedef typename allocator_type::template rebind<value_type>::other::const_reference const_reference;
		class const_iterator;
		friend class const_iterator;
		class const_iterator: public _Bidit<value_type, _Dift, _Ctptr, const_reference>
		{
		public:
			friend class _Tree<_Traits>;
			typedef bidirectional_iterator_tag iterator_category;
			typedef _Dift difference_type;
			typedef _Ctptr pointer;
			typedef const_reference reference;
			typedef _Range_checked_iterator_tag _Checked_iterator_category;
			const_iterator(): _Ptr(0)
			{
			}
			const_iterator(_Nodeptr _Pnode, const _Myt*_Plist=0): _Ptr(_Pnode)
			{
				this->_Adopt(_Plist);
			}
			const_reference operator*()const
			{
				if(this->_Mycont==0||_Ptr==((_Myt*)this->_Mycont)->_Myhead)
				{
					_Debug_message(L"map/set iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 245);

					{
						(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 246, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 246, 0);
					};
				}
				return (_Myval(_Ptr));
			}
			_Ctptr operator->()const
			{
				return (&**this);
			}
			const_iterator&operator++()
			{
				_Inc();
				return (*this);
			}
			const_iterator operator++(int)
			{
				const_iterator _Tmp=*this;
				++*this;
				return (_Tmp);
			}
			const_iterator&operator--()
			{
				_Dec();
				return (*this);
			}
			const_iterator operator--(int)
			{
				const_iterator _Tmp=*this;
				--*this;
				return (_Tmp);
			}
			bool operator==(const const_iterator&_Right)const
			{
				if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
				{
					_Debug_message(L"map/set iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 293);

					{
						(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 294, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 294, 0);
					};
				}
				return (_Ptr==_Right._Ptr);
			}
			bool operator!=(const const_iterator&_Right)const
			{
				return (!(*this==_Right));
			}
			void _Dec()
			{
				if(this->_Mycont==0)
				{
					_Debug_message(L"map/set iterator not decrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 314);

					{
						(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 315, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 315, 0);
					};
				}
				if(_Isnil(_Ptr))
				{
					_Ptr=_Right(_Ptr);
					if(_Isnil(_Ptr))
					{
						_Debug_message(L"map/set iterator not decrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 327);

						{
							(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 328, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 328, 0);
						};
					}
				}
				else if(!_Isnil(_Left(_Ptr)))_Ptr=_Max(_Left(_Ptr));
				else
				{
					_Nodeptr _Pnode;
					while(!_Isnil(_Pnode=_Parent(_Ptr))&&_Ptr==_Left(_Pnode))_Ptr=_Pnode;
					if(_Isnil(_Ptr))
					{
						_Debug_message(L"map/set iterator not decrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 349);

						{
							(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 350, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 350, 0);
						};
					}
					else _Ptr=_Pnode;
				}
			}
			void _Inc()
			{
				if(this->_Mycont==0||_Isnil(_Ptr))
				{
					_Debug_message(L"map/set iterator not incrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 370);

					{
						(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 371, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 371, 0);
					};
				}
				else if(!_Isnil(_Right(_Ptr)))_Ptr=_Min(_Right(_Ptr));
				else
				{
					_Nodeptr _Pnode;
					while(!_Isnil(_Pnode=_Parent(_Ptr))&&_Ptr==_Right(_Pnode))_Ptr=_Pnode;
					_Ptr=_Pnode;
				}
			}
			_Nodeptr _Mynode()const
			{
				return (_Ptr);
			}
		public:
			_Nodeptr _Ptr;
		};
		class iterator;
		friend class iterator;
		class iterator: public const_iterator
		{
		public:
			typedef bidirectional_iterator_tag iterator_category;
			typedef _Dift difference_type;
			typedef _ITptr pointer;
			typedef _IReft reference;
			iterator()
			{
			}
			iterator(_Nodeptr _Pnode, const _Myt*_Plist=0): const_iterator(_Pnode, _Plist)
			{
			}
			reference operator*()const
			{
				return ((reference)**(const_iterator*)this);
			}
			pointer operator->()const
			{
				return (&**this);
			}
			iterator&operator++()
			{
				++(*(const_iterator*)this);
				return (*this);
			}
			iterator operator++(int)
			{
				iterator _Tmp=*this;
				++*this;
				return (_Tmp);
			}
			iterator&operator--()
			{
				--(*(const_iterator*)this);
				return (*this);
			}
			iterator operator--(int)
			{
				iterator _Tmp=*this;
				--*this;
				return (_Tmp);
			}
		};
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		typedef pair<iterator, bool>_Pairib;
		typedef pair<iterator, iterator>_Pairii;
		typedef pair<const_iterator, const_iterator>_Paircc;
		explicit _Tree(const key_compare&_Parg, const allocator_type&_Al): _Mybase(_Parg, _Al)
		{
			_Init();
		}
		_Tree(const value_type*_First, const value_type*_Last, const key_compare&_Parg, const allocator_type&_Al): _Mybase(_Parg, _Al)
		{
			_Init();
			try
			{
				insert(_First, _Last);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		_Tree(const _Myt&_Right): _Mybase(_Right.key_comp(), _Right.get_allocator())
		{
			_Init();
			try
			{
				_Copy(_Right);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		~_Tree()
		{
			_Tidy();
		}
		_Myt&operator=(const _Myt&_Right)
		{
			if(this!=&_Right)
			{
				erase(begin(), end());
				this->comp=_Right.comp;
				_Copy(_Right);
			}
			return (*this);
		}
		iterator begin()
		{
			return (iterator(_Lmost(), this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Lmost(), this));
		}
		iterator end()
		{
			return (iterator(_Myhead, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Myhead, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			return (this->_Alval.max_size());
		}
		bool empty()const
		{
			return (size()==0);
		}
		allocator_type get_allocator()const
		{
			return (this->_Alval);
		}
		key_compare key_comp()const
		{
			return (this->comp);
		}
		value_compare value_comp()const
		{
			return (value_compare(key_comp()));
		}
		_Pairib insert(const value_type&_Val)
		{
			_Nodeptr _Trynode=_Root();
			_Nodeptr _Wherenode=_Myhead;
			bool _Addleft=true;
			while(!_Isnil(_Trynode))
			{
				_Wherenode=_Trynode;
				_Addleft=_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Trynode), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 618);
				_Trynode=_Addleft?_Left(_Trynode): _Right(_Trynode);
			}
			if(this->_Multi)return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
			else
			{
				iterator _Where=iterator(_Wherenode, this);
				if(!_Addleft);
				else if(_Where==begin())return (_Pairib(_Insert(true, _Wherenode, _Val), true));
				else--_Where;
				if(_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 635))return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
				else return (_Pairib(_Where, false));
			}
		}
		iterator insert(iterator _Where, const value_type&_Val)
		{
			if(_Where._Mycont!=this)_Debug_message(L"map/set insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 649);
			iterator _Next;
			if(size()==0)return (_Insert(true, _Myhead, _Val));
			else if(this->_Multi)
			{
				if(_Where==begin())
				{
					if(!_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 660))return (_Insert(true, _Where._Mynode(), _Val));
				}
				else if(_Where==end())
				{
					if(!_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Rmost()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 666))return (_Insert(false, _Rmost(), _Val));
				}
				else if(!_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 670)&&!_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key((--(_Next=_Where))._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 672))
				{
					if(_Isnil(_Right(_Next._Mynode())))return (_Insert(false, _Next._Mynode(), _Val));
					else return (_Insert(true, _Where._Mynode(), _Val));
				}
				else if(!_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 680)&&(++(_Next=_Where)==end()||!_Debug_lt_pred(this->comp, _Key(_Next._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 683)))
				{
					if(_Isnil(_Right(_Where._Mynode())))return (_Insert(false, _Where._Mynode(), _Val));
					else return (_Insert(true, _Next._Mynode(), _Val));
				}
			}
			else
			{
				if(_Where==begin())
				{
					if(_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 696))return (_Insert(true, _Where._Mynode(), _Val));
				}
				else if(_Where==end())
				{
					if(_Debug_lt_pred(this->comp, _Key(_Rmost()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 702))return (_Insert(false, _Rmost(), _Val));
				}
				else if(_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 706)&&_Debug_lt_pred(this->comp, _Key((--(_Next=_Where))._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 708))
				{
					if(_Isnil(_Right(_Next._Mynode())))return (_Insert(false, _Next._Mynode(), _Val));
					else return (_Insert(true, _Where._Mynode(), _Val));
				}
				else if(_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 716)&&(++(_Next=_Where)==end()||_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Next._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 719)))
				{
					if(_Isnil(_Right(_Where._Mynode())))return (_Insert(false, _Where._Mynode(), _Val));
					else return (_Insert(true, _Next._Mynode(), _Val));
				}
			}
			return (insert(_Val).first);
		}
		template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 737);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"map/set insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 739);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
		iterator erase(iterator _Where)
		{
			if(_Where._Mycont!=this||_Isnil(_Where._Mynode()))_Debug_message(L"map/set erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 751);
			_Nodeptr _Erasednode=_Where._Mynode();
			++_Where;
			_Orphan_ptr(*this, _Erasednode);
			_Nodeptr _Fixnode;
			_Nodeptr _Fixnodeparent;
			_Nodeptr _Pnode=_Erasednode;
			if(_Isnil(_Left(_Pnode)))_Fixnode=_Right(_Pnode);
			else if(_Isnil(_Right(_Pnode)))_Fixnode=_Left(_Pnode);
			else
			{
				_Pnode=_Where._Mynode();
				_Fixnode=_Right(_Pnode);
			}
			if(_Pnode==_Erasednode)
			{
				_Fixnodeparent=_Parent(_Erasednode);
				if(!_Isnil(_Fixnode))_Parent(_Fixnode)=_Fixnodeparent;
				if(_Root()==_Erasednode)_Root()=_Fixnode;
				else if(_Left(_Fixnodeparent)==_Erasednode)_Left(_Fixnodeparent)=_Fixnode;
				else _Right(_Fixnodeparent)=_Fixnode;
				if(_Lmost()==_Erasednode)_Lmost()=_Isnil(_Fixnode)?_Fixnodeparent: _Min(_Fixnode);
				if(_Rmost()==_Erasednode)_Rmost()=_Isnil(_Fixnode)?_Fixnodeparent: _Max(_Fixnode);
			}
			else
			{
				_Parent(_Left(_Erasednode))=_Pnode;
				_Left(_Pnode)=_Left(_Erasednode);
				if(_Pnode==_Right(_Erasednode))_Fixnodeparent=_Pnode;
				else
				{
					_Fixnodeparent=_Parent(_Pnode);
					if(!_Isnil(_Fixnode))_Parent(_Fixnode)=_Fixnodeparent;
					_Left(_Fixnodeparent)=_Fixnode;
					_Right(_Pnode)=_Right(_Erasednode);
					_Parent(_Right(_Erasednode))=_Pnode;
				}
				if(_Root()==_Erasednode)_Root()=_Pnode;
				else if(_Left(_Parent(_Erasednode))==_Erasednode)_Left(_Parent(_Erasednode))=_Pnode;
				else _Right(_Parent(_Erasednode))=_Pnode;
				_Parent(_Pnode)=_Parent(_Erasednode);
				std::swap(_Color(_Pnode), _Color(_Erasednode));
			}
			if(_Color(_Erasednode)==_Black)
			{
				for(;
				_Fixnode!=_Root()&&_Color(_Fixnode)==_Black;
				_Fixnodeparent=_Parent(_Fixnode))if(_Fixnode==_Left(_Fixnodeparent))
				{
					_Pnode=_Right(_Fixnodeparent);
					if(_Color(_Pnode)==_Red)
					{
						_Color(_Pnode)=_Black;
						_Color(_Fixnodeparent)=_Red;
						_Lrotate(_Fixnodeparent);
						_Pnode=_Right(_Fixnodeparent);
					}
					if(_Isnil(_Pnode))_Fixnode=_Fixnodeparent;
					else if(_Color(_Left(_Pnode))==_Black&&_Color(_Right(_Pnode))==_Black)
					{
						_Color(_Pnode)=_Red;
						_Fixnode=_Fixnodeparent;
					}
					else
					{
						if(_Color(_Right(_Pnode))==_Black)
						{
							_Color(_Left(_Pnode))=_Black;
							_Color(_Pnode)=_Red;
							_Rrotate(_Pnode);
							_Pnode=_Right(_Fixnodeparent);
						}
						_Color(_Pnode)=_Color(_Fixnodeparent);
						_Color(_Fixnodeparent)=_Black;
						_Color(_Right(_Pnode))=_Black;
						_Lrotate(_Fixnodeparent);
						break;
					}
				}
				else
				{
					_Pnode=_Left(_Fixnodeparent);
					if(_Color(_Pnode)==_Red)
					{
						_Color(_Pnode)=_Black;
						_Color(_Fixnodeparent)=_Red;
						_Rrotate(_Fixnodeparent);
						_Pnode=_Left(_Fixnodeparent);
					}
					if(_Isnil(_Pnode))_Fixnode=_Fixnodeparent;
					else if(_Color(_Right(_Pnode))==_Black&&_Color(_Left(_Pnode))==_Black)
					{
						_Color(_Pnode)=_Red;
						_Fixnode=_Fixnodeparent;
					}
					else
					{
						if(_Color(_Left(_Pnode))==_Black)
						{
							_Color(_Right(_Pnode))=_Black;
							_Color(_Pnode)=_Red;
							_Lrotate(_Pnode);
							_Pnode=_Left(_Fixnodeparent);
						}
						_Color(_Pnode)=_Color(_Fixnodeparent);
						_Color(_Fixnodeparent)=_Black;
						_Color(_Left(_Pnode))=_Black;
						_Rrotate(_Fixnodeparent);
						break;
					}
				}
				_Color(_Fixnode)=_Black;
			}
			this->_Alnod.destroy(_Erasednode);
			this->_Alnod.deallocate(_Erasednode, 1);
			if(0<_Mysize)--_Mysize;
			return (_Where);
		}
		iterator erase(iterator _First, iterator _Last)
		{
			if(_First==begin()&&_Last==end())
			{
				clear();
				return (begin());
			}
			else
			{
				while(_First!=_Last)erase(_First++);
				return (_First);
			}
		}
		size_type erase(const key_type&_Keyval)
		{
			_Pairii _Where=equal_range(_Keyval);
			size_type _Num=0;
			_Distance(_Where.first, _Where.second, _Num);
			erase(_Where.first, _Where.second);
			return (_Num);
		}
		void erase(const key_type*_First, const key_type*_Last)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 942);
			while(_First!=_Last)erase(*_First++);
		}
		void clear()
		{
			this->_Orphan_ptr(*this, 0);
			_Erase(_Root());
			_Root()=_Myhead, _Mysize=0;
			_Lmost()=_Myhead, _Rmost()=_Myhead;
		}
		iterator find(const key_type&_Keyval)
		{
			iterator _Where=lower_bound(_Keyval);
			return (_Where==end()||_Debug_lt_pred(this->comp, _Keyval, _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 963)?end(): _Where);
		}
		const_iterator find(const key_type&_Keyval)const
		{
			const_iterator _Where=lower_bound(_Keyval);
			return (_Where==end()||_Debug_lt_pred(this->comp, _Keyval, _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 972)?end(): _Where);
		}
		size_type count(const key_type&_Keyval)const
		{
			_Paircc _Ans=equal_range(_Keyval);
			size_type _Num=0;
			_Distance(_Ans.first, _Ans.second, _Num);
			return (_Num);
		}
		iterator lower_bound(const key_type&_Keyval)
		{
			return (iterator(_Lbound(_Keyval), this));
		}
		const_iterator lower_bound(const key_type&_Keyval)const
		{
			return (const_iterator(_Lbound(_Keyval), this));
		}
		iterator upper_bound(const key_type&_Keyval)
		{
			return (iterator(_Ubound(_Keyval), this));
		}
		const_iterator upper_bound(const key_type&_Keyval)const
		{
			return (const_iterator(_Ubound(_Keyval), this));
		}
		_Pairii equal_range(const key_type&_Keyval)
		{
			return (_Pairii(lower_bound(_Keyval), upper_bound(_Keyval)));
		}
		_Paircc equal_range(const key_type&_Keyval)const
		{
			return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));
		}
		void swap(_Myt&_Right)
		{
			if(get_allocator()==_Right.get_allocator())
			{
				this->_Swap_all(_Right);
				std::swap(this->comp, _Right.comp);
				std::swap(_Myhead, _Right._Myhead);
				std::swap(_Mysize, _Right._Mysize);
			}
			else
			{
				_Myt _Tmp=*this;
				*this=_Right, _Right=_Tmp;
			}
		}
		protected: void _Copy(const _Myt&_Right)
		{
			_Root()=_Copy(_Right._Root(), _Myhead);
			_Mysize=_Right.size();
			if(!_Isnil(_Root()))
			{
				_Lmost()=_Min(_Root());
				_Rmost()=_Max(_Root());
			}
			else _Lmost()=_Myhead, _Rmost()=_Myhead;
		}
		_Nodeptr _Copy(_Nodeptr _Rootnode, _Nodeptr _Wherenode)
		{
			_Nodeptr _Newroot=_Myhead;
			if(!_Isnil(_Rootnode))
			{
				_Nodeptr _Pnode=_Buynode(_Myhead, _Wherenode, _Myhead, _Myval(_Rootnode), _Color(_Rootnode));
				if(_Isnil(_Newroot))_Newroot=_Pnode;
				try
				{
					_Left(_Pnode)=_Copy(_Left(_Rootnode), _Pnode);
					_Right(_Pnode)=_Copy(_Right(_Rootnode), _Pnode);
				}
				catch(...)
				{
					_Erase(_Newroot);
					throw;
				}
			}
			return (_Newroot);
		}
		void _Erase(_Nodeptr _Rootnode)
		{
			for(_Nodeptr _Pnode=_Rootnode;
			!_Isnil(_Pnode);
			_Rootnode=_Pnode)
			{
				_Erase(_Right(_Pnode));
				_Pnode=_Left(_Pnode);
				this->_Alnod.destroy(_Rootnode);
				this->_Alnod.deallocate(_Rootnode, 1);
			}
		}
		void _Init()
		{
			_Myhead=_Buynode();
			_Isnil(_Myhead)=true;
			_Root()=_Myhead;
			_Lmost()=_Myhead, _Rmost()=_Myhead;
			_Mysize=0;
		}
		iterator _Insert(bool _Addleft, _Nodeptr _Wherenode, const value_type&_Val)
		{
			if(max_size()-1<=_Mysize)throw length_error("map/set<T> too long");
			_Nodeptr _Newnode=_Buynode(_Myhead, _Wherenode, _Myhead, _Val, _Red);
			++_Mysize;
			if(_Wherenode==_Myhead)
			{
				_Root()=_Newnode;
				_Lmost()=_Newnode, _Rmost()=_Newnode;
			}
			else if(_Addleft)
			{
				_Left(_Wherenode)=_Newnode;
				if(_Wherenode==_Lmost())_Lmost()=_Newnode;
			}
			else
			{
				_Right(_Wherenode)=_Newnode;
				if(_Wherenode==_Rmost())_Rmost()=_Newnode;
			}
			for(_Nodeptr _Pnode=_Newnode;
			_Color(_Parent(_Pnode))==_Red;
			)if(_Parent(_Pnode)==_Left(_Parent(_Parent(_Pnode))))
			{
				_Wherenode=_Right(_Parent(_Parent(_Pnode)));
				if(_Color(_Wherenode)==_Red)
				{
					_Color(_Parent(_Pnode))=_Black;
					_Color(_Wherenode)=_Black;
					_Color(_Parent(_Parent(_Pnode)))=_Red;
					_Pnode=_Parent(_Parent(_Pnode));
				}
				else
				{
					if(_Pnode==_Right(_Parent(_Pnode)))
					{
						_Pnode=_Parent(_Pnode);
						_Lrotate(_Pnode);
					}
					_Color(_Parent(_Pnode))=_Black;
					_Color(_Parent(_Parent(_Pnode)))=_Red;
					_Rrotate(_Parent(_Parent(_Pnode)));
				}
			}
			else
			{
				_Wherenode=_Left(_Parent(_Parent(_Pnode)));
				if(_Color(_Wherenode)==_Red)
				{
					_Color(_Parent(_Pnode))=_Black;
					_Color(_Wherenode)=_Black;
					_Color(_Parent(_Parent(_Pnode)))=_Red;
					_Pnode=_Parent(_Parent(_Pnode));
				}
				else
				{
					if(_Pnode==_Left(_Parent(_Pnode)))
					{
						_Pnode=_Parent(_Pnode);
						_Rrotate(_Pnode);
					}
					_Color(_Parent(_Pnode))=_Black;
					_Color(_Parent(_Parent(_Pnode)))=_Red;
					_Lrotate(_Parent(_Parent(_Pnode)));
				}
			}
			_Color(_Root())=_Black;
			return (iterator(_Newnode, this));
		}
		_Nodeptr _Lbound(const key_type&_Keyval)const
		{
			_Nodeptr _Pnode=_Root();
			_Nodeptr _Wherenode=_Myhead;
			while(!_Isnil(_Pnode))if(_Debug_lt_pred(this->comp, _Key(_Pnode), _Keyval, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 1174))_Pnode=_Right(_Pnode);
			else
			{
				_Wherenode=_Pnode;
				_Pnode=_Left(_Pnode);
			}
			return (_Wherenode);
		}
		_Nodeptr&_Lmost()const
		{
			return (_Left(_Myhead));
		}
		void _Lrotate(_Nodeptr _Wherenode)
		{
			_Nodeptr _Pnode=_Right(_Wherenode);
			_Right(_Wherenode)=_Left(_Pnode);
			if(!_Isnil(_Left(_Pnode)))_Parent(_Left(_Pnode))=_Wherenode;
			_Parent(_Pnode)=_Parent(_Wherenode);
			if(_Wherenode==_Root())_Root()=_Pnode;
			else if(_Wherenode==_Left(_Parent(_Wherenode)))_Left(_Parent(_Wherenode))=_Pnode;
			else _Right(_Parent(_Wherenode))=_Pnode;
			_Left(_Pnode)=_Wherenode;
			_Parent(_Wherenode)=_Pnode;
		}
		static _Nodeptr _Max(_Nodeptr _Pnode)
		{
			while(!_Isnil(_Right(_Pnode)))_Pnode=_Right(_Pnode);
			return (_Pnode);
		}
		static _Nodeptr _Min(_Nodeptr _Pnode)
		{
			while(!_Isnil(_Left(_Pnode)))_Pnode=_Left(_Pnode);
			return (_Pnode);
		}
		_Nodeptr&_Rmost()const
		{
			return (_Right(_Myhead));
		}
		_Nodeptr&_Root()const
		{
			return (_Parent(_Myhead));
		}
		void _Rrotate(_Nodeptr _Wherenode)
		{
			_Nodeptr _Pnode=_Left(_Wherenode);
			_Left(_Wherenode)=_Right(_Pnode);
			if(!_Isnil(_Right(_Pnode)))_Parent(_Right(_Pnode))=_Wherenode;
			_Parent(_Pnode)=_Parent(_Wherenode);
			if(_Wherenode==_Root())_Root()=_Pnode;
			else if(_Wherenode==_Right(_Parent(_Wherenode)))_Right(_Parent(_Wherenode))=_Pnode;
			else _Left(_Parent(_Wherenode))=_Pnode;
			_Right(_Pnode)=_Wherenode;
			_Parent(_Wherenode)=_Pnode;
		}
		_Nodeptr _Ubound(const key_type&_Keyval)const
		{
			_Nodeptr _Pnode=_Root();
			_Nodeptr _Wherenode=_Myhead;
			while(!_Isnil(_Pnode))if(_Debug_lt_pred(this->comp, _Keyval, _Key(_Pnode), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 1260))
			{
				_Wherenode=_Pnode;
				_Pnode=_Left(_Pnode);
			}
			else _Pnode=_Right(_Pnode);
			return (_Wherenode);
		}
		void _Orphan_ptr(_Myt&_Cont, _Nodeptr _Ptr)const
		{
			_Lockit _Lock(3);
			const_iterator**_Pnext=(const_iterator**)&_Cont._Myfirstiter;
			while(*_Pnext!=0)if((*_Pnext)->_Ptr==_Myhead||_Ptr!=0&&(*_Pnext)->_Ptr!=_Ptr)_Pnext=(const_iterator**)&(*_Pnext)->_Mynextiter;
			else
			{
				(*_Pnext)->_Mycont=0;
				*_Pnext=(const_iterator*)(*_Pnext)->_Mynextiter;
			}
		}
		_Nodeptr _Buynode()
		{
			_Nodeptr _Wherenode=this->_Alnod.allocate(1);
			int _Linkcnt=0;
			try
			{
				this->_Alptr.construct(&_Left(_Wherenode), 0);
				++_Linkcnt;
				this->_Alptr.construct(&_Parent(_Wherenode), 0);
				++_Linkcnt;
				this->_Alptr.construct(&_Right(_Wherenode), 0);
			}
			catch(...)
			{
				if(1<_Linkcnt)this->_Alptr.destroy(&_Parent(_Wherenode));
				if(0<_Linkcnt)this->_Alptr.destroy(&_Left(_Wherenode));
				this->_Alnod.deallocate(_Wherenode, 1);
				throw;
			}
			_Color(_Wherenode)=_Black;
			_Isnil(_Wherenode)=false;
			return (_Wherenode);
		}
		_Nodeptr _Buynode(_Nodeptr _Larg, _Nodeptr _Parg, _Nodeptr _Rarg, const value_type&_Val, char _Carg)
		{
			_Nodeptr _Wherenode=this->_Alnod.allocate(1);
			try
			{
				new(_Wherenode)_Node(_Larg, _Parg, _Rarg, _Val, _Carg);
			}
			catch(...)
			{
				this->_Alnod.deallocate(_Wherenode, 1);
				throw;
			}
			return (_Wherenode);
		}
		void _Tidy()
		{
			erase(begin(), end());
			this->_Alptr.destroy(&_Left(_Myhead));
			this->_Alptr.destroy(&_Parent(_Myhead));
			this->_Alptr.destroy(&_Right(_Myhead));
			this->_Alnod.deallocate(_Myhead, 1);
			_Myhead=0, _Mysize=0;
		}
		static void _Xran()
		{
			throw out_of_range("invalid map/set<T> iterator");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid map/set<T> argument");
		}
		_Nodeptr _Myhead;
		size_type _Mysize;
	};
	template<class _Traits>
	class _Move_operation_category<_Tree<_Traits> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Traits>
	inline bool operator==(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (_Left.size()==_Right.size()&&equal(_Left.begin(), _Left.end(), _Right.begin()));
	}
	template<class _Traits>
	inline bool operator!=(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Traits>
	inline bool operator<(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end()));
	}
	template<class _Traits>
	inline bool operator>(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Traits>
	inline bool operator<=(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Traits>
	inline bool operator>=(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (!(_Left<_Right));
	}
}
namespace std
{
	template<class _Kty, class _Pr, class _Alloc, bool _Mfl>
	class _Tset_traits: public _Container_base
	{
	public:
		typedef _Kty key_type;
		typedef _Kty value_type;
		typedef _Pr key_compare;
		typedef typename _Alloc::template rebind<value_type>::other allocator_type;
		typedef typename allocator_type::template rebind<value_type>::other::pointer _ITptr;
		typedef typename allocator_type::template rebind<value_type>::other::reference _IReft;
		enum
		{
			_Multi=_Mfl
		};
		_Tset_traits(): comp()
		{
		}
		_Tset_traits(_Pr _Parg): comp(_Parg)
		{
		}
		typedef key_compare value_compare;
		static const _Kty&_Kfn(const value_type&_Val)
		{
			return (_Val);
		}
		_Pr comp;
	};
	template<class _Kty, class _Pr=less<_Kty>, class _Alloc=allocator<_Kty> >
	class set: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> >
	{
	public:
		typedef set<_Kty, _Pr, _Alloc>_Myt;
		typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> >_Mybase;
		typedef _Kty key_type;
		typedef _Pr key_compare;
		typedef typename _Mybase::value_compare value_compare;
		typedef typename _Mybase::allocator_type allocator_type;
		typedef typename _Mybase::size_type size_type;
		typedef typename _Mybase::difference_type difference_type;
		typedef typename _Mybase::pointer pointer;
		typedef typename _Mybase::const_pointer const_pointer;
		typedef typename _Mybase::reference reference;
		typedef typename _Mybase::const_reference const_reference;
		typedef typename _Mybase::iterator iterator;
		typedef typename _Mybase::const_iterator const_iterator;
		typedef typename _Mybase::reverse_iterator reverse_iterator;
		typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
		typedef typename _Mybase::value_type value_type;
		set(): _Mybase(key_compare(), allocator_type())
		{
		}
		explicit set(const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
		}
		set(const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
		}
		template<class _Iter>
		set(_Iter _First, _Iter _Last): _Mybase(key_compare(), allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 109);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		set(_Iter _First, _Iter _Last, const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 119);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		set(_Iter _First, _Iter _Last, const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 129);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
	};
	template<class _Kty, class _Pr, class _Alloc>
	class _Move_operation_category<set<_Kty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Kty, class _Pr, class _Alloc>
	inline void swap(set<_Kty, _Pr, _Alloc>&_Left, set<_Kty, _Pr, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	template<class _Kty, class _Pr=less<_Kty>, class _Alloc=allocator<_Kty> >
	class multiset: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true> >
	{
	public:
		typedef multiset<_Kty, _Pr, _Alloc>_Myt;
		typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true> >_Mybase;
		typedef _Kty key_type;
		typedef _Pr key_compare;
		typedef typename _Mybase::value_compare value_compare;
		typedef typename _Mybase::allocator_type allocator_type;
		typedef typename _Mybase::size_type size_type;
		typedef typename _Mybase::difference_type difference_type;
		typedef typename _Mybase::pointer pointer;
		typedef typename _Mybase::const_pointer const_pointer;
		typedef typename _Mybase::reference reference;
		typedef typename _Mybase::const_reference const_reference;
		typedef typename _Mybase::iterator iterator;
		typedef typename _Mybase::const_iterator const_iterator;
		typedef typename _Mybase::reverse_iterator reverse_iterator;
		typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
		typedef typename _Mybase::value_type value_type;
		multiset(): _Mybase(key_compare(), allocator_type())
		{
		}
		explicit multiset(const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
		}
		multiset(const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
		}
		template<class _Iter>
		multiset(_Iter _First, _Iter _Last): _Mybase(key_compare(), allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 218);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		multiset(_Iter _First, _Iter _Last, const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 228);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		multiset(_Iter _First, _Iter _Last, const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 238);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		iterator insert(const value_type&_Val)
		{
			return (_Mybase::insert(_Val).first);
		}
		iterator insert(iterator _Where, const value_type&_Val)
		{
			return (_Mybase::insert(_Where, _Val));
		}
		template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 275);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"multiset insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 277);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
	};
	template<class _Kty, class _Pr, class _Alloc>
	class _Move_operation_category<multiset<_Kty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Kty, class _Pr, class _Alloc>
	inline void swap(multiset<_Kty, _Pr, _Alloc>&_Left, multiset<_Kty, _Pr, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
}
namespace std
{
	template<class _Kty, class _Ty, class _Pr, class _Alloc, bool _Mfl>
	class _Tmap_traits: public _Container_base
	{
	public:
		typedef _Kty key_type;
		typedef pair<const _Kty, _Ty>value_type;
		typedef _Pr key_compare;
		typedef typename _Alloc::template rebind<value_type>::other allocator_type;
		typedef typename allocator_type::template rebind<value_type>::other::pointer _ITptr;
		typedef typename allocator_type::template rebind<value_type>::other::reference _IReft;
		enum
		{
			_Multi=_Mfl
		};
		_Tmap_traits(): comp()
		{
		}
		_Tmap_traits(_Pr _Parg): comp(_Parg)
		{
		}
		class value_compare: public binary_function<value_type, value_type, bool>
		{
			friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;
		public:
			bool operator()(const value_type&_Left, const value_type&_Right)const
			{
				return (comp(_Left.first, _Right.first));
			}
			value_compare(key_compare _Pred): comp(_Pred)
			{
			}
			protected: key_compare comp;
		};
		static const _Kty&_Kfn(const value_type&_Val)
		{
			return (_Val.first);
		}
		_Pr comp;
	};
	template<class _Kty, class _Ty, class _Pr=less<_Kty>, class _Alloc=allocator<pair<const _Kty, _Ty> > >
	class map: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{
	public:
		typedef map<_Kty, _Ty, _Pr, _Alloc>_Myt;
		typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >_Mybase;
		typedef _Kty key_type;
		typedef _Ty mapped_type;
		typedef _Ty referent_type;
		typedef _Pr key_compare;
		typedef typename _Mybase::value_compare value_compare;
		typedef typename _Mybase::allocator_type allocator_type;
		typedef typename _Mybase::size_type size_type;
		typedef typename _Mybase::difference_type difference_type;
		typedef typename _Mybase::pointer pointer;
		typedef typename _Mybase::const_pointer const_pointer;
		typedef typename _Mybase::reference reference;
		typedef typename _Mybase::const_reference const_reference;
		typedef typename _Mybase::iterator iterator;
		typedef typename _Mybase::const_iterator const_iterator;
		typedef typename _Mybase::reverse_iterator reverse_iterator;
		typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
		typedef typename _Mybase::value_type value_type;
		map(): _Mybase(key_compare(), allocator_type())
		{
		}
		explicit map(const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
		}
		map(const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
		}
		template<class _Iter>
		map(_Iter _First, _Iter _Last): _Mybase(key_compare(), allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 124);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		map(_Iter _First, _Iter _Last, const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 134);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		map(_Iter _First, _Iter _Last, const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 144);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		mapped_type&operator[](const key_type&_Keyval)
		{
			iterator _Where=this->lower_bound(_Keyval);
			if(_Where==this->end()||this->comp(_Keyval, this->_Key(_Where._Mynode())))_Where=this->insert(_Where, value_type(_Keyval, mapped_type()));
			return ((*_Where).second);
		}
	};
	template<class _Kty, class _Ty, class _Pr, class _Alloc>
	class _Move_operation_category<map<_Kty, _Ty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Kty, class _Ty, class _Pr, class _Alloc>
	inline void swap(map<_Kty, _Ty, _Pr, _Alloc>&_Left, map<_Kty, _Ty, _Pr, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	template<class _Kty, class _Ty, class _Pr=less<_Kty>, class _Alloc=allocator<pair<const _Kty, _Ty> > >
	class multimap: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
	{
	public:
		typedef multimap<_Kty, _Ty, _Pr, _Alloc>_Myt;
		typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >_Mybase;
		typedef _Kty key_type;
		typedef _Ty mapped_type;
		typedef _Ty referent_type;
		typedef _Pr key_compare;
		typedef typename _Mybase::value_compare value_compare;
		typedef typename _Mybase::allocator_type allocator_type;
		typedef typename _Mybase::size_type size_type;
		typedef typename _Mybase::difference_type difference_type;
		typedef typename _Mybase::pointer pointer;
		typedef typename _Mybase::const_pointer const_pointer;
		typedef typename _Mybase::reference reference;
		typedef typename _Mybase::const_reference const_reference;
		typedef typename _Mybase::iterator iterator;
		typedef typename _Mybase::const_iterator const_iterator;
		typedef typename _Mybase::reverse_iterator reverse_iterator;
		typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
		typedef typename _Mybase::value_type value_type;
		multimap(): _Mybase(key_compare(), allocator_type())
		{
		}
		explicit multimap(const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
		}
		multimap(const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
		}
		template<class _Iter>
		multimap(_Iter _First, _Iter _Last): _Mybase(key_compare(), allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 243);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
		template<class _Iter>
		multimap(_Iter _First, _Iter _Last, const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 253);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
		template<class _Iter>
		multimap(_Iter _First, _Iter _Last, const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 263);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
		iterator insert(const value_type&_Val)
		{
			return (_Mybase::insert(_Val).first);
		}
		iterator insert(iterator _Where, const value_type&_Val)
		{
			return (_Mybase::insert(_Where, _Val));
		}
		template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 300);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"multimap insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 302);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
	};
	template<class _Kty, class _Ty, class _Pr, class _Alloc>
	class _Move_operation_category<multimap<_Kty, _Ty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Kty, class _Ty, class _Pr, class _Alloc>
	inline void swap(multimap<_Kty, _Ty, _Pr, _Alloc>&_Left, multimap<_Kty, _Ty, _Pr, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
}
typedef std::set<const struct IncludeDependencyNode*>IncludeDependencyNodes;
struct IncludeDependencyNode: public IncludeDependencyNodes
{
	Name name;
	IncludeDependencyNode(Name name): name(name)
	{
	}
};
inline bool operator<(const IncludeDependencyNode&left, const IncludeDependencyNode&right)
{
	return left.name<right.name;
}
typedef std::pair<Name, const char*>MacroDeclaration;
typedef std::set<MacroDeclaration>MacroDeclarationSet;
const MacroDeclarationSet MACRODECLARATIONSET_NULL=MacroDeclarationSet();
typedef std::map<Name, MacroDeclarationSet>MacroDependencyMap;
struct IncludeDependencyGraph
{
	typedef std::set<IncludeDependencyNode>Includes;
	Includes includes;
	MacroDependencyMap macros;
	IncludeDependencyNode&get(Name name)
	{
		Includes::iterator i=includes.insert(name).first;
		return const_cast<IncludeDependencyNode&>(*i);
	}
};
inline bool isEOF(LexTokenId token)
{
	return ((((token)&boost::wave::TokenTypeMask)==(boost::wave::EOFTokenType))?true: false);
}
inline bool isWhiteSpace(LexTokenId token)
{
	return ((((token)&boost::wave::TokenTypeMask)==(boost::wave::WhiteSpaceTokenType))?true: false)||((((token)&boost::wave::TokenTypeMask)==(boost::wave::EOLTokenType))?true: false);
}
struct Token
{
	LexTokenId id;
	TokenValue value;
	FilePosition position;
	Source source;
	IncludeEvents events;
	Token(): id(boost::wave::T_UNKNOWN)
	{
	}
	Token(LexTokenId id, const TokenValue&value, const FilePosition&position, Source source=Source(Path(Name("\"$unknown\""), Name("$unknown")), 0, 0), IncludeEvents events=IncludeEvents()): id(id), value(value), position(position), events(events), source(source)
	{
	}
};
struct BacktrackStats
{
	size_t count;
	const char*symbol;
	FilePosition position;
	BacktrackStats(): count(0)
	{
	}
};
class TokenBuffer
{
	TokenBuffer(const TokenBuffer&);
	TokenBuffer&operator=(const TokenBuffer&);
public:
	Token*tokens;
	size_t m_size;
	TokenBuffer(): tokens(0), m_size(0)
	{
	}
	TokenBuffer(size_t size): tokens(new Token[size]), m_size(size)
	{
	}
	~TokenBuffer()
	{
		delete[]tokens;
	}
	Token*begin()
	{
		return tokens;
	}
	const Token*begin()const
	{
		return tokens;
	}
	Token*end()
	{
		return tokens+m_size;
	}
	const Token*end()const
	{
		return tokens+m_size;
	}
	void resize(size_t count)
	{
		this->~TokenBuffer();
		new(this)TokenBuffer(count);
	}
	void swap(TokenBuffer&other)
	{
		std::swap(tokens, other.tokens);
		std::swap(m_size, other.m_size);
	}
};
struct BacktrackBuffer: public TokenBuffer
{
	Token*position;
	typedef Token*iterator;
	typedef const Token*const_iterator;
	BacktrackBuffer(): position(0)
	{
	}
	BacktrackBuffer(size_t count): TokenBuffer(count), position(tokens)
	{
	}
	iterator next(iterator i)
	{
		++i;
		return i==TokenBuffer::end()?TokenBuffer::begin(): i;
	}
	const_iterator next(const_iterator i)const
	{
		++i;
		return i==TokenBuffer::end()?TokenBuffer::begin(): i;
	}
	size_t distance(const_iterator i, const_iterator other)const
	{
		return (i>other)?m_size-(i-other): other-i;
	}
	const_iterator backtrack(const_iterator i, size_t count)
	{
		return (count>size_t(i-tokens))?i+(m_size-count): i-count;
	}
	const_iterator advance(const_iterator i, size_t count)
	{
		return (i+count<tokens+m_size)?i+count: i-(m_size-count);
	}
	iterator begin()
	{
		return next(position);
	}
	iterator end()
	{
		return position;
	}
	const_iterator begin()const
	{
		return next(position);
	}
	const_iterator end()const
	{
		return position;
	}
	void push_back(const Token&token)
	{
		*position=token;
		position=next(position);
	}
	size_t size()const
	{
		return m_size;
	}
	void resize(size_t count)
	{
		TokenBuffer::resize(count);
		position=tokens;
	}
	void swap(BacktrackBuffer&other)
	{
		TokenBuffer::swap(other);
		std::swap(position, other.position);
	}
};
inline size_t distance(const BacktrackBuffer&buffer, BacktrackBuffer::const_iterator first, BacktrackBuffer::const_iterator last)
{
	return buffer.distance(first, last);
}
inline BacktrackBuffer::const_iterator next(const BacktrackBuffer&buffer, BacktrackBuffer::const_iterator position)
{
	return buffer.next(position);
}
inline BacktrackBuffer::const_iterator backtrack(BacktrackBuffer&buffer, BacktrackBuffer::const_iterator position, size_t count)
{
	return buffer.backtrack(position, count);
}
inline BacktrackBuffer::const_iterator advance(BacktrackBuffer&buffer, BacktrackBuffer::const_iterator position, size_t count)
{
	return buffer.advance(position, count);
}
typedef TokenPrinter<std::ostream>FileTokenPrinter;
struct Lexer
{
	LexContext&context;
	std::ofstream out;
	FileTokenPrinter printer;
	LexIterator&first;
	LexIterator&last;
	enum
	{
		BACKTRACK_MAX=1024*128
	};
	typedef BacktrackBuffer Tokens;
	Tokens history;
	Tokens::const_iterator position;
	Tokens::const_iterator error;
	typedef std::vector<size_t>Positions;
	Positions stacktrace;
	Positions::iterator stackpos;
	BacktrackStats stats;
	bool maxBacktrack;
	Lexer(LexContext&context, const char*path): context(context), out(path), printer(out), first(createBegin(context)), last(createEnd(context)), history(BACKTRACK_MAX), position(history.end()), error(history.end()), stackpos(stacktrace.end()), maxBacktrack(false)
	{
		depth=0;
		includes[depth++]=Name("<root>");
		refill();
	}
	~Lexer()
	{
		release(first);
		release(last);
	}
	bool canBacktrack(size_t count)
	{
		return ::distance(history, position, history.end())+count<history.size();
	}
	void backtrack(size_t count, const char*symbol=0)
	{
		if(count==0)
		{
			return ;
		}
		if(!canBacktrack(count))
		{
			maxBacktrack=true;
		}
		else
		{
			if(::distance(history, position, history.end())< ::distance(history, error, history.end()))
			{
				error=position;
			}
			position=::backtrack(history, position, count);
			if(count>stats.count&&symbol!=0)
			{
				stats.count=count;
				stats.symbol=symbol;
				stats.position=(*position).position;
			};
		}
	}
	void advance(size_t count)
	{
		if(count==0)
		{
			return ;
		}
		position=::advance(history, position, count);
	}
	bool finished()const
	{
		return isEOF((*position).id)&&first==last;
	}
	LexTokenId get_id()
	{
		return (*position).id;
	}
	const TokenValue&get_value()
	{
		return (*position).value;
	}
	const FilePosition&get_position()
	{
		return (*position).position;
	}
	IncludeEvents get_events()
	{
		return (*position).events;
	}
	const Source&get_source()
	{
		return (*position).source;
	}
	const TokenValue&getErrorValue()
	{
		return (*error).value;
	}
	FilePosition getErrorPosition()
	{
		return (*error).position;
	}
	Name includes[1024];
	size_t depth;
	void debugEvents(IncludeEvents events, Name source);
	Token*read(Token*first, Token*last);
	void refill()
	{
		if(position==history.end())
		{
			const size_t COUNT=1024;
			Token*end=history.TokenBuffer::end();
			history.position=read(history.position, std::min(end, history.position+COUNT));
			if(history.position==end)
			{
				history.position=history.TokenBuffer::begin();
			}
		}
		debugEvents((*position).events, (*position).source.absolute);
	}
	void increment()
	{
		position=::next(history, position);
		refill();
	}
	const IncludeDependencyGraph&getIncludeGraph()const;
	const char*makeIdentifier(const char*value);
};
inline void printPosition(const FilePosition&position)
{
	std::cout<<position.file.c_str()<<"("<<position.line<<"): ";
}
inline void printPosition(const Source&source)
{
	std::cout<<source.absolute.c_str()<<"("<<source.line<<"): ";
}
namespace std
{
	template<class _Ty, class _Alloc>
	class _List_nod: public _Container_base
	{
		protected: struct _Node;
		friend struct _Node;
		typedef typename _Alloc::template rebind<_Node>::other::pointer _Genptr;
		struct _Node
		{
			_Genptr _Next;
			_Genptr _Prev;
			_Ty _Myval;
		};
		_List_nod(_Alloc _Al): _Alnod(_Al)
		{
		}
		typename _Alloc::template rebind<_Node>::other _Alnod;
	};
	template<class _Ty, class _Alloc>
	class _List_ptr: public _List_nod<_Ty, _Alloc>
	{
		protected: typedef typename _List_nod<_Ty, _Alloc>::_Node _Node;
		typedef typename _Alloc::template rebind<_Node>::other::pointer _Nodeptr;
		_List_ptr(_Alloc _Al): _List_nod<_Ty, _Alloc>(_Al), _Alptr(_Al)
		{
		}
		typename _Alloc::template rebind<_Nodeptr>::other _Alptr;
	};
	template<class _Ty, class _Alloc>
	class _List_val: public _List_ptr<_Ty, _Alloc>
	{
	public:
		typedef typename _Alloc::template rebind<_Ty>::other _Alty;
		_List_val(_Alloc _Al=_Alloc()): _List_ptr<_Ty, _Alloc>(_Al), _Alval(_Al)
		{
		}
		_Alty _Alval;
	};
	template<class _Ty, class _Ax=allocator<_Ty> >
	class list: public _List_val<_Ty, _Ax>
	{
	public:
		typedef list<_Ty, _Ax>_Myt;
		typedef _List_val<_Ty, _Ax>_Mybase;
		typedef typename _Mybase::_Alty _Alloc;
		protected: typedef typename _List_nod<_Ty, _Ax>::_Genptr _Genptr;
		typedef typename _List_nod<_Ty, _Ax>::_Node _Node;
		typedef typename _Alloc::template rebind<_Node>::other::pointer _Nodeptr;
		typedef typename _Alloc::template rebind<_Nodeptr>::other::reference _Nodepref;
		typedef typename _Alloc::reference _Vref;
		static _Nodepref _Nextnode(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Next);
		}
		static _Nodepref _Prevnode(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Prev);
		}
		static _Vref _Myval(_Nodeptr _Pnode)
		{
			return ((_Vref)(*_Pnode)._Myval);
		}
	public:
		typedef _Alloc allocator_type;
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename _Alloc::pointer _Tptr;
		typedef typename _Alloc::const_pointer _Ctptr;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef typename _Alloc::reference _Reft;
		typedef _Reft reference;
		typedef typename _Alloc::const_reference const_reference;
		typedef typename _Alloc::value_type value_type;
		template<bool _Secure_validation>
		class _Const_iterator;
		friend class _Const_iterator<true>;
		friend class _Const_iterator<false>;
		template<bool _Secure_validation>
		class _Const_iterator: public _Bidit<_Ty, _Dift, _Ctptr, const_reference>
		{
		public:
			typedef _Const_iterator<_Secure_validation>_Myt_iter;
			typedef bidirectional_iterator_tag iterator_category;
			typedef _Ty value_type;
			typedef _Dift difference_type;
			typedef _Ctptr pointer;
			typedef const_reference reference;
			_Const_iterator(): _Ptr(0)
			{
			}
			_Const_iterator(_Nodeptr _Pnode, const _Myt*_Plist=0): _Ptr(_Pnode)
			{
				this->_Adopt(_Plist);
			}
			typedef typename _Secure_validation_helper<_Secure_validation>::_Checked_iterator_category _Checked_iterator_category;
			typedef typename _If<_Secure_validation, _Const_iterator<false>, _Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
			friend _Const_iterator<false>;
			friend _Const_iterator<true>;
			_Const_iterator<false>_Checked_iterator_base()const
			{
				_Const_iterator<false>_Base(this->_Ptr, ((_Myt*)this->_Mycont));
				return _Base;
			}
			void _Checked_iterator_assign_from_base(_Const_iterator<false>_Base)
			{

				{
					if(!(this->_Mycont==_Base._Mycont))
					{
						(void)((!!((("this->_Mycont == _Base._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 201, 0, L"(\"this->_Mycont == _Base._Mycont\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 201, 0);
					};
				};
				this->_Ptr=_Base._Ptr;
			}
			const_reference operator*()const
			{
				if(this->_Mycont==0||_Ptr==((_Myt*)this->_Mycont)->_Myhead)
				{
					_Debug_message(L"list iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 213);

					{
						;
						;
						if(_Secure_validation)
						{

							{
								(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 214, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
								::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 214, 0);
							}
						};
					};
				}
				return (_Myval(_Ptr));
			}
			_Ctptr operator->()const
			{
				return (&**this);
			}
			_Myt_iter&operator++()
			{
				if(this->_Mycont==0||_Ptr==((_Myt*)this->_Mycont)->_Myhead)
				{
					_Debug_message(L"list iterator not incrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 236);

					{
						;
						;
						if(_Secure_validation)
						{

							{
								(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 237, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
								::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 237, 0);
							}
						};
					};
				}
				_Ptr=_Nextnode(_Ptr);
				return (*this);
			}
			_Myt_iter operator++(int)
			{
				_Myt_iter _Tmp=*this;
				++*this;
				return (_Tmp);
			}
			_Myt_iter&operator--()
			{
				if(this->_Mycont==0||(_Ptr=_Prevnode(_Ptr))==((_Myt*)this->_Mycont)->_Myhead)
				{
					_Debug_message(L"list iterator not decrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 262);

					{
						;
						;
						if(_Secure_validation)
						{

							{
								(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 263, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
								::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 263, 0);
							}
						};
					};
				}
				return (*this);
			}
			_Myt_iter operator--(int)
			{
				_Myt_iter _Tmp=*this;
				--*this;
				return (_Tmp);
			}
			bool operator==(const _Myt_iter&_Right)const
			{
				_Compat(_Right);
				return (_Ptr==_Right._Ptr);
			}
			bool operator!=(const _Myt_iter&_Right)const
			{
				return (!(*this==_Right));
			}
			_Nodeptr _Mynode()const
			{
				return (_Ptr);
			}
			void _Compat(const _Myt_iter&_Right)const
			{
				if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
				{
					_Debug_message(L"list iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 309);

					{
						;
						;
						if(_Secure_validation)
						{

							{
								(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 310, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
								::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 310, 0);
							}
						};
					};
				}
			}
			_Nodeptr _Ptr;
		};
		typedef _Const_iterator<true>const_iterator;
		template<bool _Secure_validation>
		class _Iterator;
		friend class _Iterator<true>;
		friend class _Iterator<false>;
		template<bool _Secure_validation>
		class _Iterator: public _Const_iterator<_Secure_validation>
		{
		public:
			friend class list<_Ty, _Ax>;
			typedef _Iterator<_Secure_validation>_Myt_iter;
			typedef _Const_iterator<_Secure_validation>_Mybase_iter;
			typedef bidirectional_iterator_tag iterator_category;
			typedef _Ty value_type;
			typedef _Dift difference_type;
			typedef _Tptr pointer;
			typedef _Reft reference;
			_Iterator()
			{
			}
			_Iterator(_Nodeptr _Pnode, const _Myt*_Plist=0): _Mybase_iter(_Pnode, _Plist)
			{
			}
			typedef typename _If<_Secure_validation, _Iterator<false>, _Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
			friend _Iterator<false>;
			friend _Iterator<true>;
			_Iterator<false>_Checked_iterator_base()const
			{
				_Iterator<false>_Base(this->_Ptr, ((_Myt*)this->_Mycont));
				return _Base;
			}
			void _Checked_iterator_assign_from_base(_Iterator<false>_Base)
			{

				{
					if(!(this->_Mycont==_Base._Mycont))
					{
						(void)((!!((("this->_Mycont == _Base._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 381, 0, L"(\"this->_Mycont == _Base._Mycont\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 381, 0);
					};
				};
				this->_Ptr=_Base._Ptr;
			}
			reference operator*()const
			{
				return ((reference)**(_Mybase_iter*)this);
			}
			_Tptr operator->()const
			{
				return (&**this);
			}
			_Myt_iter&operator++()
			{
				++(*(_Mybase_iter*)this);
				return (*this);
			}
			_Myt_iter operator++(int)
			{
				_Myt_iter _Tmp=*this;
				++*this;
				return (_Tmp);
			}
			_Myt_iter&operator--()
			{
				--(*(_Mybase_iter*)this);
				return (*this);
			}
			_Myt_iter operator--(int)
			{
				_Myt_iter _Tmp=*this;
				--*this;
				return (_Tmp);
			}
		};
		typedef _Iterator<true>iterator;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		list(): _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
		}
		explicit list(const _Alloc&_Al): _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
		}
		explicit list(size_type _Count): _Mybase(), _Mysize(0)
		{
			_Ty _Val=_Ty();
			_Myhead=_Buynode();
			_Construct_n(_Count, _Val);
		}
		list(size_type _Count, const _Ty&_Val): _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
			_Construct_n(_Count, _Val);
		}
		list(size_type _Count, const _Ty&_Val, const _Alloc&_Al): _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
			_Construct_n(_Count, _Val);
		}
		list(const _Myt&_Right): _Mybase(_Right._Alval), _Myhead(_Buynode()), _Mysize(0)
		{
			try
			{
				insert(begin(), _Right.begin(), _Right.end());
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		template<class _Iter>
		list(_Iter _First, _Iter _Last): _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		list(_Iter _First, _Iter _Last, const _Alloc&_Al): _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Construct_n((size_type)_Count, (_Ty)_Val);
		}
		template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			try
			{
				insert(begin(), _First, _Last);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		void _Construct_n(size_type _Count, const _Ty&_Val)
		{
			try
			{
				_Insert_n(begin(), _Count, _Val);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		~list()
		{
			_Tidy();
		}
		_Myt&operator=(const _Myt&_Right)
		{
			if(this!=&_Right)assign(_Right.begin(), _Right.end());
			return (*this);
		}
		iterator begin()
		{
			return (iterator(_Nextnode(_Myhead), this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Nextnode(_Myhead), this));
		}
		iterator end()
		{
			return (iterator(_Myhead, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Myhead, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		void resize(size_type _Newsize)
		{
			resize(_Newsize, _Ty());
		}
		void resize(size_type _Newsize, _Ty _Val)
		{
			if(_Mysize<_Newsize)_Insert_n(end(), _Newsize-_Mysize, _Val);
			else while(_Newsize<_Mysize)pop_back();
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			return (this->_Alval.max_size());
		}
		bool empty()const
		{
			return (_Mysize==0);
		}
		allocator_type get_allocator()const
		{
			return (this->_Alval);
		}
		reference front()
		{
			return (*begin());
		}
		const_reference front()const
		{
			return (*begin());
		}
		reference back()
		{
			return (*(--end()));
		}
		const_reference back()const
		{
			return (*(--end()));
		}
		void push_front(const _Ty&_Val)
		{
			_Insert(begin(), _Val);
		}
		void pop_front()
		{
			erase(begin());
		}
		void push_back(const _Ty&_Val)
		{
			_Insert(end(), _Val);
		}
		void pop_back()
		{
			erase(--end());
		}
		template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
			_Assign(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Assign_n((size_type)_Count, (_Ty)_Val);
		}
		template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			clear();
			insert(begin(), _First, _Last);
		}
		void assign(size_type _Count, const _Ty&_Val)
		{
			_Assign_n(_Count, _Val);
		}
		iterator insert(iterator _Where, const _Ty&_Val)
		{
			_Insert(_Where, _Val);
			return (--_Where);
		}
		void _Insert(iterator _Where, const _Ty&_Val)
		{
			if(_Where._Mycont!=this)_Debug_message(L"list insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 698);
			_Nodeptr _Pnode=_Where._Mynode();
			_Nodeptr _Newnode=_Buynode(_Pnode, _Prevnode(_Pnode), _Val);
			_Incsize(1);
			_Prevnode(_Pnode)=_Newnode;
			_Nextnode(_Prevnode(_Newnode))=_Newnode;
		}
		void insert(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			_Insert_n(_Where, _Count, _Val);
		}
		template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Insert_n(_Where, (size_type)_Count, (_Ty)_Val);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
		{
			size_type _Num=0;
			try
			{
				for(;
				_First!=_Last;
				++_First, ++_Num)_Insert(_Where, *_First);
			}
			catch(...)
			{
				for(;
				0<_Num;
				--_Num)
				{
					iterator _Before=_Where;
					erase(--_Before);
				}
				throw;
			}
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 751);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"list insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 753);
			_Iter _Next=_First;
			try
			{
				for(;
				_First!=_Last;
				++_First)_Insert(_Where, *_First);
			}
			catch(...)
			{
				for(;
				_Next!=_First;
				++_Next)
				{
					iterator _Before=_Where;
					erase(--_Before);
				}
				throw;
			}
		}
		iterator erase(iterator _Where)
		{
			if(_Where._Mycont!=this||_Where._Ptr==_Myhead)_Debug_message(L"list erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 776);
			_Nodeptr _Pnode=(_Where++)._Mynode();
			_Orphan_ptr(*this, _Pnode);
			if(_Pnode!=_Myhead)
			{
				_Nextnode(_Prevnode(_Pnode))=_Nextnode(_Pnode);
				_Prevnode(_Nextnode(_Pnode))=_Prevnode(_Pnode);
				this->_Alnod.destroy(_Pnode);
				this->_Alnod.deallocate(_Pnode, 1);
				--_Mysize;
			}
			return (_Where);
		}
		iterator erase(iterator _First, iterator _Last)
		{
			if(_First==begin()&&_Last==end())
			{
				clear();
				return (end());
			}
			else
			{
				while(_First!=_Last)_First=erase(_First);
				return (_Last);
			}
		}
		void clear()
		{
			this->_Orphan_ptr(*this, 0);
			_Nodeptr _Pnext;
			_Nodeptr _Pnode=_Nextnode(_Myhead);
			_Nextnode(_Myhead)=_Myhead;
			_Prevnode(_Myhead)=_Myhead;
			_Mysize=0;
			for(;
			_Pnode!=_Myhead;
			_Pnode=_Pnext)
			{
				_Pnext=_Nextnode(_Pnode);
				this->_Alnod.destroy(_Pnode);
				this->_Alnod.deallocate(_Pnode, 1);
			}
		}
		void swap(_Myt&_Right)
		{
			if(this->_Alval==_Right._Alval)
			{
				this->_Swap_all(_Right);
				std::swap(_Myhead, _Right._Myhead);
				std::swap(_Mysize, _Right._Mysize);
			}
			else
			{
				iterator _Where=begin();
				splice(_Where, _Right);
				_Right.splice(_Right.begin(), *this, _Where, end());
			}
		}
		void splice(iterator _Where, _Myt&_Right)
		{
			if(this!=&_Right&&!_Right.empty())
			{
				_Splice(_Where, _Right, _Right.begin(), _Right.end(), _Right._Mysize);
			}
		}
		void splice(iterator _Where, _Myt&_Right, iterator _First)
		{
			if(_First==_Right.end())_Debug_message(L"list splice iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 865);
			else
			{
				iterator _Last=_First;
				++_Last;
				if(this!=&_Right||(_Where!=_First&&_Where!=_Last))_Splice(_Where, _Right, _First, _Last, 1);
			}
		}
		void splice(iterator _Where, _Myt&_Right, iterator _First, iterator _Last)
		{
			if(_First!=_Last&&(this!=&_Right||_Where!=_Last))
			{
				size_type _Count=0;
				if(this==&_Right);
				else if(_First==_Right.begin()&&_Last==_Right.end())_Count=_Right._Mysize;
				else _Distance(_First, _Last, _Count);
				_Splice(_Where, _Right, _First, _Last, _Count);
			}
		}
		void remove(const _Ty&_Val)
		{
			iterator _Last=end();
			for(iterator _First=begin();
			_First!=_Last;
			)if(*_First==_Val)_First=erase(_First);
			else++_First;
		}
		template<class _Pr1>
		void remove_if(_Pr1 _Pred)
		{
			iterator _Last=end();
			for(iterator _First=begin();
			_First!=_Last;
			)if(_Pred(*_First))_First=erase(_First);
			else++_First;
		}
		void unique()
		{
			if(2<=_Mysize)
			{
				iterator _First=begin();
				iterator _After=_First;
				for(++_After;
				_After!=end();
				)if(*_First==*_After)_After=erase(_After);
				else _First=_After++;
			}
		}
		template<class _Pr2>
		void unique(_Pr2 _Pred)
		{
			if(2<=_Mysize)
			{
				iterator _First=begin();
				iterator _After=_First;
				for(++_After;
				_After!=end();
				)if(_Pred(*_First, *_After))_After=erase(_After);
				else _First=_After++;
			}
		}
		void merge(_Myt&_Right)
		{
			if(&_Right!=this)
			{
				iterator _First1=begin(), _Last1=end();
				iterator _First2=_Right.begin(), _Last2=_Right.end();
				_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 953);
				_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 954);
				while(_First1!=_Last1&&_First2!=_Last2)if(_Debug_lt(*_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 957))
				{
					iterator _Mid2=_First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2=_Mid2;
				}
				else++_First1;
				if(_First2!=_Last2)_Splice(_Last1, _Right, _First2, _Last2, _Right._Mysize);
			}
		}
		template<class _Pr3>
		void merge(_Myt&_Right, _Pr3 _Pred)
		{
			if(&_Right!=this)
			{
				iterator _First1=begin(), _Last1=end();
				iterator _First2=_Right.begin(), _Last2=_Right.end();
				_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 979);
				_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 980);
				while(_First1!=_Last1&&_First2!=_Last2)if(_Debug_lt_pred(_Pred, *_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 983))
				{
					iterator _Mid2=_First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2=_Mid2;
				}
				else++_First1;
				if(_First2!=_Last2)_Splice(_Last1, _Right, _First2, _Last2, _Right._Mysize);
			}
		}
		void sort()
		{
			if(2<=_Mysize)
			{
				const size_t _MAXBINS=25;
				_Myt _Templist(this->_Alval), _Binlist[_MAXBINS+1];
				size_t _Maxbin=0;
				while(!empty())
				{
					_Templist._Splice(_Templist.begin(), *this, begin(), ++begin(), 1, true);
					size_t _Bin;
					for(_Bin=0;
					_Bin<_Maxbin&&!_Binlist[_Bin].empty();
					++_Bin)
					{
						_Binlist[_Bin].merge(_Templist);
						_Binlist[_Bin].swap(_Templist);
					}
					if(_Bin==_MAXBINS)_Binlist[_Bin-1].merge(_Templist);
					else
					{
						_Binlist[_Bin].swap(_Templist);
						if(_Bin==_Maxbin)++_Maxbin;
					}
				}
				for(size_t _Bin=1;
				_Bin<_Maxbin;
				++_Bin)_Binlist[_Bin].merge(_Binlist[_Bin-1]);
				splice(begin(), _Binlist[_Maxbin-1]);
			}
		}
		template<class _Pr3>
		void sort(_Pr3 _Pred)
		{
			if(2<=_Mysize)
			{
				const size_t _MAXBINS=25;
				_Myt _Templist(this->_Alval), _Binlist[_MAXBINS+1];
				size_t _Maxbin=0;
				while(!empty())
				{
					_Templist._Splice(_Templist.begin(), *this, begin(), ++begin(), 1, true);
					size_t _Bin;
					for(_Bin=0;
					_Bin<_Maxbin&&!_Binlist[_Bin].empty();
					++_Bin)
					{
						_Binlist[_Bin].merge(_Templist, _Pred);
						_Binlist[_Bin].swap(_Templist);
					}
					if(_Bin==_MAXBINS)_Binlist[_Bin-1].merge(_Templist, _Pred);
					else
					{
						_Binlist[_Bin].swap(_Templist);
						if(_Bin==_Maxbin)++_Maxbin;
					}
				}
				for(size_t _Bin=1;
				_Bin<_Maxbin;
				++_Bin)_Binlist[_Bin].merge(_Binlist[_Bin-1], _Pred);
				splice(begin(), _Binlist[_Maxbin-1]);
			}
		}
		void reverse()
		{
			if(2<=_Mysize)
			{
				iterator _Last=end();
				for(iterator _Next=++begin();
				_Next!=_Last;
				)
				{
					iterator _Before=_Next;
					_Splice(begin(), *this, _Before, ++_Next, 1);
				}
			}
		}
		void _Splice(iterator _Where, _Myt&_Right, iterator _First, iterator _Last, size_type _Count, bool _Keep=false)
		{
			if(_Where._Mycont!=this)_Debug_message(L"list splice iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 1093);
			if(this->_Alval==_Right._Alval)
			{
				if(!_Keep&&this!=&_Right)for(iterator _Next=_First;
				_Next!=_Last;
				)_Orphan_ptr(_Right, (_Next++)._Ptr);
				if(this!=&_Right)
				{
					_Incsize(_Count);
					_Right._Mysize-=_Count;
				}
				_Nextnode(_Prevnode(_First._Mynode()))=_Last._Mynode();
				_Nextnode(_Prevnode(_Last._Mynode()))=_Where._Mynode();
				_Nextnode(_Prevnode(_Where._Mynode()))=_First._Mynode();
				_Nodeptr _Pnode=_Prevnode(_Where._Mynode());
				_Prevnode(_Where._Mynode())=_Prevnode(_Last._Mynode());
				_Prevnode(_Last._Mynode())=_Prevnode(_First._Mynode());
				_Prevnode(_First._Mynode())=_Pnode;
			}
			else
			{
				insert(_Where, _First, _Last);
				_Right.erase(_First, _Last);
			}
		}
		protected: void _Assign_n(size_type _Count, const _Ty&_Val)
		{
			_Ty _Tmp=_Val;
			clear();
			_Insert_n(begin(), _Count, _Tmp);
		}
		_Nodeptr _Buynode()
		{
			_Nodeptr _Pnode=this->_Alnod.allocate(1);
			int _Linkcnt=0;
			try
			{
				this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);
				++_Linkcnt;
				this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);
			}
			catch(...)
			{
				if(0<_Linkcnt)this->_Alptr.destroy(&_Nextnode(_Pnode));
				this->_Alnod.deallocate(_Pnode, 1);
				throw;
			}
			return (_Pnode);
		}
		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev, const _Ty&_Val)
		{
			_Nodeptr _Pnode=this->_Alnod.allocate(1);
			int _Linkcnt=0;
			try
			{
				this->_Alptr.construct(&_Nextnode(_Pnode), _Next);
				++_Linkcnt;
				this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);
				++_Linkcnt;
				this->_Alval.construct(&_Myval(_Pnode), _Val);
			}
			catch(...)
			{
				if(1<_Linkcnt)this->_Alptr.destroy(&_Prevnode(_Pnode));
				if(0<_Linkcnt)this->_Alptr.destroy(&_Nextnode(_Pnode));
				this->_Alnod.deallocate(_Pnode, 1);
				throw;
			}
			return (_Pnode);
		}
		void _Tidy()
		{
			clear();
			this->_Alptr.destroy(&_Nextnode(_Myhead));
			this->_Alptr.destroy(&_Prevnode(_Myhead));
			this->_Alnod.deallocate(_Myhead, 1);
			_Myhead=0;
		}
		void _Insert_n(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			size_type _Countsave=_Count;
			try
			{
				for(;
				0<_Count;
				--_Count)_Insert(_Where, _Val);
			}
			catch(...)
			{
				for(;
				_Count<_Countsave;
				++_Count)
				{
					iterator _Before=_Where;
					erase(--_Before);
				}
				throw;
			}
		}
		void _Incsize(size_type _Count)
		{
			if(max_size()-_Mysize<_Count)throw length_error("list<T> too long");
			_Mysize+=_Count;
		}
		static void _Xran()
		{
			throw out_of_range("invalid list<T> subscript");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid list<T> argument");
		}
		void _Orphan_ptr(_Myt&_Cont, _Nodeptr _Ptr)const
		{
			_Lockit _Lock(3);
			const_iterator**_Pnext=(const_iterator**)&_Cont._Myfirstiter;
			while(*_Pnext!=0)if((*_Pnext)->_Ptr==_Myhead||_Ptr!=0&&(*_Pnext)->_Ptr!=_Ptr)_Pnext=(const_iterator**)&(*_Pnext)->_Mynextiter;
			else
			{
				(*_Pnext)->_Mycont=0;
				*_Pnext=(const_iterator*)(*_Pnext)->_Mynextiter;
			}
		}
		_Nodeptr _Myhead;
		size_type _Mysize;
	};
	template<class _Ty, class _Ax>
	class _Move_operation_category<list<_Ty, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Ty, class _Alloc>
	inline void swap(list<_Ty, _Alloc>&_Left, list<_Ty, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	template<class _Ty, class _Alloc>
	inline bool operator==(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (_Left.size()==_Right.size()&&equal(_Left.begin(), _Left.end(), _Right.begin()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator!=(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty, class _Alloc>
	inline bool operator<(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Ty, class _Alloc>
	inline bool operator<=(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>=(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
}
struct ParseError
{
	ParseError()
	{
	}
};
struct GeneralError
{
	GeneralError()
	{
	}
};
inline bool isAlphabet(char c)
{
	return (c>='a'&&c<='z')||(c>='A'&&c<='Z');
}
inline bool isNumber(char c)
{
	return (c>='0'&&c<='9');
}
inline bool isIdentifier(char c)
{
	return isAlphabet(c)||isNumber(c)||c=='_';
}
inline bool isToken(LexTokenId token, boost::wave::token_id id)
{
	return token==id;
}
inline bool isIdentifier(LexTokenId token)
{
	return isToken(token, boost::wave::T_IDENTIFIER);
}
inline void printSequence(BacktrackBuffer&buffer, BacktrackBuffer::const_iterator first, BacktrackBuffer::const_iterator last)
{
	std::cout<<"   ";
	bool space=false;
	bool endline=false;
	for(BacktrackBuffer::const_iterator i=first;
	i!=last;
	i=next(buffer, i))
	{
		if(space&&isIdentifier(*(*i).value.c_str()))
		{
			std::cout<<" ";
		}
		std::cout<<(*i).value.c_str();
		space=isIdentifier((*i).value.c_str()[strlen((*i).value.c_str())-1]);
	}
}
inline void printSequence(Lexer&lexer)
{
	printSequence(lexer.history, lexer.position, lexer.error);
	std::cout<<std::endl;
}
inline void printSequence(Lexer&lexer, size_t position)
{
}
struct VisualiserNode
{
	VisualiserNode*parent;
	const char*name;
	size_t allocation;
	BacktrackBuffer::const_iterator position;
	const DeclarationInstance*declaration;
};
inline void printIndent(VisualiserNode*node)
{
	for(VisualiserNode*p=node;
	p!=0;
	p=p->parent)
	{
		if(p->name!=(typeid(cpp::declaration_seq).name()+12)&&p->name!=(typeid(cpp::statement_seq).name()+12)&&p->name!=(typeid(cpp::member_specification).name()+12))
		{
			std::cout<<".";
		}
	}
}
cpp::terminal_identifier&getDeclarationId(const DeclarationInstance*declaration);
struct Visualiser
{
	typedef LinearAllocator<false>Allocator;
	Allocator allocator;
	VisualiserNode*node;
	Visualiser(): node(0)
	{
	}
	void push(const char*name, BacktrackBuffer::const_iterator position)
	{
		VisualiserNode tmp=
		{
			node, name, allocator.position, position, 0
		};
		node=new(allocator.allocate(sizeof(VisualiserNode)))VisualiserNode(tmp);
	}
	void pop(bool hit)
	{
		VisualiserNode*parent=node->parent;
		if(hit)
		{
			if(node->name==(typeid(cpp::declaration).name()+12)||node->name==(typeid(cpp::statement).name()+12)||node->name==(typeid(cpp::member_declaration).name()+12))
			{
				allocator.backtrack(node->allocation);
			}
			else
			{
				node->allocation=size_t(-1);
			}
		}
		node=parent;
	}
	void pop(cpp::identifier*symbol)
	{
		node->declaration=symbol->value.dec.p;
		pop(symbol!=0);
	}
	template<typename T>
	void pop(T*symbol)
	{
		pop(symbol!=0);
	}
	void print(BacktrackBuffer&buffer)
	{
		Allocator::Pages::iterator last=allocator.pages.begin()+allocator.position/sizeof(Page);
		for(Allocator::Pages::iterator i=allocator.pages.begin();
		i!=allocator.pages.end();
		++i)
		{
			size_t pageSize=i==last?allocator.position%Page::SIZE: Page::SIZE;
			VisualiserNode*first=reinterpret_cast<VisualiserNode*>((*i)->buffer);
			VisualiserNode*last=first+pageSize/sizeof(VisualiserNode);
			for(VisualiserNode*p=first;
			p!=last;
			++p)
			{
				if(p->name!=(typeid(cpp::declaration_seq).name()+12)&&p->name!=(typeid(cpp::statement_seq).name()+12))
				{
					bool success=p->allocation==size_t(-1);
					printIndent(p);
					std::cout<<p->name;
					std::cout<<(success?"*": "");
					if(p->name==(typeid(cpp::identifier).name()+12))
					{
						std::cout<<" ";
						if(p->declaration!=0)
						{
							cpp::terminal_identifier&id=getDeclarationId(p->declaration);
							std::cout<<id.value.c_str()<<" ";
							printPosition(id.source);
						}
						else
						{
							std::cout<<(*p->position).value.c_str();
						}
					}
					std::cout<<std::endl;
				}
			}
			if(pageSize!=Page::SIZE)
			{
				break;
			}
		}
		std::cout<<std::endl;
	}
};
typedef LinearAllocatorWrapper<int, struct ParserAllocator>DefaultParserAllocator;
inline struct ParserAllocator&NullParserAllocator();
class OpaqueCopied: DefaultParserAllocator
{
	void*p;
	void(*release)(DefaultParserAllocator&, void*);
	template<typename T>
	struct ReleaseGeneric
	{
		static void apply(DefaultParserAllocator&allocator, void*p)
		{
			allocatorDelete(allocator, static_cast<T*>(p));
		}
	};
	static void releaseNull(DefaultParserAllocator&, void*p)
	{
	}
public:
	OpaqueCopied(const DefaultParserAllocator&allocator): DefaultParserAllocator(*this), p(0), release(releaseNull)
	{
	}
	OpaqueCopied(const OpaqueCopied&other): DefaultParserAllocator(other), p(0), release(releaseNull)
	{
		if(!(other.p==0))
		{
			throw GeneralError();
		};
	}
	OpaqueCopied&operator=(const OpaqueCopied&other)
	{
		if(!(p==0))
		{
			throw GeneralError();
		};
		if(!(other.p==0))
		{
			throw GeneralError();
		};
	}
	template<typename T>
	OpaqueCopied(const T&value, const DefaultParserAllocator&allocator): DefaultParserAllocator(allocator), p(allocatorNew(allocator, T(value))), release(ReleaseGeneric<T>::apply)
	{
	}
	~OpaqueCopied()
	{
		release(*this, p);
	}
	template<typename T>
	void get(T*&result)
	{
		result=static_cast<T*>(p);
	}
};
template<typename Symbol, typename Walker>
struct Cached
{
	size_t count;
	size_t allocation;
	Symbol*symbol;
	Walker walker;
	Cached(Symbol*symbol, const Walker&walker): symbol(symbol), walker(walker)
	{
	}
};
template<typename T>
struct TypeInfo
{
	static const std::type_info*id;
};
template<typename T>
const std::type_info*TypeInfo<T>::id=&typeid(T);
template<typename T>
struct Opaque
{
	char data[sizeof(T)];
};
struct CachedSymbols
{
	typedef Lexer::Tokens::const_iterator Key;
	struct Value;
	typedef std::pair<Key, Value>Entry;
	typedef std::list<Entry, DefaultParserAllocator>Entries;
	typedef Entries::iterator Position;
	struct Value
	{
		const std::type_info*type;
		Position end;
		OpaqueCopied copied;
		Value(): copied(NullParserAllocator())
		{
		}
	};
	Entries entries;
	Entries::iterator position;
	size_t hits;
	static const size_t NONE=size_t(-1);
	CachedSymbols(const DefaultParserAllocator&allocator): entries(allocator), position(entries.begin()), hits(0)
	{
	}
	~CachedSymbols()
	{
		if(hits>0)
		{
		}
	}
	template<typename T>
	void find(Key key, const T*&p)
	{
		for(Entries::iterator i=position;
		i!=entries.begin();
		)
		{
			--i;
			if((*i).first!=key)
			{
				break;
			}
			if((*i).second.type==TypeInfo<T>::id)
			{
				++hits;
				Value&value=(*i).second;
				value.copied.get(p);
				entries.erase(++i, position);
				position=value.end;
				return ;
			}
		}
		p=0;
	}
	template<typename T>
	T&insert(Entries::iterator at, Key key, const T&t)
	{
		flush();
		Value&value=(*entries.insert(at, Entries::value_type(key, Value()))).second;
		position=entries.begin();
		value.type=TypeInfo<T>::id;
		value.end=position;
		value.copied.~OpaqueCopied();
		new(&value.copied)OpaqueCopied(t, entries.get_allocator());
		T*p;
		value.copied.get(p);
		return *p;
	}
	void flush()
	{
		entries.erase(entries.begin(), position);
	}
};
typedef LinearAllocator<true>LexerAllocator;
struct BacktrackCallback
{
	typedef void(*Thunk)(void*data, LexerAllocator&allocator);
	Thunk thunk;
	void*data;
	void operator()(LexerAllocator&context)const
	{
		thunk(data, context);
	}
};
template<typename T, void(*op)(T*p, LexerAllocator&allocator)>
struct BacktrackCallbackThunk
{
	static void thunk(void*data, LexerAllocator&allocator)
	{
		op(static_cast<T*>(data), allocator);
	}
};
template<typename T>
inline void deleteObject(T*p, LexerAllocator&allocator)
{
	allocatorDelete(LinearAllocatorWrapper<int>(allocator), p);
}
template<typename T>
BacktrackCallback makeDeleteCallback(T*p)
{
	BacktrackCallback result=
	{
		BacktrackCallbackThunk<T, deleteObject>::thunk, p
	};
	return result;
}
template<typename T>
inline void destroyObject(T*p, LexerAllocator&allocator)
{
	LinearAllocatorWrapper<T>(allocator).destroy(p);
}
template<typename T>
BacktrackCallback makeDestroyCallback(T*p)
{
	BacktrackCallback result=
	{
		BacktrackCallbackThunk<T, destroyObject>::thunk, p
	};
	return result;
}
template<typename T>
inline void deallocateObject(T*p, LexerAllocator&allocator)
{
	LinearAllocatorWrapper<T>(allocator).deallocate(p, 1);
}
template<typename T>
BacktrackCallback makeDeallocateCallback(T*p)
{
	BacktrackCallback result=
	{
		BacktrackCallbackThunk<T, deallocateObject>::thunk, p
	};
	return result;
}
typedef std::pair<size_t, BacktrackCallback>BacktrackCallbacksElement;
typedef List<BacktrackCallbacksElement, DefaultParserAllocator>BacktrackCallbacks;
struct ParserAllocator: public LexerAllocator
{
	BacktrackCallbacks backtrackCallbacks;
	size_t position;
	CachedSymbols cachedSymbols;
	Callback1<size_t>onBacktrack;
	ParserAllocator(): position(0), backtrackCallbacks(DefaultParserAllocator(*this)), cachedSymbols(DefaultParserAllocator(*this))
	{
	}
	void addBacktrackCallback(size_t position, const BacktrackCallback&callback)
	{
		backtrackCallbacks.push_front(BacktrackCallbacksElement(position, callback));
	}
	void backtrack(size_t original)
	{
		if(!(original<=position))
		{
			throw AllocatorError();
		};
		position=original;
	}
	void*allocate(size_t size)
	{
		deferredBacktrack();
		void*result=LexerAllocator::allocate(size);
		position=LexerAllocator::position;
		return result;
	}
	void deferredBacktrack()
	{
		if(position==LexerAllocator::position)
		{
			return ;
		}
		onBacktrack(LexerAllocator::position-position);
		cachedSymbols.flush();

		{
			BacktrackCallbacks::iterator i=backtrackCallbacks.begin();
			for(;
			i!=backtrackCallbacks.end();
			++i)
			{
				if((*i).first<position)
				{
					break;
				}
				(*i).second(*this);
			}
			backtrackCallbacks.erase(backtrackCallbacks.begin(), i);
		}
		LexerAllocator::backtrack(position);
	}
};
inline ParserAllocator&NullParserAllocator()
{
	static ParserAllocator null;
	return null;
}
template<class T>
class ParserAllocatorWrapper
{
public:
	ParserAllocator&instance;
	typedef T value_type;
	typedef T*pointer;
	typedef T&reference;
	typedef const T*const_pointer;
	typedef const T&const_reference;
	typedef std::size_t size_type;
	typedef std::ptrdiff_t difference_type;
	template<class OtherT>
	struct rebind
	{
		typedef ParserAllocatorWrapper<OtherT>other;
	};
	ParserAllocatorWrapper(): instance(NullParserAllocator())
	{
		throw AllocatorError();
	}
	ParserAllocatorWrapper(ParserAllocator&instance): instance(instance)
	{
	}
	ParserAllocatorWrapper(const ParserAllocatorWrapper<T>&other): instance(other.instance)
	{
	}
	template<class OtherT>
	ParserAllocatorWrapper(const ParserAllocatorWrapper<OtherT>&other): instance(other.instance)
	{
	}
	template<class OtherT>
	ParserAllocatorWrapper<T>&operator=(const ParserAllocatorWrapper<OtherT>&other)
	{
		if(this!=&other)
		{
			this->~ParserAllocatorWrapper();
			new(this)ParserAllocatorWrapper(other);
		}
		return (*this);
	}
	void deallocate(pointer p, size_type count)
	{
	}
	pointer allocate(size_type count)
	{
		size_t position=instance.position;
		pointer p=pointer(instance.allocate(count*sizeof(T)+sizeof(size_t)));
		*reinterpret_cast<size_t*>(p+count)=position;
		*reinterpret_cast<size_t*>(p)=position;
		instance.addBacktrackCallback(position, makeDeallocateCallback(p));
		return p;
	}
	pointer allocate(size_type count, const void*hint)
	{
		return allocate(count);
	}
	void construct(pointer p, const T&value)
	{
		instance.addBacktrackCallback(*reinterpret_cast<size_t*>(p), makeDestroyCallback(p));
		new(p)T(value);
	}
	void destroy(pointer p)
	{
	}
	size_type max_size()const
	{
		size_type _Count=size_type(-1)/sizeof(T);
		return (0<_Count?_Count: 1);
	}
};
template<class T, class OtherT>
inline bool operator==(const ParserAllocatorWrapper<T>&, const ParserAllocatorWrapper<OtherT>&)
{
	return true;
}
template<class T, class OtherT>
inline bool operator!=(const ParserAllocatorWrapper<T>&, const ParserAllocatorWrapper<OtherT>&)
{
	return false;
}
struct ParserContext: Lexer
{
	Visualiser visualiser;
	ParserAllocator allocator;
	BacktrackStats stats;
	ParserContext(LexContext&context, const char*path): Lexer(context, path)
	{
		allocator.onBacktrack=makeCallback(Member1<ParserContext, size_t, &ParserContext::onBacktrack>(*this));
	}
	void onBacktrack(size_t count)
	{
		if(count>stats.count)
		{
			stats.count=count;
			stats.symbol="$symbol";
			stats.position=Lexer::get_position();
		}
	}
	void backtrack(size_t count, const char*symbol=0)
	{
		Lexer::backtrack(count, symbol);
	}
	void addBacktrackCallback(size_t position, const BacktrackCallback&callback)
	{
		allocator.addBacktrackCallback(position, callback);
	}
};
struct ParserState
{
	bool inTemplateArgumentList;
	ParserState(): inTemplateArgumentList(false)
	{
	}
};
struct Parser: public ParserState
{
	ParserContext&context;
	size_t position;
	size_t allocation;
	CachedSymbols::Position cachePosition;
	Parser(ParserContext&context): context(context), position(0), allocation(0)
	{
	}
	Parser(const Parser&other): ParserState(other), context(other.context), position(0), allocation(context.allocator.position), cachePosition(context.allocator.cachedSymbols.position)
	{
	}
	LexTokenId get_id()
	{
		return context.get_id();
	}
	const TokenValue&get_value()
	{
		return context.get_value();
	}
	const FilePosition&get_position()
	{
		return context.get_position();
	}
	IncludeEvents get_events()
	{
		return context.get_events();
	}
	const Source&get_source()
	{
		return context.get_source();
	}
	void increment()
	{
		++position;
		context.increment();
	}
	void backtrack(const char*symbol, bool preserveAllocation=false)
	{
		if(!preserveAllocation)
		{
			context.allocator.backtrack(allocation);
		}
		context.backtrack(position, symbol);
		context.allocator.cachedSymbols.position=cachePosition;
	}
	void advance()
	{
		if(position!=0)
		{
			context.advance(position);
		}
	}
	template<typename Symbol, typename Walker>
	bool cacheLookup(Symbol*&symbol, Walker&walker)
	{
		CachedSymbols::Key key=context.position;
		const Cached<Symbol, Walker>*p=0;
		context.allocator.cachedSymbols.find(context.position, p);
		if(p!=0)
		{
			symbol=p->symbol;
			walker.~Walker();
			new(&walker)Walker(p->walker);
			context.allocator.position=p->allocation;
			position=p->count;
			advance();
			return true;
		}
		if(!(context.position==key))
		{
			throw GeneralError();
		};
		return false;
	}
	template<typename Symbol, typename Walker>
	void cacheStore(CachedSymbols::Key key, Symbol*symbol, const Walker&walker)
	{
		Cached<Symbol, Walker>&entry=context.allocator.cachedSymbols.insert(cachePosition, key, Cached<Symbol, Walker>(symbol, walker));
		entry.count=position;
		entry.allocation=context.allocator.position;
	}
};
inline void printError(ParserContext&context)
{
	printPosition(context.getErrorPosition());
	std::cout<<"syntax error: '"<<context.getErrorValue().c_str()<<"'"<<std::endl;
	context.visualiser.print(context.history);
	printSequence(context);
}
inline void printError(Parser&parser)
{
	printError(parser.context);
}
inline void printSequence(Parser&parser)
{
	printSequence(parser.context, parser.position);
}
template<typename T>
inline cpp::symbol_required<T>makeSymbolRequired(T*p)
{
	return cpp::symbol_required<T>(p);
}
template<typename T>
inline cpp::symbol_required<T>&checkSymbolRequired(cpp::symbol_required<T>&symbol)
{
	return symbol;
}
template<typename T>
inline cpp::symbol_optional<T>makeSymbolOptional(T*p)
{
	return cpp::symbol_optional<T>(p);
}
template<typename T>
inline cpp::symbol_optional<T>&checkSymbolOptional(cpp::symbol_optional<T>&symbol)
{
	return symbol;
}
template<typename T>
inline cpp::symbol_sequence<T>&checkSymbolSequence(cpp::symbol_sequence<T>&symbol)
{
	return symbol;
}
template<typename T>
struct IsConcrete
{
	static const bool RESULT=!IsConvertible<T, cpp::choice<T> >::RESULT&&!IsConvertible<T, cpp::terminal_choice>::RESULT;
};
template<typename T>
T*createSymbol(Parser&parser, T*)
{
	return allocatorNew(ParserAllocatorWrapper<int>(parser.context.allocator), T());
}
template<typename T, bool isConcrete=IsConcrete<T>::RESULT>
struct SymbolHolder;
template<typename T>
struct SymbolHolder<T, true>
{
	ParserContext&context;
	SymbolHolder(ParserContext&context): context(context)
	{
	}
	T value;
	T*get()
	{
		return &value;
	}
	static T*hit(T*result, ParserContext&context)
	{
		return allocatorNew(ParserAllocatorWrapper<int>(context.allocator), T(*result));
	}
};
template<typename T>
struct SymbolHolder<T, false>
{
	SymbolHolder(ParserContext&context)
	{
	}
	T*get()
	{
		return 0;
	}
	static T*hit(T*result, ParserContext&context)
	{
		return result;
	}
};
template<typename T>
T*parseHit(Parser&parser, T*p)
{
	return SymbolHolder<T>::hit(p, parser.context);
}
inline bool checkBacktrack(Parser&parser)
{
	if(parser.context.maxBacktrack)
	{
		printError(parser);
		return true;
	}
	return false;
};
inline void breakpoint()
{
}
template<typename T>
T*pruneSymbol(T*symbol)
{
	return symbol;
}
template<typename T>
inline T*pruneBinaryExpression(T*symbol)
{
	return symbol->right==0?symbol->left: symbol;
}
template<LexTokenId id>
inline LexTokenId getTokenId(cpp::terminal<id>)
{
	return id;
}
inline bool parseTerminal(Parser&parser, LexTokenId id, TokenValue&value)
{
	if(isToken(parser.get_id(), id))
	{
		value=parser.get_value();
		parser.increment();
		return true;
	}
	return false;
}
enum ParseResult
{
	PARSERESULT_PASS, PARSERESULT_FAIL, PARSERESULT_SKIP,
};
template<LexTokenId id>
inline ParseResult parseTerminal(Parser&parser, cpp::terminal<id>&result)
{
	return parseTerminal(parser, getTokenId(result), result.value)?PARSERESULT_PASS: PARSERESULT_FAIL;
}
template<LexTokenId id>
inline ParseResult parseTerminal(Parser&parser, cpp::terminal_optional<id>&result)
{
	parseTerminal(parser, getTokenId(result), result.value);
	return PARSERESULT_PASS;
}
template<LexTokenId id>
inline ParseResult parseTerminal(Parser&parser, cpp::terminal_suffix<id>&result)
{
	return parseTerminal(parser, getTokenId(result), result.value)?PARSERESULT_PASS: PARSERESULT_SKIP;
}
struct CachedNull
{
};
struct CachedLeaf
{
};
struct CachedWalk
{
};
typedef CachedNull DisableCache;
typedef CachedLeaf EnableCache;
struct DeferDefault
{
	template<typename WalkerType>
	static bool isDeferredParse(WalkerType&walker)
	{
		return false;
	}
	template<typename WalkerType, typename T>
	static T*addDeferredParse(WalkerType&walker, T*symbol)
	{
		return 0;
	}
};
struct ParserOpaque: public Parser
{
	void*walker;
	ParserOpaque(ParserContext&context, void*walker): Parser(context), walker(walker)
	{
	}
};
template<typename Walker, typename T>
struct DeferredParseThunk
{
	static void*thunk(ParserContext&context, const typename Walker::State&state, void*p)
	{
		Walker walker(state);
		T*symbol=static_cast<T*>(p);
		ParserGeneric<Walker>parser(context, walker);
		void*result=makeParser(symbol).parseSymbol(parser, symbol);
		return result;
	}
};
template<typename ContextType>
struct DeferredParseBase
{
	typedef void*(*Func)(ParserContext&, const ContextType&, void*);
	ContextType context;
	void*symbol;
	Func func;
};
template<typename ContextType>
struct DeferredParse: public DeferredParseBase<ContextType>
{
	BacktrackBuffer buffer;
	DeferredParse(const DeferredParseBase<ContextType>&base): buffer(), DeferredParseBase<ContextType>(base)
	{
	}
	DeferredParse(const DeferredParse&other): buffer(), DeferredParseBase<ContextType>(other)
	{
	}
	DeferredParse&operator=(const DeferredParse&other)
	{
		if(&other!=this)
		{
			this->~DeferredParse();
			new(this)DeferredParse(other);
		}
		return *this;
	}
};
struct ContextBase
{
	template<typename WalkerType>
	ParserGeneric<WalkerType>&getParser(WalkerType&walker, ParserOpaque*parser)
	{
		parser->walker=&walker;
		return *static_cast<ParserGeneric<WalkerType>*>(parser);
	}
};
template<typename Walker, typename T>
inline DeferredParse<typename Walker::State>makeDeferredParse(const Walker&walker, T*symbol)
{
	DeferredParseBase<typename Walker::State>result=
	{
		walker, symbol, DeferredParseThunk<Walker, T>::thunk
	};
	return result;
}
template<typename ListType>
inline void parseDeferred(ListType&deferred, ParserContext&context)
{
	const Token*position=context.position;
	for(typename ListType::iterator i=deferred.begin();
	i!=deferred.end();
	++i)
	{
		typename ListType::value_type&item=(*i);
		context.history.swap(item.buffer);
		context.position=context.error=context.history.tokens;
		void*result=item.func(context, item.context, item.symbol);
		if(result==0||context.position!=context.history.end()-1)
		{
			printError(context);
		}
		context.history.swap(item.buffer);
	}
	context.position=context.error=position;
}
template<typename ListType, typename ContextType, typename T, typename Func>
inline T*addDeferredParse(Parser&parser, ListType&deferred, ContextType&walker, Func skipFunc, T*symbol)
{
	const Token*first=parser.context.position;
	skipFunc(parser);
	size_t count=::distance(parser.context.history, first, parser.context.position);
	if(count!=0)
	{
		T*result=parseHit(parser, symbol);
		deferred.push_back(makeDeferredParse(walker, result));
		BacktrackBuffer buffer;
		buffer.resize(count+2);
		for(const Token*p=first;
		p!=parser.context.position;
		p=::next(parser.context.history, p))
		{
			*buffer.position++=*p;
		}
		FilePosition nullPos=
		{
			"$null.cpp", 0, 0
		};
		*buffer.position++=Token(boost::wave::T_EOF, TokenValue(), nullPos);
		deferred.back().buffer.swap(buffer);
		return result;
	}
	return 0;
}
template<typename WalkerType>
class ParserGeneric: public ParserOpaque
{
public:
	bool skip;
	ParserGeneric(ParserContext&context, WalkerType&walker): ParserOpaque(context, &walker), skip(false)
	{
	}
	WalkerType&getWalker()
	{
		return *static_cast<WalkerType*>(ParserOpaque::walker);
	}
	template<typename T, typename Base>
	inline cpp::symbol<Base>parseExpression(cpp::symbol_required<T>symbol, Base*result)
	{
		T tmp;
		if(parse(checkSymbolRequired(tmp.right)))
		{
			result=tmp.right;
			for(;
			;
			)
			{
				symbol=cpp::symbol_required<T>(0);
				if(!parse(symbol)||symbol->right==0)
				{
					break;
				}
				symbol->left=makeSymbolRequired(result);
				result=symbol;
			}
			return makeSymbol(result);
		}
		return cpp::symbol<Base>(0);
	}
	template<LexTokenId ID>
	ParseResult parseTerminal(cpp::terminal<ID>&t)
	{
		ParseResult result=::parseTerminal(*this, t);
		if(!t.value.empty())
		{
			WalkerType&walker=getWalker();
			walker.action(t);
		}
		return result;
	}
	template<typename Inner>
	static ParserGeneric<Inner>&getParser(Inner&walker, ParserOpaque*parser)
	{
		parser->walker=&walker;
		return *static_cast<ParserGeneric<Inner>*>(parser);
	}
	template<typename Symbol>
	bool cacheLookup(const CachedNull&, Symbol*&symbol, WalkerType&walker)
	{
		return false;
	}
	template<typename Symbol>
	void cacheStore(const CachedNull&, CachedSymbols::Key key, Symbol*symbol, const WalkerType&walker)
	{
	}
	template<typename Symbol>
	bool cacheLookup(const CachedLeaf&, Symbol*&symbol, WalkerType&walker)
	{
		int dummy;
		return Parser::cacheLookup(symbol, dummy);
	}
	template<typename Symbol>
	void cacheStore(const CachedLeaf&, CachedSymbols::Key key, Symbol*symbol, const WalkerType&walker)
	{
		int dummy;
		Parser::cacheStore(key, symbol, dummy);
	}
	template<typename Symbol>
	bool cacheLookup(const CachedWalk&, Symbol*&symbol, WalkerType&walker)
	{
		return Parser::cacheLookup(symbol, walker);
	}
	template<typename Symbol>
	void cacheStore(const CachedWalk&, CachedSymbols::Key key, Symbol*symbol, const WalkerType&walker)
	{
		Parser::cacheStore(key, symbol, walker);
	}
	bool isDeferredParse(const DeferDefault&, WalkerType&walker)
	{
		return false;
	}
	template<typename T>
	T*addDeferredParse(const DeferDefault&, WalkerType&walker, T*symbol)
	{
		return 0;
	}
	template<typename Defer>
	bool isDeferredParse(const Defer&, WalkerType&walker)
	{
		return Defer::isDeferredParse(walker);
	}
	template<typename Defer, typename T>
	T*addDeferredParse(const Defer&, WalkerType&walker, T*symbol)
	{
		return ::addDeferredParse(*this, Defer::getDeferredSymbolsList(walker), walker, Defer::getSkipFunc(walker), symbol);
	}
	template<typename T, typename Inner, typename Annotate, typename Action, typename Cache, typename Defer>
	T*visit(WalkerType&walker, T*symbol, const Inner&innerConst, const Annotate&, const Action&action, const Cache&cache, const Defer&defer)
	{
		Inner&inner=*const_cast<Inner*>(&innerConst);
		ParserGeneric<Inner>&innerParser=getParser(inner, this);
		typename Annotate::Data data=Annotate::makeData(*context.position);
		if(innerParser.isDeferredParse(defer, inner))
		{
			symbol=innerParser.addDeferredParse(defer, inner, symbol);
			if(symbol==0)
			{
				return 0;
			}
		}
		else if(!innerParser.cacheLookup(cache, symbol, inner))
		{
			CachedSymbols::Key key=context.position;
			symbol=makeParser(symbol).parseSymbol(innerParser, symbol);
			if(symbol==0)
			{
				return 0;
			}
			symbol=parseHit(*this, symbol);
			innerParser.cacheStore(cache, key, symbol, inner);
		}
		bool success=Action::invokeAction(walker, symbol, inner);
		if(success)
		{
			Annotate::annotate(symbol, data);
			return symbol;
		}
		return 0;
	}
	template<typename T, bool required>
	bool parse(cpp::symbol_generic<T, required>&s)
	{
		if(!(s.p==0))
		{
			throw ParseError();
		};
		if(!(!checkBacktrack(*this)))
		{
			throw ParseError();
		};
		ParserGeneric<WalkerType>tmp(*this);
		SymbolHolder<T>holder(context);
		WalkerType&walker=getWalker();
		T*result=tmp.visit(walker, holder.get(), makeInnerWalker(walker, walker.makePolicy(static_cast<T*>(0)).getInnerPolicy()), walker.makePolicy(static_cast<T*>(0)).getAnnotatePolicy(), walker.makePolicy(static_cast<T*>(0)).getActionPolicy(), walker.makePolicy(static_cast<T*>(0)).getCachePolicy(), walker.makePolicy(static_cast<T*>(0)).getDeferPolicy());
		if(result!=0)
		{
			position+=tmp.position;
			s=cpp::symbol_generic<T, required>(result);
			return true;
		}
		tmp.backtrack((typeid(T).name()+12));
		s=cpp::symbol_generic<T, required>(0);
		return !required;
	}
	template<typename T>
	bool parse(cpp::symbol_sequence<T>&s)
	{
		T tmp;
		cpp::symbol_next<T>p(&tmp);
		for(;
		;
		)
		{
			cpp::symbol_required<T>next=cpp::symbol_required<T>(0);
			if(!parse(next))
			{
				break;
			}
			p->next=cpp::symbol_next<T>(next);
			p=p->next;
		}
		s=cpp::symbol_sequence<T>(tmp.next);
		return true;
	}
	template<typename T>
	bool parse(cpp::symbol_next<T>&s)
	{
		return true;
	}
	template<LexTokenId ID>
	bool parse(cpp::terminal<ID>&t)
	{
		return parseTerminal(t)==PARSERESULT_PASS;
	}
	template<LexTokenId ID>
	bool parse(cpp::terminal_optional<ID>&t)
	{
		parseTerminal(t);
		return true;
	}
	template<LexTokenId ID>
	bool parse(cpp::terminal_suffix<ID>&t)
	{
		skip=parseTerminal(t)!=PARSERESULT_PASS;
		return !skip;
	}
};
template<typename T, size_t N>
struct ChoiceParser
{
};
template<typename T>
struct ChoiceParser<T, 1>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 2>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 3>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 4>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 5>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 6>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 7>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 8>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 9>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 10>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 11>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 12>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 13>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 14>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 15>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 16>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T>
struct ChoiceParser<T, 17>
{
	template<typename Walker>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};

		{
			cpp::symbol_required<typename TypeListNth<typename T::Choices, 0+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1>::Result>result;
			if(parser.parse(result))return result;
		};
		return result;
	}
};
template<typename T, typename Choices>
struct MakeParser
{
	typedef ChoiceParser<T, TypeListCount<typename T::Choices>::RESULT>Type;
};
struct DefaultParser;
template<typename T>
struct MakeParser<T, TypeListEnd>
{
	typedef DefaultParser Type;
};
template<typename T>
typename MakeParser<T, typename T::Choices>::Type makeParser(T*)
{
	return typename MakeParser<T, typename T::Choices>::Type();
}
inline void skipBraced(Parser&parser)
{
	while(!isToken((parser).get_id(), boost::wave::T_RIGHTBRACE))
	{
		if(!(!isToken((parser).get_id(), boost::wave::T_EOF)))
		{
			throw ParseError();
		};
		if(isToken((parser).get_id(), boost::wave::T_LEFTBRACE))
		{
			parser.increment();
			skipBraced(parser);
			parser.increment();
		}
		else
		{
			parser.increment();
		}
	}
}
inline void skipParenthesised(Parser&parser)
{
	while(!isToken((parser).get_id(), boost::wave::T_RIGHTPAREN))
	{
		if(!(!isToken((parser).get_id(), boost::wave::T_EOF)))
		{
			throw ParseError();
		};
		if(!(!isToken((parser).get_id(), boost::wave::T_SEMICOLON)))
		{
			throw ParseError();
		};
		if(isToken((parser).get_id(), boost::wave::T_LEFTPAREN))
		{
			parser.increment();
			skipParenthesised(parser);
			parser.increment();
		}
		else
		{
			parser.increment();
		}
	}
}
inline void skipTemplateArgumentList(Parser&parser)
{
	while(!isToken((parser).get_id(), boost::wave::T_GREATER))
	{
		if(!(!isToken((parser).get_id(), boost::wave::T_EOF)))
		{
			throw ParseError();
		};
		if(isToken((parser).get_id(), boost::wave::T_LEFTPAREN))
		{
			parser.increment();
			skipParenthesised(parser);
			parser.increment();
		}
		else
		{
			parser.increment();
		}
	}
}
template<typename Declare>
struct SkipParenthesised
{
	Declare declare;
	SkipParenthesised(Declare declare): declare(declare)
	{
	}
	inline void operator()(Parser&parser)const
	{
		while(!isToken((parser).get_id(), boost::wave::T_RIGHTPAREN))
		{
			if(!(!isToken((parser).get_id(), boost::wave::T_EOF)))
			{
				throw ParseError();
			};
			if(!(!isToken((parser).get_id(), boost::wave::T_SEMICOLON)))
			{
				throw ParseError();
			};
			if(isToken((parser).get_id(), boost::wave::T_CLASS)||isToken((parser).get_id(), boost::wave::T_STRUCT)||isToken((parser).get_id(), boost::wave::T_UNION))
			{
				parser.increment();
				if(!(isToken((parser).get_id(), boost::wave::T_IDENTIFIER)))
				{
					throw ParseError();
				};
				cpp::terminal_identifier id=
				{
					parser.get_value(), parser.get_source()
				};
				parser.increment();
				if(!isToken((parser).get_id(), boost::wave::T_LESS)&&!isToken((parser).get_id(), boost::wave::T_COLON_COLON))
				{
					declare(id);
				}
			}
			else if(isToken((parser).get_id(), boost::wave::T_LEFTPAREN))
			{
				parser.increment();
				(*this)(parser);
				parser.increment();
			}
			else
			{
				parser.increment();
			}
		}
	}
};
template<typename Declare>
inline SkipParenthesised<Declare>makeSkipParenthesised(Declare declare)
{
	return SkipParenthesised<Declare>(declare);
}
template<typename IsTemplateName>
struct SkipDefaultArgument
{
	IsTemplateName isTemplateName;
	SkipDefaultArgument(IsTemplateName isTemplateName): isTemplateName(isTemplateName)
	{
	}
	void operator()(Parser&parser)const
	{
		while(!isToken((parser).get_id(), boost::wave::T_RIGHTPAREN)&&!isToken((parser).get_id(), boost::wave::T_COMMA))
		{
			if(!(!isToken((parser).get_id(), boost::wave::T_EOF)))
			{
				throw ParseError();
			};
			if(!(!isToken((parser).get_id(), boost::wave::T_SEMICOLON)))
			{
				throw ParseError();
			};
			if(isToken((parser).get_id(), boost::wave::T_IDENTIFIER))
			{
				cpp::terminal_identifier id=
				{
					parser.get_value(), parser.get_source()
				};
				parser.increment();
				if(isToken((parser).get_id(), boost::wave::T_LESS)&&isTemplateName(id))
				{
					parser.increment();
					skipTemplateArgumentList(parser);
					parser.increment();
				}
			}
			else if(isToken((parser).get_id(), boost::wave::T_LEFTPAREN))
			{
				parser.increment();
				skipParenthesised(parser);
				parser.increment();
			}
			else
			{
				parser.increment();
			}
		}
	}
};
template<typename IsTemplateName>
inline SkipDefaultArgument<IsTemplateName>makeSkipDefaultArgument(IsTemplateName isTemplateName)
{
	return SkipDefaultArgument<IsTemplateName>(isTemplateName);
}
inline void skipMemInitializerClause(Parser&parser)
{
	parser.increment();
	while(!isToken((parser).get_id(), boost::wave::T_LEFTBRACE))
	{
		if(!(!isToken((parser).get_id(), boost::wave::T_EOF)))
		{
			throw ParseError();
		};
		if(!(!isToken((parser).get_id(), boost::wave::T_SEMICOLON)))
		{
			throw ParseError();
		};
		parser.increment();
	}
}
template<typename D, typename B>
inline bool abstractLess(const D&d, const B&b)
{
	return (typeid(d).before(typeid(b))||!(typeid(b).before(typeid(d)))&&d<*static_cast<const D*>(&b));
}
struct IndirectLess
{
	template<typename T, typename U>
	bool operator()(T left, U right)const
	{
		return *left<*right;
	}
};
template<typename Ptr>
struct IndirectSet
{
	typedef std::set<Ptr, IndirectLess>Set;
	Set elements;
	typedef typename Set::iterator iterator;
	iterator begin()
	{
		return elements.begin();
	}
	iterator end()
	{
		return elements.end();
	}
	template<typename T>
	iterator find(const T&value)
	{
		return elements.find(&value);
	}
	template<typename T>
	inline iterator insert(const T&value)
	{
		iterator i=elements.lower_bound(&value);
		if(i!=elements.end()&&!elements.key_comp()(&value, *i))
		{
			return i;
		}
		return elements.insert(i, new T(value));
	}
	void clear()
	{
		for(iterator i=elements.begin();
		i!=elements.end();
		++i)
		{
			delete&(*(*i));
		}
		elements.clear();
	}
};
template<typename Visitor>
struct SequenceNode
{
	Reference<SequenceNode>next;
	virtual~SequenceNode()
	{
	}
	virtual void accept(Visitor&visitor)const=0;
	const SequenceNode*get()const
	{
		return next.get();
	}
};
template<typename Visitor>
struct SequenceNodeEmpty: SequenceNode<Visitor>
{
	virtual void accept(Visitor&visitor)const
	{
		throw AllocatorError();
	}
	virtual bool operator<(const SequenceNode<Visitor>&other)const
	{
		throw AllocatorError();
	}
};
template<typename T, typename Visitor>
struct SequenceNodeGeneric: Reference<SequenceNode<Visitor> >::Value
{
	T value;
	SequenceNodeGeneric(const T&value): value(value)
	{
	}
	void accept(Visitor&visitor)const
	{
		visitor.visit(value);
	}
};
template<typename A, typename Visitor>
struct Sequence: A
{
	typedef SequenceNode<Visitor>Node;
	typedef Reference<Node>Pointer;
	SequenceNodeEmpty<Visitor>head;
	A&getAllocator()
	{
		return *this;
	}
	const A&getAllocator()const
	{
		return *this;
	}
	Sequence()
	{
		construct();
	}
	Sequence(const A&allocator): A(allocator)
	{
		construct();
	}
	Sequence&operator=(Sequence other)
	{
		head=other.head;
		return *this;
	}
	void construct()
	{
		head.next=0;
	}
	bool empty()const
	{
		return head.next==Pointer(0);
	}
	void clear()
	{
		construct();
	}
	template<typename T>
	void push_front(const T&value)
	{
		Pointer node=allocatorNew(getAllocator(), SequenceNodeGeneric<T, Visitor>(value));
		node->next=head.next;
		head.next=node;
	}
	template<typename T>
	void push_back(const T&value)
	{
		Pointer node=allocatorNew(getAllocator(), SequenceNodeGeneric<T, Visitor>(value));
		if(empty())
		{
			node->next=head.next;
			head.next=node;
		}
		else
		{
			Pointer last=head.next;
			for(Pointer next=last->next;
			next.get()!=0;
			next=next->next)
			{
				last=next;
			}
			node->next=0;
			last->next=node;
		}
	}
	void pop_front()
	{
		if(!(head.next.p->count==1))
		{
			throw AllocatorError();
		};
		if(!(!empty()))
		{
			throw AllocatorError();
		};
		Pointer node=head.next;
		head.next=node->next;
		allocatorDelete(getAllocator(), node.get());
	}
	void swap(Sequence&other)
	{
		head.next.swap(other.head.next);
	}
	void reverse()
	{
		if(!(head.next.p->count==1))
		{
			throw AllocatorError();
		};
		Pointer root=head.next;
		head.next=0;
		while(root!=0)
		{
			Pointer next=root->next;
			root->next=head.next;
			head.next=root;
			root=next;
		}
	}
	const Node*get()const
	{
		return head.next.get();
	}
	void accept(Visitor&visitor)const
	{
		for(const Node*node=get();
		node!=0;
		node=node->get())
		{
			node->accept(visitor);
		}
	}
};
template<typename Visitor>
const SequenceNode<Visitor>*findLast(const SequenceNode<Visitor>*node)
{
	if(!(node!=0))
	{
		throw AllocatorError();
	};
	const SequenceNode<Visitor>*next=node->get();
	if(next==0)
	{
		return node;
	}
	return findLast(next);
}
typedef AllocatorError SymbolsError;
struct DeclSpecifiers
{
	bool isTypedef;
	bool isFriend;
	bool isStatic;
	bool isExtern;
	bool isExplicit;
	DeclSpecifiers(): isTypedef(false), isFriend(false), isStatic(false), isExtern(false), isExplicit(false)
	{
	}
	DeclSpecifiers(bool isTypedef, bool isFriend, bool isStatic, bool isExtern): isTypedef(isTypedef), isFriend(isFriend), isStatic(isStatic), isExtern(isExtern), isExplicit(false)
	{
	}
};
const DeclSpecifiers DECLSPEC_TYPEDEF=DeclSpecifiers(true, false, false, false);
struct TypeSequenceVisitor
{
	virtual void visit(const struct DeclaratorPointerType&)=0;
	virtual void visit(const struct DeclaratorReferenceType&)=0;
	virtual void visit(const struct DeclaratorArrayType&)=0;
	virtual void visit(const struct DeclaratorMemberPointerType&)=0;
	virtual void visit(const struct DeclaratorFunctionType&)=0;
};
typedef Sequence<ParserAllocatorWrapper<int>, TypeSequenceVisitor>TypeSequence;
typedef cpp::terminal_identifier Identifier;
inline Identifier makeIdentifier(const char*value)
{
	Identifier result=
	{
		TokenValue(value)
	};
	return result;
}
const Identifier IDENTIFIER_NULL=Identifier();
inline const char*getValue(const Identifier&id)
{
	return id.value.empty()?"$unnamed": id.value.c_str();
}
typedef SafePtr<Identifier>IdentifierPtr;
typedef ListReference<struct TemplateArgument, ParserAllocatorWrapper<struct TemplateArgument> >TemplateArguments2;
struct TemplateArguments: public TemplateArguments2
{
	TemplateArguments(const ParserAllocatorWrapper<int>&allocator): TemplateArguments2(allocator)
	{
	}
private:
	TemplateArguments()
	{
	}
};
typedef ListReference<struct Type, ParserAllocatorWrapper<int> >Types2;
struct Types: public Types2
{
	Types(const ParserAllocatorWrapper<int>&allocator): Types2(allocator)
	{
	}
private:
	Types()
	{
	}
};
typedef ListReference<struct TypeId, ParserAllocatorWrapper<int> >TypeIds2;
struct TypeIds: public TypeIds2
{
	TypeIds(const ParserAllocatorWrapper<int>&allocator): TypeIds2(allocator)
	{
	}
private:
	TypeIds()
	{
	}
};
struct Type;
typedef Reference<const Type>TypePtr;
typedef CopiedReference<const Type, ParserAllocatorWrapper<int> >TypeRef;
typedef TypeRef Qualifying;
class Declaration;
typedef SafePtr<Declaration>DeclarationPtr;
struct Scope;
typedef SafePtr<Scope>ScopePtr;
const size_t INDEX_INVALID=size_t(-1);
struct Type
{
	IdentifierPtr id;
	DeclarationPtr declaration;
	TemplateArguments templateArguments;
	Qualifying qualifying;
	DeclarationPtr dependent;
	ScopePtr enclosingTemplate;
	UniqueType unique;
	bool isDependent;
	bool isImplicitTemplateId;
	bool isEnclosingClass;
	Type(Declaration*declaration, const ParserAllocatorWrapper<int>&allocator): id(0), declaration(declaration), templateArguments(allocator), qualifying(allocator), dependent(0), enclosingTemplate(0), unique(0), isDependent(false), isImplicitTemplateId(false), isEnclosingClass(false)
	{
	}
	void swap(Type&other)
	{
		std::swap(id, other.id);
		std::swap(declaration, other.declaration);
		templateArguments.swap(other.templateArguments);
		qualifying.swap(other.qualifying);
		std::swap(dependent, other.dependent);
		std::swap(enclosingTemplate, other.enclosingTemplate);
		std::swap(unique, other.unique);
		std::swap(isDependent, other.isDependent);
		std::swap(isImplicitTemplateId, other.isImplicitTemplateId);
		std::swap(isEnclosingClass, other.isEnclosingClass);
	}
	Type&operator=(Declaration*declaration)
	{
		if(!(templateArguments.empty()))
		{
			throw AllocatorError();
		};
		if(!(qualifying.empty()))
		{
			throw AllocatorError();
		};
		this->declaration=declaration;
		return *this;
	}
private:
	Type();
};
struct TypeId: Type
{
	TypeSequence typeSequence;
	CvQualifiers qualifiers;
	TypeId(Declaration*declaration, const ParserAllocatorWrapper<int>&allocator): Type(declaration, allocator), typeSequence(allocator)
	{
	}
	TypeId&operator=(Declaration*declaration)
	{
		if(!(typeSequence.empty()))
		{
			throw AllocatorError();
		};
		Type::operator=(declaration);
		return *this;
	}
	void swap(TypeId&other)
	{
		Type::swap(other);
		typeSequence.swap(other.typeSequence);
		std::swap(qualifiers, other.qualifiers);
	}
	void swap(Type&other)
	{
		if(!(typeSequence.empty()))
		{
			throw AllocatorError();
		};
		Type::swap(other);
	}
};
struct Dependent: DeclarationPtr
{
	Dependent(): DeclarationPtr(0)
	{
	}
};
struct IntegralConstant
{
	int value;
	IntegralConstant(): value(0)
	{
	}
	explicit IntegralConstant(int value): value(value)
	{
	}
	explicit IntegralConstant(double value): value(int(value))
	{
	}
	explicit IntegralConstant(size_t value): value(int(value))
	{
	}
};
typedef IntegralConstant(*UnaryIceOp)(IntegralConstant);
typedef IntegralConstant(*BinaryIceOp)(IntegralConstant, IntegralConstant);
typedef IntegralConstant(*TernaryIceOp)(IntegralConstant, IntegralConstant, IntegralConstant);
inline IntegralConstant identity(IntegralConstant left)
{
	return left;
}
inline IntegralConstant assign(IntegralConstant left, IntegralConstant right)
{
	return left=right;
}
inline IntegralConstant operator++(IntegralConstant left)
{
	return IntegralConstant(++left.value);
}
inline IntegralConstant operator--(IntegralConstant left)
{
	return IntegralConstant(--left.value);
}
inline IntegralConstant operator+(IntegralConstant left)
{
	return IntegralConstant(+left.value);
}
inline IntegralConstant operator-(IntegralConstant left)
{
	return IntegralConstant(-left.value);
}
inline IntegralConstant operator!(IntegralConstant left)
{
	return IntegralConstant(!left.value);
}
inline IntegralConstant operator~(IntegralConstant left)
{
	return IntegralConstant(~left.value);
}
inline IntegralConstant addressOf(IntegralConstant left)
{
	return IntegralConstant(0);
}
inline IntegralConstant dereference(IntegralConstant left)
{
	return IntegralConstant(0);
}
inline UnaryIceOp getUnaryIceOp(cpp::unary_expression_op*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::unary_operator::PLUSPLUS: return operator++;
		case cpp::unary_operator::MINUSMINUS: return operator--;
		case cpp::unary_operator::STAR: return dereference;
		case cpp::unary_operator::AND: return addressOf;
		case cpp::unary_operator::PLUS: return operator+;
		case cpp::unary_operator::MINUS: return operator-;
		case cpp::unary_operator::NOT: return operator!;
		case cpp::unary_operator::COMPL: return operator~;
		default: break;
	}
	throw SymbolsError();
}
inline BinaryIceOp getBinaryIceOp(cpp::pm_expression_default*symbol)
{
	return 0;
}
inline IntegralConstant operator*(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value*right.value);
}
inline IntegralConstant operator/(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value/right.value);
}
inline IntegralConstant operator%(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value%right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::multiplicative_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::multiplicative_operator::STAR: return operator*;
		case cpp::multiplicative_operator::DIVIDE: return operator/;
		case cpp::multiplicative_operator::PERCENT: return operator%;
		default: break;
	}
	throw SymbolsError();
}
inline IntegralConstant operator+(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value+right.value);
}
inline IntegralConstant operator-(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value-right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::additive_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::additive_operator::PLUS: return operator+;
		case cpp::additive_operator::MINUS: return operator-;
		default: break;
	}
	throw SymbolsError();
}
inline IntegralConstant operator<<(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value<<right.value);
}
inline IntegralConstant operator>>(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value>>right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::shift_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::shift_operator::SHIFTLEFT: return operator<<;
		case cpp::shift_operator::SHIFTRIGHT: return operator>>;
		default: break;
	}
	throw SymbolsError();
}
inline IntegralConstant operator<(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value<right.value);
}
inline IntegralConstant operator>(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value>right.value);
}
inline IntegralConstant operator<=(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value<=right.value);
}
inline IntegralConstant operator>=(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value>=right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::relational_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::relational_operator::LESS: return operator<;
		case cpp::relational_operator::GREATER: return operator>;
		case cpp::relational_operator::LESSEQUAL: return operator<=;
		case cpp::relational_operator::GREATEREQUAL: return operator>=;
		default: break;
	}
	throw SymbolsError();
}
inline IntegralConstant operator==(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value==right.value);
}
inline IntegralConstant operator!=(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value!=right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::equality_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::equality_operator::EQUAL: return operator==;
		case cpp::equality_operator::NOTEQUAL: return operator!=;
		default: break;
	}
	throw SymbolsError();
}
inline IntegralConstant operator&(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value&right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::and_expression_default*symbol)
{
	return operator&;
}
inline IntegralConstant operator^(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value^right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::exclusive_or_expression_default*symbol)
{
	return operator^;
}
inline IntegralConstant operator|(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value|right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::inclusive_or_expression_default*symbol)
{
	return operator|;
}
inline IntegralConstant operator&&(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value&&right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::logical_and_expression_default*symbol)
{
	return operator&&;
}
inline IntegralConstant operator||(IntegralConstant left, IntegralConstant right)
{
	return IntegralConstant(left.value||right.value);
}
inline BinaryIceOp getBinaryIceOp(cpp::logical_or_expression_default*symbol)
{
	return operator||;
}
inline BinaryIceOp getBinaryIceOp(cpp::assignment_expression_suffix*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::assignment_operator::ASSIGN: return assign;
		case cpp::assignment_operator::STAR: return operator*;
		case cpp::assignment_operator::DIVIDE: return operator/;
		case cpp::assignment_operator::PERCENT: return operator%;
		case cpp::assignment_operator::PLUS: return operator+;
		case cpp::assignment_operator::MINUS: return operator-;
		case cpp::assignment_operator::SHIFTRIGHT: return operator>>;
		case cpp::assignment_operator::SHIFTLEFT: return operator<<;
		case cpp::assignment_operator::AND: return operator&;
		case cpp::assignment_operator::XOR: return operator^;
		case cpp::assignment_operator::OR: return operator|;
		default: break;
	}
	throw SymbolsError();
}
inline IntegralConstant conditional(IntegralConstant first, IntegralConstant second, IntegralConstant third)
{
	return IntegralConstant(first.value?second.value: third.value);
}
struct ExpressionNodeVisitor
{
	virtual void visit(const struct IntegralConstantExpression&)=0;
	virtual void visit(const struct CastExpression&)=0;
	virtual void visit(const struct NonTypeTemplateParameter&)=0;
	virtual void visit(const struct DependentIdExpression&)=0;
	virtual void visit(const struct IdExpression&)=0;
	virtual void visit(const struct SizeofExpression&)=0;
	virtual void visit(const struct SizeofTypeExpression&)=0;
	virtual void visit(const struct UnaryExpression&)=0;
	virtual void visit(const struct BinaryExpression&)=0;
	virtual void visit(const struct TernaryExpression&)=0;
	virtual void visit(const struct TypeTraitsUnaryExpression&)=0;
	virtual void visit(const struct TypeTraitsBinaryExpression&)=0;
	virtual void visit(const struct ExplicitTypeExpression&)=0;
	virtual void visit(const struct ObjectExpression&)=0;
	virtual void visit(const struct DependentObjectExpression&)=0;
	virtual void visit(const struct ClassMemberAccessExpression&)=0;
	virtual void visit(const struct FunctionCallExpression&)=0;
	virtual void visit(const struct SubscriptExpression&)=0;
	virtual void visit(const struct PostfixOperatorExpression&)=0;
};
struct ExpressionNode
{
	ExpressionNode()
	{
	}
	virtual~ExpressionNode()
	{
	}
	virtual void accept(ExpressionNodeVisitor&visitor)const=0;
	virtual bool operator<(const ExpressionNode&other)const=0;
};
typedef SafePtr<ExpressionNode>ExpressionPtr;
template<typename T>
struct ExpressionNodeGeneric: ExpressionNode
{
	T value;
	ExpressionNodeGeneric(const T&value): value(value)
	{
	}
	void accept(ExpressionNodeVisitor&visitor)const
	{
		visitor.visit(value);
	}
	bool operator<(const ExpressionNodeGeneric&other)const
	{
		return value<other.value;
	}
	bool operator<(const ExpressionNode&other)const
	{
		return abstractLess(*this, other);
	}
};
typedef ExpressionNode*UniqueExpression;
typedef IndirectSet<UniqueExpression>UniqueExpressions;
extern UniqueExpressions gBuiltInExpressions;
extern UniqueExpressions gUniqueExpressions;
template<typename T>
inline UniqueExpression makeBuiltInExpression(const T&value)
{
	ExpressionNodeGeneric<T>node(value);
	return *gBuiltInExpressions.insert(node);
}
template<typename T>
inline UniqueExpression makeUniqueExpression(const T&value)
{
	ExpressionNodeGeneric<T>node(value);

	{
		UniqueExpressions::iterator i=gBuiltInExpressions.find(node);
		if(i!=gBuiltInExpressions.end())
		{
			return *i;
		}
	}
	return *gUniqueExpressions.insert(node);
}
struct Location: Source
{
	std::size_t pointOfInstantiation;
	Location()
	{
	}
	Location(Source source, std::size_t pointOfInstantiation): Source(source), pointOfInstantiation(pointOfInstantiation)
	{
	}
};
struct SimpleType;
struct InstantiationContext;
inline IntegralConstant evaluate(ExpressionNode*node, const InstantiationContext&context);
struct ExpressionWrapper: ExpressionPtr
{
	bool isConstant;
	bool isTypeDependent;
	bool isValueDependent;
	bool isTemplateArgumentAmbiguity;
	bool isNonStaticMemberName;
	bool isQualifiedNonStaticMemberName;
	ExpressionWrapper(): ExpressionPtr(0), isConstant(false), isTypeDependent(false), isValueDependent(false), isTemplateArgumentAmbiguity(false), isNonStaticMemberName(false), isQualifiedNonStaticMemberName(false)
	{
	}
	ExpressionWrapper(ExpressionNode*node, bool isConstant=true, bool isTypeDependent=false, bool isValueDependent=false): ExpressionPtr(node), isConstant(isConstant), isTypeDependent(isTypeDependent), isValueDependent(isValueDependent), isTemplateArgumentAmbiguity(false), isNonStaticMemberName(false), isQualifiedNonStaticMemberName(false)
	{
	}
};
struct TemplateArgument
{
	TypeId type;
	Dependent valueDependent;
	ExpressionWrapper expression;
	Location source;
	TemplateArgument(const ParserAllocatorWrapper<int>&allocator): type(0, allocator)
	{
	}
	void swap(TemplateArgument&other)
	{
		type.swap(other.type);
		std::swap(valueDependent, other.valueDependent);
		std::swap(expression, other.expression);
	}
};
const TemplateArguments TEMPLATEARGUMENTS_NULL=TemplateArguments(ParserAllocatorWrapper<int>(NullParserAllocator()));
struct TemplateParameter: Type
{
	TemplateArgument argument;
	TemplateParameter(const ParserAllocatorWrapper<int>&allocator): Type(0, allocator), argument(allocator)
	{
	}
	void swap(TemplateParameter&other)
	{
		Type::swap(other);
		argument.swap(other.argument);
	}
	Type&operator=(Declaration*declaration)
	{
		return Type::operator=(declaration);
	}
};
struct TemplateParameters: Types
{
	TemplateArguments defaults;
	TemplateParameters(const ParserAllocatorWrapper<int>&allocator): Types(allocator), defaults(allocator)
	{
	}
	void swap(TemplateParameters&other)
	{
		Types::swap(other);
		defaults.swap(other.defaults);
	}
	void push_front(const TemplateParameter&other)
	{
		Types::push_front(other);
		defaults.push_front(other.argument);
	}
};
const TemplateParameters TEMPLATEPARAMETERS_NULL=TemplateParameters(ParserAllocatorWrapper<int>(NullParserAllocator()));
class Declaration
{
	Identifier*name;
public:
	std::size_t uniqueId;
	Scope*scope;
	TypeId type;
	Scope*enclosed;
	Scope*templateParamScope;
	Declaration*overloaded;
	Dependent valueDependent;
	ExpressionWrapper initializer;
	DeclSpecifiers specifiers;
	std::size_t templateParameter;
	TemplateParameters templateParams;
	TemplateArguments templateArguments;
	bool isComplete;
	bool isTemplate;
	bool isTemplateName;
	bool isSpecialization;
	bool isFunctionDefinition;
	std::size_t instance;
	Declaration(const ParserAllocatorWrapper<int>&allocator, Scope*scope, Identifier&name, const TypeId&type, Scope*enclosed, DeclSpecifiers specifiers=DeclSpecifiers(), bool isTemplate=false, const TemplateParameters&templateParams=TEMPLATEPARAMETERS_NULL, bool isSpecialization=false, const TemplateArguments&templateArguments=TEMPLATEARGUMENTS_NULL, size_t templateParameter=INDEX_INVALID, const Dependent&valueDependent=Dependent()): name(&name), uniqueId(0), scope(scope), type(type), enclosed(enclosed), templateParamScope(0), overloaded(0), valueDependent(valueDependent), specifiers(specifiers), templateParameter(templateParameter), templateParams(templateParams), templateArguments(templateArguments), isComplete(false), isTemplate(isTemplate), isTemplateName(isTemplate), isSpecialization(isSpecialization), isFunctionDefinition(false), instance(INDEX_INVALID)
	{
	}
	Declaration(): type(0, ParserAllocatorWrapper<int>(NullParserAllocator())), templateParams(ParserAllocatorWrapper<int>(NullParserAllocator())), templateArguments(ParserAllocatorWrapper<int>(NullParserAllocator()))
	{
	}
	void swap(Declaration&other)
	{
		std::swap(name, other.name);
		std::swap(uniqueId, other.uniqueId);
		std::swap(scope, other.scope);
		type.swap(other.type);
		std::swap(enclosed, other.enclosed);
		std::swap(templateParamScope, other.templateParamScope);
		std::swap(overloaded, other.overloaded);
		std::swap(valueDependent, other.valueDependent);
		std::swap(initializer, other.initializer);
		std::swap(specifiers, other.specifiers);
		std::swap(templateParameter, other.templateParameter);
		templateParams.swap(other.templateParams);
		templateArguments.swap(other.templateArguments);
		std::swap(isComplete, other.isComplete);
		std::swap(isTemplate, other.isTemplate);
		std::swap(isTemplateName, other.isTemplateName);
		std::swap(isSpecialization, other.isSpecialization);
		std::swap(isFunctionDefinition, other.isFunctionDefinition);
		std::swap(instance, other.instance);
	}
	Identifier&getName()
	{
		return *name;
	}
	const Identifier&getName()const
	{
		return *name;
	}
	void setName(Identifier&other)
	{
		name=&other;
	}
};
typedef SafePtr<Declaration>DeclarationPtr;
struct UniqueName: public Identifier
{
	char buffer[10];
	UniqueName(size_t index)
	{
		sprintf(buffer, "$%x", unsigned(index));
		Identifier::value=TokenValue(buffer);
	}
};
typedef std::vector<UniqueName*>UniqueNames;
extern UniqueNames gUniqueNames;
enum ScopeType
{
	SCOPETYPE_UNKNOWN, SCOPETYPE_NAMESPACE, SCOPETYPE_PROTOTYPE, SCOPETYPE_LOCAL, SCOPETYPE_CLASS, SCOPETYPE_TEMPLATE,
};
extern size_t gScopeCount;
struct ScopeCounter
{
	ScopeCounter()
	{
		++gScopeCount;
	}
	ScopeCounter(const ScopeCounter&)
	{
		++gScopeCount;
	}
	~ScopeCounter()
	{
		--gScopeCount;
	}
};
const std::size_t VISIBILITY_ALL=0xffffffff;
struct DeclarationInstance: DeclarationPtr
{
	Identifier*name;
	const DeclarationInstance*overloaded;
	const DeclarationInstance*redeclared;
	std::size_t visibility;
	DeclarationInstance(): DeclarationPtr(0), name(0), overloaded(0), redeclared(0), visibility(VISIBILITY_ALL)
	{
	}
	explicit DeclarationInstance(Declaration*declaration, std::size_t visibility=0): DeclarationPtr(declaration), name(declaration!=0?&declaration->getName(): 0), overloaded(0), redeclared(0), visibility(visibility)
	{
		if(!(name!=0))
		{
			throw AllocatorError();
		};
	}
};
inline bool operator<(const DeclarationInstance&l, const DeclarationInstance&r)
{
	return l.name<r.name;
}
inline cpp::terminal_identifier&getDeclarationId(const DeclarationInstance*declaration)
{
	return (*declaration)->getName();
}
inline bool isDecorated(const Identifier&id)
{
	return id.dec.p!=0;
}
inline const DeclarationInstance&getDeclaration(const Identifier&id)
{
	if(!(isDecorated(id)))
	{
		throw AllocatorError();
	};
	return *id.dec.p;
}
struct Scope: public ScopeCounter
{
	ScopePtr parent;
	Identifier name;
	size_t enclosedScopeCount;
	typedef std::less<TokenValue>IdentifierLess;
	typedef std::multimap<TokenValue, DeclarationInstance, IdentifierLess, ParserAllocatorWrapper<int> >Declarations2;
	struct Declarations: public Declarations2
	{
		Declarations(const ParserAllocatorWrapper<int>&allocator): Declarations2(IdentifierLess(), allocator)
		{
		}
		Declarations(const Declarations&other): Declarations2(other)
		{
			if(!(other.empty()))
			{
				throw AllocatorError();
			};
		}
		~Declarations()
		{
			if(!(Declarations2::empty()))
			{
				throw AllocatorError();
			};
			new(static_cast<Declarations2*>(this))Declarations2(IdentifierLess(), ParserAllocatorWrapper<int>(NullParserAllocator()));
		}
		const DeclarationInstance&insert(const DeclarationInstance&declaration)
		{
			if(!(declaration.name!=0))
			{
				throw AllocatorError();
			};
			Declarations2::iterator result=Declarations2::insert(Declarations2::value_type(declaration.name->value, declaration));
			return (*result).second;
		}
	};
	Declarations declarations;
	ScopeType type;
	Types bases;
	typedef List<ScopePtr, ParserAllocatorWrapper<int> >Scopes;
	Scopes usingDirectives;
	typedef List<DeclarationPtr, ParserAllocatorWrapper<int> >DeclarationList;
	DeclarationList declarationList;
	size_t templateDepth;
	Scope(const ParserAllocatorWrapper<int>&allocator, const Identifier&name, ScopeType type=SCOPETYPE_UNKNOWN): parent(0), name(name), enclosedScopeCount(0), declarations(allocator), type(type), bases(allocator), usingDirectives(allocator), declarationList(allocator), templateDepth(0)
	{
	}
	~Scope()
	{
	}
	Identifier&getUniqueName()
	{
		if(enclosedScopeCount==gUniqueNames.size())
		{
			gUniqueNames.push_back(new UniqueName(enclosedScopeCount));
		}
		return *gUniqueNames[enclosedScopeCount++];
	}
private:

};
inline Scope::Declarations::iterator findDeclaration(Scope::Declarations&declarations, const DeclarationInstance*declaration)
{
	const Identifier&id=*declaration->name;
	Scope::Declarations::iterator i=declarations.upper_bound(id.value);
	for(;
	i!=declarations.begin()&&(*--i).first==id.value;
	)
	{
		if(&(*i).second==declaration)
		{
			return i;
		}
	}
	return declarations.end();
}
inline void undeclare(const DeclarationInstance*p, LexerAllocator&allocator)
{
	if(!(p->name->dec.p==0||p->name->dec.p==p))
	{
		throw AllocatorError();
	};
	p->name->dec.p=0;
	Declaration*declaration=*p;
	if(!(!declaration->scope->declarations.empty()))
	{
		throw AllocatorError();
	};
	if(!(!declaration->scope->declarationList.empty()))
	{
		throw AllocatorError();
	};
	if(!(declaration==declaration->scope->declarationList.back()))
	{
		throw AllocatorError();
	};
	declaration->scope->declarationList.pop_back();
	Scope::Declarations::iterator i=findDeclaration(declaration->scope->declarations, p);
	if(!(i!=declaration->scope->declarations.end()))
	{
		throw AllocatorError();
	};
	declaration->scope->declarations.erase(i);
}
inline BacktrackCallback makeUndeclareCallback(const DeclarationInstance*p)
{
	BacktrackCallback result=
	{
		BacktrackCallbackThunk<const DeclarationInstance, undeclare>::thunk, const_cast<DeclarationInstance*>(p)
	};
	return result;
}
static void backtrackError(void*data, LexerAllocator&allocator)
{
	throw SymbolsError();
}
inline BacktrackCallback makeBacktrackErrorCallback()
{
	BacktrackCallback result=
	{
		backtrackError, 0
	};
	return result;
}
inline const Scope&nullScope()
{
	static Scope null(ParserAllocatorWrapper<int>(NullParserAllocator()), IDENTIFIER_NULL);
	return null;
}
inline bool enclosesEts(ScopeType type)
{
	return type==SCOPETYPE_NAMESPACE||type==SCOPETYPE_LOCAL;
}
inline Scope*getEnclosingClass(Scope*scope)
{
	for(;
	scope!=0;
	scope=scope->parent)
	{
		if(scope->type==SCOPETYPE_CLASS&&*scope->name.value.c_str()!='$')
		{
			return scope;
		}
	}
	return 0;
}
extern Identifier gGlobalId;
inline Scope*getEnclosingNamespace(Scope*scope)
{
	for(;
	scope!=0;
	scope=scope->parent)
	{
		if(scope->type==SCOPETYPE_NAMESPACE&&scope->name.value!=gGlobalId.value)
		{
			return scope;
		}
	}
	return 0;
}
extern Declaration gArithmetic;
extern Declaration gSpecial;
extern Declaration gClass;
extern Declaration gEnum;
extern Declaration gNamespace;
extern Declaration gCtor;
extern Declaration gUnknown;
inline bool isTemplate(const Scope&scope)
{
	return scope.templateDepth!=0;
}
inline bool isType(const Declaration&type)
{
	return type.specifiers.isTypedef||type.type.declaration==&gArithmetic||type.type.declaration==&gSpecial||type.type.declaration==&gEnum||type.type.declaration==&gClass;
}
inline bool isFunction(const Declaration&declaration)
{
	return declaration.enclosed!=0&&declaration.enclosed->type==SCOPETYPE_PROTOTYPE;
}
inline bool isMember(const Declaration&declaration)
{
	return declaration.scope!=0&&declaration.scope->type==SCOPETYPE_CLASS;
}
inline bool isMemberOfTemplate(const Declaration&declaration)
{
	return isMember(declaration)&&isTemplate(*declaration.scope);
}
inline bool isNonMember(const Declaration&declaration)
{
	return !isMember(declaration);
}
inline bool isMemberObject(const Declaration&declaration)
{
	return isMember(declaration)&&!isFunction(declaration);
}
inline bool isMemberFunction(const Declaration&declaration)
{
	return isMember(declaration)&&isFunction(declaration);
}
inline bool isStatic(const Declaration&declaration)
{
	return declaration.specifiers.isStatic;
}
inline bool isStaticMember(const Declaration&declaration)
{
	return isMemberObject(declaration)&&isStatic(declaration);
}
inline bool isTypedef(const Declaration&declaration)
{
	return declaration.specifiers.isTypedef;
}
inline bool isClassKey(const Declaration&declaration)
{
	return &declaration==&gClass;
}
inline bool isClass(const Declaration&declaration)
{
	return declaration.type.declaration==&gClass;
}
inline bool isEnum(const Declaration&declaration)
{
	return declaration.type.declaration==&gEnum;
}
inline bool isComplete(const Declaration&declaration)
{
	return declaration.enclosed!=0;
}
inline bool isIncomplete(const Declaration&declaration)
{
	return declaration.enclosed==0;
}
inline bool isElaboratedType(const Declaration&declaration)
{
	return (isClass(declaration)||isEnum(declaration))&&isIncomplete(declaration);
}
inline bool isNamespace(const Declaration&declaration)
{
	return declaration.type.declaration==&gNamespace;
}
inline bool isObject(const Declaration&declaration)
{
	return !isType(declaration)&&!isNamespace(declaration);
}
inline bool isExtern(const Declaration&declaration)
{
	return declaration.specifiers.isExtern;
}
inline bool isSpecialization(const Declaration&declaration)
{
	return declaration.isSpecialization;
}
struct LookupFilter
{
	typedef bool(*Function)(void*context, const DeclarationInstance&declaration);
	Function function;
	void*context;
	bool operator()(const DeclarationInstance&declaration)
	{
		return function(context, declaration);
	}
};
inline bool isAny(const Declaration&declaration)
{
	return declaration.type.declaration!=&gCtor;
}
template<typename T>
struct LookupFilterThunk
{
	static bool apply(void*context, const DeclarationInstance&declaration)
	{
		return (*static_cast<T*>(context))(*declaration);
	}
};
template<typename T>
LookupFilter makeLookupFilter(T&filter)
{
	LookupFilter result=
	{
		LookupFilterThunk<T>::apply, &filter
	};
	return result;
}
template<bool filter(const Declaration&declaration)>
struct LookupFilterDefault: LookupFilter
{
	explicit LookupFilterDefault(std::size_t visibility=VISIBILITY_ALL)
	{
		LookupFilter::context=reinterpret_cast<void*>(visibility);
		LookupFilter::function=apply;
	}
	static bool apply(void*context, const DeclarationInstance&declaration)
	{
		std::size_t visibility=reinterpret_cast<std::size_t>(context);
		return declaration.visibility<visibility&&filter(*declaration);
	}
};
typedef LookupFilterDefault<isAny>IsAny;
inline bool isConstructor(const Declaration&declaration)
{
	return declaration.type.declaration==&gCtor;
}
typedef LookupFilterDefault<isConstructor>IsConstructor;
inline bool isTypeName(const Declaration&declaration)
{
	return isType(declaration);
}
typedef LookupFilterDefault<isTypeName>IsTypeName;
inline bool isNamespaceName(const Declaration&declaration)
{
	return isNamespace(declaration);
}
typedef LookupFilterDefault<isNamespaceName>IsNamespaceName;
inline bool isTemplateName(const Declaration&declaration)
{
	return declaration.isTemplateName;
}
inline bool isNestedName(const Declaration&declaration)
{
	return isTypeName(declaration)||isNamespaceName(declaration);
}
typedef LookupFilterDefault<isNestedName>IsNestedName;
inline bool isNonMemberName(const Declaration&declaration)
{
	return isNonMember(declaration);
}
typedef LookupFilterDefault<isNonMemberName>IsNonMemberName;
inline bool isFunctionName(const Declaration&declaration)
{
	return isFunction(declaration);
}
typedef LookupFilterDefault<isFunctionName>IsFunctionName;
struct TypeElementVisitor
{
	virtual void visit(const struct DependentType&)=0;
	virtual void visit(const struct DependentTypename&)=0;
	virtual void visit(const struct DependentNonType&)=0;
	virtual void visit(const struct TemplateTemplateArgument&)=0;
	virtual void visit(const struct NonType&)=0;
	virtual void visit(const struct SimpleType&)=0;
	virtual void visit(const struct PointerType&)=0;
	virtual void visit(const struct ReferenceType&)=0;
	virtual void visit(const struct ArrayType&)=0;
	virtual void visit(const struct MemberPointerType&)=0;
	virtual void visit(const struct FunctionType&)=0;
};
struct TypeElement
{
	UniqueType next;
	TypeElement()
	{
	}
	virtual~TypeElement()
	{
	}
	virtual void accept(TypeElementVisitor&visitor)const=0;
	virtual bool operator<(const TypeElement&other)const=0;
};
struct TypeElementEmpty: TypeElement
{
	TypeElementEmpty()
	{
		next=0;
	}
	virtual void accept(TypeElementVisitor&visitor)const
	{
		throw SymbolsError();
	}
	virtual bool operator<(const TypeElement&other)const
	{
		throw SymbolsError();
	}
};
extern const TypeElementEmpty gTypeElementEmpty;
template<typename T>
struct TypeElementGeneric: TypeElement
{
	T value;
	TypeElementGeneric(const T&value): value(value)
	{
	}
	void accept(TypeElementVisitor&visitor)const
	{
		visitor.visit(value);
	}
	bool operator<(const TypeElementGeneric&other)const
	{
		return value<other.value;
	}
	bool operator<(const TypeElement&other)const
	{
		return next!=other.next?next<other.next: abstractLess(*this, other);
	}
};
const UniqueType UNIQUETYPE_NULL=&gTypeElementEmpty;
typedef IndirectSet<UniqueType>UniqueTypes;
extern UniqueTypes gBuiltInTypes;
template<typename T>
inline UniqueType pushBuiltInType(UniqueType type, const T&value)
{
	TypeElementGeneric<T>node(value);
	node.next=type;
	return *gBuiltInTypes.insert(node);
}
template<typename T>
inline UniqueType pushUniqueType(UniqueTypes&types, UniqueType type, const T&value)
{
	TypeElementGeneric<T>node(value);
	node.next=type;

	{
		UniqueTypes::iterator i=gBuiltInTypes.find(node);
		if(i!=gBuiltInTypes.end())
		{
			return *i;
		}
	}
	return *types.insert(node);
}
extern UniqueTypes gUniqueTypes;
template<typename T>
inline void pushUniqueType(UniqueType&type, const T&value)
{
	type=pushUniqueType(gUniqueTypes, type, value);
}
inline void popUniqueType(UniqueType&type)
{
	if(!(type.getBits()!=0))
	{
		throw AllocatorError();
	};
	type=type->next;
}
struct UniqueTypeWrapper
{
	UniqueType value;
	UniqueTypeWrapper(): value(&gTypeElementEmpty)
	{
	}
	explicit UniqueTypeWrapper(UniqueType value): value(value)
	{
	}
	template<typename T>
	void push_front(const T&t)
	{
		pushUniqueType(value, t);
	}
	void pop_front()
	{
		if(!(value!=0))
		{
			throw AllocatorError();
		};
		if(!(value!=UNIQUETYPE_NULL))
		{
			throw AllocatorError();
		};
		popUniqueType(value);
	}
	void swap(UniqueTypeWrapper&other)
	{
		std::swap(value, other.value);
	}
	bool empty()const
	{
		return value==UNIQUETYPE_NULL;
	}
	bool isSimple()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<SimpleType>);
	}
	bool isPointer()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<PointerType>);
	}
	bool isReference()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<ReferenceType>);
	}
	bool isArray()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<ArrayType>);
	}
	bool isMemberPointer()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<MemberPointerType>);
	}
	bool isFunction()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<FunctionType>);
	}
	bool isDependentNonType()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<DependentNonType>);
	}
	bool isDependentType()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<DependentType>);
	}
	bool isDependent()const
	{
		return isDependentType()||typeid(*value)==typeid(TypeElementGeneric<DependentTypename>)||isDependentNonType();
	}
	bool isNonType()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<NonType>);
	}
	bool isTemplateTemplateArgument()const
	{
		return typeid(*value)==typeid(TypeElementGeneric<TemplateTemplateArgument>);
	}
	bool isSimplePointer()const
	{
		return isPointer()&&UniqueTypeWrapper(value->next).isSimple();
	}
	bool isSimpleReference()const
	{
		return isReference()&&UniqueTypeWrapper(value->next).isSimple();
	}
	bool isSimpleArray()const
	{
		return isArray()&&UniqueTypeWrapper(value->next).isSimple();
	}
	bool isFunctionPointer()const
	{
		return isPointer()&&UniqueTypeWrapper(value->next).isFunction();
	}
};
template<typename T>
inline UniqueTypeWrapper pushType(UniqueTypeWrapper type, const T&t)
{
	pushUniqueType(type.value, t);
	return type;
}
template<typename T>
inline UniqueTypeWrapper pushBuiltInType(UniqueTypeWrapper type, const T&value)
{
	return UniqueTypeWrapper(pushBuiltInType(type.value, value));
}
inline UniqueTypeWrapper popType(UniqueTypeWrapper type)
{
	type.pop_front();
	return type;
}
inline UniqueTypeWrapper qualifyType(UniqueTypeWrapper type, CvQualifiers qualifiers)
{
	type.value.setQualifiers(qualifiers);
	return type;
}
inline bool operator==(UniqueTypeWrapper l, UniqueTypeWrapper r)
{
	return l.value==r.value;
}
inline bool operator!=(UniqueTypeWrapper l, UniqueTypeWrapper r)
{
	return !operator==(l, r);
}
inline bool operator<(UniqueTypeWrapper l, UniqueTypeWrapper r)
{
	return l.value<r.value;
}
inline bool isGreaterCvQualification(CvQualifiers l, CvQualifiers r)
{
	return l.isConst+l.isVolatile>r.isConst+r.isVolatile;
}
inline bool isGreaterCvQualification(UniqueTypeWrapper to, UniqueTypeWrapper from)
{
	return isGreaterCvQualification(to.value.getQualifiers(), from.value.getQualifiers());
}
inline bool isEqualCvQualification(UniqueTypeWrapper to, UniqueTypeWrapper from)
{
	return to.value.getQualifiers()==from.value.getQualifiers();
}
struct Parameter
{
	DeclarationPtr declaration;
	cpp::default_argument*defaultArgument;
	Parameter(Declaration*declaration, cpp::default_argument*defaultArgument): declaration(declaration), defaultArgument(defaultArgument)
	{
	}
};
struct Parameters: std::vector<Parameter>
{
	bool isEllipsis;
	Parameters(): isEllipsis(false)
	{
	}
};
typedef UniqueTypeWrapper UniqueTypeId;
const UniqueTypeId gUniqueTypeNull=UniqueTypeId(UNIQUETYPE_NULL);
inline bool isEqual(const UniqueTypeId&l, const UniqueTypeId&r)
{
	return l.value==r.value;
}
inline UniqueType getInner(UniqueType type)
{
	if(!(typeid(*type)!=typeid(TypeElementGeneric<struct SimpleType>)))
	{
		throw AllocatorError();
	};
	return type->next;
}
inline bool isEqualInner(const UniqueTypeId&l, const UniqueTypeId&r)
{
	return getInner(l.value)==getInner(r.value);
}
inline bool isSameType(const UniqueTypeId&l, const UniqueTypeId&r)
{
	return typeid(*l.value)==typeid(*r.value);
}
struct NonType: IntegralConstant
{
	explicit NonType(IntegralConstant value): IntegralConstant(value)
	{
	}
};
inline bool operator<(const NonType&left, const NonType&right)
{
	return left.value<right.value;
}
inline const NonType&getNonTypeValue(UniqueType type)
{
	if(!(typeid(*type)==typeid(TypeElementGeneric<NonType>)))
	{
		throw AllocatorError();
	};
	return static_cast<const TypeElementGeneric<NonType>*>(type.getPointer())->value;
}
typedef std::vector<UniqueTypeWrapper>UniqueTypeArray;
typedef UniqueTypeArray TemplateArgumentsInstance;
typedef UniqueTypeArray InstantiatedTypes;
typedef std::vector<const struct SimpleType*>UniqueBases;
struct ChildInstantiation
{
	const struct SimpleType*instance;
	Location source;
	ChildInstantiation(const struct SimpleType*instance, Location source): instance(instance), source(source)
	{
	}
};
typedef std::vector<ChildInstantiation>ChildInstantiations;
typedef std::vector<Location>InstanceLocations;
struct SimpleType
{
	std::size_t uniqueId;
	DeclarationPtr primary;
	DeclarationPtr declaration;
	TemplateArgumentsInstance templateArguments;
	TemplateArgumentsInstance deducedArguments;
	const SimpleType*enclosing;
	UniqueBases bases;
	size_t size;
	InstantiatedTypes children;
	InstanceLocations childLocations;
	bool instantiated;
	bool instantiating;
	bool allowLookup;
	mutable bool visited;
	mutable bool dumped;
	Location instantiation;
	ChildInstantiations childInstantiations;
	SimpleType(Declaration*declaration, const SimpleType*enclosing): uniqueId(0), primary(declaration), declaration(declaration), enclosing(enclosing), size(0), instantiated(false), instantiating(false), allowLookup(false), visited(false), dumped(false)
	{
		if(!(enclosing==0||isClass(*enclosing->declaration)))
		{
			throw AllocatorError();
		};
	}
};
inline bool operator==(const SimpleType&left, const SimpleType&right)
{
	return left.primary.p==right.primary.p&&left.enclosing==right.enclosing&&left.templateArguments==right.templateArguments;
}
inline bool operator<(const SimpleType&left, const SimpleType&right)
{
	return left.primary.p!=right.primary.p?left.primary.p<right.primary.p: left.enclosing!=right.enclosing?left.enclosing<right.enclosing: left.templateArguments!=right.templateArguments?left.templateArguments<right.templateArguments: false;
}
inline const SimpleType&getSimpleType(UniqueType type)
{
	if(!(typeid(*type)==typeid(TypeElementGeneric<SimpleType>)))
	{
		throw AllocatorError();
	};
	return static_cast<const TypeElementGeneric<SimpleType>*>(type.getPointer())->value;
}
struct TemplateTemplateArgument
{
	DeclarationPtr declaration;
	const SimpleType*enclosing;
	TemplateTemplateArgument(Declaration*declaration, const SimpleType*enclosing): declaration(declaration), enclosing(enclosing)
	{
	}
};
inline bool operator<(const TemplateTemplateArgument&left, const TemplateTemplateArgument&right)
{
	return left.declaration.p<right.declaration.p;
}
inline const TemplateTemplateArgument&getTemplateTemplateArgument(UniqueType type)
{
	if(!(typeid(*type)==typeid(TypeElementGeneric<TemplateTemplateArgument>)))
	{
		throw AllocatorError();
	};
	return static_cast<const TypeElementGeneric<TemplateTemplateArgument>*>(type.getPointer())->value;
}
struct DependentType
{
	DeclarationPtr type;
	TemplateArgumentsInstance templateArguments;
	std::size_t templateParameterCount;
	DependentType(Declaration*type, TemplateArgumentsInstance templateArguments=TemplateArgumentsInstance(), std::size_t templateParameterCount=0): type(type), templateArguments(templateArguments), templateParameterCount(templateParameterCount)
	{
		if(!(type->templateParameter!=INDEX_INVALID))
		{
			throw AllocatorError();
		};
	}
};
inline bool operator<(const DependentType&left, const DependentType&right)
{
	return left.templateParameterCount!=right.templateParameterCount?left.templateParameterCount<right.templateParameterCount: left.type->scope->templateDepth!=right.type->scope->templateDepth?left.type->scope->templateDepth<right.type->scope->templateDepth: left.type->templateParameter!=right.type->templateParameter?left.type->templateParameter<right.type->templateParameter: left.templateArguments<right.templateArguments;
}
inline const DependentType&getDependentType(UniqueType type)
{
	if(!(typeid(*type)==typeid(TypeElementGeneric<DependentType>)))
	{
		throw AllocatorError();
	};
	return static_cast<const TypeElementGeneric<DependentType>*>(type.getPointer())->value;
}
struct DependentTypename
{
	Name name;
	UniqueTypeWrapper qualifying;
	TemplateArgumentsInstance templateArguments;
	bool isNested;
	bool isTemplate;
	DependentTypename(Name name, UniqueTypeWrapper qualifying, TemplateArgumentsInstance templateArguments, bool isNested, bool isTemplate): name(name), qualifying(qualifying), templateArguments(templateArguments), isNested(isNested), isTemplate(isTemplate)
	{
	}
};
inline bool operator<(const DependentTypename&left, const DependentTypename&right)
{
	return left.name!=right.name?left.name<right.name: left.qualifying!=right.qualifying?left.qualifying<right.qualifying: left.isNested!=right.isNested?left.isNested<right.isNested: left.isTemplate!=right.isTemplate?left.isTemplate<right.isTemplate: left.templateArguments<right.templateArguments;
}
struct DependentNonType
{
	UniqueExpression expression;
	DependentNonType(UniqueExpression expression): expression(expression)
	{
	}
};
inline bool operator<(const DependentNonType&left, const DependentNonType&right)
{
	return left.expression<right.expression;
}
struct DeclaratorPointerType
{
	CvQualifiers qualifiers;
	DeclaratorPointerType()
	{
	}
	explicit DeclaratorPointerType(CvQualifiers qualifiers): qualifiers(qualifiers)
	{
	}
};
struct PointerType
{
	PointerType()
	{
	}
};
inline bool operator<(const PointerType&left, const PointerType&right)
{
	return false;
}
struct DeclaratorReferenceType
{
};
struct ReferenceType
{
};
inline bool operator<(const ReferenceType&left, const ReferenceType&right)
{
	return false;
}
struct DeclaratorMemberPointerType
{
	Type type;
	CvQualifiers qualifiers;
	DeclaratorMemberPointerType(const Type&type, CvQualifiers qualifiers): type(type), qualifiers(qualifiers)
	{
	}
};
struct MemberPointerType
{
	UniqueTypeWrapper type;
	MemberPointerType(UniqueTypeWrapper type): type(type)
	{
	}
};
inline const MemberPointerType&getMemberPointerType(UniqueType type)
{
	if(!(typeid(*type)==typeid(TypeElementGeneric<MemberPointerType>)))
	{
		throw AllocatorError();
	};
	return static_cast<const TypeElementGeneric<MemberPointerType>*>(type.getPointer())->value;
}
inline const SimpleType&getMemberPointerClass(UniqueType type)
{
	return getSimpleType(getMemberPointerType(type).type.value);
}
inline bool operator<(const MemberPointerType&left, const MemberPointerType&right)
{
	return left.type<right.type;
}
typedef std::vector<ExpressionWrapper>ArrayRank;
struct DeclaratorArrayType
{
	ArrayRank rank;
	DeclaratorArrayType(const ArrayRank&rank): rank(rank)
	{
	}
};
struct ArrayType
{
	std::size_t size;
	ArrayType(std::size_t size): size(size)
	{
	}
};
inline bool operator<(const ArrayType&left, const ArrayType&right)
{
	return left.size<right.size;
}
inline const ArrayType&getArrayType(UniqueType type)
{
	if(!(typeid(*type)==typeid(TypeElementGeneric<ArrayType>)))
	{
		throw AllocatorError();
	};
	return static_cast<const TypeElementGeneric<ArrayType>*>(type.getPointer())->value;
}
struct DeclaratorFunctionType
{
	Parameters parameters;
	CvQualifiers qualifiers;
	DeclaratorFunctionType()
	{
	}
	DeclaratorFunctionType(const Parameters&parameters, CvQualifiers qualifiers): parameters(parameters), qualifiers(qualifiers)
	{
	}
};
typedef UniqueTypeArray ParameterTypes;
struct FunctionType
{
	ParameterTypes parameterTypes;
	bool isEllipsis;
	FunctionType(): isEllipsis(false)
	{
	}
};
inline bool operator<(const FunctionType&left, const FunctionType&right)
{
	return left.isEllipsis!=right.isEllipsis?left.isEllipsis<right.isEllipsis: left.parameterTypes<right.parameterTypes;
}
inline const TypeSequence::Node*getLastNode(const TypeSequence&typeSequence)
{
	const TypeSequence::Node*result=0;
	for(const TypeSequence::Node*node=typeSequence.get();
	node!=0;
	node=node->get())
	{
		result=node;
	}
	return result;
}
inline const DeclaratorFunctionType&getDeclaratorFunctionType(const TypeSequence::Node*node)
{
	if(!(node!=0))
	{
		throw AllocatorError();
	};
	if(!(typeid(*node)==typeid(SequenceNodeGeneric<DeclaratorFunctionType, TypeSequenceVisitor>)))
	{
		throw AllocatorError();
	};
	return static_cast<const SequenceNodeGeneric<DeclaratorFunctionType, TypeSequenceVisitor>*>(node)->value;
}
inline const Parameters&getParameters(const TypeId&type)
{
	const TypeSequence::Node*node=getLastNode(type.typeSequence);
	return getDeclaratorFunctionType(node).parameters;
}
inline const FunctionType&getFunctionType(UniqueType type)
{
	if(!(typeid(*type)==typeid(TypeElementGeneric<FunctionType>)))
	{
		throw AllocatorError();
	};
	return static_cast<const TypeElementGeneric<FunctionType>*>(type.getPointer())->value;
}
inline const ParameterTypes&getParameterTypes(UniqueType type)
{
	return getFunctionType(type).parameterTypes;
}
inline UniqueTypeWrapper adjustFunctionParameter(UniqueTypeWrapper type)
{
	UniqueTypeWrapper result(type.value.getPointer());
	if(type.isFunction())
	{
		pushUniqueType(result.value, PointerType());
	}
	else if(type.isArray())
	{
		popUniqueType(result.value);
		pushUniqueType(result.value, PointerType());
	}
	return result;
}
inline bool isFunctionParameterEquivalent(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	return adjustFunctionParameter(left)==adjustFunctionParameter(right);
}
inline bool isEquivalent(const ParameterTypes&left, const ParameterTypes&right)
{
	ParameterTypes::const_iterator l=left.begin();
	ParameterTypes::const_iterator r=right.begin();
	for(;
	;
	++l, ++r)
	{
		if(l==left.end())
		{
			return r==right.end();
		}
		if(r==right.end())
		{
			return false;
		}
		if(!isFunctionParameterEquivalent(*l, *r))
		{
			return false;
		}
	}
	return true;
}
template<bool builtIn>
struct UniqueTypeGeneric: UniqueTypeWrapper
{
	UniqueTypeGeneric()
	{
	}
	explicit UniqueTypeGeneric(UniqueTypeWrapper value): UniqueTypeWrapper(value)
	{
	}
};
typedef UniqueTypeGeneric<true>BuiltInType;
struct BuiltInTypeId: BuiltInType
{
	BuiltInTypeId(Declaration*declaration, const ParserAllocatorWrapper<int>&allocator)
	{
		value=pushBuiltInType(value, SimpleType(declaration, 0));
		declaration->type.unique=value;
		declaration->isComplete=true;
	}
};
inline Declaration*findPrimaryTemplate(Declaration*declaration)
{
	if(!(declaration->isTemplate))
	{
		throw AllocatorError();
	};
	for(;
	declaration!=0;
	declaration=declaration->overloaded)
	{
		if(!isSpecialization(*declaration))
		{
			if(!(declaration->isTemplate))
			{
				throw AllocatorError();
			};
			return declaration;
		}
	}
	if(!(false))
	{
		throw AllocatorError();
	};
	return 0;
}
inline const DeclarationInstance&findLastDeclaration(const DeclarationInstance&instance, Declaration*declaration)
{
	for(const DeclarationInstance*p=&instance;
	p!=0;
	p=p->overloaded)
	{
		if(*p==declaration)
		{
			return *p;
		}
	}
	throw SymbolsError();
}
inline const DeclarationInstance&findPrimaryTemplateLastDeclaration(const DeclarationInstance&instance)
{
	return findLastDeclaration(instance, findPrimaryTemplate(instance));
}
struct LookupResult
{
	const DeclarationInstance*filtered;
	const SimpleType*enclosing;
	LookupResult(): filtered(0), enclosing(0)
	{
	}
	operator const DeclarationInstance*()const
	{
		return filtered;
	}
	bool append(const LookupResult&other)
	{
		*this=other;
		return filtered!=0;
	}
};
struct DeclarationInstanceRef
{
	const DeclarationInstance*p;
	DeclarationInstanceRef(): p(0)
	{
	}
	DeclarationInstanceRef(const DeclarationInstance&p): p(&p)
	{
		checkAllocated(this->p);
	}
	Declaration&operator*()const
	{
		checkAllocated(p);
		return p->operator*();
	}
	Declaration*operator->()const
	{
		checkAllocated(p);
		return p->operator->();
	}
	operator const DeclarationInstance&()const
	{
		checkAllocated(p);
		return *p;
	}
	operator Declaration*()const
	{
		checkAllocated(p);
		return p==0?0: static_cast<Declaration*>(*p);
	}
};
struct LookupResultRef: DeclarationInstanceRef
{
	LookupResultRef()
	{
	}
	LookupResultRef(const DeclarationInstance&p): DeclarationInstanceRef(p)
	{
	}
	LookupResultRef(const LookupResult&result): DeclarationInstanceRef(*result.filtered)
	{
	}
};
inline const DeclarationInstance*findDeclaration(Scope::Declarations&declarations, const Identifier&id, LookupFilter filter=IsAny());
struct RecursionGuard
{
	const SimpleType&instance;
	RecursionGuard(const SimpleType&instance): instance(instance)
	{
		if(!(!instance.visited))
		{
			throw AllocatorError();
		};
		instance.visited=true;
	}
	~RecursionGuard()
	{
		instance.visited=false;
	}
};
inline void printType(const SimpleType&type, std::ostream&out=std::cout, bool escape=false);
inline LookupResult findDeclaration(const SimpleType&instance, const Identifier&id, LookupFilter filter)
{
	if(!(instance.declaration->enclosed!=0))
	{
		throw AllocatorError();
	};
	if(!(instance.instantiated))
	{
		throw AllocatorError();
	};
	if(!(instance.allowLookup))
	{
		throw AllocatorError();
	};
	LookupResult result;
	if(instance.visited)
	{
		std::cout<<"duplicate base: ";
		printType(instance);
		std::cout<<std::endl;
		return result;
	}
	RecursionGuard guard(instance);
	result.filtered=findDeclaration(instance.declaration->enclosed->declarations, id, filter);
	if(result.filtered)
	{
		result.enclosing=&instance;
		return result;
	}
	for(UniqueBases::const_iterator i=instance.bases.begin();
	i!=instance.bases.end();
	++i)
	{
		const SimpleType&base=*(*i);
		if(!(base.declaration->enclosed!=0))
		{
			throw AllocatorError();
		};
		if(!(base.declaration->enclosed->usingDirectives.empty()))
		{
			throw AllocatorError();
		};
		if(base.declaration->getName().value==id.value&&filter(DeclarationInstance(base.declaration)))
		{
			result.filtered=&getDeclaration(base.declaration->getName());
			result.enclosing=base.enclosing;
			return result;
		}
		if(result.append(findDeclaration(base, id, filter)))
		{
			return result;
		}
	}
	return result;
}
inline void printType(UniqueTypeWrapper type, std::ostream&out=std::cout, bool escape=false);
struct TypeError
{
	virtual void report()=0;
};
struct TypeErrorBase: TypeError
{
	Location source;
	TypeErrorBase(Location source): source(source)
	{
	}
	void report()
	{
		printPosition(source);
	}
};
struct MemberNotFoundError: TypeErrorBase
{
	Name name;
	UniqueTypeWrapper qualifying;
	MemberNotFoundError(Location source, Name name, UniqueTypeWrapper qualifying): TypeErrorBase(source), name(name), qualifying(qualifying)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"member '"<<name.c_str()<<"' not found in ";
		if(getSimpleType(qualifying.value).instantiating)
		{
			std::cout<<"(partially instantiated) ";
		}
		printType(qualifying);
		std::cout<<std::endl;
	}
};
struct MemberIsNotTypeError: TypeErrorBase
{
	Name name;
	UniqueTypeWrapper qualifying;
	MemberIsNotTypeError(Location source, Name name, UniqueTypeWrapper qualifying): TypeErrorBase(source), name(name), qualifying(qualifying)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"member '"<<name.c_str()<<"' is not a type in ";
		printType(qualifying);
		std::cout<<std::endl;
	}
};
struct ExpectedTemplateTemplateArgumentError: TypeErrorBase
{
	UniqueTypeWrapper type;
	ExpectedTemplateTemplateArgumentError(Location source, UniqueTypeWrapper type): TypeErrorBase(source), type(type)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"expected template template argument: ";
		printType(type);
		std::cout<<std::endl;
	}
};
struct MismatchedTemplateTemplateArgumentError: TypeErrorBase
{
	UniqueTypeWrapper type;
	MismatchedTemplateTemplateArgumentError(Location source, UniqueTypeWrapper type): TypeErrorBase(source), type(type)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"mismatched template template argument: ";
		printType(type);
		std::cout<<std::endl;
	}
};
struct QualifyingIsNotClassError: TypeErrorBase
{
	UniqueTypeWrapper qualifying;
	QualifyingIsNotClassError(Location source, UniqueTypeWrapper qualifying): TypeErrorBase(source), qualifying(qualifying)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"qualifying type is not a class: ";
		printType(qualifying);
		std::cout<<std::endl;
	}
};
struct PointerToReferenceError: TypeErrorBase
{
	PointerToReferenceError(Location source): TypeErrorBase(source)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"cannot create pointer to reference"<<std::endl;
	}
};
struct ReferenceToReferenceError: TypeErrorBase
{
	ReferenceToReferenceError(Location source): TypeErrorBase(source)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"cannot create reference to reference"<<std::endl;
	}
};
struct InvalidArrayError: TypeErrorBase
{
	InvalidArrayError(Location source): TypeErrorBase(source)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"cannot create array of type void, function or reference"<<std::endl;
	}
};
struct VoidParameterError: TypeErrorBase
{
	VoidParameterError(Location source): TypeErrorBase(source)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"cannot create function with void parameter"<<std::endl;
	}
};
struct TooFewTemplateArgumentsError: TypeErrorBase
{
	TooFewTemplateArgumentsError(Location source): TypeErrorBase(source)
	{
	}
	void report()
	{
		TypeErrorBase::report();
		std::cout<<"too few template arguments"<<std::endl;
	}
};
struct InstantiationContext
{
	Location source;
	const SimpleType*enclosingType;
	ScopePtr enclosingScope;
	InstantiationContext(Location source, const SimpleType*enclosingType, ScopePtr enclosingScope): source(source), enclosingType(enclosingType), enclosingScope(enclosingScope)
	{
	}
};
inline InstantiationContext setEnclosingType(const InstantiationContext&context, const SimpleType*enclosingType)
{
	return InstantiationContext(context.source, enclosingType, context.enclosingScope);
}
inline InstantiationContext setEnclosingTypeSafe(const InstantiationContext&context, const SimpleType*enclosingType)
{
	if(!(enclosingType!=0))
	{
		throw AllocatorError();
	};
	return setEnclosingType(context, enclosingType);
}
struct Argument: ExpressionWrapper
{
	UniqueTypeWrapper type;
	Argument(ExpressionWrapper expression, UniqueTypeWrapper type): ExpressionWrapper(expression), type(type)
	{
	}
};
typedef std::vector<Argument>Arguments;
struct IntegralConstantExpression
{
	UniqueTypeWrapper type;
	IntegralConstant value;
	IntegralConstantExpression(UniqueTypeWrapper type, IntegralConstant value): type(type), value(value)
	{
	}
};
inline bool operator<(const IntegralConstantExpression&left, const IntegralConstantExpression&right)
{
	return left.type!=right.type?left.type<right.type: left.value.value<right.value.value;
}
struct CastExpression
{
	UniqueTypeWrapper type;
	ExpressionWrapper operand;
	CastExpression(UniqueTypeWrapper type, ExpressionWrapper operand): type(type), operand(operand)
	{
	}
};
inline bool operator<(const CastExpression&left, const CastExpression&right)
{
	return left.type!=right.type?left.type<right.type: left.operand.p<right.operand.p;
}
inline bool isCastExpression(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<CastExpression>);
}
inline const CastExpression&getCastExpression(ExpressionNode*node)
{
	if(!(isCastExpression(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<CastExpression>*>(node)->value;
}
struct DependentIdExpression
{
	Name name;
	UniqueTypeWrapper qualifying;
	TemplateArgumentsInstance templateArguments;
	DependentIdExpression(Name name, UniqueTypeWrapper qualifying, TemplateArgumentsInstance templateArguments): name(name), qualifying(qualifying), templateArguments(templateArguments)
	{
		if(!(qualifying.value.p!=0))
		{
			throw AllocatorError();
		};
	}
};
inline bool operator<(const DependentIdExpression&left, const DependentIdExpression&right)
{
	return left.name!=right.name?left.name<right.name: left.qualifying!=right.qualifying?left.qualifying<right.qualifying: left.templateArguments<right.templateArguments;
}
inline bool isDependentIdExpression(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<DependentIdExpression>);
}
inline const DependentIdExpression&getDependentIdExpression(ExpressionNode*node)
{
	if(!(isDependentIdExpression(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<DependentIdExpression>*>(node)->value;
}
struct IdExpression
{
	DeclarationInstanceRef declaration;
	const SimpleType*enclosing;
	TemplateArgumentsInstance templateArguments;
	IdExpression(DeclarationInstanceRef declaration, const SimpleType*enclosing, const TemplateArgumentsInstance&templateArguments): declaration(declaration), enclosing(enclosing), templateArguments(templateArguments)
	{
	}
};
inline bool operator<(const IdExpression&left, const IdExpression&right)
{
	if(!(false))
	{
		throw AllocatorError();
	};
}
inline bool isIdExpression(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<IdExpression>);
}
inline const IdExpression&getIdExpression(ExpressionNode*node)
{
	if(!(isIdExpression(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<IdExpression>*>(node)->value;
}
struct NonTypeTemplateParameter
{
	DeclarationPtr declaration;
	NonTypeTemplateParameter(DeclarationPtr declaration): declaration(declaration)
	{
	}
};
inline bool operator<(const NonTypeTemplateParameter&left, const NonTypeTemplateParameter&right)
{
	return left.declaration->scope->templateDepth!=right.declaration->scope->templateDepth?left.declaration->scope->templateDepth<right.declaration->scope->templateDepth: left.declaration->templateParameter<right.declaration->templateParameter;
}
inline bool isNonTypeTemplateParameter(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<NonTypeTemplateParameter>);
}
inline const NonTypeTemplateParameter&getNonTypeTemplateParameter(ExpressionNode*node)
{
	if(!(isNonTypeTemplateParameter(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<NonTypeTemplateParameter>*>(node)->value;
}
struct SizeofExpression
{
	ExpressionWrapper operand;
	SizeofExpression(ExpressionWrapper operand): operand(operand)
	{
	}
};
inline bool operator<(const SizeofExpression&left, const SizeofExpression&right)
{
	return left.operand.p<right.operand.p;
}
struct SizeofTypeExpression
{
	UniqueTypeWrapper type;
	SizeofTypeExpression(UniqueTypeWrapper type): type(type)
	{
	}
};
inline bool operator<(const SizeofTypeExpression&left, const SizeofTypeExpression&right)
{
	return left.type<right.type;
}
struct UnaryExpression
{
	Name operatorName;
	UnaryIceOp operation;
	ExpressionWrapper first;
	UnaryExpression(Name operatorName, UnaryIceOp operation, ExpressionWrapper first): operatorName(operatorName), operation(operation), first(first)
	{
	}
};
inline bool operator<(const UnaryExpression&left, const UnaryExpression&right)
{
	return left.operation!=right.operation?left.operation<right.operation: left.first.p<right.first.p;
}
inline bool isUnaryExpression(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<UnaryExpression>);
}
inline const UnaryExpression&getUnaryExpression(ExpressionNode*node)
{
	if(!(isUnaryExpression(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<UnaryExpression>*>(node)->value;
}
typedef UniqueTypeWrapper(*BinaryTypeOp)(Name operatorName, Argument first, Argument second, const InstantiationContext&context);
struct BinaryExpression
{
	Name operatorName;
	BinaryIceOp operation;
	BinaryTypeOp type;
	ExpressionWrapper first;
	ExpressionWrapper second;
	BinaryExpression(Name operatorName, BinaryIceOp operation, BinaryTypeOp type, ExpressionWrapper first, ExpressionWrapper second): operatorName(operatorName), operation(operation), type(type), first(first), second(second)
	{
	}
};
inline bool operator<(const BinaryExpression&left, const BinaryExpression&right)
{
	return left.operation!=right.operation?left.operation<right.operation: left.type!=right.type?left.type<right.type: left.first.p!=right.first.p?left.first.p<right.first.p: left.second.p<right.second.p;
}
struct TernaryExpression
{
	TernaryIceOp operation;
	ExpressionWrapper first;
	ExpressionWrapper second;
	ExpressionWrapper third;
	TernaryExpression(TernaryIceOp operation, ExpressionWrapper first, ExpressionWrapper second, ExpressionWrapper third): operation(operation), first(first), second(second), third(third)
	{
	}
};
inline bool operator<(const TernaryExpression&left, const TernaryExpression&right)
{
	return left.operation!=right.operation?left.operation<right.operation: left.first.p!=right.first.p?left.first.p<right.first.p: left.second.p!=right.second.p?left.second.p<right.second.p: left.third.p<right.third.p;
}
typedef bool(*UnaryTypeTraitsOp)(UniqueTypeWrapper);
typedef bool(*BinaryTypeTraitsOp)(UniqueTypeWrapper, UniqueTypeWrapper, const InstantiationContext&context);
struct TypeTraitsUnaryExpression
{
	Name traitName;
	UnaryTypeTraitsOp operation;
	UniqueTypeWrapper type;
	TypeTraitsUnaryExpression(Name traitName, UnaryTypeTraitsOp operation, UniqueTypeWrapper type): traitName(traitName), operation(operation), type(type)
	{
	}
};
inline bool operator<(const TypeTraitsUnaryExpression&left, const TypeTraitsUnaryExpression&right)
{
	return left.operation!=right.operation?left.operation<right.operation: left.type<right.type;
}
struct TypeTraitsBinaryExpression
{
	Name traitName;
	BinaryTypeTraitsOp operation;
	UniqueTypeWrapper first;
	UniqueTypeWrapper second;
	TypeTraitsBinaryExpression(Name traitName, BinaryTypeTraitsOp operation, UniqueTypeWrapper first, UniqueTypeWrapper second): traitName(traitName), operation(operation), first(first), second(second)
	{
		if(!(first!=gUniqueTypeNull))
		{
			throw AllocatorError();
		};
		if(!(second!=gUniqueTypeNull))
		{
			throw AllocatorError();
		};
	}
};
inline bool operator<(const TypeTraitsBinaryExpression&left, const TypeTraitsBinaryExpression&right)
{
	return left.operation!=right.operation?left.operation<right.operation: left.first!=right.first?left.first<right.first: left.second<right.second;
}
struct ExplicitTypeExpression
{
	UniqueTypeWrapper type;
	ExplicitTypeExpression(UniqueTypeWrapper type): type(type)
	{
	}
};
inline bool operator<(const ExplicitTypeExpression&left, const ExplicitTypeExpression&right)
{
	return left.type<right.type;
}
inline bool isExplicitTypeExpression(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<ExplicitTypeExpression>);
}
inline const ExplicitTypeExpression&getExplicitTypeExpression(ExpressionNode*node)
{
	if(!(isExplicitTypeExpression(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<ExplicitTypeExpression>*>(node)->value;
}
struct DependentObjectExpression
{
	ExpressionWrapper left;
	bool isArrow;
	DependentObjectExpression(ExpressionWrapper left, bool isArrow): left(left), isArrow(isArrow)
	{
	}
};
inline bool operator<(const DependentObjectExpression&left, const DependentObjectExpression&right)
{
	if(!(false))
	{
		throw AllocatorError();
	};
	return false;
}
inline bool isDependentObjectExpression(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<DependentObjectExpression>);
}
inline const DependentObjectExpression&getDependentObjectExpression(ExpressionNode*node)
{
	if(!(isDependentObjectExpression(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<DependentObjectExpression>*>(node)->value;
}
struct ObjectExpression
{
	const SimpleType*classType;
	ObjectExpression(const SimpleType*classType): classType(classType)
	{
	}
};
inline bool operator<(const ObjectExpression&left, const ObjectExpression&right)
{
	if(!(false))
	{
		throw AllocatorError();
	};
	return false;
}
inline bool isObjectExpression(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<ObjectExpression>);
}
inline const ObjectExpression&getObjectExpression(ExpressionNode*node)
{
	if(!(isObjectExpression(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<ObjectExpression>*>(node)->value;
}
struct ClassMemberAccessExpression
{
	ExpressionWrapper left;
	ExpressionWrapper right;
	ClassMemberAccessExpression(ExpressionWrapper left, ExpressionWrapper right): left(left), right(right)
	{
	}
};
inline bool operator<(const ClassMemberAccessExpression&left, const ClassMemberAccessExpression&right)
{
	if(!(false))
	{
		throw AllocatorError();
	};
	return false;
}
inline bool isClassMemberAccessExpression(ExpressionNode*node)
{
	return typeid(*node)==typeid(ExpressionNodeGeneric<ClassMemberAccessExpression>);
}
inline const ClassMemberAccessExpression&getClassMemberAccessExpression(ExpressionNode*node)
{
	if(!(isClassMemberAccessExpression(node)))
	{
		throw AllocatorError();
	};
	return static_cast<const ExpressionNodeGeneric<ClassMemberAccessExpression>*>(node)->value;
}
struct FunctionCallExpression
{
	ExpressionWrapper left;
	Arguments arguments;
	FunctionCallExpression(ExpressionWrapper left, Arguments arguments): left(left), arguments(arguments)
	{
	}
};
inline bool operator<(const FunctionCallExpression&left, const FunctionCallExpression&right)
{
	if(!(false))
	{
		throw AllocatorError();
	};
	return false;
}
struct SubscriptExpression
{
	ExpressionWrapper left;
	ExpressionWrapper right;
	SubscriptExpression(ExpressionWrapper left, ExpressionWrapper right): left(left), right(right)
	{
	}
};
inline bool operator<(const SubscriptExpression&left, const SubscriptExpression&right)
{
	if(!(false))
	{
		throw AllocatorError();
	};
	return false;
}
struct PostfixOperatorExpression
{
	Name operatorName;
	ExpressionWrapper operand;
	PostfixOperatorExpression(Name operatorName, ExpressionWrapper operand): operatorName(operatorName), operand(operand)
	{
	}
};
inline bool operator<(const PostfixOperatorExpression&left, const PostfixOperatorExpression&right)
{
	if(!(false))
	{
		throw AllocatorError();
	};
	return false;
}
inline UniqueTypeWrapper typeOfExpression(ExpressionNode*node, const InstantiationContext&context);
inline bool isPointerToMemberExpression(ExpressionNode*expression)
{
	if(!isUnaryExpression(expression))
	{
		return false;
	}
	const UnaryExpression&unary=getUnaryExpression(expression);
	extern Name gOperatorAndId;
	if(unary.operatorName!=gOperatorAndId||!isIdExpression(unary.first))
	{
		return false;
	}
	return getIdExpression(unary.first).enclosing!=0;
}
inline bool isPointerToFunctionExpression(ExpressionNode*expression)
{
	if(isUnaryExpression(expression))
	{
		expression=getUnaryExpression(expression).first;
	}
	if(!isIdExpression(expression))
	{
		return false;
	}
	const IdExpression node=getIdExpression(expression);
	return UniqueTypeWrapper(node.declaration->type.unique).isFunction();
}
inline bool isDependentPointerToMemberExpression(ExpressionNode*expression)
{
	return isUnaryExpression(expression)&&getUnaryExpression(expression).operation==addressOf&&isDependentIdExpression(getUnaryExpression(expression).first);
}
extern BuiltInTypeId gUnsignedInt;
extern BuiltInTypeId gBool;
extern const DeclarationInstance gCopyAssignmentOperatorInstance;
extern const DeclarationInstance gDestructorInstance;
inline UniqueTypeWrapper removeReference(UniqueTypeWrapper type)
{
	if(type.isReference())
	{
		type.pop_front();
	}
	return type;
}
inline bool isDependent(UniqueTypeWrapper type);
inline UniqueTypeWrapper makeUniqueSimpleType(const SimpleType&type);
inline UniqueTypeWrapper typeOfUnaryExpression(Name operatorName, Argument operand, const InstantiationContext&context);
inline UniqueTypeWrapper getConditionalOperatorType(UniqueTypeWrapper leftType, UniqueTypeWrapper rightType);
inline UniqueTypeWrapper typeOfSubscriptExpression(Argument left, Argument right, const InstantiationContext&context);
inline const SimpleType&getMemberOperatorType(Argument operand, bool isArrow, const InstantiationContext&context);
inline UniqueTypeWrapper makeCopyAssignmentOperatorType(const SimpleType&classType);
inline const SimpleType*findEnclosingType(const SimpleType*enclosing, Scope*scope);
inline UniqueTypeWrapper getUniqueType(const TypeId&type, const InstantiationContext&context, bool allowDependent=false);
inline UniqueTypeWrapper getUniqueType(const Type&type, const InstantiationContext&context, bool allowDependent=false);
inline UniqueTypeWrapper typeOfIdExpression(const SimpleType*qualifying, const DeclarationInstance&declaration, const InstantiationContext&context);
inline UniqueTypeWrapper typeOfPostfixOperatorExpression(Name operatorName, Argument operand, const InstantiationContext&context);
inline IdExpression substituteIdExpression(const DependentIdExpression&node, const InstantiationContext&context);
inline UniqueTypeWrapper getNonTypeTemplateParameterType(const NonTypeTemplateParameter&node, const InstantiationContext&context);
inline UniqueTypeWrapper typeOfFunctionCallExpression(Argument left, const Arguments&arguments, const InstantiationContext&context);
struct TypeOfVisitor: ExpressionNodeVisitor
{
	UniqueTypeWrapper result;
	InstantiationContext context;
	explicit TypeOfVisitor(const InstantiationContext&context): context(context)
	{
	}
	void visit(const IntegralConstantExpression&node)
	{
		result=node.type;
	}
	void visit(const CastExpression&node)
	{
		result=node.type;
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const NonTypeTemplateParameter&node)
	{
		result=getNonTypeTemplateParameterType(node, context);
	}
	void visit(const DependentIdExpression&node)
	{
		const IdExpression expression=substituteIdExpression(node, context);
		result=typeOfIdExpression(expression.enclosing, expression.declaration, context);
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const IdExpression&node)
	{
		result=typeOfIdExpression(node.enclosing, node.declaration, context);
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const SizeofExpression&node)
	{
		result=gUnsignedInt;
	}
	void visit(const SizeofTypeExpression&node)
	{
		result=gUnsignedInt;
	}
	void visit(const UnaryExpression&node)
	{
		result=typeOfUnaryExpression(node.operatorName, Argument(node.first, removeReference(typeOfExpression(node.first, context))), context);
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const BinaryExpression&node)
	{
		result=node.type(node.operatorName, Argument(node.first, removeReference(typeOfExpression(node.first, context))), Argument(node.second, removeReference(typeOfExpression(node.second, context))), context);
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const TernaryExpression&node)
	{
		result=getConditionalOperatorType(removeReference(typeOfExpression(node.second, context)), removeReference(typeOfExpression(node.third, context)));
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const TypeTraitsUnaryExpression&node)
	{
		result=gBool;
	}
	void visit(const TypeTraitsBinaryExpression&node)
	{
		result=gBool;
	}
	void visit(const struct ExplicitTypeExpression&node)
	{
		result=node.type;
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct ObjectExpression&node)
	{
		result=makeUniqueSimpleType(*node.classType);
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct DependentObjectExpression&node)
	{
		UniqueTypeWrapper type=typeOfExpression(node.left, context);
		const SimpleType&classType=getMemberOperatorType(Argument(node.left, removeReference(type)), node.isArrow, context);
		result=makeUniqueSimpleType(classType);
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct ClassMemberAccessExpression&node)
	{
		UniqueTypeWrapper type=typeOfExpression(node.left, context);
		if(!(!isDependent(type)))
		{
			throw AllocatorError();
		};
		const SimpleType&classType=getSimpleType(type.value);
		result=typeOfExpression(node.right, setEnclosingTypeSafe(context, &classType));
		if(!(!isDependent(result)))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct FunctionCallExpression&node)
	{
		result=typeOfFunctionCallExpression(Argument(node.left, removeReference(typeOfExpression(node.left, context))), node.arguments, context);
	}
	void visit(const struct SubscriptExpression&node)
	{
		result=typeOfSubscriptExpression(Argument(node.left, removeReference(typeOfExpression(node.left, context))), Argument(node.right, removeReference(typeOfExpression(node.right, context))), context);
	}
	void visit(const struct PostfixOperatorExpression&node)
	{
		result=typeOfPostfixOperatorExpression(node.operatorName, Argument(node.operand, removeReference(typeOfExpression(node.operand, context))), context);
	}
};
inline UniqueTypeWrapper typeOfExpression(ExpressionNode*node, const InstantiationContext&context)
{
	if(isPointerToMemberExpression(node)||isDependentPointerToMemberExpression(node))
	{
		return gUniqueTypeNull;
	}
	TypeOfVisitor visitor(context);
	node->accept(visitor);
	return visitor.result;
}
inline std::size_t instantiateClass(const SimpleType&instanceConst, const InstantiationContext&context, bool allowDependent=false);
inline std::size_t requireCompleteObjectType(UniqueTypeWrapper type, const InstantiationContext&context);
inline UniqueTypeWrapper removeReference(UniqueTypeWrapper type);
inline const SimpleType*makeUniqueEnclosing(const Qualifying&qualifying, const InstantiationContext&context, bool allowDependent=false);
inline const SimpleType*findEnclosingType(const SimpleType*enclosing, Scope*scope);
inline bool isDependent(const SimpleType&type);
inline UniqueTypeWrapper substitute(UniqueTypeWrapper dependent, const InstantiationContext&context);
inline const SimpleType*findEnclosingTemplate(const SimpleType*enclosing, Declaration*declaration)
{
	Declaration*primary=findPrimaryTemplate(declaration);
	if(!(primary->isTemplate))
	{
		throw AllocatorError();
	};
	if(!(!primary->isSpecialization))
	{
		throw AllocatorError();
	};
	for(const SimpleType*i=enclosing;
	i!=0;
	i=(*i).enclosing)
	{
		if(!(!(*i).primary->isSpecialization))
		{
			throw AllocatorError();
		};
		if((*i).primary->isTemplate&&(*i).primary==primary)
		{
			return i;
		}
	}
	return 0;
}
inline const SimpleType*findEnclosingTemplate(const SimpleType*enclosing, Scope*scope)
{
	if(!(scope!=0))
	{
		throw AllocatorError();
	};
	if(!(scope->type==SCOPETYPE_TEMPLATE))
	{
		throw AllocatorError();
	};
	for(const SimpleType*i=enclosing;
	i!=0;
	i=(*i).enclosing)
	{
		if((*i).declaration->templateParamScope!=0&&(*i).declaration->templateParamScope->templateDepth==scope->templateDepth)
		{
			return i;
		}
	}
	return 0;
}
inline const SimpleType*getEnclosingType(const SimpleType*enclosing)
{
	for(const SimpleType*i=enclosing;
	i!=0;
	i=(*i).enclosing)
	{
		if((*i).declaration->getName().value.c_str()[0]!='$')
		{
			return i;
		}
	}
	return 0;
}
inline IntegralConstant evaluateIdExpression(const IdExpression&node, const InstantiationContext&context)
{
	if(!(node.declaration->templateParameter==INDEX_INVALID))
	{
		throw AllocatorError();
	};
	const SimpleType*enclosing=node.enclosing!=0?node.enclosing: context.enclosingType;
	const SimpleType*memberEnclosing=isMember(*node.declaration)?findEnclosingType(enclosing, node.declaration->scope): 0;
	return evaluate(node.declaration->initializer, setEnclosingType(context, memberEnclosing));
}
inline IdExpression substituteIdExpression(const DependentIdExpression&node, const InstantiationContext&context)
{
	if(!(node.qualifying!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	if(!(context.enclosingType!=0))
	{
		throw AllocatorError();
	};
	UniqueTypeWrapper substituted=substitute(node.qualifying, context);
	const SimpleType*qualifyingType=substituted.isSimple()?&getSimpleType(substituted.value): 0;
	if(qualifyingType==0||!isClass(*qualifyingType->declaration))
	{
		throw QualifyingIsNotClassError(context.source, node.qualifying);
	}
	instantiateClass(*qualifyingType, context);
	Identifier id;
	id.value=node.name;
	std::size_t visibility=qualifyingType->instantiating?context.enclosingType->instantiation.pointOfInstantiation: VISIBILITY_ALL;
	LookupResultRef declaration=findDeclaration(*qualifyingType, id, IsAny(visibility));
	if(declaration==0)
	{
		throw MemberNotFoundError(context.source, node.name, node.qualifying);
	}
	return IdExpression(declaration, qualifyingType, TemplateArgumentsInstance());
}
inline IntegralConstant evaluateIdExpression(const DependentIdExpression&node, const InstantiationContext&context)
{
	const IdExpression expression=substituteIdExpression(node, context);
	return evaluateIdExpression(expression, context);
}
inline const Type&getTemplateParameter(const TemplateParameters&templateParameters, std::size_t index)
{
	if(!(index<std::size_t(std::distance(templateParameters.begin(), templateParameters.end()))))
	{
		throw AllocatorError();
	};
	TemplateParameters::const_iterator i=templateParameters.begin();
	std::advance(i, index);
	return *i;
}
inline UniqueTypeWrapper getNonTypeTemplateParameterType(const NonTypeTemplateParameter&node, const InstantiationContext&context)
{
	std::size_t index=node.declaration->templateParameter;
	if(!(index!=INDEX_INVALID))
	{
		throw AllocatorError();
	};
	const SimpleType*enclosingType=findEnclosingTemplate(context.enclosingType, node.declaration->scope);
	if(!(enclosingType!=0))
	{
		throw AllocatorError();
	};
	if(!(!isDependent(*enclosingType)))
	{
		throw AllocatorError();
	};
	if(!(!enclosingType->declaration->isSpecialization||enclosingType->instantiated))
	{
		throw AllocatorError();
	};
	const TemplateParameters&templateParams=enclosingType->declaration->templateParams;
	const Type&parameter=getTemplateParameter(templateParams, index);
	UniqueTypeWrapper type=getUniqueType(parameter.declaration->type, context);
	if(!(!isDependent(type)))
	{
		throw AllocatorError();
	};
	return type;
}
inline const NonType&substituteNonTypeTemplateParameter(const NonTypeTemplateParameter&node, const InstantiationContext&context)
{
	size_t index=node.declaration->templateParameter;
	if(!(index!=INDEX_INVALID))
	{
		throw AllocatorError();
	};
	const SimpleType*enclosingType=findEnclosingTemplate(context.enclosingType, node.declaration->scope);
	if(!(enclosingType!=0))
	{
		throw AllocatorError();
	};
	if(!(!isDependent(*enclosingType)))
	{
		throw AllocatorError();
	};
	if(!(!enclosingType->declaration->isSpecialization||enclosingType->instantiated))
	{
		throw AllocatorError();
	};
	const TemplateArgumentsInstance&templateArguments=enclosingType->declaration->isSpecialization?enclosingType->deducedArguments: enclosingType->templateArguments;
	if(!(index<templateArguments.size()))
	{
		throw AllocatorError();
	};
	UniqueTypeWrapper argument=templateArguments[index];
	if(!(argument.isNonType()))
	{
		throw AllocatorError();
	};
	return getNonTypeValue(argument.value);
}
struct EvaluateVisitor: ExpressionNodeVisitor
{
	IntegralConstant result;
	const InstantiationContext context;
	explicit EvaluateVisitor(const InstantiationContext&context): context(context)
	{
	}
	void visit(const IntegralConstantExpression&node)
	{
		result=node.value;
	}
	void visit(const CastExpression&node)
	{
		result=evaluate(node.operand, context);
	}
	void visit(const NonTypeTemplateParameter&node)
	{
		result=substituteNonTypeTemplateParameter(node, context);
	}
	void visit(const DependentIdExpression&node)
	{
		result=evaluateIdExpression(node, context);
	}
	void visit(const IdExpression&node)
	{
		result=evaluateIdExpression(node, context);
	}
	void visit(const SizeofExpression&node)
	{
		if(node.operand==0)
		{
			std::cout<<"sizeof expression with dependent type!"<<std::endl;
			return ;
		}
		if(isPointerToMemberExpression(node.operand))
		{
			return ;
		}
		if(isPointerToFunctionExpression(node.operand))
		{
			return ;
		}
		UniqueTypeWrapper type=typeOfExpression(node.operand, context);
		result=IntegralConstant(requireCompleteObjectType(removeReference(type), context));
	}
	void visit(const SizeofTypeExpression&node)
	{
		result=IntegralConstant(requireCompleteObjectType(removeReference(node.type), context));
	}
	void visit(const UnaryExpression&node)
	{
		result=node.operation(evaluate(node.first, context));
	}
	void visit(const BinaryExpression&node)
	{
		result=node.operation(evaluate(node.first, context), evaluate(node.second, context));
	}
	void visit(const TernaryExpression&node)
	{
		result=node.operation(evaluate(node.first, context), evaluate(node.second, context), evaluate(node.third, context));
	}
	void visit(const TypeTraitsUnaryExpression&node)
	{
		result=IntegralConstant(node.operation(substitute(node.type, context)));
	}
	void visit(const TypeTraitsBinaryExpression&node)
	{
		result=IntegralConstant(node.operation(substitute(node.first, context), substitute(node.second, context), context));
	}
	void visit(const struct ExplicitTypeExpression&node)
	{
		if(!(false))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct ObjectExpression&node)
	{
		if(!(false))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct DependentObjectExpression&node)
	{
		if(!(false))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct ClassMemberAccessExpression&node)
	{
		if(!(false))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct FunctionCallExpression&node)
	{
		if(!(false))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct SubscriptExpression&node)
	{
		if(!(false))
		{
			throw AllocatorError();
		};
	}
	void visit(const struct PostfixOperatorExpression&node)
	{
		if(!(false))
		{
			throw AllocatorError();
		};
	}
};
inline IntegralConstant evaluate(ExpressionNode*node, const InstantiationContext&context)
{
	EvaluateVisitor visitor(context);
	node->accept(visitor);
	return visitor.result;
}
inline IntegralConstant evaluateExpression(ExpressionNode*node, const InstantiationContext&context)
{
	if(isDependentPointerToMemberExpression(node))
	{
		return IntegralConstant(0);
	}
	return evaluate(node, context);
}
inline IntegralConstant evaluateExpression(const ExpressionWrapper&expression, const InstantiationContext&context)
{
	if(isPointerToMemberExpression(expression))
	{
		return IntegralConstant(0);
	}
	if(isPointerToFunctionExpression(expression))
	{
		return IntegralConstant(0);
	}
	if(!(expression.isConstant))
	{
		throw AllocatorError();
	};
	return evaluateExpression(expression.p, context);
}
inline bool isDependent(const UniqueTypeArray&types)
{
	for(UniqueTypeArray::const_iterator i=types.begin();
	i!=types.end();
	++i)
	{
		if(isDependent(*i))
		{
			return true;
		}
	}
	return false;
}
inline bool isDependent(const SimpleType&type)
{
	if(type.enclosing&&isDependent(*type.enclosing))
	{
		return true;
	}
	if(isDependent(type.templateArguments))
	{
		return true;
	}
	return false;
}
struct IsDependentVisitor: TypeElementVisitor
{
	bool result;
	IsDependentVisitor(): result(false)
	{
	}
	virtual void visit(const DependentType&)
	{
		result=true;
	}
	virtual void visit(const DependentTypename&)
	{
		result=true;
	}
	virtual void visit(const DependentNonType&)
	{
		result=true;
	}
	virtual void visit(const TemplateTemplateArgument&)
	{
	}
	virtual void visit(const NonType&)
	{
	}
	virtual void visit(const SimpleType&element)
	{
		if(isDependent(element))
		{
			result=true;
		}
	}
	virtual void visit(const PointerType&)
	{
	}
	virtual void visit(const ReferenceType&)
	{
	}
	virtual void visit(const ArrayType&)
	{
	}
	virtual void visit(const MemberPointerType&element)
	{
		if(isDependent(element.type))
		{
			result=true;
		}
	}
	virtual void visit(const FunctionType&element)
	{
		if(isDependent(element.parameterTypes))
		{
			result=true;
		}
	}
};
inline bool isDependent(UniqueTypeWrapper type)
{
	for(UniqueTypeWrapper i=type;
	!i.empty();
	i.pop_front())
	{
		IsDependentVisitor visitor;
		i.value->accept(visitor);
		if(visitor.result)
		{
			return true;
		}
	}
	return false;
}
inline bool deduce(UniqueTypeWrapper parameter, UniqueTypeWrapper argument, TemplateArgumentsInstance&result, bool allowGreaterCvQualification=false);
inline bool deducePairs(const UniqueTypeArray&parameters, const UniqueTypeArray&arguments, TemplateArgumentsInstance&result)
{
	UniqueTypeArray::const_iterator p=parameters.begin();
	for(UniqueTypeArray::const_iterator a=arguments.begin();
	a!=arguments.end()&&p!=parameters.end();
	++a, ++p)
	{
		if(!deduce(*p, *a, result))
		{
			return false;
		}
	}
	return true;
}
inline bool isNonDeduced(const SimpleType&type)
{
	return false;
}
struct DeduceVisitor: TypeElementVisitor
{
	UniqueTypeWrapper argument;
	TemplateArgumentsInstance&templateArguments;
	bool result;
	DeduceVisitor(UniqueTypeWrapper argument, TemplateArgumentsInstance&templateArguments): argument(argument), templateArguments(templateArguments), result(true)
	{
	}
	void commit(std::size_t index)
	{
		if(!(index!=INDEX_INVALID))
		{
			throw AllocatorError();
		};
		if(!(index<templateArguments.size()))
		{
			throw AllocatorError();
		};
		if(templateArguments[index]==gUniqueTypeNull)
		{
			templateArguments[index]=argument;
		}
		else if(templateArguments[index]!=argument)
		{
			result=false;
		}
	}
	virtual void visit(const DependentType&element)
	{
		if(element.templateParameterCount!=0)
		{
			if(element.templateArguments.empty())
			{
				if(!argument.isTemplateTemplateArgument())
				{
					result=false;
					return ;
				}
			}
			else
			{
				if(!argument.isSimple())
				{
					result=false;
					return ;
				}
				const SimpleType&type=getSimpleType(argument.value);
				if(!type.declaration->isTemplate||!deducePairs(element.templateArguments, type.templateArguments, templateArguments))
				{
					result=false;
					return ;
				}
				argument=gUniqueTypeNull;
				argument.push_front(TemplateTemplateArgument(type.declaration, type.enclosing));
			}
		}
		commit(element.type->templateParameter);
	}
	virtual void visit(const DependentTypename&)
	{
	}
	virtual void visit(const DependentNonType&element)
	{
		if(isNonTypeTemplateParameter(element.expression))
		{
			commit(getNonTypeTemplateParameter(element.expression).declaration->templateParameter);
		}
	}
	virtual void visit(const TemplateTemplateArgument&element)
	{
	}
	virtual void visit(const NonType&)
	{
	}
	virtual void visit(const SimpleType&element)
	{
		if(!(argument.isSimple()))
		{
			throw AllocatorError();
		};
		const SimpleType&type=getSimpleType(argument.value);
		if(type.primary!=element.primary)
		{
			result=false;
			return ;
		}
		if(!isNonDeduced(element))
		{
			result=deducePairs(element.templateArguments, type.templateArguments, templateArguments);
		}
	}
	virtual void visit(const PointerType&)
	{
	}
	virtual void visit(const ReferenceType&)
	{
	}
	virtual void visit(const ArrayType&)
	{
	}
	virtual void visit(const MemberPointerType&element)
	{
		if(!(argument.isMemberPointer()))
		{
			throw AllocatorError();
		};
		result=deduce(element.type, getMemberPointerType(argument.value).type, templateArguments);
	}
	virtual void visit(const FunctionType&element)
	{
		if(!(argument.isFunction()))
		{
			throw AllocatorError();
		};
		result=deducePairs(element.parameterTypes, getParameterTypes(argument.value), templateArguments);
	}
};
inline UniqueTypeWrapper applyArrayToPointerConversion(UniqueTypeWrapper type);
inline UniqueTypeWrapper applyFunctionToPointerConversion(UniqueTypeWrapper type);
struct DeductionFailure
{
};
inline const SimpleType*findUniqueBase(const SimpleType&derived, const Declaration&type, const SimpleType*result=0)
{
	if(!(derived.instantiated))
	{
		throw AllocatorError();
	};
	if(!(derived.declaration->enclosed!=0))
	{
		throw AllocatorError();
	};
	if(!(isClass(type)))
	{
		throw AllocatorError();
	};
	for(UniqueBases::const_iterator i=derived.bases.begin();
	i!=derived.bases.end();
	++i)
	{
		const SimpleType&base=*(*i);
		if(!(isClass(*base.declaration)))
		{
			throw AllocatorError();
		};
		if(base.primary==&type)
		{
			if(result!=0)
			{
				throw DeductionFailure();
			}
			result=&base;
		}
		result=findUniqueBase(base, type, result);
	}
	return result;
}
inline UniqueTypeWrapper removePointer(UniqueTypeWrapper type)
{
	if(type.isPointer())
	{
		type.pop_front();
	}
	return type;
}
inline const SimpleType*getClassType(UniqueTypeWrapper type)
{
	if(!type.isSimple())
	{
		return 0;
	}
	const SimpleType*result=&getSimpleType(type.value);
	if(!isClass(*result->declaration))
	{
		return 0;
	}
	return result;
}
inline void adjustFunctionCallDeductionPair(UniqueTypeWrapper&parameter, UniqueTypeWrapper&argument, const InstantiationContext&context)
{
	argument=removeReference(argument);
	parameter.value.setQualifiers(CvQualifiers());
	if(parameter.isReference())
	{
		parameter=removeReference(parameter);
	}
	else
	{
		if(argument.isArray())
		{
			argument=applyArrayToPointerConversion(argument);
		}
		else if(argument.isFunction())
		{
			argument=applyFunctionToPointerConversion(argument);
		}
		else
		{
			argument.value.setQualifiers(CvQualifiers());
		}
	}
	const SimpleType*parameterType=getClassType(removePointer(parameter));
	const SimpleType*argumentType=getClassType(removePointer(argument));
	if(parameterType!=0&&parameterType->declaration->isTemplate&&argumentType!=0&&isComplete(*argumentType->declaration)&&parameter.isPointer()==argument.isPointer()&&argumentType->primary!=parameterType->primary)
	{
		instantiateClass(*argumentType, context);
		const SimpleType*base=findUniqueBase(*argumentType, *parameterType->primary);
		if(base!=0)
		{
			bool isPointer=argument.isPointer();
			CvQualifiers qualifiers=removePointer(argument).value.getQualifiers();
			argument=makeUniqueSimpleType(*base);
			argument.value.setQualifiers(qualifiers);
			if(isPointer)
			{
				argument.push_front(PointerType());
			}
		}
	}
}
inline bool deduce(UniqueTypeWrapper parameter, UniqueTypeWrapper argument, TemplateArgumentsInstance&result, bool allowGreaterCvQualification)
{
	if(!isDependent(parameter))
	{
		return !isDependent(argument);
	}
	std::size_t depth=0;
	for(;
	!parameter.empty()&&!argument.empty();
	parameter.pop_front(), argument.pop_front(), ++depth)
	{
		if(allowGreaterCvQualification)
		{
			allowGreaterCvQualification=(parameter.isPointer()||parameter.isMemberPointer())&&(depth==0||parameter.value.getQualifiers().isConst);
			if(isGreaterCvQualification(parameter, argument))
			{
				parameter.value.setQualifiers(argument.value.getQualifiers());
			}
		}
		if(!parameter.isDependent())
		{
			if(!isSameType(parameter, argument))
			{
				return false;
			}
			if(!isEqualCvQualification(parameter, argument))
			{
				return false;
			}
		}
		if(parameter.isDependent())
		{
			if(isGreaterCvQualification(parameter, argument))
			{
				return false;
			}
			CvQualifiers qualifiers=argument.value.getQualifiers();
			qualifiers.isConst^=parameter.value.getQualifiers().isConst;
			qualifiers.isVolatile^=parameter.value.getQualifiers().isVolatile;
			argument.value.setQualifiers(qualifiers);
		}
		DeduceVisitor visitor(argument, result);
		parameter.value->accept(visitor);
		if(!visitor.result)
		{
			return false;
		}
	}
	return true;
}
inline bool deduceFunctionCall(const ParameterTypes&parameters, const UniqueTypeArray&arguments, TemplateArgumentsInstance&result, const InstantiationContext&context)
{
	try
	{
		UniqueTypeArray::const_iterator p=parameters.begin();
		for(UniqueTypeArray::const_iterator a=arguments.begin();
		a!=arguments.end()&&p!=parameters.end();
		++a, ++p)
		{
			UniqueTypeWrapper parameter=*p;
			UniqueTypeWrapper argument=*a;
			adjustFunctionCallDeductionPair(parameter, argument, context);
			if(!deduce(parameter, argument, result, true))
			{
				throw DeductionFailure();
			}
		}
		if(std::find(result.begin(), result.end(), gUniqueTypeNull)!=result.end())
		{
			throw DeductionFailure();
		}
	}
	catch(DeductionFailure)
	{
		return false;
	}
	return true;
}
extern BuiltInTypeId gVoid;
inline void substitute(UniqueTypeArray&substituted, const UniqueTypeArray&dependent, const InstantiationContext&context)
{
	for(UniqueTypeArray::const_iterator i=dependent.begin();
	i!=dependent.end();
	++i)
	{
		UniqueTypeWrapper type=substitute(*i, context);
		substituted.push_back(type);
	}
}
inline Declaration*findTemplateSpecialization(Declaration*declaration, TemplateArgumentsInstance&deducedArguments, const TemplateArgumentsInstance&arguments, const InstantiationContext&context, bool allowDependent);
inline UniqueTypeWrapper makeUniqueTemplateArgument(const TemplateArgument&argument, const InstantiationContext&context, bool allowDependent=false);
inline UniqueTypeWrapper substitute(Declaration*declaration, const SimpleType*enclosing, const TemplateArgumentsInstance&templateArguments, const InstantiationContext&context)
{
	SimpleType result(declaration, enclosing);
	if(declaration->isTemplate)
	{
		result.declaration=result.primary=findPrimaryTemplate(declaration);
		substitute(result.templateArguments, templateArguments, context);
		TemplateArguments::const_iterator i=result.declaration->templateParams.defaults.begin();
		std::advance(i, templateArguments.size());
		for(;
		i!=result.declaration->templateParams.defaults.end();
		++i)
		{
			if((*i).type.declaration==0)
			{
				throw TooFewTemplateArgumentsError(context.source);
			}
			UniqueTypeWrapper argument=makeUniqueTemplateArgument(*i, setEnclosingTypeSafe(context, &result), isDependent(result));
			UniqueTypeWrapper substituted=substitute(argument, setEnclosingTypeSafe(context, &result));
			result.templateArguments.push_back(substituted);
		}
		if(!(std::distance(result.declaration->templateParams.begin(), result.declaration->templateParams.end())==result.templateArguments.size()))
		{
			throw AllocatorError();
		};
	}
	static size_t uniqueId=0;
	result.uniqueId=++uniqueId;
	return makeUniqueSimpleType(result);
}
inline const SimpleType*substitute(const SimpleType&instance, const InstantiationContext&context)
{
	const SimpleType*enclosing=0;
	if(instance.enclosing!=0)
	{
		enclosing=substitute(*instance.enclosing, context);
	}
	UniqueTypeWrapper result=substitute(instance.declaration, enclosing, instance.templateArguments, context);
	return &getSimpleType(result.value);
}
inline LookupResult findNamespaceDeclaration(Scope&scope, const Identifier&id, LookupFilter filter=IsAny());
struct SubstituteVisitor: TypeElementVisitor
{
	UniqueTypeWrapper type;
	const InstantiationContext context;
	SubstituteVisitor(UniqueTypeWrapper type, const InstantiationContext&context): type(type), context(context)
	{
	}
	virtual void visit(const DependentType&element)
	{
		std::size_t index=element.type->templateParameter;
		if(!(index!=INDEX_INVALID))
		{
			throw AllocatorError();
		};
		const SimpleType*enclosingTemplate=findEnclosingTemplate(context.enclosingType, element.type->scope);
		if(!(enclosingTemplate!=0))
		{
			throw AllocatorError();
		};
		if(!(!enclosingTemplate->declaration->isSpecialization||enclosingTemplate->instantiated))
		{
			throw AllocatorError();
		};
		const TemplateArgumentsInstance&templateArguments=enclosingTemplate->declaration->isSpecialization?enclosingTemplate->deducedArguments: enclosingTemplate->templateArguments;
		if(!(index<templateArguments.size()))
		{
			throw AllocatorError();
		};
		if(!(type==gUniqueTypeNull))
		{
			throw AllocatorError();
		};
		type=templateArguments[index];
		if(element.templateParameterCount!=0)
		{
			if(type.isDependentType())
			{
				DependentType result=getDependentType(type.value);
				substitute(result.templateArguments, element.templateArguments, context);
				type=gUniqueTypeNull;
				type.push_front(result);
			}
			else
			{
				if(!type.isTemplateTemplateArgument())
				{
					throw ExpectedTemplateTemplateArgumentError(context.source, type);
				}
				const TemplateTemplateArgument&argument=getTemplateTemplateArgument(type.value);
				if(std::distance(argument.declaration->templateParams.begin(), argument.declaration->templateParams.end())!=element.templateParameterCount)
				{
					throw MismatchedTemplateTemplateArgumentError(context.source, type);
				}
				if(!element.templateArguments.empty())
				{
					type=substitute(argument.declaration, argument.enclosing, element.templateArguments, context);
				}
			}
		}
	}
	virtual void visit(const DependentTypename&element)
	{
		if(isDependent(*context.enclosingType))
		{
			type.push_front(element);
			return ;
		}
		Identifier id;
		id.value=element.name;
		Declaration*declaration=0;
		const SimpleType*memberEnclosing=0;

		{
			UniqueTypeWrapper qualifying=substitute(element.qualifying, context);
			if(!(qualifying!=gUniqueTypeNull))
			{
				throw AllocatorError();
			};

			{
				const SimpleType*enclosing=qualifying.isSimple()?&getSimpleType(qualifying.value): 0;
				if(enclosing==0||!isClass(*enclosing->declaration))
				{
					throw QualifyingIsNotClassError(context.source, qualifying);
				}
				instantiateClass(*enclosing, context);
				std::size_t visibility=enclosing->instantiating?context.enclosingType->instantiation.pointOfInstantiation: VISIBILITY_ALL;
				LookupResultRef result=findDeclaration(*enclosing, id, element.isNested?LookupFilter(IsNestedName(visibility)): LookupFilter(IsAny(visibility)));
				if(result==0)
				{
					LookupResultRef result=findDeclaration(*enclosing, id, element.isNested?LookupFilter(IsNestedName(VISIBILITY_ALL)): LookupFilter(IsAny(VISIBILITY_ALL)));
					if(result!=0)
					{
						std::cout<<"visibility: "<<visibility<<std::endl;
						std::cout<<"found with VISIBILITY_ALL: "<<result.p->visibility<<std::endl;
					}
					throw MemberNotFoundError(context.source, element.name, qualifying);
				}
				declaration=result;
				if(!isType(*declaration))
				{
					throw MemberIsNotTypeError(context.source, element.name, qualifying);
				}
				if(!(isMember(*declaration)))
				{
					throw AllocatorError();
				};
				memberEnclosing=findEnclosingType(enclosing, declaration->scope);
			}
		}
		if(isClass(*declaration)||isEnum(*declaration))
		{
			type=substitute(declaration, memberEnclosing, element.templateArguments, context);
			return ;
		}
		if(!(declaration->specifiers.isTypedef))
		{
			throw AllocatorError();
		};
		if(!(declaration->type.unique!=0))
		{
			throw AllocatorError();
		};
		type=UniqueTypeWrapper(declaration->type.unique);
		if(declaration->type.isDependent)
		{
			if(!(memberEnclosing!=0))
			{
				throw AllocatorError();
			};
			type=substitute(type, setEnclosingTypeSafe(context, memberEnclosing));
		}
	}
	virtual void visit(const DependentNonType&element)
	{
		if(isDependent(*context.enclosingType))
		{
			type.push_front(element);
			return ;
		}
		IntegralConstant value=evaluateExpression(element.expression, context);
		type.push_front(NonType(value));
	}
	virtual void visit(const TemplateTemplateArgument&element)
	{
		type.push_front(element);
	}
	virtual void visit(const NonType&element)
	{
		type.push_front(element);
	}
	virtual void visit(const SimpleType&element)
	{
		const SimpleType*result=substitute(element, context);
		type.push_front(*result);
	}
	virtual void visit(const PointerType&element)
	{
		if(type.isReference())
		{
			throw PointerToReferenceError(context.source);
		}
		type.push_front(element);
	}
	virtual void visit(const ReferenceType&element)
	{
		if(type.isReference()||type==gVoid)
		{
			throw ReferenceToReferenceError(context.source);
		}
		type.push_front(element);
	}
	virtual void visit(const ArrayType&element)
	{
		if(type.isFunction()||type.isReference()||type==gVoid)
		{
			throw InvalidArrayError(context.source);
		}
		type.push_front(element);
	}
	virtual void visit(const MemberPointerType&element)
	{
		UniqueTypeWrapper classType=substitute(element.type, context);
		if(!classType.isSimple()||!isClass(*getSimpleType(classType.value).declaration))
		{
			throw QualifyingIsNotClassError(context.source, classType);
		}
		type.push_front(MemberPointerType(classType));
	}
	virtual void visit(const FunctionType&element)
	{
		FunctionType result;
		result.isEllipsis=element.isEllipsis;
		substitute(result.parameterTypes, element.parameterTypes, context);
		if(std::find(result.parameterTypes.begin(), result.parameterTypes.end(), gVoid)!=result.parameterTypes.end())
		{
			throw VoidParameterError(context.source);
		}
		type.push_front(result);
	}
};
inline UniqueTypeWrapper substitute(UniqueTypeWrapper dependent, const InstantiationContext&context)
{
	UniqueTypeWrapper inner=dependent;
	inner.pop_front();
	UniqueTypeWrapper type=inner.empty()?gUniqueTypeNull: substitute(inner, context);
	SubstituteVisitor visitor(type, context);
	dependent.value->accept(visitor);
	visitor.type.value.addQualifiers(dependent.value.getQualifiers());
	return visitor.type;
}
inline UniqueTypeWrapper makeUniqueType(const TypeId&type, const InstantiationContext&context, bool allowDependent);
inline UniqueTypeWrapper makeUniqueType(const Type&type, const InstantiationContext&context, bool allowDependent);
inline void reportTypeInfo(const Type&type, const SimpleType*enclosing)
{
	printPosition(type.id->source);
	std::cout<<std::endl;
	std::cout<<"while uniquing: ";
	if(!(type.unique!=0))
	{
		throw AllocatorError();
	};
	printType(UniqueTypeWrapper(type.unique));
	std::cout<<std::endl;
	std::cout<<"in context: ";
	if(!(enclosing!=0))
	{
		throw AllocatorError();
	};
	printType(*enclosing);
	std::cout<<std::endl;
}
extern BuiltInTypeId gSignedInt;
template<typename T>
inline UniqueTypeWrapper getUniqueTypeImpl(const T&type, const InstantiationContext&context, bool allowDependent)
{
	if(!(type.unique!=0))
	{
		throw AllocatorError();
	};
	UniqueTypeWrapper result=UniqueTypeWrapper(type.unique);
	if(type.isDependent&&!allowDependent)
	{
		UniqueTypeWrapper substituted=substitute(result, context);
		if(!(!isDependent(substituted)))
		{
			throw AllocatorError();
		};
		return substituted;
	}
	return result;
}
inline UniqueTypeWrapper getUniqueType(const TypeId&type, const InstantiationContext&context, bool allowDependent)
{
	return getUniqueTypeImpl(type, context, allowDependent);
}
inline UniqueTypeWrapper getUniqueType(const Type&type, const InstantiationContext&context, bool allowDependent)
{
	return getUniqueTypeImpl(type, context, allowDependent);
}
inline Scope*getEnclosingTemplate(Scope*enclosing)
{
	for(Scope*scope=enclosing;
	scope!=0;
	scope=scope->parent)
	{
		if(isTemplate(*scope))
		{
			return scope;
		}
	}
	return 0;
}
inline bool findScope(Scope*scope, Scope*other)
{
	if(scope==0)
	{
		return false;
	}
	if(scope==other)
	{
		return true;
	}
	return findScope(scope->parent, other);
}
inline Declaration*getClassDeclaration(Scope*scope)
{
	if(!(scope))
	{
		throw AllocatorError();
	};
	if(!(scope->type==SCOPETYPE_CLASS))
	{
		throw AllocatorError();
	};
	return getDeclaration(scope->name);
}
inline Declaration*findEnclosingClassTemplate(Declaration*dependent)
{
	if(dependent!=0&&(isClass(*dependent)||isEnum(*dependent))&&isMember(*dependent))
	{
		Scope*scope=getEnclosingClass(dependent->scope);
		if(scope==0)
		{
			return 0;
		}
		Declaration*declaration=getClassDeclaration(scope);
		return declaration->isTemplate?declaration: findEnclosingClassTemplate(declaration);
	}
	return 0;
}
inline bool isDependentImpl(Declaration*dependent, Scope*enclosing, Scope*templateParamScope)
{
	return dependent!=0&&(findScope(enclosing, dependent->scope)!=0||findScope(templateParamScope, dependent->scope)!=0);
}
inline Declaration*findOverloaded(const DeclarationInstance&instance)
{
	for(const DeclarationInstance*p=&instance;
	p!=0;
	p=p->overloaded)
	{
		if((*p).redeclared==0)
		{
			return *p;
		}
	}
	return 0;
}
inline std::size_t addBase(SimpleType&instance, UniqueTypeWrapper base, const InstantiationContext&context)
{
	if(!(!isDependent(base)))
	{
		throw AllocatorError();
	};
	if(!(base.isSimple()))
	{
		throw AllocatorError();
	};
	const SimpleType&objectType=getSimpleType(base.value);
	std::size_t size=instantiateClass(objectType, setEnclosingTypeSafe(context, &instance));
	if(!(isClass(*objectType.declaration)))
	{
		throw AllocatorError();
	};
	if(!(objectType.declaration->enclosed!=0))
	{
		throw AllocatorError();
	};
	instance.bases.push_back(&objectType);
	return size;
}
inline bool isTemplate(const SimpleType&instance)
{
	if(instance.declaration->isTemplate)
	{
		return true;
	}
	return instance.enclosing!=0&&isTemplate(*instance.enclosing);
}
void dumpTemplateInstantiations(const SimpleType&instance, bool root=false);
inline std::size_t instantiateClass(const SimpleType&instanceConst, const InstantiationContext&context, bool allowDependent)
{
	SimpleType&instance=const_cast<SimpleType&>(instanceConst);
	if(!(isClass(*instance.declaration)))
	{
		throw AllocatorError();
	};
	if(context.enclosingType!=0)
	{
		ChildInstantiations&instantiations=const_cast<SimpleType*>(context.enclosingType)->childInstantiations;
		instantiations.push_back(ChildInstantiation(&instance, context.source));
	}
	if(instance.instantiated)
	{
		return instance.size;
	}
	try
	{
		instance.instantiated=true;
		if(!(!instance.instantiating))
		{
			throw AllocatorError();
		};
		instance.instantiating=true;
		instance.instantiation=context.source;
		static std::size_t uniqueId=0;
		instance.uniqueId=++uniqueId;
		if(!allowDependent&&instance.declaration->isTemplate)
		{
			const DeclarationInstance*declaration=findDeclaration(instance.declaration->scope->declarations, instance.declaration->getName());
			if(!(declaration!=0))
			{
				throw AllocatorError();
			};
			Declaration*specialization=findTemplateSpecialization(findOverloaded(*declaration), instance.deducedArguments, instance.templateArguments, InstantiationContext(context.source, instance.enclosing, context.enclosingScope), false);
			if(specialization!=0)
			{
				instance.declaration=specialization;
			}
		}
		if(instance.declaration->enclosed==0)
		{
			std::cout<<"instantiateClass failed: ";
			printType(instance);
			std::cout<<std::endl;
			return 0;
		}
		if(!(instance.declaration->type.unique!=0))
		{
			throw AllocatorError();
		};
		const SimpleType&original=getSimpleType(instance.declaration->type.unique);
		instance.size=4;
		if(!(instance.declaration->enclosed!=0))
		{
			throw AllocatorError();
		};
		Types&bases=instance.declaration->enclosed->bases;
		instance.bases.reserve(std::distance(bases.begin(), bases.end()));
		for(Types::const_iterator i=bases.begin();
		i!=bases.end();
		++i)
		{
			InstantiationContext baseContext=InstantiationContext(original.instantiation, &instance, context.enclosingScope);
			UniqueTypeId base=getUniqueType(*i, baseContext, allowDependent);
			if(!((*i).unique!=0))
			{
				throw AllocatorError();
			};
			if(!((*i).isDependent||base.value==(*i).unique))
			{
				throw AllocatorError();
			};
			if(allowDependent&&(*i).isDependent)
			{
				continue;
			}
			instance.size+=addBase(instance, base, baseContext);
		}
		instance.allowLookup=true;
		if(!allowDependent)
		{
			if(!original.children.empty()&&&instance!=&original)
			{
				if(!(instance.declaration->isComplete))
				{
					throw AllocatorError();
				};
				instance.children.reserve(original.children.size());
				InstanceLocations::const_iterator l=original.childLocations.begin();
				for(InstantiatedTypes::const_iterator i=original.children.begin();
				i!=original.children.end();
				++i, ++l)
				{
					InstantiationContext childContext(*l, &instance, context.enclosingScope);
					UniqueTypeWrapper substituted=substitute(*i, childContext);
					if(!(!isDependent(substituted)))
					{
						throw AllocatorError();
					};
					instance.children.push_back(substituted);
				}
			}
		}
		instance.instantiating=false;
	}
	catch(TypeError&)
	{
		printPosition(context.source);
		std::cout<<"while instantiating ";
		printType(instance);
		std::cout<<std::endl;
		if(instance.declaration->isTemplate)
		{
			const TemplateArgumentsInstance&templateArguments=instance.declaration->isSpecialization?instance.deducedArguments: instance.templateArguments;
			TemplateArgumentsInstance::const_iterator a=templateArguments.begin();
			for(TemplateParameters::const_iterator i=instance.declaration->templateParams.begin();
			i!=instance.declaration->templateParams.end();
			++i)
			{
				if(!(a!=templateArguments.end()))
				{
					throw AllocatorError();
				};
				std::cout<<getValue((*i).declaration->getName())<<": ";
				printType(*a++);
				std::cout<<std::endl;
			}
		}
		if(context.enclosingType==0||!isTemplate(*context.enclosingType))
		{
			dumpTemplateInstantiations(instance, true);
		}
		throw;
	}
	return instance.size;
}
inline std::size_t requireCompleteObjectType(UniqueTypeWrapper type, const InstantiationContext&context)
{
	std::size_t count=1;
	while(type.isArray()&&getArrayType(type.value).size!=0)
	{
		count*=getArrayType(type.value).size;
		type.pop_front();
	}
	if(type.isSimple())
	{
		const SimpleType&objectType=getSimpleType(type.value);
		if(isClass(*objectType.declaration))
		{
			return instantiateClass(objectType, context)*count;
		}
	}
	return 4;
}
inline UniqueTypeWrapper makeUniqueQualifying(const Qualifying&qualifying, const InstantiationContext&context, bool allowDependent=false)
{
	return qualifying.empty()||isNamespace(*qualifying.back().declaration)?gUniqueTypeNull: getUniqueType(qualifying.back(), context, allowDependent);
}
inline const SimpleType*makeUniqueEnclosing(const Qualifying&qualifying, const InstantiationContext&context, bool allowDependent, UniqueTypeWrapper&unique)
{
	if(!qualifying.empty())
	{
		if(isNamespace(*qualifying.back().declaration))
		{
			return 0;
		}
		unique=getUniqueType(qualifying.back(), context, allowDependent);
		if(allowDependent&&qualifying.back().isDependent)
		{
			return 0;
		}
		const SimpleType&type=getSimpleType(unique.value);
		instantiateClass(type, context, allowDependent);
		return &type;
	}
	return context.enclosingType;
}
inline const SimpleType*makeUniqueEnclosing(const Qualifying&qualifying, const InstantiationContext&context, bool allowDependent)
{
	UniqueTypeWrapper tmp;
	return makeUniqueEnclosing(qualifying, context, allowDependent, tmp);
}
inline bool deduceAndSubstitute(const UniqueTypeArray&parameters, const UniqueTypeArray&arguments, const InstantiationContext&context, SimpleType&enclosing, TemplateArgumentsInstance&substituted)
{
	TemplateArgumentsInstance&deduced=enclosing.deducedArguments;
	if(!deducePairs(parameters, arguments, deduced)||std::find(deduced.begin(), deduced.end(), gUniqueTypeNull)!=deduced.end())
	{
		return false;
	}
	try
	{
		substitute(substituted, parameters, setEnclosingTypeSafe(context, &enclosing));
	}
	catch(TypeError&)
	{
		if(!(std::find(substituted.begin(), substituted.end(), gUniqueTypeNull)==substituted.end()))
		{
			throw AllocatorError();
		};
		return false;
	}
	return true;
}
inline bool matchTemplatePartialSpecialization(Declaration*declaration, TemplateArgumentsInstance&deducedArguments, const TemplateArgumentsInstance&specializationArguments, const TemplateArgumentsInstance&arguments, const InstantiationContext&context)
{
	if(!(!declaration->templateParams.empty()))
	{
		throw AllocatorError();
	};
	TemplateArgumentsInstance deduced(std::distance(declaration->templateParams.begin(), declaration->templateParams.end()), gUniqueTypeNull);
	TemplateArgumentsInstance substituted;
	SimpleType enclosing(declaration, 0);
	enclosing.deducedArguments.swap(deduced);
	enclosing.instantiated=true;
	if(!deduceAndSubstitute(specializationArguments, arguments, context, enclosing, substituted))
	{
		return false;
	}
	if(std::equal(substituted.begin(), substituted.end(), arguments.begin()))
	{
		deducedArguments.swap(enclosing.deducedArguments);
		return true;
	}
	return false;
}
inline bool matchTemplatePartialSpecialization(Declaration*declaration, const TemplateArgumentsInstance&specializationArguments, const TemplateArgumentsInstance&arguments, const InstantiationContext&context)
{
	TemplateArgumentsInstance deducedArguments;
	return matchTemplatePartialSpecialization(declaration, deducedArguments, specializationArguments, arguments, context);
}
inline UniqueTypeWrapper makeUniqueTemplateArgument(const TemplateArgument&argument, const InstantiationContext&context, bool allowDependent)
{
	if(!(argument.type.declaration!=0))
	{
		throw AllocatorError();
	};
	extern Declaration gNonType;
	if(argument.type.declaration==&gNonType)
	{
		if(allowDependent&&argument.expression.isValueDependent)
		{
			return pushType(gUniqueTypeNull, DependentNonType(argument.expression));
		}
		IntegralConstant value=evaluateExpression(argument.expression, context);
		return pushType(gUniqueTypeNull, NonType(value));
	}
	return getUniqueType(argument.type, context, allowDependent&&argument.type.isDependent);
}
inline void makeUniqueTemplateArguments(TemplateArguments&templateArguments, TemplateArgumentsInstance&result, const InstantiationContext&context, bool allowDependent=false)
{
	for(TemplateArguments::const_iterator i=templateArguments.begin();
	i!=templateArguments.end();
	++i)
	{
		UniqueTypeWrapper type=makeUniqueTemplateArgument(*i, context, allowDependent);
		result.push_back(type);
	}
}
inline void makeUniqueTemplateParameters(const TemplateParameters&templateParams, TemplateArgumentsInstance&arguments, const InstantiationContext&context, bool allowDependent)
{
	for(Types::const_iterator i=templateParams.begin();
	i!=templateParams.end();
	++i)
	{
		const Type&argument=(*i);
		UniqueTypeWrapper result;
		extern Declaration gParam;
		if(argument.declaration->type.declaration==&gParam)
		{
			result=getUniqueType(argument, context, allowDependent);
			if(!(result.value!=UNIQUETYPE_NULL))
			{
				throw AllocatorError();
			};
		}
		else
		{
			UniqueExpression expression=makeUniqueExpression(NonTypeTemplateParameter(argument.declaration));
			if(allowDependent)
			{
				result=pushType(gUniqueTypeNull, DependentNonType(expression));
			}
			else
			{
				IntegralConstant value=evaluateExpression(expression, context);
				result=pushType(gUniqueTypeNull, NonType(value));
			}
		}
		arguments.push_back(result);
	}
	if(!(!arguments.empty()))
	{
		throw AllocatorError();
	};
}
inline Declaration*findTemplateSpecialization(Declaration*declaration, TemplateArgumentsInstance&deducedArguments, const TemplateArgumentsInstance&arguments, const InstantiationContext&context, bool allowDependent)
{
	Declaration*best=0;
	TemplateArgumentsInstance bestArguments;
	for(;
	declaration!=0;
	declaration=declaration->overloaded)
	{
		if(!isSpecialization(*declaration))
		{
			continue;
		}
		TemplateArgumentsInstance specializationArguments;
		makeUniqueTemplateArguments(declaration->templateArguments, specializationArguments, context, true);
		if(!(specializationArguments.size()<=arguments.size()))
		{
			throw AllocatorError();
		};
		if(declaration->templateParams.empty())
		{
			if(std::equal(specializationArguments.begin(), specializationArguments.end(), arguments.begin()))
			{
				deducedArguments.clear();
				return declaration;
			}
			continue;
		}
		TemplateArgumentsInstance deduced;
		if(matchTemplatePartialSpecialization(declaration, deduced, specializationArguments, arguments, context))
		{
			if(best!=0)
			{
				bool atLeastAsSpecializedCurrent=matchTemplatePartialSpecialization(best, bestArguments, specializationArguments, context);
				bool atLeastAsSpecializedBest=matchTemplatePartialSpecialization(declaration, specializationArguments, bestArguments, context);
				if(atLeastAsSpecializedCurrent&&atLeastAsSpecializedBest)
				{
					struct AmbiguousSpecialization: TypeError
					{
						void report()
						{
							std::cout<<"ambiguous specialization!";
							std::cout<<std::endl;
						}
					};
					throw AmbiguousSpecialization();
				}
				if(atLeastAsSpecializedBest)
				{
					continue;
				}
			}
			best=declaration;
			bestArguments.swap(specializationArguments);
			deducedArguments.swap(deduced);
		}
	}
	return best;
}
inline void makeUniqueTemplateArguments(const TemplateArguments&arguments, TemplateArgumentsInstance&templateArguments, const InstantiationContext&context, bool allowDependent)
{
	for(TemplateArguments::const_iterator i=arguments.begin();
	i!=arguments.end();
	++i)
	{
		const TemplateArgument&argument=*i;
		if(!(argument.type.declaration!=0))
		{
			throw AllocatorError();
		};
		UniqueTypeWrapper result=makeUniqueTemplateArgument(argument, context, allowDependent);
		templateArguments.push_back(result);
	}
}
inline const SimpleType*findEnclosingType(const SimpleType&enclosing, Scope*scope)
{
	if(!(scope!=0))
	{
		throw AllocatorError();
	};
	if(scope->type==SCOPETYPE_TEMPLATE)
	{
		return enclosing.declaration->templateParamScope==scope?&enclosing: 0;
	}
	if(enclosing.declaration->enclosed==scope)
	{
		return &enclosing;
	}
	if(enclosing.declaration->enclosed!=0)
	{
		if(!(enclosing.instantiated))
		{
			throw AllocatorError();
		};
	}
	for(UniqueBases::const_iterator i=enclosing.bases.begin();
	i!=enclosing.bases.end();
	++i)
	{
		const SimpleType*result=findEnclosingType(*(*i), scope);
		if(result!=0)
		{
			return result;
		}
	}
	return 0;
}
inline const SimpleType*findEnclosingType(const SimpleType*enclosing, Scope*scope)
{
	if(!(scope!=0))
	{
		throw AllocatorError();
	};
	for(const SimpleType*i=enclosing;
	i!=0;
	i=(*i).enclosing)
	{
		const SimpleType*result=findEnclosingType(*i, scope);
		if(result!=0)
		{
			return result;
		}
	}
	return 0;
}
inline UniqueTypeWrapper makeUniqueSimpleType(const SimpleType&type)
{
	if(!(!(type.primary->isTemplate&&isSpecialization(*type.primary))))
	{
		throw AllocatorError();
	};
	return UniqueTypeWrapper(pushUniqueType(gUniqueTypes, UNIQUETYPE_NULL, type));
}
struct LookupFailed: TypeError
{
	const SimpleType*enclosing;
	const Identifier*id;
	LookupFailed(const SimpleType*enclosing, const Identifier*id): enclosing(enclosing), id(id)
	{
	}
	void report()
	{
		std::cout<<"lookup failed: ";
		printType(*enclosing);
		std::cout<<"::"<<id->value.c_str()<<std::endl;
	}
};
inline UniqueTypeWrapper makeUniqueType(const Type&type, const InstantiationContext&context, bool allowDependent)
{
	UniqueTypeWrapper qualifying;
	const SimpleType*enclosing=makeUniqueEnclosing(type.qualifying, context, allowDependent, qualifying);
	Declaration*declaration=type.declaration;
	extern Declaration gDependentType;
	extern Declaration gDependentTemplate;
	extern Declaration gDependentNested;
	extern Declaration gDependentNestedTemplate;
	if(declaration==&gDependentType||declaration==&gDependentTemplate||declaration==&gDependentNested||declaration==&gDependentNestedTemplate)
	{
		if(!(allowDependent))
		{
			throw AllocatorError();
		};
		bool isNested=declaration==&gDependentNested||declaration==&gDependentNestedTemplate;
		if(!(type.id!=IdentifierPtr(0)))
		{
			throw AllocatorError();
		};
		TemplateArgumentsInstance templateArguments;
		makeUniqueTemplateArguments(type.templateArguments, templateArguments, context, allowDependent);
		return pushType(gUniqueTypeNull, DependentTypename(type.id->value, qualifying, templateArguments, isNested, declaration->isTemplate));
	}
	size_t index=declaration->templateParameter;
	if(index!=INDEX_INVALID)
	{
		if(!(allowDependent))
		{
			throw AllocatorError();
		};
		if(!(type.qualifying.empty()))
		{
			throw AllocatorError();
		};
		const SimpleType*parameterEnclosing=findEnclosingType(enclosing, declaration->scope);
		if(parameterEnclosing!=0&&!isDependent(*parameterEnclosing))
		{
			if(!(!parameterEnclosing->declaration->isSpecialization||parameterEnclosing->instantiated))
			{
				throw AllocatorError();
			};
			const TemplateArgumentsInstance&arguments=parameterEnclosing->declaration->isSpecialization?parameterEnclosing->deducedArguments: parameterEnclosing->templateArguments;
			if(!(index<arguments.size()))
			{
				throw AllocatorError();
			};
			UniqueTypeWrapper result=arguments[index];
			if(!(result!=gUniqueTypeNull))
			{
				throw AllocatorError();
			};
			return result;
		}
		TemplateArgumentsInstance templateArguments;
		makeUniqueTemplateArguments(type.templateArguments, templateArguments, context, allowDependent);
		std::size_t templateParameterCount=declaration->isTemplate?std::distance(declaration->templateParams.begin(), declaration->templateParams.end()): 0;
		return UniqueTypeWrapper(pushUniqueType(gUniqueTypes, UNIQUETYPE_NULL, DependentType(declaration, templateArguments, templateParameterCount)));
	}
	const SimpleType*memberEnclosing=isMember(*declaration)?findEnclosingType(enclosing, declaration->scope): 0;
	if(declaration->specifiers.isTypedef)
	{
		UniqueTypeWrapper result=getUniqueType(declaration->type, setEnclosingType(context, memberEnclosing), allowDependent);
		if(memberEnclosing!=0&&!allowDependent&&declaration->instance!=INDEX_INVALID)
		{
			if(!(memberEnclosing->instantiated))
			{
				throw AllocatorError();
			};
			if(!(declaration->instance<memberEnclosing->children.size()))
			{
				throw AllocatorError();
			};
			if(!(memberEnclosing->children[declaration->instance]==result))
			{
				throw AllocatorError();
			};
		}
		return result;
	}
	if(declaration->isTemplate&&type.isImplicitTemplateId&&!type.isEnclosingClass)
	{
		return UniqueTypeWrapper(pushUniqueType(gUniqueTypes, UNIQUETYPE_NULL, TemplateTemplateArgument(declaration, memberEnclosing)));
	}
	SimpleType tmp(declaration, memberEnclosing);
	if(!(declaration->type.declaration!=&gArithmetic||tmp.enclosing==0))
	{
		throw AllocatorError();
	};
	if(declaration->isTemplate)
	{
		tmp.declaration=tmp.primary=findPrimaryTemplate(declaration);
		bool isEnclosingSpecialization=type.isEnclosingClass&&isSpecialization(*type.declaration);
		const TemplateArguments&defaults=tmp.declaration->templateParams.defaults;
		if(!(!defaults.empty()))
		{
			throw AllocatorError();
		};
		if(type.isImplicitTemplateId&&!isEnclosingSpecialization)
		{
			bool dependent=allowDependent||!type.isEnclosingClass;
			makeUniqueTemplateParameters(tmp.declaration->templateParams, tmp.templateArguments, context, dependent);
		}
		else
		{
			const TemplateArguments&arguments=isEnclosingSpecialization?type.declaration->templateArguments: type.templateArguments;
			TemplateArguments::const_iterator a=arguments.begin();
			for(TemplateArguments::const_iterator i=defaults.begin();
			i!=defaults.end();
			++i)
			{
				bool isTemplateParamDefault=a==arguments.end();
				if(allowDependent&&isTemplateParamDefault)
				{
					break;
				}
				const TemplateArgument&argument=isTemplateParamDefault?(*i): (*a++);
				if(!(argument.type.declaration!=0))
				{
					throw AllocatorError();
				};
				const SimpleType*enclosing=isTemplateParamDefault?&tmp: context.enclosingType;
				UniqueTypeWrapper result=makeUniqueTemplateArgument(argument, InstantiationContext(argument.source, enclosing, context.enclosingScope), allowDependent);
				tmp.templateArguments.push_back(result);
			}
			if(!(allowDependent||!tmp.templateArguments.empty()))
			{
				throw AllocatorError();
			};
		}
	}
	if(!(tmp.bases.empty()))
	{
		throw AllocatorError();
	};
	if(!(tmp.children.empty()))
	{
		throw AllocatorError();
	};
	static size_t uniqueId=0;
	tmp.uniqueId=++uniqueId;
	return makeUniqueSimpleType(tmp);
}
inline std::size_t evaluateArraySize(const ExpressionWrapper&expression, const InstantiationContext&context)
{
	if(expression==0)
	{
		return 0;
	}
	if(expression.isValueDependent)
	{
		return -1;
	}
	if(!(expression.isConstant))
	{
		throw AllocatorError();
	};
	return evaluate(expression, context).value;
}
struct TypeSequenceMakeUnique: TypeSequenceVisitor
{
	UniqueType&type;
	const InstantiationContext context;
	bool allowDependent;
	TypeSequenceMakeUnique(UniqueType&type, const InstantiationContext&context, bool allowDependent): type(type), context(context), allowDependent(allowDependent)
	{
	}
	void visit(const DeclaratorPointerType&element)
	{
		pushUniqueType(type, PointerType());
		type.setQualifiers(element.qualifiers);
	}
	void visit(const DeclaratorReferenceType&element)
	{
		pushUniqueType(type, ReferenceType());
	}
	void visit(const DeclaratorArrayType&element)
	{
		for(ArrayRank::const_reverse_iterator i=element.rank.rbegin();
		i!=element.rank.rend();
		++i)
		{
			pushUniqueType(type, ArrayType(evaluateArraySize(*i, context)));
		}
	}
	void visit(const DeclaratorMemberPointerType&element)
	{
		UniqueTypeWrapper tmp=getUniqueType(element.type, context, allowDependent);
		if(!(allowDependent||!tmp.isDependent()))
		{
			throw AllocatorError();
		};
		pushUniqueType(type, MemberPointerType(tmp));
		type.setQualifiers(element.qualifiers);
	}
	void visit(const DeclaratorFunctionType&element)
	{
		FunctionType result;
		result.isEllipsis=element.parameters.isEllipsis;
		result.parameterTypes.reserve(element.parameters.size());
		for(Parameters::const_iterator i=element.parameters.begin();
		i!=element.parameters.end();
		++i)
		{
			result.parameterTypes.push_back(getUniqueType((*i).declaration->type, context, allowDependent));
		}
		pushUniqueType(type, result);
		type.setQualifiers(element.qualifiers);
	}
};
inline UniqueTypeWrapper makeUniqueType(const TypeId&type, const InstantiationContext&context, bool allowDependent)
{
	UniqueTypeWrapper result=makeUniqueType(*static_cast<const Type*>(&type), context, allowDependent);
	result.value.addQualifiers(type.qualifiers);
	TypeSequenceMakeUnique visitor(result.value, context, allowDependent);
	type.typeSequence.accept(visitor);
	return result;
}
template<typename T, bool isExpression=IsConvertible<T, cpp::expression>::RESULT>
struct ExpressionType;
template<typename T>
struct ExpressionType<T, false>
{
	static UniqueTypeId get(T*symbol)
	{
		return gUniqueTypeNull;
	}
	static void set(T*symbol, UniqueTypeId declaration)
	{
	}
};
inline UniqueTypeId getExpressionType(cpp::expression*symbol)
{
	return UniqueTypeId(symbol->type.p);
}
inline void setExpressionType(cpp::expression*symbol, UniqueTypeId value)
{
	symbol->type.p=value.value;
}
inline UniqueTypeId getExpressionType(cpp::postfix_expression_suffix*symbol)
{
	return UniqueTypeId(symbol->type.p);
}
inline void setExpressionType(cpp::postfix_expression_suffix*symbol, UniqueTypeId value)
{
	symbol->type.p=value.value;
}
inline UniqueTypeId getExpressionType(cpp::type_id*symbol)
{
	return UniqueTypeId(symbol->type.p);
}
inline void setExpressionType(cpp::type_id*symbol, UniqueTypeId value)
{
	symbol->type.p=value.value;
}
inline UniqueTypeId getExpressionType(cpp::base_specifier*symbol)
{
	return UniqueTypeId(symbol->type.p);
}
inline void setExpressionType(cpp::base_specifier*symbol, UniqueTypeId value)
{
	symbol->type.p=value.value;
}
template<typename T>
struct ExpressionType<T, true>
{
	static UniqueTypeId get(T*symbol)
	{
		return getExpressionType(symbol);
	}
	static void set(T*symbol, UniqueTypeId declaration)
	{
		setExpressionType(symbol, declaration);
	}
};
extern Declaration gUndeclared;
extern const DeclarationInstance gUndeclaredInstance;
struct BuiltInTypeDeclaration: Declaration
{
	BuiltInTypeDeclaration(Identifier&name, const TypeId&type=TypeId(&gArithmetic, ParserAllocatorWrapper<int>(NullParserAllocator()))): Declaration(ParserAllocatorWrapper<int>(NullParserAllocator()), 0, name, type, 0)
	{
	}
};
extern Declaration gEnumerator;
extern BuiltInTypeDeclaration gCharDeclaration;
extern BuiltInTypeDeclaration gSignedCharDeclaration;
extern BuiltInTypeDeclaration gUnsignedCharDeclaration;
extern BuiltInTypeDeclaration gSignedShortIntDeclaration;
extern BuiltInTypeDeclaration gUnsignedShortIntDeclaration;
extern BuiltInTypeDeclaration gSignedIntDeclaration;
extern BuiltInTypeDeclaration gUnsignedIntDeclaration;
extern BuiltInTypeDeclaration gSignedLongIntDeclaration;
extern BuiltInTypeDeclaration gUnsignedLongIntDeclaration;
extern BuiltInTypeDeclaration gSignedLongLongIntDeclaration;
extern BuiltInTypeDeclaration gUnsignedLongLongIntDeclaration;
extern BuiltInTypeDeclaration gWCharTDeclaration;
extern BuiltInTypeDeclaration gBoolDeclaration;
extern BuiltInTypeDeclaration gFloatDeclaration;
extern BuiltInTypeDeclaration gDoubleDeclaration;
extern BuiltInTypeDeclaration gLongDoubleDeclaration;
extern BuiltInTypeDeclaration gVoidDeclaration;
extern BuiltInTypeId gChar;
extern BuiltInTypeId gSignedChar;
extern BuiltInTypeId gUnsignedChar;
extern BuiltInTypeId gSignedShortInt;
extern BuiltInTypeId gUnsignedShortInt;
extern BuiltInTypeId gSignedInt;
extern BuiltInTypeId gUnsignedInt;
extern BuiltInTypeId gSignedLongInt;
extern BuiltInTypeId gUnsignedLongInt;
extern BuiltInTypeId gSignedLongLongInt;
extern BuiltInTypeId gUnsignedLongLongInt;
extern BuiltInTypeId gWCharT;
extern BuiltInTypeId gBool;
extern BuiltInTypeId gFloat;
extern BuiltInTypeId gDouble;
extern BuiltInTypeId gLongDouble;
extern BuiltInTypeId gVoid;
typedef ArrayRange<BuiltInType>BuiltInTypeArrayRange;
typedef UniqueTypeGeneric<false>UserType;
template<bool builtIn, int N>
struct TypeTuple;
template<bool builtIn>
struct TypeTuple<builtIn, 1>: UniqueTypeGeneric<builtIn>
{
	TypeTuple(UniqueTypeGeneric<builtIn>type): UniqueTypeGeneric<builtIn>(type)
	{
	}
};
template<bool builtIn>
struct TypeTuple<builtIn, 2>: std::pair<UniqueTypeGeneric<builtIn>, UniqueTypeGeneric<builtIn> >
{
	typedef UniqueTypeGeneric<builtIn>Value;
	TypeTuple(Value first, Value second): std::pair<Value, Value>(first, second)
	{
	}
};
template<int N>
struct BuiltInGenericType: BuiltInType
{
	typedef UserType(*Substitute)(TypeTuple<false, N>args);
	Substitute substitute;
	BuiltInGenericType(BuiltInType type, Substitute substitute): BuiltInType(type), substitute(substitute)
	{
	}
};
typedef BuiltInGenericType<1>BuiltInGenericType1;
typedef BuiltInGenericType<2>BuiltInGenericType2;
typedef ArrayRange<BuiltInGenericType1>BuiltInGenericType1ArrayRange;
typedef ArrayRange<BuiltInGenericType2>BuiltInGenericType2ArrayRange;
inline bool isVoid(UniqueTypeWrapper type)
{
	return type.value.getPointer()==gVoid.value.getPointer();
}
inline bool isVoidPointer(UniqueTypeWrapper type)
{
	if(!type.isPointer())
	{
		return false;
	}
	type.pop_front();
	return isVoid(type);
}
inline bool isVoidParameter(const TypeId&type)
{
	return type.declaration==&gVoidDeclaration&&type.typeSequence.empty();
}
struct StringLiteralTypeId: BuiltInTypeId
{
	StringLiteralTypeId(Declaration*declaration, const ParserAllocatorWrapper<int>&allocator): BuiltInTypeId(declaration, allocator)
	{
		value=pushBuiltInType(value, ArrayType(0));
	}
};
extern StringLiteralTypeId gStringLiteral;
extern StringLiteralTypeId gWideStringLiteral;
inline unsigned combineFundamental(unsigned fundamental, unsigned token)
{
	unsigned mask=1<<token;
	if((fundamental&mask)!=0)
	{
		mask<<=16;
	}
	return fundamental|mask;
}
inline Declaration*getFundamentalType(unsigned fundamental)
{
	switch(fundamental)
	{
		case(1<<cpp::simple_type_specifier_builtin::CHAR): return &gCharDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::CHAR): return &gSignedCharDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::CHAR): return &gUnsignedCharDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::SHORT): case(1<<cpp::simple_type_specifier_builtin::SHORT)|(1<<cpp::simple_type_specifier_builtin::INT): case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::SHORT): case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::SHORT)|(1<<cpp::simple_type_specifier_builtin::INT): return &gSignedShortIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::SHORT): case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::SHORT)|(1<<cpp::simple_type_specifier_builtin::INT): return &gUnsignedShortIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::INT): case(1<<cpp::simple_type_specifier_builtin::SIGNED): case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::INT): return &gSignedIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::UNSIGNED): case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::INT): return &gUnsignedIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::LONG): case(1<<cpp::simple_type_specifier_builtin::LONG)|(1<<cpp::simple_type_specifier_builtin::INT): case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::LONG): case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::LONG)|(1<<cpp::simple_type_specifier_builtin::INT): return &gSignedLongIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::LONG): case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::LONG)|(1<<cpp::simple_type_specifier_builtin::INT): return &gUnsignedLongIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::LONG)|((1<<cpp::simple_type_specifier_builtin::LONG)<<16): case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::LONG)|((1<<cpp::simple_type_specifier_builtin::LONG)<<16): case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::LONG)|((1<<cpp::simple_type_specifier_builtin::LONG)<<16)|(1<<cpp::simple_type_specifier_builtin::INT): return &gSignedLongLongIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::LONG)|((1<<cpp::simple_type_specifier_builtin::LONG)<<16): case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::LONG)|((1<<cpp::simple_type_specifier_builtin::LONG)<<16)|(1<<cpp::simple_type_specifier_builtin::INT): return &gUnsignedLongLongIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::WCHAR_T): return &gWCharTDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::BOOL): return &gBoolDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::FLOAT): return &gFloatDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::DOUBLE): return &gDoubleDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::LONG)|(1<<cpp::simple_type_specifier_builtin::DOUBLE): return &gLongDoubleDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::VOID): return &gVoidDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::INT64): case(1<<cpp::simple_type_specifier_builtin::SIGNED)|(1<<cpp::simple_type_specifier_builtin::INT64): return &gSignedLongLongIntDeclaration;
		case(1<<cpp::simple_type_specifier_builtin::UNSIGNED)|(1<<cpp::simple_type_specifier_builtin::INT64): return &gUnsignedLongLongIntDeclaration;
	}
	if(!(false))
	{
		throw AllocatorError();
	};
	return 0;
}
inline bool isHexadecimalLiteral(const char*value)
{
	return *value++=='0'&&(*value=='x'||*value=='X');
}
inline bool isFloatingLiteral(const char*value)
{
	if(!isHexadecimalLiteral(value))
	{
		const char*p=value;
		for(;
		*p!='\0';
		++p)
		{
			if(std::strchr(".eE", *p)!=0)
			{
				return true;
			}
		}
	}
	return false;
}
inline const char*getIntegerLiteralSuffix(const char*value)
{
	const char*p=value;
	for(;
	*p!='\0';
	++p)
	{
		if(std::strchr("ulUL", *p)!=0)
		{
			break;
		}
	}
	return p;
}
inline const UniqueTypeId&getIntegerLiteralSuffixType(const char*suffix)
{
	if(*suffix=='\0')
	{
		return gSignedInt;
	}
	if(*(suffix+1)=='\0')
	{
		return *suffix=='u'||*suffix=='U'?gUnsignedInt: gSignedLongInt;
	}
	if(*(suffix+2)=='\0')
	{
		return gUnsignedLongInt;
	}
	throw SymbolsError();
}
inline const UniqueTypeId&getIntegerLiteralType(const char*value)
{
	return getIntegerLiteralSuffixType(getIntegerLiteralSuffix(value));
}
inline IntegralConstantExpression parseIntegerLiteral(const char*value)
{
	char*suffix;
	IntegralConstant result(strtol(value, &suffix, 0));
	return IntegralConstantExpression(getIntegerLiteralSuffixType(suffix), result);
}
inline const char*getFloatingLiteralSuffix(const char*value)
{
	const char*p=value;
	for(;
	*p!='\0';
	++p)
	{
		if(std::strchr("flFL", *p)!=0)
		{
			break;
		}
	}
	return p;
}
inline const UniqueTypeId&getFloatingLiteralSuffixType(const char*suffix)
{
	if(*suffix=='\0')
	{
		return gDouble;
	}
	if(*(suffix+1)=='\0')
	{
		return *suffix=='f'||*suffix=='F'?gFloat: gLongDouble;
	}
	throw SymbolsError();
}
inline const UniqueTypeId&getFloatingLiteralType(const char*value)
{
	return getFloatingLiteralSuffixType(getFloatingLiteralSuffix(value));
}
inline IntegralConstantExpression parseFloatingLiteral(const char*value)
{
	char*suffix;
	IntegralConstant result(strtod(value, &suffix));
	return IntegralConstantExpression(getFloatingLiteralSuffixType(suffix), result);
}
inline const UniqueTypeId&getCharacterLiteralType(const char*value)
{
	return *value=='L'?gWCharT: gChar;
}
inline IntegralConstantExpression parseCharacterLiteral(const char*value)
{
	IntegralConstant result;
	return IntegralConstantExpression(getCharacterLiteralType(value), result);
}
inline const UniqueTypeId&getNumericLiteralType(cpp::numeric_literal*symbol)
{
	const char*value=symbol->value.value.c_str();
	switch(symbol->id)
	{
		case cpp::numeric_literal::INTEGER: return getIntegerLiteralType(value);
		case cpp::numeric_literal::CHARACTER: return getCharacterLiteralType(value);
		case cpp::numeric_literal::FLOATING: return getFloatingLiteralType(value);
		case cpp::numeric_literal::BOOLEAN: return gBool;
		default: break;
	}
	throw SymbolsError();
}
inline IntegralConstantExpression parseBooleanLiteral(const char*value)
{
	return IntegralConstantExpression(gBool, IntegralConstant(*value=='t'?1: 0));
}
inline IntegralConstantExpression parseNumericLiteral(cpp::numeric_literal*symbol)
{
	const char*value=symbol->value.value.c_str();
	switch(symbol->id)
	{
		case cpp::numeric_literal::INTEGER: return parseIntegerLiteral(value);
		case cpp::numeric_literal::CHARACTER: return parseCharacterLiteral(value);
		case cpp::numeric_literal::FLOATING: return parseFloatingLiteral(value);
		case cpp::numeric_literal::BOOLEAN: return parseBooleanLiteral(value);
		default: break;
	}
	throw SymbolsError();
}
inline const UniqueTypeId&getStringLiteralType(cpp::string_literal*symbol)
{
	const char*value=symbol->value.value.c_str();
	return *value=='L'?gWideStringLiteral: gStringLiteral;
}
extern Declaration gDependentType;
extern const DeclarationInstance gDependentTypeInstance;
extern Declaration gDependentObject;
extern const DeclarationInstance gDependentObjectInstance;
extern Declaration gDependentTemplate;
extern const DeclarationInstance gDependentTemplateInstance;
extern Declaration gDependentNested;
extern const DeclarationInstance gDependentNestedInstance;
extern Declaration gDependentNestedTemplate;
extern const DeclarationInstance gDependentNestedTemplateInstance;
extern Declaration gParam;
extern Declaration gNonType;
extern Name gOperatorNewId;
extern Name gOperatorDeleteId;
extern Name gOperatorNewArrayId;
extern Name gOperatorDeleteArrayId;
extern Name gOperatorPlusId;
extern Name gOperatorMinusId;
extern Name gOperatorStarId;
extern Name gOperatorDivideId;
extern Name gOperatorPercentId;
extern Name gOperatorXorId;
extern Name gOperatorAndId;
extern Name gOperatorOrId;
extern Name gOperatorComplId;
extern Name gOperatorNotId;
extern Name gOperatorAssignId;
extern Name gOperatorLessId;
extern Name gOperatorGreaterId;
extern Name gOperatorPlusAssignId;
extern Name gOperatorMinusAssignId;
extern Name gOperatorStarAssignId;
extern Name gOperatorDivideAssignId;
extern Name gOperatorPercentAssignId;
extern Name gOperatorXorAssignId;
extern Name gOperatorAndAssignId;
extern Name gOperatorOrAssignId;
extern Name gOperatorShiftLeftId;
extern Name gOperatorShiftRightId;
extern Name gOperatorShiftRightAssignId;
extern Name gOperatorShiftLeftAssignId;
extern Name gOperatorEqualId;
extern Name gOperatorNotEqualId;
extern Name gOperatorLessEqualId;
extern Name gOperatorGreaterEqualId;
extern Name gOperatorAndAndId;
extern Name gOperatorOrOrId;
extern Name gOperatorPlusPlusId;
extern Name gOperatorMinusMinusId;
extern Name gOperatorCommaId;
extern Name gOperatorArrowStarId;
extern Name gOperatorArrowId;
extern Name gOperatorFunctionId;
extern Name gOperatorSubscriptId;
inline Name getOverloadableOperatorId(cpp::overloadable_operator_default*symbol)
{
	switch(symbol->id)
	{
		case cpp::overloadable_operator_default::ASSIGN: return gOperatorAssignId;
		case cpp::overloadable_operator_default::STARASSIGN: return gOperatorStarAssignId;
		case cpp::overloadable_operator_default::DIVIDEASSIGN: return gOperatorDivideAssignId;
		case cpp::overloadable_operator_default::PERCENTASSIGN: return gOperatorPercentAssignId;
		case cpp::overloadable_operator_default::PLUSASSIGN: return gOperatorPlusAssignId;
		case cpp::overloadable_operator_default::MINUSASSIGN: return gOperatorMinusAssignId;
		case cpp::overloadable_operator_default::SHIFTRIGHTASSIGN: return gOperatorShiftRightAssignId;
		case cpp::overloadable_operator_default::SHIFTLEFTASSIGN: return gOperatorShiftLeftAssignId;
		case cpp::overloadable_operator_default::ANDASSIGN: return gOperatorAndAssignId;
		case cpp::overloadable_operator_default::XORASSIGN: return gOperatorXorAssignId;
		case cpp::overloadable_operator_default::ORASSIGN: return gOperatorOrAssignId;
		case cpp::overloadable_operator_default::EQUAL: return gOperatorEqualId;
		case cpp::overloadable_operator_default::NOTEQUAL: return gOperatorNotEqualId;
		case cpp::overloadable_operator_default::LESS: return gOperatorLessId;
		case cpp::overloadable_operator_default::GREATER: return gOperatorGreaterId;
		case cpp::overloadable_operator_default::LESSEQUAL: return gOperatorLessEqualId;
		case cpp::overloadable_operator_default::GREATEREQUAL: return gOperatorGreaterEqualId;
		case cpp::overloadable_operator_default::ANDAND: return gOperatorAndAndId;
		case cpp::overloadable_operator_default::OROR: return gOperatorOrOrId;
		case cpp::overloadable_operator_default::PLUSPLUS: return gOperatorPlusPlusId;
		case cpp::overloadable_operator_default::MINUSMINUS: return gOperatorMinusMinusId;
		case cpp::overloadable_operator_default::STAR: return gOperatorStarId;
		case cpp::overloadable_operator_default::DIVIDE: return gOperatorDivideId;
		case cpp::overloadable_operator_default::PERCENT: return gOperatorPercentId;
		case cpp::overloadable_operator_default::PLUS: return gOperatorPlusId;
		case cpp::overloadable_operator_default::MINUS: return gOperatorMinusId;
		case cpp::overloadable_operator_default::SHIFTLEFT: return gOperatorShiftLeftId;
		case cpp::overloadable_operator_default::SHIFTRIGHT: return gOperatorShiftRightId;
		case cpp::overloadable_operator_default::AND: return gOperatorAndId;
		case cpp::overloadable_operator_default::OR: return gOperatorOrId;
		case cpp::overloadable_operator_default::XOR: return gOperatorXorId;
		case cpp::overloadable_operator_default::NOT: return gOperatorNotId;
		case cpp::overloadable_operator_default::COMPL: return gOperatorComplId;
		case cpp::overloadable_operator_default::ARROW: return gOperatorArrowId;
		case cpp::overloadable_operator_default::ARROWSTAR: return gOperatorArrowStarId;
		case cpp::overloadable_operator_default::COMMA: return gOperatorCommaId;
		default: break;
	}
	throw SymbolsError();
}
inline Name getOverloadableOperatorId(cpp::new_operator*symbol)
{
	if(symbol->array.p!=0)
	{
		return gOperatorNewArrayId;
	}
	return gOperatorNewId;
}
inline Name getOverloadableOperatorId(cpp::delete_operator*symbol)
{
	if(symbol->array.p!=0)
	{
		return gOperatorDeleteArrayId;
	}
	return gOperatorDeleteId;
}
inline Name getOverloadableOperatorId(cpp::function_operator*symbol)
{
	return gOperatorFunctionId;
}
inline Name getOverloadableOperatorId(cpp::array_operator*symbol)
{
	return gOperatorSubscriptId;
}
inline Name getOverloadedOperatorId(cpp::postfix_operator*symbol)
{
	switch(symbol->id)
	{
		case cpp::postfix_operator::PLUSPLUS: return gOperatorPlusPlusId;
		case cpp::postfix_operator::MINUSMINUS: return gOperatorMinusMinusId;
		default: break;
	}
	throw SymbolsError();
}
inline Name getOverloadedOperatorId(cpp::unary_operator*symbol)
{
	switch(symbol->id)
	{
		case cpp::unary_operator::PLUSPLUS: return gOperatorPlusPlusId;
		case cpp::unary_operator::MINUSMINUS: return gOperatorMinusMinusId;
		case cpp::unary_operator::STAR: return gOperatorStarId;
		case cpp::unary_operator::AND: return gOperatorAndId;
		case cpp::unary_operator::PLUS: return gOperatorPlusId;
		case cpp::unary_operator::MINUS: return gOperatorMinusId;
		case cpp::unary_operator::NOT: return gOperatorNotId;
		case cpp::unary_operator::COMPL: return gOperatorComplId;
		default: break;
	}
	throw SymbolsError();
}
inline Name getOverloadedOperatorId(cpp::pm_expression_default*symbol)
{
	if(symbol->op->id==cpp::pm_operator::ARROWSTAR)
	{
		return gOperatorArrowStarId;
	}
	return Name();
}
inline Name getOverloadedOperatorId(cpp::multiplicative_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::multiplicative_operator::STAR: return gOperatorStarId;
		case cpp::multiplicative_operator::DIVIDE: return gOperatorDivideId;
		case cpp::multiplicative_operator::PERCENT: return gOperatorPercentId;
		default: break;
	}
	throw SymbolsError();
}
inline Name getOverloadedOperatorId(cpp::additive_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::additive_operator::PLUS: return gOperatorPlusId;
		case cpp::additive_operator::MINUS: return gOperatorMinusId;
		default: break;
	}
	throw SymbolsError();
}
inline Name getOverloadedOperatorId(cpp::shift_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::shift_operator::SHIFTLEFT: return gOperatorShiftLeftId;
		case cpp::shift_operator::SHIFTRIGHT: return gOperatorShiftRightId;
		default: break;
	}
	throw SymbolsError();
}
inline Name getOverloadedOperatorId(cpp::relational_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::relational_operator::LESS: return gOperatorLessId;
		case cpp::relational_operator::GREATER: return gOperatorGreaterId;
		case cpp::relational_operator::LESSEQUAL: return gOperatorLessEqualId;
		case cpp::relational_operator::GREATEREQUAL: return gOperatorGreaterEqualId;
		default: break;
	}
	throw SymbolsError();
}
inline Name getOverloadedOperatorId(cpp::equality_expression_default*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::equality_operator::EQUAL: return gOperatorEqualId;
		case cpp::equality_operator::NOTEQUAL: return gOperatorNotEqualId;
		default: break;
	}
	throw SymbolsError();
}
inline Name getOverloadedOperatorId(cpp::and_expression_default*symbol)
{
	return gOperatorAndId;
}
inline Name getOverloadedOperatorId(cpp::exclusive_or_expression_default*symbol)
{
	return gOperatorXorId;
}
inline Name getOverloadedOperatorId(cpp::inclusive_or_expression_default*symbol)
{
	return gOperatorOrId;
}
inline Name getOverloadedOperatorId(cpp::logical_and_expression_default*symbol)
{
	return gOperatorAndAndId;
}
inline Name getOverloadedOperatorId(cpp::logical_or_expression_default*symbol)
{
	return gOperatorOrOrId;
}
inline Name getOverloadedOperatorId(cpp::assignment_expression_suffix*symbol)
{
	switch(symbol->op->id)
	{
		case cpp::assignment_operator::ASSIGN: return gOperatorAssignId;
		case cpp::assignment_operator::STAR: return gOperatorStarAssignId;
		case cpp::assignment_operator::DIVIDE: return gOperatorDivideAssignId;
		case cpp::assignment_operator::PERCENT: return gOperatorPercentAssignId;
		case cpp::assignment_operator::PLUS: return gOperatorPlusAssignId;
		case cpp::assignment_operator::MINUS: return gOperatorMinusAssignId;
		case cpp::assignment_operator::SHIFTRIGHT: return gOperatorShiftRightAssignId;
		case cpp::assignment_operator::SHIFTLEFT: return gOperatorShiftLeftAssignId;
		case cpp::assignment_operator::AND: return gOperatorAndAssignId;
		case cpp::assignment_operator::XOR: return gOperatorXorAssignId;
		case cpp::assignment_operator::OR: return gOperatorOrAssignId;
		default: break;
	}
	throw SymbolsError();
}
extern Identifier gConversionFunctionId;
extern Identifier gOperatorFunctionTemplateId;
extern Identifier gAnonymousId;
extern Identifier gDestructorId;
inline UniqueTypeWrapper binaryOperatorAssignment(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	return left;
}
inline UniqueTypeWrapper binaryOperatorComma(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	return right;
}
inline UniqueTypeWrapper binaryOperatorBoolean(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	return gBool;
}
inline UniqueTypeWrapper binaryOperatorMemberPointer(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	return popType(right);
}
inline UniqueTypeWrapper ternaryOperatorNull(UniqueTypeWrapper first, UniqueTypeWrapper second, UniqueTypeWrapper third)
{
	return gUniqueTypeNull;
}
inline bool isClass(UniqueTypeWrapper type)
{
	return type.isSimple()&&getSimpleType(type.value).declaration->type.declaration==&gClass;
}
inline bool isEnum(UniqueTypeWrapper type)
{
	return type.isSimple()&&getSimpleType(type.value).declaration->type.declaration==&gEnum;
}
inline bool isObject(UniqueTypeWrapper type)
{
	return type!=gVoid&&!type.isReference()&&!type.isFunction();
}
inline bool isComplete(const UniqueTypeId&type)
{
	return type.isSimple()&&isComplete(*getSimpleType(type.value).declaration);
}
inline bool isArithmetic(const UniqueTypeId&type)
{
	return type.isSimple()&&getSimpleType(type.value).declaration->type.declaration==&gArithmetic;
}
inline bool isFloating(const UniqueTypeId&type)
{
	return isEqual(type, gFloat)||isEqual(type, gDouble)||isEqual(type, gLongDouble);
}
inline bool isIntegral(const UniqueTypeId&type)
{
	return isArithmetic(type)&&!isFloating(type);
}
inline bool isPromotedIntegral(UniqueTypeWrapper type)
{
	return type==gSignedInt||type==gUnsignedInt||type==gSignedLongInt||type==gUnsignedLongInt||type==gSignedLongLongInt||type==gUnsignedLongLongInt;
}
inline bool isPromotedArithmetic(UniqueTypeWrapper type)
{
	return isPromotedIntegral(type)||isFloating(type);
}
inline bool isEnumeration(const UniqueTypeId&type)
{
	return isEnum(type);
}
inline const Declaration*getType(const Declaration&declaration)
{
	if(declaration.specifiers.isTypedef)
	{
		return getType(*declaration.type.declaration);
	}
	return declaration.type.declaration;
}
inline const Type&getUnderlyingType(const Type&type)
{
	if(type.declaration->specifiers.isTypedef&&type.declaration->templateParameter==INDEX_INVALID)
	{
		return getUnderlyingType(type.declaration->type);
	}
	return type;
}
inline bool isEqual(const TypeId&l, const TypeId&r)
{
	if(!(l.unique!=0))
	{
		throw AllocatorError();
	};
	if(!(r.unique!=0))
	{
		throw AllocatorError();
	};
	return l.unique==r.unique;
}
inline bool isEqual(const Type&left, const Type&right)
{
	if(!(left.unique!=0))
	{
		throw AllocatorError();
	};
	if(!(right.unique!=0))
	{
		throw AllocatorError();
	};
	return left.unique==right.unique;
}
inline bool isEqual(const TemplateArgument&l, const TemplateArgument&r)
{
	if((l.type.declaration==&gNonType)!=(r.type.declaration==&gNonType))
	{
		return false;
	}
	return l.type.declaration==&gNonType?l.expression.p==r.expression.p: isEqual(l.type, r.type);
}
inline bool matchTemplateSpecialization(const Declaration&declaration, const TemplateArguments&arguments)
{
	TemplateArguments::const_iterator a=arguments.begin();
	for(TemplateArguments::const_iterator i=declaration.templateArguments.begin();
	i!=declaration.templateArguments.end();
	++i)
	{
		if(!(a!=arguments.end()))
		{
			throw AllocatorError();
		};
		if(!isEqual(*i, *a))
		{
			return false;
		}
		++a;
	}
	if(!(a==arguments.end()))
	{
		throw AllocatorError();
	};
	return true;
}
inline Declaration*findTemplateSpecialization(Declaration*declaration, const TemplateArguments&arguments)
{
	for(;
	declaration!=0;
	declaration=declaration->overloaded)
	{
		if(!isSpecialization(*declaration))
		{
			continue;
		}
		if(matchTemplateSpecialization(*declaration, arguments))
		{
			return declaration;
		}
	}
	return 0;
}
enum IcsRank
{
	ICSRANK_STANDARDEXACT, ICSRANK_STANDARDPROMOTION, ICSRANK_STANDARDCONVERSION, ICSRANK_USERDEFINED, ICSRANK_ELLIPSIS, ICSRANK_INVALID,
};
enum ScsRank
{
	SCSRANK_IDENTITY, SCSRANK_EXACT, SCSRANK_PROMOTION, SCSRANK_CONVERSION, SCSRANK_INVALID,
};
struct StandardConversionSequence
{
	ScsRank rank;
	CvQualifiers adjustment;
	bool isReference;
	UniqueTypeWrapper matched;
	StandardConversionSequence(ScsRank rank, CvQualifiers adjustment, UniqueTypeWrapper matched=gUniqueTypeNull): rank(rank), adjustment(adjustment), isReference(false), matched(matched)
	{
	}
};
const StandardConversionSequence STANDARDCONVERSIONSEQUENCE_INVALID=StandardConversionSequence(SCSRANK_INVALID, CvQualifiers());
inline bool findBase(const SimpleType&other, const SimpleType&type)
{
	if(!(other.declaration!=&gParam))
	{
		throw AllocatorError();
	};
	if(!(other.declaration->enclosed!=0))
	{
		throw AllocatorError();
	};
	if(!(isClass(*type.declaration)))
	{
		throw AllocatorError();
	};
	for(UniqueBases::const_iterator i=other.bases.begin();
	i!=other.bases.end();
	++i)
	{
		const SimpleType&base=*(*i);
		if(!(isClass(*base.declaration)))
		{
			throw AllocatorError();
		};
		if(&base==&type)
		{
			return true;
		}
		if(findBase(base, type))
		{
			return true;
		}
	}
	return false;
}
inline bool isBaseOf(const SimpleType&type, const SimpleType&other, const InstantiationContext&context)
{
	if(!isClass(*type.declaration)||!isClass(*other.declaration))
	{
		return false;
	}
	if(isIncomplete(*type.declaration)||isIncomplete(*other.declaration))
	{
		return false;
	}
	instantiateClass(other, context);
	return findBase(other, type);
}
inline const UniqueTypeId&promoteToIntegralType(const UniqueTypeId&type)
{
	if(isEqual(type, gChar)||isEqual(type, gSignedChar)||isEqual(type, gUnsignedChar)||isEqual(type, gSignedShortInt)||isEqual(type, gUnsignedShortInt))
	{
		return gSignedInt;
	}
	if(isEqual(type, gWCharT)||isEnumeration(type))
	{
		return gSignedInt;
	}
	if(isEqual(type, gBool))
	{
		return gSignedInt;
	}
	return type;
}
inline BuiltInType usualArithmeticConversions(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	if(!(left!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	if(!(right!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	if(!(isArithmetic(left)||isEnumeration(left)))
	{
		throw AllocatorError();
	};
	if(!(isArithmetic(right)||isEnumeration(right)))
	{
		throw AllocatorError();
	};
	if(isEqual(left, gLongDouble)||isEqual(right, gLongDouble))
	{
		return gLongDouble;
	}
	if(isEqual(left, gDouble)||isEqual(right, gDouble))
	{
		return gDouble;
	}
	if(isEqual(left, gFloat)||isEqual(right, gFloat))
	{
		return gFloat;
	}
	left=promoteToIntegralType(left);
	right=promoteToIntegralType(right);
	if(isEqual(left, gUnsignedLongInt)||isEqual(right, gUnsignedLongInt))
	{
		return gUnsignedLongInt;
	}
	if((isEqual(left, gSignedLongInt)&&isEqual(right, gUnsignedInt))||(isEqual(left, gUnsignedInt)&&isEqual(right, gSignedLongInt)))
	{
		return gUnsignedLongInt;
	}
	if(isEqual(left, gSignedLongInt)||isEqual(right, gSignedLongInt))
	{
		return gSignedLongInt;
	}
	if(isEqual(left, gUnsignedInt)||isEqual(right, gUnsignedInt))
	{
		return gUnsignedInt;
	}
	return gSignedInt;
}
inline UniqueTypeWrapper applyArrayToPointerConversion(UniqueTypeWrapper type)
{
	if(!(type.isArray()))
	{
		throw AllocatorError();
	};
	type.pop_front();
	type.push_front(PointerType());
	return type;
}
inline UniqueTypeWrapper applyFunctionToPointerConversion(UniqueTypeWrapper type)
{
	if(!(type.isFunction()))
	{
		throw AllocatorError();
	};
	type.push_front(PointerType());
	return type;
}
inline UniqueTypeWrapper applyLvalueToRvalueConversion(UniqueTypeWrapper type)
{
	if(type.isArray())
	{
		return applyArrayToPointerConversion(type);
	}
	if(type.isFunction())
	{
		return applyFunctionToPointerConversion(type);
	}
	return type;
}
inline CvQualifiers makeQualificationAdjustment(UniqueTypeId to, UniqueTypeId from)
{
	return CvQualifiers(to.value.getQualifiers().isConst>from.value.getQualifiers().isConst, to.value.getQualifiers().isVolatile>from.value.getQualifiers().isVolatile);
}
struct TargetType: UniqueTypeWrapper
{
	TargetType(UniqueTypeWrapper type): UniqueTypeWrapper(type)
	{
	}
};
extern BuiltInTypeId gArithmeticPlaceholder;
extern BuiltInTypeId gIntegralPlaceholder;
extern BuiltInTypeId gPromotedIntegralPlaceholder;
extern BuiltInTypeId gPromotedArithmeticPlaceholder;
extern BuiltInTypeId gEnumerationPlaceholder;
extern BuiltInTypeId gPointerToAnyPlaceholder;
extern BuiltInTypeId gPointerToObjectPlaceholder;
extern BuiltInTypeId gPointerToClassPlaceholder;
extern BuiltInTypeId gPointerToFunctionPlaceholder;
extern BuiltInTypeId gPointerToMemberPlaceholder;
inline UniqueTypeWrapper getExactMatch(UniqueTypeWrapper to, UniqueTypeWrapper from)
{
	return isEqual(to, from)?from: gUniqueTypeNull;
}
inline UniqueTypeWrapper getExactMatch(TargetType to, UniqueTypeWrapper from)
{
	if(to==gPromotedArithmeticPlaceholder&&isPromotedArithmetic(from))
	{
		return from;
	}
	if(to==gArithmeticPlaceholder&&isArithmetic(from))
	{
		return from;
	}
	if(to==gIntegralPlaceholder&&isIntegral(from))
	{
		return from;
	}
	if(to==gPromotedIntegralPlaceholder&&isPromotedIntegral(from))
	{
		return from;
	}
	if(to==gEnumerationPlaceholder&&isEnumeration(from))
	{
		return from;
	}
	if(from.isPointer())
	{
		if(to==gPointerToAnyPlaceholder)
		{
			return from;
		}
		if(to==gPointerToObjectPlaceholder&&isObject(popType(from)))
		{
			return from;
		}
		if(to==gPointerToClassPlaceholder&&isClass(popType(from)))
		{
			return from;
		}
		if(to==gPointerToFunctionPlaceholder&&popType(from).isFunction())
		{
			return from;
		}
	}
	if(to==gPointerToMemberPlaceholder&&from.isMemberPointer())
	{
		return from;
	}
	return getExactMatch(UniqueTypeWrapper(to), from);
}
template<typename To>
inline UniqueTypeWrapper getExactMatchNoQualifiers(To to, UniqueTypeWrapper from)
{
	to.value.setQualifiers(CvQualifiers());
	from.value.setQualifiers(CvQualifiers());
	return getExactMatch(to, from);
}
inline bool isArithmetic(TargetType to)
{
	if(to==gArithmeticPlaceholder||to==gPromotedArithmeticPlaceholder||to==gIntegralPlaceholder||to==gPromotedIntegralPlaceholder)
	{
		return true;
	}
	return isArithmetic(UniqueTypeWrapper(to));
}
template<typename To>
inline StandardConversionSequence makeScsPromotion(To to, UniqueTypeWrapper from)
{
	if(isArithmetic(from)&&isArithmetic(to))
	{
		if(from==gFloat)
		{
			UniqueTypeWrapper matched=getExactMatch(to, gDouble);
			if(matched!=gUniqueTypeNull)
			{
				return StandardConversionSequence(SCSRANK_PROMOTION, CvQualifiers(), matched);
			}
		}
		UniqueTypeWrapper matched=getExactMatch(to, promoteToIntegralType(from));
		if(matched!=gUniqueTypeNull)
		{
			return StandardConversionSequence(SCSRANK_PROMOTION, CvQualifiers(), matched);
		}
	}
	if(isEnum(from)&&getExactMatch(to, gSignedInt)!=gUniqueTypeNull)
	{
		return StandardConversionSequence(SCSRANK_PROMOTION, CvQualifiers(), gSignedInt);
	}
	return STANDARDCONVERSIONSEQUENCE_INVALID;
}
inline bool isGeneralPointer(UniqueTypeWrapper type)
{
	return type.isPointer()||type.isMemberPointer();
}
inline bool isPointerPlaceholder(UniqueTypeWrapper type)
{
	return type==gPointerToAnyPlaceholder||type==gPointerToObjectPlaceholder||type==gPointerToClassPlaceholder||type==gPointerToFunctionPlaceholder;
}
inline bool isGeneralPointer(TargetType type)
{
	return isPointerPlaceholder(type)||type==gPointerToMemberPlaceholder||isGeneralPointer(UniqueTypeWrapper(type));
}
template<typename To>
inline StandardConversionSequence makeScsConversion(const InstantiationContext&context, To to, UniqueTypeWrapper from, bool isNullPointerConstant=false)
{
	if(!(to.value.getQualifiers()==CvQualifiers()))
	{
		throw AllocatorError();
	};
	if(!(from.value.getQualifiers()==CvQualifiers()))
	{
		throw AllocatorError();
	};
	if((isArithmetic(from)||isEnumeration(from))&&isArithmetic(to))
	{
		return StandardConversionSequence(SCSRANK_CONVERSION, CvQualifiers(), gSignedInt);
	}
	if(isGeneralPointer(to)&&isIntegral(from)&&isNullPointerConstant)
	{
		return StandardConversionSequence(SCSRANK_CONVERSION, CvQualifiers());
	}
	if(to.isSimplePointer()&&from.isSimplePointer()&&getInner(to.value).getPointer()==gVoid.value.getPointer())
	{
		to.pop_front();
		from.pop_front();
		return isEqualCvQualification(to, from)||isGreaterCvQualification(to, from)?StandardConversionSequence(SCSRANK_CONVERSION, makeQualificationAdjustment(to, from)): STANDARDCONVERSIONSEQUENCE_INVALID;
	}
	if(to.isSimplePointer()&&from.isSimplePointer()&&isBaseOf(getSimpleType(getInner(to.value)), getSimpleType(getInner(from.value)), context))
	{
		to.pop_front();
		from.pop_front();
		return isEqualCvQualification(to, from)||isGreaterCvQualification(to, from)?StandardConversionSequence(SCSRANK_CONVERSION, makeQualificationAdjustment(to, from)): STANDARDCONVERSIONSEQUENCE_INVALID;
	}
	if(to.isMemberPointer()&&from.isMemberPointer()&&isBaseOf(getMemberPointerClass(to.value), getMemberPointerClass(from.value), context))
	{
		return StandardConversionSequence(SCSRANK_CONVERSION, CvQualifiers());
	}
	if(to==gBool&&(from.isPointer()||from.isMemberPointer()))
	{
		return StandardConversionSequence(SCSRANK_CONVERSION, CvQualifiers());
	}
	if(to.isSimple()&&from.isSimple()&&isBaseOf(getSimpleType(to.value), getSimpleType(from.value), context))
	{
		return StandardConversionSequence(SCSRANK_CONVERSION, CvQualifiers());
	}
	return STANDARDCONVERSIONSEQUENCE_INVALID;
}
template<typename To>
inline StandardConversionSequence makeScsExactMatch(To target, UniqueTypeWrapper from)
{
	UniqueTypeWrapper matched=getExactMatchNoQualifiers(target, from);
	UniqueTypeWrapper to=target;
	for(;
	;
	)
	{
		if(matched!=gUniqueTypeNull)
		{
			return isEqualCvQualification(to, from)||isGreaterCvQualification(to, from)?StandardConversionSequence(SCSRANK_EXACT, makeQualificationAdjustment(to, from), matched): STANDARDCONVERSIONSEQUENCE_INVALID;
		}
		if(to.isPointer()&&from.isPointer())
		{
		}
		else if(to.isMemberPointer()&&from.isMemberPointer()&&getMemberPointerType(to.value).type==getMemberPointerType(from.value).type)
		{
		}
		else
		{
			break;
		}
		to.pop_front();
		from.pop_front();
		matched=getExactMatchNoQualifiers(to, from);
	}
	return STANDARDCONVERSIONSEQUENCE_INVALID;
}
template<typename To>
inline StandardConversionSequence makeStandardConversionSequence(To to, UniqueTypeWrapper from, const InstantiationContext&context, bool isNullPointerConstant=false, bool isLvalue=false)
{
	if(!(to!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	if(!(from!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	to.value.setQualifiers(CvQualifiers());
	from.value.setQualifiers(CvQualifiers());
	UniqueTypeWrapper tmp=from;
	from=applyLvalueToRvalueConversion(from);
	if(tmp==from&&to==from)
	{
		return StandardConversionSequence(SCSRANK_IDENTITY, CvQualifiers());
	}

	{
		StandardConversionSequence result=makeScsExactMatch(to, from);
		if(result.rank!=SCSRANK_INVALID)
		{
			return result;
		}
	}

	{
		StandardConversionSequence result=makeScsPromotion(to, from);
		if(result.rank!=SCSRANK_INVALID)
		{
			return result;
		}
	}

	{
		StandardConversionSequence result=makeScsConversion(context, to, from, isNullPointerConstant);
		if(result.rank!=SCSRANK_INVALID)
		{
			return result;
		}
	}
	return STANDARDCONVERSIONSEQUENCE_INVALID;
}
inline bool isProperSubsequence(CvQualifiers l, CvQualifiers r)
{
	return !l.isConst&&!l.isVolatile&&(r.isConst||r.isVolatile);
}
inline bool isProperSubsequence(const StandardConversionSequence&l, const StandardConversionSequence&r)
{
	return (l.rank==SCSRANK_IDENTITY&&r.rank!=SCSRANK_IDENTITY)||(l.rank==r.rank&&!l.isReference&&!r.isReference&&isProperSubsequence(l.adjustment, r.adjustment));
}
inline bool isBetter(const StandardConversionSequence&l, const StandardConversionSequence&r)
{
	if(isProperSubsequence(l, r))
	{
		return true;
	}
	if(l.rank<r.rank)
	{
		return true;
	}
	if(l.isReference&&r.isReference&&isGreaterCvQualification(r.adjustment, l.adjustment))
	{
		return true;
	}
	return false;
}
enum IcsType
{
	ICSTYPE_STANDARD, ICSTYPE_USERDEFINED, ICSTYPE_ELLIPSIS,
};
struct ImplicitConversion
{
	StandardConversionSequence sequence;
	IcsType type;
	Declaration*conversion;
	explicit ImplicitConversion(StandardConversionSequence sequence, IcsType type=ICSTYPE_STANDARD, Declaration*conversion=0): sequence(sequence), type(type), conversion(conversion)
	{
	}
};
const ImplicitConversion IMPLICITCONVERSION_ELLIPSIS=ImplicitConversion(StandardConversionSequence(SCSRANK_IDENTITY, CvQualifiers()), ICSTYPE_ELLIPSIS);
struct FunctionOverload
{
	Declaration*declaration;
	UniqueTypeWrapper type;
	FunctionOverload(Declaration*declaration, UniqueTypeWrapper type): declaration(declaration), type(type)
	{
	}
};
template<typename To>
FunctionOverload findBestConversionFunction(To to, Argument from, const InstantiationContext&context, bool isNullPointerConstant=false, bool isLvalue=false);
template<typename To>
ImplicitConversion makeImplicitConversionSequence(To to, Argument from, const InstantiationContext&context, bool isNullPointerConstant=false, bool isLvalue=false, bool isUserDefinedConversion=false)
{
	if(!(to!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	if(!(from.p!=0))
	{
		throw AllocatorError();
	};
	if(!(from.type!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	bool isReference=false;
	if(from.type.isReference())
	{
		isLvalue=true;
		isReference=true;
		from.type.pop_front();
	}
	if(to.isReference())
	{
		to.pop_front();
		if(isLvalue&&(isEqualCvQualification(to, from.type)||isGreaterCvQualification(to, from.type)))
		{
			UniqueTypeWrapper matched=getExactMatchNoQualifiers(to, from.type);
			if(matched!=gUniqueTypeNull)
			{
				StandardConversionSequence sequence(SCSRANK_IDENTITY, to.value.getQualifiers(), matched);
				sequence.isReference=true;
				return ImplicitConversion(sequence);
			}
			if(to.isSimple()&&from.type.isSimple()&&isBaseOf(getSimpleType(to.value), getSimpleType(from.type.value), context))
			{
				StandardConversionSequence sequence(SCSRANK_CONVERSION, to.value.getQualifiers());
				sequence.isReference=true;
				return ImplicitConversion(sequence);
			}
		}
		if(isClass(from.type))
		{
			To tmp=to;
			tmp.push_front(ReferenceType());
			FunctionOverload overload=findBestConversionFunction(tmp, from, context);
			if(overload.declaration!=0)
			{
				UniqueTypeWrapper type=overload.type;
				if(!(type.isReference()))
				{
					throw AllocatorError();
				};
				type.pop_front();
				bool isIdentity=type.value.getPointer()==to.value.getPointer();
				StandardConversionSequence second(isIdentity?SCSRANK_IDENTITY: SCSRANK_CONVERSION, to.value.getQualifiers());
				second.isReference=true;
				return ImplicitConversion(second, ICSTYPE_USERDEFINED, overload.declaration);
			}
		}
		if(!to.value.getQualifiers().isConst||to.value.getQualifiers().isVolatile)
		{
			return ImplicitConversion(STANDARDCONVERSIONSEQUENCE_INVALID);
		}
	}
	if(isClass(to))
	{
		UniqueTypeWrapper matched=getExactMatchNoQualifiers(to, from.type);
		if(matched!=gUniqueTypeNull)
		{
			return ImplicitConversion(StandardConversionSequence(SCSRANK_IDENTITY, CvQualifiers(), matched));
		}
		if(to.isSimple()&&from.type.isSimple()&&isBaseOf(getSimpleType(to.value), getSimpleType(from.type.value), context))
		{
			return ImplicitConversion(StandardConversionSequence(SCSRANK_CONVERSION, CvQualifiers()));
		}
	}
	if(!isUserDefinedConversion&&(isClass(to)||isClass(from.type)))
	{
		FunctionOverload overload=findBestConversionFunction(to, from, context, isNullPointerConstant, isLvalue);
		if(overload.declaration==0)
		{
			return ImplicitConversion(STANDARDCONVERSIONSEQUENCE_INVALID);
		}
		bool isLvalue=overload.type.isReference();
		StandardConversionSequence second=makeStandardConversionSequence(to, removeReference(overload.type), context, false, isLvalue);
		second.isReference=isReference;
		return ImplicitConversion(second, ICSTYPE_USERDEFINED, overload.declaration);
	}
	StandardConversionSequence sequence=makeStandardConversionSequence(to, from.type, context, isNullPointerConstant, isLvalue);
	sequence.isReference=isReference;
	return ImplicitConversion(sequence);
}
inline IcsRank getIcsRank(ScsRank rank)
{
	switch(rank)
	{
		case SCSRANK_IDENTITY: case SCSRANK_EXACT: return ICSRANK_STANDARDEXACT;
		case SCSRANK_PROMOTION: return ICSRANK_STANDARDPROMOTION;
		case SCSRANK_CONVERSION: return ICSRANK_STANDARDCONVERSION;
	}
	return ICSRANK_INVALID;
}
inline IcsRank getIcsRank(UniqueTypeWrapper to, UniqueTypeWrapper from, const InstantiationContext&context, bool isNullPointerConstant=false, bool isLvalue=false)
{
	ExpressionNodeGeneric<ExplicitTypeExpression>transientExpression=ExplicitTypeExpression(from);
	Argument argument(ExpressionWrapper(&transientExpression, false), from);
	ImplicitConversion conversion=makeImplicitConversionSequence(to, argument, context, isNullPointerConstant, isLvalue);
	return getIcsRank(conversion.sequence.rank);
}
inline bool isBetter(const ImplicitConversion&l, const ImplicitConversion&r)
{
	if(l.type!=r.type)
	{
		return l.type<r.type;
	}
	return isBetter(l.sequence, r.sequence);
}
inline bool isValid(const ImplicitConversion&conversion)
{
	return conversion.sequence.rank!=SCSRANK_INVALID;
}
typedef std::vector<ImplicitConversion>ArgumentConversions;
struct FunctionTemplate
{
	ParameterTypes parameters;
	UniqueTypeArray templateParameters;
	FunctionTemplate()
	{
	}
	FunctionTemplate(const ParameterTypes&parameters, const UniqueTypeArray&templateParameters): parameters(parameters), templateParameters(templateParameters)
	{
	}
};
struct CandidateFunction: FunctionOverload, FunctionTemplate
{
	ArgumentConversions conversions;
	bool isTemplate;
	CandidateFunction(): FunctionOverload(0, gUniqueTypeNull)
	{
	}
	CandidateFunction(FunctionOverload overload, const FunctionTemplate&functionTemplate=FunctionTemplate()): FunctionOverload(overload), FunctionTemplate(functionTemplate), isTemplate(overload.declaration->isTemplate)
	{
	}
};
extern BuiltInTypeId gImplicitObjectParameter;
inline bool isMoreSpecialized(const FunctionTemplate&left, const FunctionTemplate&right)
{
	bool isMoreCvQualified=false;
	UniqueTypeArray leftDeduced(left.templateParameters.size(), gUniqueTypeNull);
	UniqueTypeArray rightDeduced(right.templateParameters.size(), gUniqueTypeNull);
	if(!(left.parameters.size()==right.parameters.size()))
	{
		throw AllocatorError();
	};
	UniqueTypeArray::const_iterator l=left.parameters.begin();
	UniqueTypeArray::const_iterator r=right.parameters.begin();
	if(*l==gImplicitObjectParameter||*r==gImplicitObjectParameter)
	{
		++l;
		++r;
	}
	for(;
	l!=left.parameters.end();
	++l, ++r)
	{
		UniqueTypeWrapper leftType=*l;
		UniqueTypeWrapper rightType=*r;
		leftType=removeReference(leftType);
		rightType=removeReference(rightType);
		bool leftMoreCvQualified=isGreaterCvQualification(leftType, rightType);
		bool rightMoreCvQualified=isGreaterCvQualification(rightType, leftType);
		leftType.value.setQualifiers(CvQualifiers());
		rightType.value.setQualifiers(CvQualifiers());
		if(!deduce(rightType, leftType, rightDeduced))
		{
			return false;
		}
		if(!deduce(leftType, rightType, leftDeduced))
		{
			return true;
		}
		if((*l).isReference()&&(*r).isReference())
		{
			isMoreCvQualified|=leftMoreCvQualified;
			if(rightMoreCvQualified)
			{
				return false;
			}
		}
	}
	return isMoreCvQualified;
}
inline bool isBetter(const CandidateFunction&l, const CandidateFunction&r)
{
	if(!(l.conversions.size()==r.conversions.size()))
	{
		throw AllocatorError();
	};
	std::size_t first=0;
	if((!l.parameters.empty()&&l.parameters.front()==gImplicitObjectParameter)||(!r.parameters.empty()&&r.parameters.front()==gImplicitObjectParameter))
	{
		++first;
	}
	for(std::size_t i=first;
	i!=l.conversions.size();
	++i)
	{
		if(isBetter(r.conversions[i], l.conversions[i]))
		{
			return false;
		}
	}
	for(std::size_t i=first;
	i!=l.conversions.size();
	++i)
	{
		if(isBetter(l.conversions[i], r.conversions[i]))
		{
			return true;
		}
	}
	if(!l.isTemplate&&r.isTemplate)
	{
		return true;
	}
	if(l.isTemplate&&r.isTemplate&&isMoreSpecialized(l, r))
	{
		return true;
	}
	return false;
}
inline const char*getDeclarationType(const Declaration&declaration)
{
	if(isNamespace(declaration))
	{
		return "namespace";
	}
	if(isType(declaration))
	{
		return declaration.isTemplate?"templateName": "type";
	}
	return "object";
}
inline bool isAnonymous(const Declaration&declaration)
{
	return *declaration.getName().value.c_str()=='$';
}
struct DeclarationError
{
	const char*description;
	DeclarationError(const char*description): description(description)
	{
	}
};
inline const Declaration&getPrimaryDeclaration(const Declaration&first, const Declaration&second)
{
	if(isNamespace(first))
	{
		if(!isNamespace(second))
		{
			throw DeclarationError("non-namespace already declared as namespace");
		}
		return first;
	}
	if(isType(first))
	{
		if(!isType(second))
		{
			throw DeclarationError("non-type already declared as type");
		}
		if(getType(first)!=getType(second))
		{
			throw DeclarationError("type already declared as different type");
		}
		if(isTypedef(first))
		{
			return second;
		}
		if(isTypedef(second))
		{
			return second;
		}
		if(isClass(first))
		{
			if(isSpecialization(second))
			{
				return second;
			}
			if(isSpecialization(first))
			{
				return second;
			}
			if(isIncomplete(second))
			{
				return second;
			}
			if(isIncomplete(first))
			{
				return second;
			}
			throw DeclarationError("class-definition already defined");
		}
		if(isEnum(first))
		{
			throw DeclarationError("enum-definition already defined");
		}
		throw SymbolsError();
	}
	if(isType(second))
	{
		throw DeclarationError("type already declared as non-type");
	}
	if(isFunction(first)||isFunction(second))
	{
		return second;
	}
	if(isStaticMember(first))
	{
		if(!isMemberObject(second))
		{
			throw DeclarationError("non-member-object already declared as static member-object");
		}
		return second;
	}
	if(isExtern(first)||isExtern(second))
	{
		return second;
	}
	if(!first.templateParams.defaults.empty())
	{
		return first;
	}
	throw DeclarationError("symbol already defined");
}
inline const DeclarationInstance*findDeclaration(Scope::Declarations&declarations, const Identifier&id, LookupFilter filter)
{
	Scope::Declarations::iterator i=declarations.upper_bound(id.value);
	for(;
	i!=declarations.begin()&&(*--i).first==id.value;
	)
	{
		if(filter((*i).second))
		{
			return &(*i).second;
		}
	}
	return 0;
}
inline LookupResult findDeclaration(Scope&scope, const Identifier&id, LookupFilter filter=IsAny())
{
	LookupResult result;
	result.filtered=findDeclaration(scope.declarations, id, filter);
	return result;
}
inline LookupResult findDeclaration(Scope::Scopes&scopes, const Identifier&id, LookupFilter filter=IsAny())
{
	LookupResult result;
	for(Scope::Scopes::iterator i=scopes.begin();
	i!=scopes.end();
	++i)
	{
		Scope&scope=*(*i);
		if(result.append(findNamespaceDeclaration(scope, id, filter)))
		{
			return result;
		}
	}
	return result;
}
inline LookupResult findNamespaceDeclaration(Scope&scope, const Identifier&id, LookupFilter filter)
{
	if(!(scope.type==SCOPETYPE_NAMESPACE))
	{
		throw AllocatorError();
	};
	LookupResult result;
	if(result.append(::findDeclaration(scope, id, filter)))
	{
		return result;
	}
	if(result.append(::findDeclaration(scope.usingDirectives, id, filter)))
	{
		return result;
	}
	return result;
}
inline LookupResult findMemberDeclaration(Scope&scope, const Identifier&id, LookupFilter filter)
{
	LookupResult result;
	if(result.append(findDeclaration(scope, id, filter)))
	{
		return result;
	}
	if(scope.type!=SCOPETYPE_CLASS)
	{
		return result;
	}
	for(Types::iterator i=scope.bases.begin();
	i!=scope.bases.end();
	++i)
	{
		if(!((*i).unique!=0))
		{
			throw AllocatorError();
		};
		if((*i).isDependent)
		{
			continue;
		}
		const SimpleType&base=getSimpleType((*i).unique);
		if(base.declaration->getName().value==id.value&&filter(DeclarationInstance(base.declaration)))
		{
			result.filtered=base.declaration->getName().dec.p;
			result.enclosing=base.enclosing;
			return result;
		}
		Scope*scope=base.declaration->enclosed;
		if(scope!=0)
		{
			if(!(scope->usingDirectives.empty()))
			{
				throw AllocatorError();
			};
			if(result.append(findMemberDeclaration(*scope, id, filter)))
			{
				return result;
			}
		}
	}
	return result;
}
inline LookupResult findClassOrNamespaceMemberDeclaration(Scope&scope, const Identifier&id, LookupFilter filter=IsAny())
{
	LookupResult result;
	if(result.append(findMemberDeclaration(scope, id, filter)))
	{
		return result;
	}
	if(scope.parent!=0)
	{
		if(result.append(findClassOrNamespaceMemberDeclaration(*scope.parent, id, filter)))
		{
			return result;
		}
	}
	result.append(findDeclaration(scope.usingDirectives, id, filter));
	return result;
}
inline bool hasTemplateParamDefaults(const TemplateParameters&params)
{
	for(TemplateArguments::const_iterator i=params.defaults.begin();
	i!=params.defaults.end();
	++i)
	{
		if((*i).type.declaration!=0)
		{
			return true;
		}
	}
	return false;
}
inline void fixTemplateParamDefault(TemplateArgument&argument, const TemplateParameters&params, const TemplateParameters&otherParams)
{
	if(argument.type.declaration==0)
	{
		return ;
	}
	std::size_t index=argument.type.declaration->templateParameter;
	if(index!=INDEX_INVALID)
	{
		Types::const_iterator i=params.begin();
		std::advance(i, index);
		Types::const_iterator j=otherParams.begin();
		std::advance(j, index);
		if(argument.type.declaration->scope==(*j).declaration->scope)
		{
			argument.type.declaration=(*i).declaration;
		}
	}
	for(TemplateArguments::iterator i=argument.type.templateArguments.begin();
	i!=argument.type.templateArguments.end();
	++i)
	{
		fixTemplateParamDefault(*i, params, otherParams);
	}
}
inline void copyTemplateParamDefault(TemplateArgument&argument, const TemplateArgument&otherArgument, const TemplateParameters&params, const TemplateParameters&otherParams)
{
	argument=otherArgument;
	fixTemplateParamDefault(argument, params, otherParams);
}
inline void copyTemplateParamDefaults(TemplateParameters&params, const TemplateParameters&otherParams)
{
	if(!(params.defaults.empty()))
	{
		throw AllocatorError();
	};
	for(TemplateArguments::const_iterator i=otherParams.defaults.begin();
	i!=otherParams.defaults.end();
	++i)
	{
		params.defaults.push_back(TemplateArgument(ParserAllocatorWrapper<int>(NullParserAllocator())));
		copyTemplateParamDefault(params.defaults.back(), *i, params, otherParams);
	}
}
inline void mergeTemplateParamDefaults(TemplateParameters&params, const TemplateParameters&otherParams)
{
	if(params.defaults.empty())
	{
		copyTemplateParamDefaults(params, otherParams);
		return ;
	}
	if(!hasTemplateParamDefaults(otherParams))
	{
		return ;
	}
	if(!(!otherParams.defaults.empty()))
	{
		throw AllocatorError();
	};
	TemplateArguments::iterator d=params.defaults.begin();
	for(TemplateArguments::const_iterator i=otherParams.defaults.begin();
	i!=otherParams.defaults.end();
	++i)
	{
		if(!(d!=params.defaults.end()))
		{
			throw AllocatorError();
		};
		if(!((*d).type.declaration==0||(*i).type.declaration==0))
		{
			throw AllocatorError();
		};
		if((*d).type.declaration==0)
		{
			copyTemplateParamDefault(*d, *i, params, otherParams);
		}
		++d;
	}
	if(!(d==params.defaults.end()))
	{
		throw AllocatorError();
	};
}
inline void mergeTemplateParamDefaults(Declaration&declaration, const TemplateParameters&templateParams)
{
	if(!(declaration.isTemplate))
	{
		throw AllocatorError();
	};
	if(!(isClass(declaration)))
	{
		throw AllocatorError();
	};
	if(!(!isSpecialization(declaration)))
	{
		throw AllocatorError();
	};
	mergeTemplateParamDefaults(declaration.templateParams, templateParams);
	if(!(!declaration.templateParams.defaults.empty()))
	{
		throw AllocatorError();
	};
}
typedef TokenPrinter<std::ostream>FileTokenPrinter;
typedef std::list<UniqueType>TypeElements;
struct SymbolPrinter: TypeElementVisitor, ExpressionNodeVisitor
{
	FileTokenPrinter&printer;
	bool escape;
	SymbolPrinter(FileTokenPrinter&printer, bool escape=false): printer(printer), escape(escape)
	{
		typeStack.push_back(false);
	}
	void printName(const Scope*scope)
	{
		if(scope!=0&&scope->parent!=0)
		{
			printName(scope->parent);
			if(scope->type!=SCOPETYPE_TEMPLATE)
			{
				printer.out<<getValue(scope->name)<<".";
			}
		}
	}
	void visit(const IntegralConstantExpression&node)
	{
		printer.out<<node.value.value;
	}
	void visit(const CastExpression&node)
	{
	}
	void visit(const NonTypeTemplateParameter&node)
	{
		printer.out<<"$i"<<node.declaration->scope->templateDepth<<"_"<<node.declaration->templateParameter;
	}
	void visit(const DependentIdExpression&node)
	{
		printType(node.qualifying);
		printer.out<<".";
		printer.out<<node.name.c_str();
	}
	void visit(const IdExpression&node)
	{
		if(node.enclosing!=0)
		{
			printType(*node.enclosing);
			printer.out<<".";
		}
		printer.out<<getValue(node.declaration->getName());
	}
	void visit(const SizeofExpression&node)
	{
		printer.out<<"sizeof(";
		printExpression(node.operand);
		printer.out<<")";
	}
	void visit(const SizeofTypeExpression&node)
	{
		printer.out<<"sizeof(";
		printType(node.type);
		printer.out<<")";
	}
	void visit(const UnaryExpression&node)
	{
		printer.out<<"(";
		printer.out<<" "<<node.operatorName.c_str()<<" ";
		printExpression(node.first);
		printer.out<<")";
	}
	void visit(const BinaryExpression&node)
	{
		printer.out<<"(";
		printExpression(node.first);
		printer.out<<" "<<node.operatorName.c_str()<<" ";
		printExpression(node.second);
		printer.out<<")";
	}
	void visit(const TernaryExpression&node)
	{
		printer.out<<"(";
		printExpression(node.first);
		printer.out<<" "<<"?"<<" ";
		printExpression(node.second);
		printer.out<<" "<<":"<<" ";
		printExpression(node.third);
		printer.out<<")";
	}
	void visit(const TypeTraitsUnaryExpression&node)
	{
		printer.out<<node.traitName.c_str();
		printer.out<<"(";
		printType(node.type);
		printer.out<<")";
	}
	void visit(const TypeTraitsBinaryExpression&node)
	{
		printer.out<<node.traitName.c_str();
		printer.out<<"(";
		printType(node.first);
		printer.out<<", ";
		printType(node.second);
		printer.out<<")";
	}
	void visit(const struct ExplicitTypeExpression&node)
	{
	}
	void visit(const struct ObjectExpression&node)
	{
	}
	void visit(const struct DependentObjectExpression&node)
	{
	}
	void visit(const struct ClassMemberAccessExpression&node)
	{
	}
	void visit(const struct FunctionCallExpression&node)
	{
	}
	void visit(const struct SubscriptExpression&node)
	{
	}
	void visit(const struct PostfixOperatorExpression&node)
	{
	}
	void printExpression(ExpressionNode*node)
	{
		if(node==0)
		{
			printer.out<<"[unknown]";
			return ;
		}
		node->accept(*this);
	}
	std::vector<bool>typeStack;
	void pushType(bool isPointer)
	{
		bool wasPointer=typeStack.back();
		bool parenthesise=typeStack.size()!=1&&!wasPointer&&isPointer;
		if(parenthesise)
		{
			printer.out<<"(";
		}
		typeStack.back()=parenthesise;
		typeStack.push_back(isPointer);
	}
	void popType()
	{
		typeStack.pop_back();
		if(typeStack.back())
		{
			printer.out<<")";
		}
	}
	std::vector<CvQualifiers>qualifierStack;
	void visit(const DependentType&element)
	{
		if(qualifierStack.back().isConst)
		{
			printer.out<<"const ";
		}
		if(qualifierStack.back().isVolatile)
		{
			printer.out<<"volatile ";
		}
		printer.out<<"$T"<<element.type->scope->templateDepth<<"_"<<element.type->templateParameter;
		visitTypeElement();
	}
	void visit(const DependentTypename&element)
	{
		printType(element.qualifying);
		printer.out<<"."<<element.name.c_str();
		if(element.isTemplate)
		{
			printTemplateArguments(element.templateArguments);
		}
		visitTypeElement();
	}
	void visit(const DependentNonType&element)
	{
		printExpression(element.expression);
		visitTypeElement();
	}
	void visit(const TemplateTemplateArgument&element)
	{
		printName(element.declaration);
		visitTypeElement();
	}
	void visit(const NonType&element)
	{
		printer.out<<element.value;
		visitTypeElement();
	}
	void visit(const SimpleType&element)
	{
		if(qualifierStack.back().isConst)
		{
			printer.out<<"const ";
		}
		if(qualifierStack.back().isVolatile)
		{
			printer.out<<"volatile ";
		}
		printType(element);
		visitTypeElement();
	}
	void visit(const ReferenceType&element)
	{
		pushType(true);
		printer.out<<"&";
		visitTypeElement();
		popType();
	}
	void visit(const PointerType&element)
	{
		pushType(true);
		printer.out<<"*";
		if(qualifierStack.back().isConst)
		{
			printer.out<<" const";
		}
		if(qualifierStack.back().isVolatile)
		{
			printer.out<<" volatile";
		}
		visitTypeElement();
		popType();
	}
	void visit(const ArrayType&element)
	{
		pushType(false);
		visitTypeElement();
		printer.out<<"[";
		if(element.size!=0)
		{
			printer.out<<element.size;
		}
		printer.out<<"]";
		popType();
	}
	void visit(const MemberPointerType&element)
	{
		pushType(true);

		{
			SymbolPrinter walker(printer, escape);
			walker.printType(element.type);
		}
		printer.out<<"::*";
		if(qualifierStack.back().isConst)
		{
			printer.out<<" const";
		}
		if(qualifierStack.back().isVolatile)
		{
			printer.out<<" volatile";
		}
		visitTypeElement();
		popType();
	}
	void visit(const FunctionType&function)
	{
		pushType(false);
		visitTypeElement();
		printParameters(function.parameterTypes);
		if(function.isEllipsis)
		{
			printer.out<<"...";
		}
		if(qualifierStack.back().isConst)
		{
			printer.out<<" const";
		}
		if(qualifierStack.back().isVolatile)
		{
			printer.out<<" volatile";
		}
		popType();
	}
	TypeElements typeElements;
	void visitTypeElement()
	{
		if(!typeElements.empty())
		{
			UniqueType element=typeElements.front();
			typeElements.pop_front();
			qualifierStack.push_back(element);
			element->accept(*this);
			qualifierStack.pop_back();
		}
	}
	void printType(const Type&type)
	{
		if(!(type.unique!=0))
		{
			throw AllocatorError();
		};
		printType(UniqueTypeWrapper(type.unique));
	}
	void printType(const SimpleType&type)
	{
		if(type.enclosing!=0)
		{
			printType(*type.enclosing);
			printer.out<<".";
		}
		else
		{
			printName(type.declaration->scope);
		}
		printer.out<<getValue(type.declaration->getName());
		if(type.declaration->isTemplate)
		{
			printTemplateArguments(type.templateArguments);
		}
	}
	void printType(const UniqueTypeId&type)
	{
		for(UniqueType i=type.value;
		i!=UNIQUETYPE_NULL;
		i=i->next)
		{
			typeElements.push_front(i);
		}
		visitTypeElement();
	}
	void printParameters(const ParameterTypes&parameters)
	{
		printer.out<<"(";
		bool separator=false;
		for(ParameterTypes::const_iterator i=parameters.begin();
		i!=parameters.end();
		++i)
		{
			if(separator)
			{
				printer.out<<",";
			}
			SymbolPrinter walker(printer, escape);
			walker.printType(*i);
			separator=true;
		}
		printer.out<<")";
	}
	void printTemplateArguments(const TemplateArgumentsInstance&templateArguments)
	{
		printer.out<<(escape?"&lt;": "<");
		bool separator=false;
		for(TemplateArgumentsInstance::const_iterator i=templateArguments.begin();
		i!=templateArguments.end();
		++i)
		{
			if(separator)
			{
				printer.out<<",";
			}
			SymbolPrinter walker(printer, escape);
			walker.printType(*i);
			separator=true;
		}
		printer.out<<(escape?"&gt;": ">");
	}
	void printName(const Declaration*name)
	{
		if(name==0)
		{
			printer.out<<"<unknown>";
		}
		else
		{
			printName(name->scope);
			printer.out<<getValue(name->getName());
			if(!(!isFunction(*name)||name->type.unique!=0))
			{
				throw AllocatorError();
			};
			if(isFunction(*name)&&UniqueTypeWrapper(name->type.unique).isFunction())
			{
				printParameters(getParameterTypes(name->type.unique));
			}
		}
	}
	void printName(const char*caption, Declaration*type, Declaration*name)
	{
		printer.out<<"/* ";
		printer.out<<caption;
		printName(type);
		printer.out<<": ";
		printName(name);
		printer.out<<" */";
	}
};
inline void printName(const Declaration*name, std::ostream&out=std::cout)
{
	FileTokenPrinter tokenPrinter(out);
	SymbolPrinter printer(tokenPrinter);
	printer.printName(name);
}
inline void printName(const Scope*scope, std::ostream&out=std::cout)
{
	FileTokenPrinter tokenPrinter(out);
	SymbolPrinter printer(tokenPrinter);
	printer.printName(scope);
}
inline void printType(const SimpleType&type, std::ostream&out, bool escape)
{
	FileTokenPrinter tokenPrinter(out);
	SymbolPrinter printer(tokenPrinter, escape);
	printer.printName(type.declaration);
	if(type.declaration->isTemplate)
	{
		printer.printTemplateArguments(type.templateArguments);
	}
}
inline void printType(UniqueTypeWrapper type, std::ostream&out, bool escape)
{
	FileTokenPrinter tokenPrinter(out);
	SymbolPrinter printer(tokenPrinter, escape);
	printer.printType(type);
}
const CandidateFunction gOverloadNull;
struct OverloadResolver
{
	const Arguments&arguments;
	const TemplateArgumentsInstance*templateArguments;
	InstantiationContext context;
	CandidateFunction best;
	Declaration*ambiguous;
	bool isUserDefinedConversion;
	OverloadResolver(const Arguments&arguments, const TemplateArgumentsInstance*templateArguments, const InstantiationContext&context, bool isUserDefinedConversion=false): arguments(arguments), templateArguments(templateArguments), context(context), ambiguous(0), isUserDefinedConversion(isUserDefinedConversion)
	{
		best.conversions.resize(arguments.size(), ImplicitConversion(STANDARDCONVERSIONSEQUENCE_INVALID));
	}
	const CandidateFunction&get()const
	{
		return ambiguous!=0?gOverloadNull: best;
	}
	bool isViable(const CandidateFunction&candidate)
	{
		if(candidate.conversions.size()!=best.conversions.size())
		{
			return false;
		}
		for(ArgumentConversions::const_iterator i=candidate.conversions.begin();
		i!=candidate.conversions.end();
		++i)
		{
			if(!isValid(*i))
			{
				return false;
			}
		}
		return true;
	}
	void add(const CandidateFunction&candidate)
	{
		if(!isViable(candidate))
		{
			return ;
		}
		if(best.declaration==0||isBetter(candidate, best))
		{
			best=candidate;
			ambiguous=0;
		}
		else if(!isBetter(best, candidate))
		{
			ambiguous=candidate.declaration;
		}
	}
	template<typename To>
	ImplicitConversion makeConversion(To to, const Argument&from)
	{
		bool isNullPointerConstant=!from.isValueDependent&&from.isConstant&&evaluateExpression(from, context).value==0;
		return makeImplicitConversionSequence(to, from, context, isNullPointerConstant, true, isUserDefinedConversion);
	}
	void add(const FunctionOverload&overload, const ParameterTypes&parameters, bool isEllipsis, const SimpleType*memberEnclosing, FunctionTemplate&functionTemplate=FunctionTemplate())
	{
		CandidateFunction candidate(overload, functionTemplate);
		candidate.conversions.reserve(best.conversions.size());
		ParameterTypes::const_iterator p=parameters.begin();
		Arguments::const_iterator a=arguments.begin();
		if(isMember(*overload.declaration)&&overload.declaration->type.declaration!=&gCtor)
		{
			if(!(p!=parameters.end()))
			{
				throw AllocatorError();
			};
			UniqueTypeWrapper implicitObjectParameter=*p++;
			if(!(a!=arguments.end()))
			{
				throw AllocatorError();
			};
			const Argument&impliedObjectArgument=*a++;
			if(!(isClass(*memberEnclosing->declaration)))
			{
				throw AllocatorError();
			};
			if(!isStatic(*overload.declaration))
			{
				candidate.conversions.push_back(makeImplicitConversionSequence(implicitObjectParameter, impliedObjectArgument, context, false, true));
			}
			else
			{
				candidate.conversions.push_back(ImplicitConversion(StandardConversionSequence(SCSRANK_IDENTITY, CvQualifiers())));
			}
		}
		if(arguments.size()<parameters.size())
		{
			if(overload.declaration==&gUnknown)
			{
				return ;
			}
			std::size_t argumentCount=arguments.end()-a;
			const Parameters&defaults=getParameters(overload.declaration->type);
			Parameters::const_iterator d=defaults.begin();
			std::advance(d, argumentCount);
			for(ParameterTypes::const_iterator i=p+argumentCount;
			i!=parameters.end();
			++i)
			{
				if(!(d!=defaults.end()))
				{
					throw AllocatorError();
				};
				if((*d).defaultArgument==0)
				{
					return ;
				}
				else
				{
					if(!((*d).defaultArgument->expr!=0))
					{
						throw AllocatorError();
					};
				}
				++d;
			}
		}
		for(;
		a!=arguments.end()&&p!=parameters.end();
		++a, ++p)
		{
			candidate.conversions.push_back(makeConversion(*p, *a));
		}
		if(!isEllipsis&&a!=arguments.end())
		{
			return ;
		}
		for(;
		a!=arguments.end();
		++a)
		{
			candidate.conversions.push_back(IMPLICITCONVERSION_ELLIPSIS);
		}
		add(candidate);
	}
};
inline ParameterTypes addOverload(OverloadResolver&resolver, const Declaration&declaration, const InstantiationContext&context)
{
	UniqueTypeWrapper type=getUniqueType(declaration.type, context, declaration.isTemplate);
	if(!(type.isFunction()))
	{
		throw AllocatorError();
	};
	ParameterTypes parameters;
	if(isMember(declaration)&&declaration.type.declaration!=&gCtor)
	{
		if(!(isClass(*context.enclosingType->declaration)))
		{
			throw AllocatorError();
		};
		UniqueTypeWrapper implicitObjectParameter=gImplicitObjectParameter;
		if(!isStatic(declaration))
		{
			implicitObjectParameter=makeUniqueSimpleType(*context.enclosingType);
			implicitObjectParameter.value.setQualifiers(type.value.getQualifiers());
			implicitObjectParameter.push_front(ReferenceType());
		}
		parameters.push_back(implicitObjectParameter);
	}
	bool isEllipsis=getFunctionType(type.value).isEllipsis;
	parameters.insert(parameters.end(), getParameterTypes(type.value).begin(), getParameterTypes(type.value).end());
	type.pop_front();
	if(!declaration.isTemplate)
	{
		if(resolver.templateArguments!=0)
		{
			return ParameterTypes();
		}
		resolver.add(FunctionOverload(const_cast<Declaration*>(&declaration), type), parameters, isEllipsis, context.enclosingType);
		return parameters;
	}
	if(declaration.isSpecialization)
	{
		return ParameterTypes();
	}
	FunctionTemplate functionTemplate;
	functionTemplate.parameters.swap(parameters);
	makeUniqueTemplateParameters(declaration.templateParams, functionTemplate.templateParameters, context, true);
	if(resolver.arguments.size()>functionTemplate.parameters.size())
	{
		return ParameterTypes();
	}
	try
	{
		if(resolver.templateArguments!=0&&resolver.templateArguments->size()>functionTemplate.templateParameters.size())
		{
			throw TypeErrorBase(context.source);
		}
		SimpleType specialization(const_cast<Declaration*>(&declaration), context.enclosingType);
		specialization.instantiated=true;

		{
			UniqueTypeArray::const_iterator p=functionTemplate.templateParameters.begin();
			if(resolver.templateArguments!=0)
			{
				for(TemplateArgumentsInstance::const_iterator a=resolver.templateArguments->begin();
				a!=resolver.templateArguments->end();
				++a, ++p)
				{
					if(!(p!=functionTemplate.templateParameters.end()))
					{
						throw AllocatorError();
					};
					if((*a).isNonType()!=(*p).isDependentNonType())
					{
						throw TypeErrorBase(context.source);
					}
					specialization.templateArguments.push_back(*a);
				}
			}
			for(;
			p!=functionTemplate.templateParameters.end();
			++p)
			{
				specialization.templateArguments.push_back(*p);
			}
		}
		ParameterTypes substituted1;
		substitute(substituted1, functionTemplate.parameters, setEnclosingTypeSafe(context, &specialization));
		UniqueTypeArray arguments;
		arguments.reserve(resolver.arguments.size());
		for(Arguments::const_iterator a=resolver.arguments.begin();
		a!=resolver.arguments.end();
		++a)
		{
			arguments.push_back((*a).type);
		}
		specialization.templateArguments.resize(resolver.templateArguments==0?0: resolver.templateArguments->size());
		specialization.templateArguments.resize(functionTemplate.templateParameters.size(), gUniqueTypeNull);
		if(!deduceFunctionCall(substituted1, arguments, specialization.templateArguments, resolver.context))
		{
			throw TypeErrorBase(context.source);
		}
		ParameterTypes substituted2;
		substitute(substituted2, substituted1, setEnclosingTypeSafe(context, &specialization));
		type=substitute(type, setEnclosingTypeSafe(context, &specialization));
		resolver.add(FunctionOverload(const_cast<Declaration*>(&declaration), type), substituted2, isEllipsis, context.enclosingType, functionTemplate);
		return substituted2;
	}
	catch(TypeError&)
	{
	}
	return ParameterTypes();
}
inline bool isBaseOf(UniqueTypeWrapper base, UniqueTypeWrapper derived, const InstantiationContext&context);
template<typename To>
inline void addConversionFunctionOverloads(OverloadResolver&resolver, const SimpleType&classType, To to, const InstantiationContext&context)
{
	instantiateClass(classType, context);
	LookupResultRef declaration=::findDeclaration(classType, gConversionFunctionId, IsAny());
	if(declaration!=0)
	{
		const SimpleType*memberEnclosing=findEnclosingType(&classType, declaration->scope);
		if(!(memberEnclosing!=0))
		{
			throw AllocatorError();
		};
		for(Declaration*p=findOverloaded(declaration);
		p!=0;
		p=p->overloaded)
		{
			if(!(p->enclosed!=0))
			{
				throw AllocatorError();
			};
			if(!(!p->isTemplate))
			{
				throw AllocatorError();
			};
			UniqueTypeWrapper yielded=getUniqueType(p->type, setEnclosingTypeSafe(context, memberEnclosing));
			yielded.pop_front();
			if(isClass(to))
			{
				if(!(getExactMatch(to, removeReference(yielded))!=gUniqueTypeNull||isBaseOf(to, removeReference(yielded), context)))
				{
					continue;
				}
			}
			else if(to.isReference())
			{
				UniqueTypeWrapper tmpTo=to;
				tmpTo.pop_front();
				if(!yielded.isReference())
				{
					continue;
				}
				yielded.pop_front();
				if(!((getExactMatch(tmpTo, yielded)!=gUniqueTypeNull||isBaseOf(tmpTo, yielded, context))&&(isEqualCvQualification(tmpTo, yielded)||isGreaterCvQualification(tmpTo, yielded))))
				{
					continue;
				}
			}
			else
			{
				bool isLvalue=yielded.isReference();
				yielded=removeReference(yielded);
				yielded.value.setQualifiers(CvQualifiers());
				if(makeStandardConversionSequence(to, yielded, context, false, isLvalue).rank==SCSRANK_INVALID)
				{
					continue;
				}
			}
			addOverload(resolver, *p, setEnclosingTypeSafe(context, memberEnclosing));
		}
	}
}
template<typename To>
FunctionOverload findBestConversionFunction(To to, Argument from, const InstantiationContext&context, bool isNullPointerConstant, bool isLvalue)
{
	Arguments arguments;
	arguments.push_back(from);
	OverloadResolver resolver(arguments, 0, context, true);
	if(isClass(to)&&isComplete(to))
	{
		const SimpleType&classType=getSimpleType(to.value);
		instantiateClass(classType, context);
		Identifier tmp;
		tmp.value=classType.declaration->getName().value;
		tmp.source=context.source;
		LookupResultRef declaration=::findDeclaration(classType, tmp, IsConstructor());
		if(declaration!=0)
		{
			const SimpleType*memberEnclosing=findEnclosingType(&classType, declaration->scope);
			if(!(memberEnclosing!=0))
			{
				throw AllocatorError();
			};
			for(Declaration*p=findOverloaded(declaration);
			p!=0;
			p=p->overloaded)
			{
				if(!(p->enclosed!=0))
				{
					throw AllocatorError();
				};
				if(declaration->specifiers.isExplicit)
				{
					continue;
				}
				addOverload(resolver, *p, setEnclosingTypeSafe(context, memberEnclosing));
			}
		}
	}
	if(isClass(from.type)&&isComplete(from.type))
	{
		addConversionFunctionOverloads(resolver, getSimpleType(from.type.value), to, context);
	}
	FunctionOverload result=resolver.get();
	if(result.declaration!=0&&result.type.isSimple()&&getSimpleType(result.type.value).declaration==&gCtor)
	{
		result.type=to;
		result.type.value.setQualifiers(CvQualifiers());
	}
	return result;
}
template<typename T>
inline Name getTypeTraitName(T*symbol)
{
	return symbol->trait->value.value;
}
inline bool hasNothrowConstructor(UniqueTypeWrapper type)
{
	return true;
}
inline bool hasNothrowCopy(UniqueTypeWrapper type)
{
	return true;
}
inline bool hasTrivialAssign(UniqueTypeWrapper type)
{
	return true;
}
inline bool hasTrivialConstructor(UniqueTypeWrapper type)
{
	return true;
}
inline bool hasTrivialCopy(UniqueTypeWrapper type)
{
	return true;
}
inline bool hasTrivialDestructor(UniqueTypeWrapper type)
{
	return true;
}
inline bool hasVirtualDestructor(UniqueTypeWrapper type)
{
	return false;
}
inline bool isAbstract(UniqueTypeWrapper type)
{
	return false;
}
inline bool isEmpty(UniqueTypeWrapper type)
{
	return false;
}
inline bool isPod(UniqueTypeWrapper type)
{
	return false;
}
inline bool isPolymorphic(UniqueTypeWrapper type)
{
	return false;
}
inline bool isUnion(UniqueTypeWrapper type)
{
	return false;
}
inline bool isBaseOf(UniqueTypeWrapper base, UniqueTypeWrapper derived, const InstantiationContext&context)
{
	if(!base.isSimple()||!derived.isSimple())
	{
		return false;
	}
	const SimpleType&baseType=getSimpleType(base.value);
	const SimpleType&derivedType=getSimpleType(derived.value);
	if(&baseType==&derivedType)
	{
		return true;
	}
	if(!(!isClass(*derivedType.declaration)||!isIncomplete(*derivedType.declaration)))
	{
		throw AllocatorError();
	};
	return isBaseOf(baseType, derivedType, context);
}
inline bool isConvertibleTo(UniqueTypeWrapper type, UniqueTypeWrapper other, const InstantiationContext&context)
{
	return false;
}
inline UnaryTypeTraitsOp getUnaryTypeTraitsOp(cpp::typetraits_unary*symbol)
{
	switch(symbol->id)
	{
		case cpp::typetraits_unary::HAS_NOTHROW_CONSTRUCTOR: return hasNothrowConstructor;
		case cpp::typetraits_unary::HAS_NOTHROW_COPY: return hasNothrowCopy;
		case cpp::typetraits_unary::HAS_TRIVIAL_ASSIGN: return hasTrivialAssign;
		case cpp::typetraits_unary::HAS_TRIVIAL_CONSTRUCTOR: return hasTrivialConstructor;
		case cpp::typetraits_unary::HAS_TRIVIAL_COPY: return hasTrivialCopy;
		case cpp::typetraits_unary::HAS_TRIVIAL_DESTRUCTOR: return hasTrivialDestructor;
		case cpp::typetraits_unary::HAS_VIRTUAL_DESTRUCTOR: return hasVirtualDestructor;
		case cpp::typetraits_unary::IS_ABSTRACT: return isAbstract;
		case cpp::typetraits_unary::IS_CLASS: return isClass;
		case cpp::typetraits_unary::IS_EMPTY: return isEnum;
		case cpp::typetraits_unary::IS_ENUM: return isEmpty;
		case cpp::typetraits_unary::IS_POD: return isPod;
		case cpp::typetraits_unary::IS_POLYMORPHIC: return isPolymorphic;
		case cpp::typetraits_unary::IS_UNION: return isUnion;
		default: break;
	}
	throw SymbolsError();
}
inline BinaryTypeTraitsOp getBinaryTypeTraitsOp(cpp::typetraits_binary*symbol)
{
	switch(symbol->id)
	{
		case cpp::typetraits_binary::IS_BASE_OF: return isBaseOf;
		case cpp::typetraits_binary::IS_CONVERTIBLE_TO: return isConvertibleTo;
		default: break;
	}
	throw SymbolsError();
}
extern const SimpleType gDependentSimpleType;
struct DefaultParser
{
	template<typename Walker, typename T>
	static T*parseSymbol(ParserGeneric<Walker>&parser, T*result)
	{
		if(!result->parse(parser))
		{
			return parser.skip?result: 0;
		}
		return result;
	}
	template<typename Walker>
	inline cpp::identifier*parseSymbol(ParserGeneric<Walker>&parser, cpp::identifier*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_IDENTIFIER))
		{
			result->value.value=parser.get_value();
			result->value.source=parser.get_source();
			parser.increment();
			return result;
		}
		return 0;
	}
	template<typename Walker>
	inline cpp::string_literal*parseSymbol(ParserGeneric<Walker>&parser, cpp::string_literal*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_STRINGLIT))
		{
			result->value.value=parser.get_value();
			parser.increment();
			parser.parse(checkSymbolOptional(result->next));
			return result;
		}
		return 0;
	}
	template<typename Walker>
	inline cpp::numeric_literal*parseSymbol(ParserGeneric<Walker>&parser, cpp::numeric_literal*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_PP_NUMBER))
		{
			result=createSymbol(parser, result);
			result->id=cpp::numeric_literal::UNKNOWN;
			result->value.id=boost::wave::T_PP_NUMBER;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_INTLIT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::numeric_literal::INTEGER;
			result->value.id=boost::wave::T_INTLIT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_CHARLIT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::numeric_literal::CHARACTER;
			result->value.id=boost::wave::T_CHARLIT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_FLOATLIT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::numeric_literal::FLOATING;
			result->value.id=boost::wave::T_FLOATLIT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_TRUE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::numeric_literal::BOOLEAN;
			result->value.id=boost::wave::T_TRUE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_FALSE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::numeric_literal::BOOLEAN;
			result->value.id=boost::wave::T_FALSE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::cv_qualifier*parseSymbol(ParserGeneric<Walker>&parser, cpp::cv_qualifier*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_CONST))
		{
			result=createSymbol(parser, result);
			result->id=cpp::cv_qualifier::CONST;
			result->value.id=boost::wave::T_CONST;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_VOLATILE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::cv_qualifier::VOLATILE;
			result->value.id=boost::wave::T_VOLATILE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::function_specifier*parseSymbol(ParserGeneric<Walker>&parser, cpp::function_specifier*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_INLINE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::function_specifier::INLINE;
			result->value.id=boost::wave::T_INLINE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_EXPLICIT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::function_specifier::EXPLICIT;
			result->value.id=boost::wave::T_EXPLICIT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_VIRTUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::function_specifier::VIRTUAL;
			result->value.id=boost::wave::T_VIRTUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::storage_class_specifier*parseSymbol(ParserGeneric<Walker>&parser, cpp::storage_class_specifier*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_REGISTER))
		{
			result=createSymbol(parser, result);
			result->id=cpp::storage_class_specifier::REGISTER;
			result->value.id=boost::wave::T_REGISTER;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_STATIC))
		{
			result=createSymbol(parser, result);
			result->id=cpp::storage_class_specifier::STATIC;
			result->value.id=boost::wave::T_STATIC;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_EXTERN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::storage_class_specifier::EXTERN;
			result->value.id=boost::wave::T_EXTERN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MUTABLE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::storage_class_specifier::MUTABLE;
			result->value.id=boost::wave::T_MUTABLE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::simple_type_specifier_builtin*parseSymbol(ParserGeneric<Walker>&parser, cpp::simple_type_specifier_builtin*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_CHAR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::CHAR;
			result->value.id=boost::wave::T_CHAR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_WCHART))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::WCHAR_T;
			result->value.id=boost::wave::T_WCHART;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_BOOL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::BOOL;
			result->value.id=boost::wave::T_BOOL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SHORT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::SHORT;
			result->value.id=boost::wave::T_SHORT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_INT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::INT;
			result->value.id=boost::wave::T_INT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_LONG))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::LONG;
			result->value.id=boost::wave::T_LONG;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SIGNED))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::SIGNED;
			result->value.id=boost::wave::T_SIGNED;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_UNSIGNED))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::UNSIGNED;
			result->value.id=boost::wave::T_UNSIGNED;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_FLOAT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::FLOAT;
			result->value.id=boost::wave::T_FLOAT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_DOUBLE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::DOUBLE;
			result->value.id=boost::wave::T_DOUBLE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_VOID))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::VOID;
			result->value.id=boost::wave::T_VOID;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_AUTO))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::AUTO;
			result->value.id=boost::wave::T_AUTO;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MSEXT_INT8))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::CHAR;
			result->value.id=boost::wave::T_MSEXT_INT8;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MSEXT_INT16))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::SHORT;
			result->value.id=boost::wave::T_MSEXT_INT16;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MSEXT_INT32))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::INT;
			result->value.id=boost::wave::T_MSEXT_INT32;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MSEXT_INT64))
		{
			result=createSymbol(parser, result);
			result->id=cpp::simple_type_specifier_builtin::INT64;
			result->value.id=boost::wave::T_MSEXT_INT64;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::decl_specifier_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::decl_specifier_default*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_FRIEND))
		{
			result=createSymbol(parser, result);
			result->id=cpp::decl_specifier_default::FRIEND;
			result->value.id=boost::wave::T_FRIEND;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_TYPEDEF))
		{
			result=createSymbol(parser, result);
			result->id=cpp::decl_specifier_default::TYPEDEF;
			result->value.id=boost::wave::T_TYPEDEF;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::access_specifier*parseSymbol(ParserGeneric<Walker>&parser, cpp::access_specifier*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_PRIVATE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::access_specifier::PRIVATE;
			result->value.id=boost::wave::T_PRIVATE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PROTECTED))
		{
			result=createSymbol(parser, result);
			result->id=cpp::access_specifier::PROTECTED;
			result->value.id=boost::wave::T_PROTECTED;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PUBLIC))
		{
			result=createSymbol(parser, result);
			result->id=cpp::access_specifier::PUBLIC;
			result->value.id=boost::wave::T_PUBLIC;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::class_key*parseSymbol(ParserGeneric<Walker>&parser, cpp::class_key*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_CLASS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::class_key::CLASS;
			result->value.id=boost::wave::T_CLASS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_STRUCT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::class_key::STRUCT;
			result->value.id=boost::wave::T_STRUCT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_UNION))
		{
			result=createSymbol(parser, result);
			result->id=cpp::class_key::UNION;
			result->value.id=boost::wave::T_UNION;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::ptr_operator_key*parseSymbol(ParserGeneric<Walker>&parser, cpp::ptr_operator_key*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_STAR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::ptr_operator_key::PTR;
			result->value.id=boost::wave::T_STAR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_AND))
		{
			result=createSymbol(parser, result);
			result->id=cpp::ptr_operator_key::REF;
			result->value.id=boost::wave::T_AND;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::type_parameter_key*parseSymbol(ParserGeneric<Walker>&parser, cpp::type_parameter_key*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_CLASS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::type_parameter_key::CLASS;
			result->value.id=boost::wave::T_CLASS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_TYPENAME))
		{
			result=createSymbol(parser, result);
			result->id=cpp::type_parameter_key::TYPENAME;
			result->value.id=boost::wave::T_TYPENAME;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::logical_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::logical_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_ANDAND))
		{
			result=createSymbol(parser, result);
			result->id=cpp::logical_operator::AND;
			result->value.id=boost::wave::T_ANDAND;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_OROR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::logical_operator::OR;
			result->value.id=boost::wave::T_OROR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::bitwise_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::bitwise_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_AND))
		{
			result=createSymbol(parser, result);
			result->id=cpp::bitwise_operator::AND;
			result->value.id=boost::wave::T_AND;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_OR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::bitwise_operator::OR;
			result->value.id=boost::wave::T_OR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_XOR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::bitwise_operator::XOR;
			result->value.id=boost::wave::T_XOR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::unary_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::unary_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_PLUSPLUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::unary_operator::PLUSPLUS;
			result->value.id=boost::wave::T_PLUSPLUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MINUSMINUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::unary_operator::MINUSMINUS;
			result->value.id=boost::wave::T_MINUSMINUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_STAR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::unary_operator::STAR;
			result->value.id=boost::wave::T_STAR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_AND))
		{
			result=createSymbol(parser, result);
			result->id=cpp::unary_operator::AND;
			result->value.id=boost::wave::T_AND;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PLUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::unary_operator::PLUS;
			result->value.id=boost::wave::T_PLUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MINUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::unary_operator::MINUS;
			result->value.id=boost::wave::T_MINUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_NOT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::unary_operator::NOT;
			result->value.id=boost::wave::T_NOT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_COMPL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::unary_operator::COMPL;
			result->value.id=boost::wave::T_COMPL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::member_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::member_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_DOT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::member_operator::DOT;
			result->value.id=boost::wave::T_DOT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ARROW))
		{
			result=createSymbol(parser, result);
			result->id=cpp::member_operator::ARROW;
			result->value.id=boost::wave::T_ARROW;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::postfix_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::postfix_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_PLUSPLUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::postfix_operator::PLUSPLUS;
			result->value.id=boost::wave::T_PLUSPLUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MINUSMINUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::postfix_operator::MINUSMINUS;
			result->value.id=boost::wave::T_MINUSMINUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::cast_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::cast_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_DYNAMICCAST))
		{
			result=createSymbol(parser, result);
			result->id=cpp::cast_operator::DYNAMIC;
			result->value.id=boost::wave::T_DYNAMICCAST;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_STATICCAST))
		{
			result=createSymbol(parser, result);
			result->id=cpp::cast_operator::STATIC;
			result->value.id=boost::wave::T_STATICCAST;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_REINTERPRETCAST))
		{
			result=createSymbol(parser, result);
			result->id=cpp::cast_operator::REINTERPRET;
			result->value.id=boost::wave::T_REINTERPRETCAST;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_CONSTCAST))
		{
			result=createSymbol(parser, result);
			result->id=cpp::cast_operator::CONST;
			result->value.id=boost::wave::T_CONSTCAST;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::pm_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::pm_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_DOTSTAR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::pm_operator::DOTSTAR;
			result->value.id=boost::wave::T_DOTSTAR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ARROWSTAR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::pm_operator::ARROWSTAR;
			result->value.id=boost::wave::T_ARROWSTAR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::multiplicative_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::multiplicative_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_STAR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::multiplicative_operator::STAR;
			result->value.id=boost::wave::T_STAR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_DIVIDE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::multiplicative_operator::DIVIDE;
			result->value.id=boost::wave::T_DIVIDE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PERCENT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::multiplicative_operator::PERCENT;
			result->value.id=boost::wave::T_PERCENT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::shift_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::shift_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_SHIFTLEFT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::shift_operator::SHIFTLEFT;
			result->value.id=boost::wave::T_SHIFTLEFT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SHIFTRIGHT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::shift_operator::SHIFTRIGHT;
			result->value.id=boost::wave::T_SHIFTRIGHT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::relational_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::relational_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_LESS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::relational_operator::LESS;
			result->value.id=boost::wave::T_LESS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_GREATER))
		{
			result=createSymbol(parser, result);
			result->id=cpp::relational_operator::GREATER;
			result->value.id=boost::wave::T_GREATER;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_LESSEQUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::relational_operator::LESSEQUAL;
			result->value.id=boost::wave::T_LESSEQUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_GREATEREQUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::relational_operator::GREATEREQUAL;
			result->value.id=boost::wave::T_GREATEREQUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::equality_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::equality_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_EQUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::equality_operator::EQUAL;
			result->value.id=boost::wave::T_EQUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_NOTEQUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::equality_operator::NOTEQUAL;
			result->value.id=boost::wave::T_NOTEQUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::assignment_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::assignment_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_ASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::ASSIGN;
			result->value.id=boost::wave::T_ASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_STARASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::STAR;
			result->value.id=boost::wave::T_STARASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_DIVIDEASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::DIVIDE;
			result->value.id=boost::wave::T_DIVIDEASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PERCENTASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::PERCENT;
			result->value.id=boost::wave::T_PERCENTASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PLUSASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::PLUS;
			result->value.id=boost::wave::T_PLUSASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MINUSASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::MINUS;
			result->value.id=boost::wave::T_MINUSASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SHIFTRIGHTASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::SHIFTRIGHT;
			result->value.id=boost::wave::T_SHIFTRIGHTASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SHIFTLEFTASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::SHIFTLEFT;
			result->value.id=boost::wave::T_SHIFTLEFTASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ANDASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::AND;
			result->value.id=boost::wave::T_ANDASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_XORASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::XOR;
			result->value.id=boost::wave::T_XORASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ORASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::assignment_operator::OR;
			result->value.id=boost::wave::T_ORASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::jump_statement_key*parseSymbol(ParserGeneric<Walker>&parser, cpp::jump_statement_key*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_BREAK))
		{
			result=createSymbol(parser, result);
			result->id=cpp::jump_statement_key::BREAK;
			result->value.id=boost::wave::T_BREAK;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_CONTINUE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::jump_statement_key::CONTINUE;
			result->value.id=boost::wave::T_CONTINUE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::overloadable_operator_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::overloadable_operator_default*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_ASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::ASSIGN;
			result->value.id=boost::wave::T_ASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_STARASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::STARASSIGN;
			result->value.id=boost::wave::T_STARASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_DIVIDEASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::DIVIDEASSIGN;
			result->value.id=boost::wave::T_DIVIDEASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PERCENTASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::PERCENTASSIGN;
			result->value.id=boost::wave::T_PERCENTASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PLUSASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::PLUSASSIGN;
			result->value.id=boost::wave::T_PLUSASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MINUSASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::MINUSASSIGN;
			result->value.id=boost::wave::T_MINUSASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SHIFTRIGHTASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::SHIFTRIGHTASSIGN;
			result->value.id=boost::wave::T_SHIFTRIGHTASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SHIFTLEFTASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::SHIFTLEFTASSIGN;
			result->value.id=boost::wave::T_SHIFTLEFTASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ANDASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::ANDASSIGN;
			result->value.id=boost::wave::T_ANDASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_XORASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::XORASSIGN;
			result->value.id=boost::wave::T_XORASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ORASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::ORASSIGN;
			result->value.id=boost::wave::T_ORASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_EQUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::EQUAL;
			result->value.id=boost::wave::T_EQUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_NOTEQUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::NOTEQUAL;
			result->value.id=boost::wave::T_NOTEQUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_LESS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::LESS;
			result->value.id=boost::wave::T_LESS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_GREATER))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::GREATER;
			result->value.id=boost::wave::T_GREATER;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_LESSEQUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::LESSEQUAL;
			result->value.id=boost::wave::T_LESSEQUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_GREATEREQUAL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::GREATEREQUAL;
			result->value.id=boost::wave::T_GREATEREQUAL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SHIFTLEFT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::SHIFTLEFT;
			result->value.id=boost::wave::T_SHIFTLEFT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_SHIFTRIGHT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::SHIFTRIGHT;
			result->value.id=boost::wave::T_SHIFTRIGHT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ARROWSTAR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::ARROWSTAR;
			result->value.id=boost::wave::T_ARROWSTAR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ARROW))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::ARROW;
			result->value.id=boost::wave::T_ARROW;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PLUSPLUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::PLUSPLUS;
			result->value.id=boost::wave::T_PLUSPLUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MINUSMINUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::MINUSMINUS;
			result->value.id=boost::wave::T_MINUSMINUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_STAR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::STAR;
			result->value.id=boost::wave::T_STAR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_DIVIDE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::DIVIDE;
			result->value.id=boost::wave::T_DIVIDE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PERCENT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::PERCENT;
			result->value.id=boost::wave::T_PERCENT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_AND))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::AND;
			result->value.id=boost::wave::T_AND;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_PLUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::PLUS;
			result->value.id=boost::wave::T_PLUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MINUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::MINUS;
			result->value.id=boost::wave::T_MINUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_NOT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::NOT;
			result->value.id=boost::wave::T_NOT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_COMPL))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::COMPL;
			result->value.id=boost::wave::T_COMPL;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_AND))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::AND;
			result->value.id=boost::wave::T_AND;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_OR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::OR;
			result->value.id=boost::wave::T_OR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_XOR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::XOR;
			result->value.id=boost::wave::T_XOR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_NOT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::NOT;
			result->value.id=boost::wave::T_NOT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_ANDAND))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::ANDAND;
			result->value.id=boost::wave::T_ANDAND;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_OROR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::OROR;
			result->value.id=boost::wave::T_OROR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_COMMA))
		{
			result=createSymbol(parser, result);
			result->id=cpp::overloadable_operator_default::COMMA;
			result->value.id=boost::wave::T_COMMA;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	};
	template<typename Walker>
	inline cpp::overloadable_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::overloadable_operator*result)
	{

		{
			cpp::symbol_required<cpp::overloadable_operator_default>result;
			if(parser.parse(result))
			{
				return result;
			}
		};

		{
			cpp::symbol_required<cpp::new_operator>result;
			if(parser.parse(result))
			{
				return result;
			}
		};

		{
			cpp::symbol_required<cpp::delete_operator>result;
			if(parser.parse(result))
			{
				return result;
			}
		};

		{
			cpp::symbol_required<cpp::function_operator>result;
			if(parser.parse(result))
			{
				return result;
			}
		};

		{
			cpp::symbol_required<cpp::array_operator>result;
			if(parser.parse(result))
			{
				return result;
			}
		};
		return result;
	};
	template<typename Walker>
	inline cpp::template_argument_list*parseSymbol(ParserGeneric<Walker>&parser, cpp::template_argument_list*result)
	{
		parser.inTemplateArgumentList=true;
		if(parser.parse(checkSymbolRequired(result->item))==0)
		{
			return 0;
		};
		switch(parseTerminal(parser, result->comma))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(parser.parse(checkSymbolRequired(result->next))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::template_argument_clause_disambiguate*parseSymbol(ParserGeneric<Walker>&parser, cpp::template_argument_clause_disambiguate*result)
	{

		{
			cpp::symbol_required<cpp::template_argument_clause>result;
			if(parser.parse(result))
			{
				return result;
			}
		};
		return result;
	}
	template<typename Walker>
	inline cpp::member_declaration_bitfield*parseSymbol(ParserGeneric<Walker>&parser, cpp::member_declaration_bitfield*result)
	{
		if(parser.parse(checkSymbolRequired(result->item))==0)
		{
			return 0;
		};
		switch(parseTerminal(parser, result->comma))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(!result->comma.value.empty())
		{
			if(parser.parse(checkSymbolRequired(result->next))==0)
			{
				return 0;
			};
		}
		switch(parseTerminal(parser, result->semicolon))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		return result;
	}
	inline cpp::expression*pruneSymbol(cpp::expression_list*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::expression*result)
	{

		{
			cpp::symbol_required<cpp::expression_list>result;
			if(parser.parse(result))
			{
				return result;
			}
		};
		return result;
	}
	template<typename Walker>
	inline cpp::primary_expression_parenthesis*parseSymbol(ParserGeneric<Walker>&parser, cpp::primary_expression_parenthesis*result)
	{
		parser.inTemplateArgumentList=false;
		switch(parseTerminal(parser, result->lp))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(parser.parse(checkSymbolRequired(result->expr))==0)
		{
			return 0;
		};
		switch(parseTerminal(parser, result->rp))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		return result;
	}
	inline cpp::postfix_expression*pruneSymbol(cpp::postfix_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::postfix_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::postfix_expression_default*result)
	{
		if(parser.parse(checkSymbolRequired(result->left))==0)
		{
			return 0;
		};
		parser.parse(checkSymbolOptional(result->right));
		return result;
	}
	template<typename Walker>
	inline cpp::postfix_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::postfix_expression*result)
	{

		{
			cpp::symbol_required<cpp::postfix_expression_default>result;
			if(parser.parse(result))
			{
				return result;
			}
		};
		return result;
	}
	inline cpp::pm_expression*pruneSymbol(cpp::pm_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::pm_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::pm_expression_default*result)
	{
		if(parser.parse(checkSymbolRequired(result->op))==0)
		{
			return 0;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::pm_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::pm_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::pm_expression_default>(0), result);
		return result;
	}
	inline cpp::multiplicative_expression*pruneSymbol(cpp::multiplicative_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::multiplicative_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::multiplicative_expression_default*result)
	{
		if(parser.parse(checkSymbolRequired(result->op))==0)
		{
			return 0;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::multiplicative_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::multiplicative_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::multiplicative_expression_default>(0), result);
		return result;
	}
	template<typename Walker>
	inline cpp::additive_operator*parseSymbol(ParserGeneric<Walker>&parser, cpp::additive_operator*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_PLUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::additive_operator::PLUS;
			result->value.id=boost::wave::T_PLUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_MINUS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::additive_operator::MINUS;
			result->value.id=boost::wave::T_MINUS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	inline cpp::additive_expression*pruneSymbol(cpp::additive_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::additive_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::additive_expression_default*result)
	{
		if(parser.parse(checkSymbolRequired(result->op))==0)
		{
			return 0;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::additive_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::additive_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::additive_expression_default>(0), result);
		return result;
	}
	inline cpp::shift_expression*pruneSymbol(cpp::shift_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::shift_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::shift_expression_default*result)
	{
		if(parser.parse(checkSymbolRequired(result->op))==0)
		{
			return 0;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::shift_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::shift_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::shift_expression_default>(0), result);
		return result;
	}
	inline cpp::relational_expression*pruneSymbol(cpp::relational_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::relational_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::relational_expression_default*result)
	{
		if(parser.inTemplateArgumentList&&isToken((parser).get_id(), boost::wave::T_GREATER))
		{
			return 0;
		}
		if(parser.parse(checkSymbolRequired(result->op))==0)
		{
			return 0;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::relational_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::relational_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::relational_expression_default>(0), result);
		return result;
	}
	inline cpp::equality_expression*pruneSymbol(cpp::equality_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::equality_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::equality_expression_default*result)
	{
		if(parser.parse(checkSymbolRequired(result->op))==0)
		{
			return 0;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::equality_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::equality_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::equality_expression_default>(0), result);
		return result;
	}
	inline cpp::and_expression*pruneSymbol(cpp::and_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::and_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::and_expression_default*result)
	{
		switch(parseTerminal(parser, result->op))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::and_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::and_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::and_expression_default>(0), result);
		return result;
	}
	inline cpp::exclusive_or_expression*pruneSymbol(cpp::exclusive_or_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::exclusive_or_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::exclusive_or_expression_default*result)
	{
		switch(parseTerminal(parser, result->op))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::exclusive_or_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::exclusive_or_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::exclusive_or_expression_default>(0), result);
		return result;
	}
	inline cpp::inclusive_or_expression*pruneSymbol(cpp::inclusive_or_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::inclusive_or_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::inclusive_or_expression_default*result)
	{
		switch(parseTerminal(parser, result->op))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::inclusive_or_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::inclusive_or_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::inclusive_or_expression_default>(0), result);
		return result;
	}
	inline cpp::logical_and_expression*pruneSymbol(cpp::logical_and_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::logical_and_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::logical_and_expression_default*result)
	{
		switch(parseTerminal(parser, result->op))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::logical_and_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::logical_and_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::logical_and_expression_default>(0), result);
		return result;
	}
	inline cpp::logical_or_expression*pruneSymbol(cpp::logical_or_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::logical_or_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::logical_or_expression_default*result)
	{
		switch(parseTerminal(parser, result->op))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(parser.parse(checkSymbolRequired(result->right))==0)
		{
			return 0;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::logical_or_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::logical_or_expression*result)
	{
		result=parser.parseExpression(cpp::symbol_required<cpp::logical_or_expression_default>(0), result);
		return result;
	}
	inline cpp::conditional_expression*pruneSymbol(cpp::conditional_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::conditional_expression_default*parseSymbol(ParserGeneric<Walker>&parser, cpp::conditional_expression_default*result)
	{
		if(parser.parse(checkSymbolRequired(result->left))==0)
		{
			return 0;
		};
		parser.parse(checkSymbolOptional(result->right));
		return result;
	}
	inline cpp::assignment_expression*pruneSymbol(cpp::assignment_expression_default*symbol)
	{
		if(symbol->right==0)
		{
			return symbol->left;
		}
		return symbol;
	}
	template<typename Walker>
	inline cpp::conditional_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::conditional_expression*result)
	{

		{
			cpp::symbol_required<cpp::conditional_expression_default>result;
			if(parser.parse(result))
			{
				return result;
			}
		};
		return result;
	}
	template<typename Walker>
	inline cpp::assignment_expression*parseSymbol(ParserGeneric<Walker>&parser, cpp::assignment_expression*result)
	{

		{
			cpp::symbol_required<cpp::assignment_expression_default>result;
			if(parser.parse(result))
			{
				return result;
			}
		};

		{
			cpp::symbol_required<cpp::throw_expression>result;
			if(parser.parse(result))
			{
				return result;
			}
		};
		return result;
	}
	template<typename Walker>
	inline cpp::parameter_declaration_list*parseSymbol(ParserGeneric<Walker>&parser, cpp::parameter_declaration_list*result)
	{
		if(parser.parse(checkSymbolRequired(result->item))==0)
		{
			return 0;
		};
		switch(parseTerminal(parser, result->comma))
		{
			case PARSERESULT_FAIL: return 0;
			case PARSERESULT_SKIP: return result;
			default: break;
		};
		if(!isToken((parser).get_id(), boost::wave::T_ELLIPSIS))
		{
			if(parser.parse(checkSymbolRequired(result->next))==0)
			{
				return 0;
			};
		}
		return result;
	}
	template<typename Walker>
	inline cpp::msext_asm_terminal*parseSymbol(ParserGeneric<Walker>&parser, cpp::msext_asm_terminal*result)
	{
		if(!isToken((parser).get_id(), boost::wave::T_RIGHTBRACE)&&!isToken((parser).get_id(), boost::wave::T_SEMICOLON)&&!isToken((parser).get_id(), boost::wave::T_LEFTBRACE))
		{
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		}
		return 0;
	}
	template<typename Walker>
	inline cpp::msext_asm_element_list_inline*parseSymbol(ParserGeneric<Walker>&parser, cpp::msext_asm_element_list_inline*result)
	{
		size_t line=parser.get_position().line;
		if(parser.parse(checkSymbolRequired(result->item))==0)
		{
			return 0;
		};
		if(parser.get_position().line==line)
		{
			parser.parse(checkSymbolOptional(result->next));
			switch(parseTerminal(parser, result->semicolon))
			{
				case PARSERESULT_FAIL: return 0;
				case PARSERESULT_SKIP: return result;
				default: break;
			};
		}
		else
		{
			result->semicolon.value.clear();
		}
		return result;
	}
	template<typename Walker>
	inline cpp::typetraits_unary*parseSymbol(ParserGeneric<Walker>&parser, cpp::typetraits_unary*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_HAS_NOTHROW_CONSTRUCTOR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::HAS_NOTHROW_CONSTRUCTOR;
			result->value.id=boost::wave::T_HAS_NOTHROW_CONSTRUCTOR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_HAS_NOTHROW_COPY))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::HAS_NOTHROW_COPY;
			result->value.id=boost::wave::T_HAS_NOTHROW_COPY;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_HAS_TRIVIAL_ASSIGN))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::HAS_TRIVIAL_ASSIGN;
			result->value.id=boost::wave::T_HAS_TRIVIAL_ASSIGN;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_HAS_TRIVIAL_CONSTRUCTOR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::HAS_TRIVIAL_CONSTRUCTOR;
			result->value.id=boost::wave::T_HAS_TRIVIAL_CONSTRUCTOR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_HAS_TRIVIAL_COPY))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::HAS_TRIVIAL_COPY;
			result->value.id=boost::wave::T_HAS_TRIVIAL_COPY;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_HAS_TRIVIAL_DESTRUCTOR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::HAS_TRIVIAL_DESTRUCTOR;
			result->value.id=boost::wave::T_HAS_TRIVIAL_DESTRUCTOR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_HAS_VIRTUAL_DESTRUCTOR))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::HAS_VIRTUAL_DESTRUCTOR;
			result->value.id=boost::wave::T_HAS_VIRTUAL_DESTRUCTOR;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_ABSTRACT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_ABSTRACT;
			result->value.id=boost::wave::T_IS_ABSTRACT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_CLASS))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_CLASS;
			result->value.id=boost::wave::T_IS_CLASS;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_EMPTY))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_EMPTY;
			result->value.id=boost::wave::T_IS_EMPTY;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_ENUM))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_ENUM;
			result->value.id=boost::wave::T_IS_ENUM;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_POD))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_POD;
			result->value.id=boost::wave::T_IS_POD;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_POLYMORPHIC))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_POLYMORPHIC;
			result->value.id=boost::wave::T_IS_POLYMORPHIC;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_UNION))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_UNION;
			result->value.id=boost::wave::T_IS_UNION;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_TRIVIALLY_COPYABLE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_TRIVIALLY_COPYABLE;
			result->value.id=boost::wave::T_IS_TRIVIALLY_COPYABLE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_STANDARD_LAYOUT))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_STANDARD_LAYOUT;
			result->value.id=boost::wave::T_IS_STANDARD_LAYOUT;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_LITERAL_TYPE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::IS_LITERAL_TYPE;
			result->value.id=boost::wave::T_IS_LITERAL_TYPE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_UNDERLYING_TYPE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_unary::UNDERLYING_TYPE;
			result->value.id=boost::wave::T_UNDERLYING_TYPE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
	template<typename Walker>
	inline cpp::typetraits_binary*parseSymbol(ParserGeneric<Walker>&parser, cpp::typetraits_binary*result)
	{
		if(isToken((parser).get_id(), boost::wave::T_IS_BASE_OF))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_binary::IS_BASE_OF;
			result->value.id=boost::wave::T_IS_BASE_OF;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_CONVERTIBLE_TO))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_binary::IS_CONVERTIBLE_TO;
			result->value.id=boost::wave::T_IS_CONVERTIBLE_TO;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_TRIVIALLY_CONSTRUCTIBLE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_binary::IS_TRIVIALLY_CONSTRUCTIBLE;
			result->value.id=boost::wave::T_IS_TRIVIALLY_CONSTRUCTIBLE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		if(isToken((parser).get_id(), boost::wave::T_IS_TRIVIALLY_ASSIGNABLE))
		{
			result=createSymbol(parser, result);
			result->id=cpp::typetraits_binary::IS_TRIVIALLY_ASSIGNABLE;
			result->value.id=boost::wave::T_IS_TRIVIALLY_ASSIGNABLE;
			result->value.value=parser.get_value();
			parser.increment();
			return result;
		};
		return result;
	}
};
struct SemanticError
{
	SemanticError()
	{
		__debugbreak();
	}
};
inline void semanticBreak()
{
}
void printDeclarations(const Scope::Declarations&declarations)
{
	std::cout<<"{ ";
	for(Scope::Declarations::const_iterator i=declarations.begin();
	i!=declarations.end();
	)
	{
		std::cout<<getValue((*i).second->getName());
		if(++i!=declarations.end())
		{
			std::cout<<", ";
		}
	}
	std::cout<<" }";
}
void printBases(const Types&bases)
{
	std::cout<<"{ ";
	for(Types::const_iterator i=bases.begin();
	i!=bases.end();
	)
	{
		std::cout<<getValue((*i).declaration->getName())<<": ";
		Scope*scope=(*i).declaration->enclosed;
		if(scope!=0)
		{
			printDeclarations((*i).declaration->enclosed->declarations);
		}
		if(++i!=bases.end())
		{
			std::cout<<", ";
		}
	}
	std::cout<<" }";
}
void printScope(const Scope&scope)
{
	std::cout<<getValue(scope.name)<<": ";
	std::cout<<std::endl;
	std::cout<<"  declarations: ";
	printDeclarations(scope.declarations);
	std::cout<<std::endl;
	std::cout<<"  bases: ";
	printBases(scope.bases);
	std::cout<<std::endl;
	if(scope.parent!=0)
	{
		printScope(*scope.parent);
	}
}
void printName(const Scope&scope)
{
	if(scope.parent!=0)
	{
		printName(*scope.parent);
		std::cout<<"::";
		std::cout<<getValue(scope.name);
	}
}
struct IdentifierMismatch
{
	Identifier id;
	const char*expected;
	DeclarationPtr declaration;
	IdentifierMismatch()
	{
	}
	IdentifierMismatch(const Identifier&id, Declaration*declaration, const char*expected): id(id), declaration(declaration), expected(expected)
	{
	}
};
const IdentifierMismatch IDENTIFIERMISMATCH_NULL=IdentifierMismatch(IDENTIFIER_NULL, 0, 0);
IdentifierMismatch gIdentifierMismatch=IDENTIFIERMISMATCH_NULL;
void printIdentifierMismatch(const IdentifierMismatch&e)
{
	printPosition(e.id.source);
	std::cout<<"'"<<getValue(e.id)<<"' expected "<<e.expected<<", "<<(e.declaration==&gUndeclared?"was undeclared": "was declared here:")<<std::endl;
	if(e.declaration!=&gUndeclared)
	{
		printPosition(e.declaration->getName().source);
		std::cout<<std::endl;
	}
}
inline void setDecoration(Identifier*id, const DeclarationInstance&declaration)
{
	if(!(declaration.name!=0))
	{
		throw SemanticError();
	};
	if(!(id!=&gAnonymousId))
	{
		throw SemanticError();
	};
	id->dec.p=&declaration;
}
inline bool isReturnTypeEqual(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	if(!(left.isFunction()))
	{
		throw AllocatorError();
	};
	if(!(right.isFunction()))
	{
		throw AllocatorError();
	};
	return isEqualInner(left, right);
}
inline bool isEquivalentSpecialization(const Declaration&declaration, const Declaration&other)
{
	return !(isComplete(declaration)&&isComplete(other))&&matchTemplateSpecialization(declaration, other.templateArguments);
}
inline bool isEquivalentTypedef(const Declaration&declaration, const Declaration&other)
{
	return getType(declaration)==getType(other);
}
inline bool isEquivalentTemplateParameter(const Type&left, const Type&right)
{
	extern Declaration gParam;
	if((left.declaration->type.declaration==&gParam)!=(right.declaration->type.declaration==&gParam))
	{
		return false;
	}
	return left.declaration->type.declaration==&gParam?isEqual(left, right): isEqual(left.declaration->type, right.declaration->type);
}
inline bool isEquivalentTemplateParameters(const TemplateParameters&left, const TemplateParameters&right)
{
	if(std::distance(left.begin(), left.end())!=std::distance(right.begin(), right.end()))
	{
		return false;
	}
	TemplateParameters::const_iterator l=left.begin();
	for(TemplateParameters::const_iterator r=right.begin();
	r!=right.end();
	++l, ++r)
	{
		if(!(l!=left.end()))
		{
			throw AllocatorError();
		};
		if(!isEquivalentTemplateParameter(*l, *r))
		{
			return false;
		}
	}
	if(!(l==left.end()))
	{
		throw AllocatorError();
	};
	return true;
}
inline bool isEquivalent(const Declaration&declaration, const Declaration&other)
{
	if(isClass(declaration)&&isClass(other))
	{
		return isSpecialization(declaration)==isSpecialization(other)&&(!isSpecialization(declaration)||isEquivalentSpecialization(declaration, other));
	}
	if(isEnum(declaration)||isEnum(other))
	{
		return isEquivalentTypedef(declaration, other);
	}
	if(isClass(declaration)||isClass(other))
	{
		return isEquivalentTypedef(declaration, other);
	}

	{
		if(!(declaration.type.unique!=0))
		{
			throw SemanticError();
		};
		if(!(other.type.unique!=0))
		{
			throw SemanticError();
		};
		UniqueTypeWrapper l(declaration.type.unique);
		UniqueTypeWrapper r(other.type.unique);
		if(l.isFunction())
		{
			if(!(r.isFunction()))
			{
				throw AllocatorError();
			};
			return declaration.isTemplate==other.isTemplate&&isEquivalentTemplateParameters(declaration.templateParams, other.templateParams)&&(declaration.getName().value==gConversionFunctionId.value?isReturnTypeEqual(l, r): isEquivalent(getParameterTypes(l.value), getParameterTypes(r.value)));
		}
		return true;
	}
	return false;
}
inline const DeclarationInstance*findRedeclared(const Declaration&declaration, const DeclarationInstance*overloaded)
{
	for(const DeclarationInstance*p=overloaded;
	p!=0;
	p=p->overloaded)
	{
		if(isEquivalent(declaration, *(*p)))
		{
			return p;
		}
	}
	return 0;
}
struct Overload
{
	const Declaration*declaration;
	const SimpleType*memberEnclosing;
	Overload(const Declaration*declaration, const SimpleType*memberEnclosing): declaration(declaration), memberEnclosing(memberEnclosing)
	{
	}
};
inline bool operator==(const Overload&left, const Overload&right)
{
	return left.declaration==right.declaration&&left.memberEnclosing==right.memberEnclosing;
}
typedef std::vector<Overload>OverloadSet;
struct KoenigAssociated
{
	typedef std::vector<Scope*>Namespaces;
	Namespaces namespaces;
	typedef std::vector<const SimpleType*>Classes;
	Classes classes;
};
void addAssociatedNamespace(KoenigAssociated&associated, Scope&scope)
{
	if(!(scope.type==SCOPETYPE_NAMESPACE))
	{
		throw SemanticError();
	};
	if(std::find(associated.namespaces.begin(), associated.namespaces.end(), &scope)==associated.namespaces.end())
	{
		associated.namespaces.push_back(&scope);
	}
}
void addAssociatedClass(KoenigAssociated&associated, const SimpleType&type)
{
	if(!(isClass(*type.declaration)))
	{
		throw SemanticError();
	};
	if(std::find(associated.classes.begin(), associated.classes.end(), &type)==associated.classes.end())
	{
		associated.classes.push_back(&type);
	}
}
void addAssociatedEnclosingNamespace(KoenigAssociated&associated, const SimpleType&type)
{
	Scope*scope=getEnclosingNamespace(type.declaration->scope);
	if(scope!=0)
	{
		addAssociatedNamespace(associated, *scope);
	}
}
void addAssociatedClassAndNamespace(KoenigAssociated&associated, const SimpleType&classType)
{
	if(!(isClass(*classType.declaration)))
	{
		throw SemanticError();
	};
	addAssociatedClass(associated, classType);
	addAssociatedEnclosingNamespace(associated, classType);
}
void addAssociatedClassRecursive(KoenigAssociated&associated, const SimpleType&classType)
{
	if(!(isClass(*classType.declaration)))
	{
		throw SemanticError();
	};
	addAssociatedClassAndNamespace(associated, classType);
	for(UniqueBases::const_iterator i=classType.bases.begin();
	i!=classType.bases.end();
	++i)
	{
		const SimpleType*base=*i;
		addAssociatedClassRecursive(associated, *base);
	}
}
void addKoenigAssociated(KoenigAssociated&associated, const SimpleType&classType)
{
	if(classType.enclosing!=0)
	{
		addAssociatedClassAndNamespace(associated, *classType.enclosing);
	}
	addAssociatedClassRecursive(associated, classType);
}
void addKoenigAssociated(KoenigAssociated&associated, UniqueTypeWrapper type);
struct KoenigVisitor: TypeElementVisitor
{
	KoenigAssociated&associated;
	KoenigVisitor(KoenigAssociated&associated): associated(associated)
	{
	}
	virtual void visit(const DependentType&element)
	{
	}
	virtual void visit(const DependentTypename&)
	{
	}
	virtual void visit(const DependentNonType&element)
	{
	}
	virtual void visit(const TemplateTemplateArgument&element)
	{
		if(element.enclosing!=0)
		{
			addAssociatedClass(associated, *element.enclosing);
		}
	}
	virtual void visit(const NonType&)
	{
	}
	virtual void visit(const SimpleType&element)
	{
		if(isClass(*element.declaration))
		{
			addKoenigAssociated(associated, element);
		}
		else if(isEnum(*element.declaration))
		{
			if(element.enclosing!=0)
			{
				addAssociatedClass(associated, *element.enclosing);
			}
			addAssociatedEnclosingNamespace(associated, element);
		}
		if(element.declaration->isTemplate)
		{
			for(TemplateArgumentsInstance::const_iterator i=element.templateArguments.begin();
			i!=element.templateArguments.end();
			++i)
			{
				addKoenigAssociated(associated, *i);
			}
		}
	}
	virtual void visit(const PointerType&)
	{
	}
	virtual void visit(const ReferenceType&)
	{
	}
	virtual void visit(const ArrayType&)
	{
	}
	virtual void visit(const MemberPointerType&element)
	{
		addKoenigAssociated(associated, getSimpleType(element.type.value));
	}
	virtual void visit(const FunctionType&element)
	{
		for(ParameterTypes::const_iterator i=element.parameterTypes.begin();
		i!=element.parameterTypes.end();
		++i)
		{
			addKoenigAssociated(associated, *i);
		}
	}
};
void addKoenigAssociated(KoenigAssociated&associated, UniqueTypeWrapper type)
{
	for(;
	type!=gUniqueTypeNull;
	type.pop_front())
	{
		KoenigVisitor visitor(associated);
		type.value->accept(visitor);
	}
}
void addUniqueOverload(OverloadSet&result, const Overload&overload)
{
	if(std::find(result.begin(), result.end(), overload)==result.end())
	{
		result.push_back(overload);
	}
}
const SimpleType*findAssociatedClass(const KoenigAssociated&associated, const Declaration&declaration)
{
	if(!(isClass(declaration)))
	{
		throw SemanticError();
	}
	for(KoenigAssociated::Classes::const_iterator i=associated.classes.begin();
	i!=associated.classes.end();
	++i)
	{
		const SimpleType*classType=*i;
		if(classType->declaration==&declaration)
		{
			return classType;
		}
	}
	return 0;
}
void addOverloaded(OverloadSet&result, const DeclarationInstance&declaration, const SimpleType*memberEnclosing)
{
	for(Declaration*p=findOverloaded(declaration);
	p!=0;
	p=p->overloaded)
	{
		if(p->specifiers.isFriend)
		{
			if(!(memberEnclosing==0))
			{
				throw SemanticError();
			};
			continue;
		}
		addUniqueOverload(result, Overload(p, memberEnclosing));
	}
}
void addOverloaded(OverloadSet&result, const DeclarationInstance&declaration, const KoenigAssociated&associated=KoenigAssociated())
{
	for(Declaration*p=findOverloaded(declaration);
	p!=0;
	p=p->overloaded)
	{
		const SimpleType*memberEnclosing=0;
		if(p->specifiers.isFriend)
		{
			Scope*enclosingClass=getEnclosingClass(p->enclosed);
			memberEnclosing=findAssociatedClass(associated, *getDeclaration(enclosingClass->name));
			if(memberEnclosing==0)
			{
				continue;
			}
		}
		addUniqueOverload(result, Overload(p, memberEnclosing));
	}
}
void argumentDependentLookup(OverloadSet&result, const Identifier&id, const Arguments&arguments)
{
	KoenigAssociated associated;
	for(Arguments::const_iterator i=arguments.begin();
	i!=arguments.end();
	++i)
	{
		UniqueTypeWrapper type=(*i).type;
		addKoenigAssociated(associated, type);
	}
	for(KoenigAssociated::Namespaces::const_iterator i=associated.namespaces.begin();
	i!=associated.namespaces.end();
	++i)
	{
		if(const DeclarationInstance*p=findDeclaration((*i)->declarations, id, IsFunctionName()))
		{
			const DeclarationInstance&declaration=*p;
			addOverloaded(result, *p, associated);
		}
	}
}
inline void addOverloads(OverloadResolver&resolver, const DeclarationInstance&declaration, const InstantiationContext&context)
{
	for(Declaration*p=findOverloaded(declaration);
	p!=0;
	p=p->overloaded)
	{
		addOverload(resolver, *p, context);
	}
}
inline void addOverloads(OverloadResolver&resolver, const OverloadSet&overloads, const InstantiationContext&context)
{
	for(OverloadSet::const_iterator i=overloads.begin();
	i!=overloads.end();
	++i)
	{
		const Overload&overload=*i;
		addOverload(resolver, *overload.declaration, setEnclosingType(context, overload.memberEnclosing));
	}
}
inline void printOverloads(OverloadResolver&resolver, const OverloadSet&overloads, const InstantiationContext&context)
{
	for(OverloadSet::const_iterator i=overloads.begin();
	i!=overloads.end();
	++i)
	{
		const Overload&overload=*i;
		addOverload(resolver, *overload.declaration, setEnclosingType(context, overload.memberEnclosing));
		const Declaration*p=overload.declaration;
		ParameterTypes parameters=addOverload(resolver, *p, context);
		printPosition(p->getName().source);
		std::cout<<"(";
		bool separator=false;
		for(ParameterTypes::const_iterator i=parameters.begin();
		i!=parameters.end();
		++i)
		{
			if(separator)
			{
				std::cout<<", ";
			}
			printType(*i);
			separator=true;
		}
		std::cout<<")"<<std::endl;
	}
}
inline FunctionOverload findBestMatch(const OverloadSet&overloads, const TemplateArgumentsInstance*templateArguments, const Arguments&arguments, const InstantiationContext&context)
{
	if(!(!overloads.empty()))
	{
		throw SemanticError();
	};
	OverloadResolver resolver(arguments, templateArguments, context);
	addOverloads(resolver, overloads, context);
	if(resolver.ambiguous!=0)
	{
	}
	if(resolver.get().declaration==0)
	{
		printPosition(context.source);
		std::cout<<"overload resolution failed when matching arguments (";
		bool separator=false;
		for(Arguments::const_iterator i=arguments.begin();
		i!=arguments.end();
		++i)
		{
			if(separator)
			{
				std::cout<<", ";
			}
			printType((*i).type);
			separator=true;
		}
		std::cout<<")"<<std::endl;
		std::cout<<"candidates for ";
		const Declaration*declaration=overloads.front().declaration;
		printName(declaration->scope);
		std::cout<<getValue(declaration->getName());
		std::cout<<std::endl;
		printOverloads(resolver, overloads, context);
	}
	return resolver.get();
}
inline void addBuiltInOperatorOverload(OverloadResolver&resolver, UniqueTypeWrapper type)
{
	const ParameterTypes&parameters=getParameterTypes(type.value);
	resolver.add(FunctionOverload(&gUnknown, popType(type)), parameters, false, 0);
}
inline void addBuiltInOperatorOverloads(OverloadResolver&resolver, BuiltInTypeArrayRange overloads)
{
	for(const BuiltInType*i=overloads.first;
	i!=overloads.last;
	++i)
	{
		BuiltInType overload=*i;
		const ParameterTypes&parameters=getParameterTypes(overload.value);
		if(resolver.arguments.size()!=parameters.size())
		{
			continue;
		}
		addBuiltInOperatorOverload(resolver, overload);
	}
}
typedef std::vector<UserType>UserTypeArray;
extern BuiltInTypeArrayRange gIntegralTypesRange;
extern BuiltInTypeArrayRange gPromotedIntegralTypesRange;
extern BuiltInTypeArrayRange gArithmeticTypesRange;
extern BuiltInTypeArrayRange gPromotedArithmeticTypesRange;
inline void addBuiltInTypeConversions(UserTypeArray&conversions, BuiltInTypeArrayRange types)
{
	for(const BuiltInType*i=types.first;
	i!=types.last;
	++i)
	{
		conversions.push_back(UserType(*i));
	}
}
template<typename Op>
inline void forEachBase(const SimpleType&classType, Op op)
{
	if(!(classType.instantiated))
	{
		throw AllocatorError();
	};
	op(classType);
	for(UniqueBases::const_iterator i=classType.bases.begin();
	i!=classType.bases.end();
	++i)
	{
		forEachBase(**i, op);
	}
}
template<typename T>
inline void addQualificationPermutations(UserTypeArray&conversions, UniqueTypeWrapper type, const T&pointerType)
{
	conversions.push_back(UserType(pushType(qualifyType(type, CvQualifiers(false, false)), pointerType)));
	conversions.push_back(UserType(pushType(qualifyType(type, CvQualifiers(true, false)), pointerType)));
	conversions.push_back(UserType(pushType(qualifyType(type, CvQualifiers(false, true)), pointerType)));
	conversions.push_back(UserType(pushType(qualifyType(type, CvQualifiers(true, true)), pointerType)));
}
inline void addQualificationPermutations(UserTypeArray&conversions, UniqueTypeWrapper type)
{
	addQualificationPermutations(conversions, type, PointerType());
}
struct AddPointerConversions
{
	UserTypeArray&conversions;
	CvQualifiers qualifiers;
	AddPointerConversions(UserTypeArray&conversions, CvQualifiers qualifiers): conversions(conversions), qualifiers(qualifiers)
	{
	}
	void operator()(const SimpleType&classType)const
	{
		addQualificationPermutations(conversions, qualifyType(makeUniqueSimpleType(classType), qualifiers));
	}
};
struct AddMemberPointerConversions
{
	UserTypeArray&conversions;
	UniqueTypeWrapper type;
	AddMemberPointerConversions(UserTypeArray&conversions, UniqueTypeWrapper type): conversions(conversions), type(type)
	{
	}
	void operator()(const SimpleType&classType)const
	{
		addQualificationPermutations(conversions, type, MemberPointerType(makeUniqueSimpleType(classType)));
	}
};
inline bool isPlaceholder(UniqueTypeWrapper type)
{
	type=removeReference(type);
	return type==gArithmeticPlaceholder||type==gIntegralPlaceholder||type==gPromotedIntegralPlaceholder||type==gPromotedArithmeticPlaceholder||type==gEnumerationPlaceholder||type==gPointerToAnyPlaceholder||type==gPointerToObjectPlaceholder||type==gPointerToClassPlaceholder||type==gPointerToFunctionPlaceholder||type==gPointerToMemberPlaceholder;
}
inline void addBuiltInOperatorConversions(UserTypeArray&conversions, UniqueTypeWrapper to, UniqueTypeWrapper from, const InstantiationContext&context)
{
	if(!(isPlaceholder(removeReference(to))))
	{
		throw AllocatorError();
	};
	if(to.isReference())
	{
		conversions.push_back(UserType(from));
		return ;
	}
	if(isPointerPlaceholder(to))
	{
		if(!(from.isPointer()))
		{
			throw AllocatorError();
		};
		UniqueTypeWrapper type=popType(from);
		CvQualifiers qualifiers=type.value.getQualifiers();
		if(isClass(type)&&isComplete(type))
		{
			const SimpleType&classType=getSimpleType(type.value);
			instantiateClass(classType, context);
			forEachBase(classType, AddPointerConversions(conversions, qualifiers));
		}
		else
		{
			addQualificationPermutations(conversions, type);
		}
		addQualificationPermutations(conversions, qualifyType(gVoid, qualifiers));
		return ;
	}
	if(to==gPointerToMemberPlaceholder)
	{
		if(!(from.isMemberPointer()))
		{
			throw AllocatorError();
		};
		UniqueTypeWrapper type=popType(from);
		if(isComplete(from))
		{
			const SimpleType&classType=getMemberPointerClass(from.value);
			instantiateClass(classType, context);
			forEachBase(classType, AddMemberPointerConversions(conversions, type));
		}
		else
		{
			addQualificationPermutations(conversions, type, getMemberPointerType(from.value));
		}
		return ;
	}
	if(to==gEnumerationPlaceholder)
	{
		if(!(isEnum(from)))
		{
			throw AllocatorError();
		};
		conversions.push_back(UserType(from));
	}
	return addBuiltInTypeConversions(conversions, gArithmeticTypesRange);
}
typedef std::vector<UserTypeArray>ConversionPairs;
typedef TypeTuple<false, 1>Permutation1;
typedef TypeTuple<false, 2>Permutation2;
typedef std::vector<Permutation1>Permutation1Array;
typedef std::vector<Permutation2>Permutation2Array;
inline void addBuiltInOperatorPermutations(Permutation1Array&result, ConversionPairs&conversionPairs)
{
	if(!(!conversionPairs.empty()))
	{
		throw SemanticError();
	};
	if(conversionPairs.size()==1)
	{
		std::copy(conversionPairs[0].begin(), conversionPairs[0].end(), std::back_inserter(result));
	}
	else
	{
		if(!(conversionPairs.size()==2))
		{
			throw SemanticError();
		};
		std::sort(conversionPairs[0].begin(), conversionPairs[0].end());
		std::sort(conversionPairs[1].begin(), conversionPairs[1].end());
		std::set_intersection(conversionPairs[0].begin(), conversionPairs[0].end(), conversionPairs[1].begin(), conversionPairs[1].end(), std::back_inserter(result));
	}
}
inline void addBuiltInOperatorPermutations(Permutation2Array&result, ConversionPairs&conversionPairs)
{
	if(!(!conversionPairs.empty()))
	{
		throw SemanticError();
	};
	if(conversionPairs.size()==1)
	{
		return ;
	}
	else
	{
		if(!(conversionPairs.size()==2))
		{
			throw SemanticError();
		};
		for(UserTypeArray::const_iterator i=conversionPairs[0].begin();
		i!=conversionPairs[0].end();
		++i)
		{
			UserType left=*i;
			for(UserTypeArray::const_iterator i=conversionPairs[0].begin();
			i!=conversionPairs[0].end();
			++i)
			{
				UserType right=*i;
				result.push_back(Permutation2(left, right));
			}
		}
	}
}
template<int N>
inline void addBuiltInOperatorOverloads(OverloadResolver&resolver, ArrayRange<BuiltInGenericType<N> >overloads)
{
	for(const BuiltInGenericType<N>*i=overloads.first;
	i!=overloads.last;
	++i)
	{
		BuiltInGenericType<N>overload=*i;
		const ParameterTypes&parameters=getParameterTypes(overload.value);
		if(resolver.arguments.size()!=parameters.size())
		{
			continue;
		}
		ConversionPairs conversionPairs;
		conversionPairs.reserve(2);
		Arguments::const_iterator a=resolver.arguments.begin();
		ParameterTypes::const_iterator p=parameters.begin();
		for(;
		a!=resolver.arguments.end();
		++a, ++p)
		{
			UniqueTypeWrapper to=*p;
			const Argument&from=*a;
			ImplicitConversion conversion=resolver.makeConversion(TargetType(to), from);
			if(!isValid(conversion))
			{
				conversionPairs.clear();
				break;
			}
			if(!isPlaceholder(to))
			{
				continue;
			}
			if(isGeneralPointer(TargetType(to))&&isIntegral(from.type))
			{
				continue;
			}
			conversionPairs.push_back(UserTypeArray());
			UserTypeArray&conversions=conversionPairs.back();
			addBuiltInOperatorConversions(conversions, to, conversion.sequence.matched, resolver.context);
		}
		if(conversionPairs.empty())
		{
			continue;
		}
		typedef TypeTuple<false, N>Permutation;
		typedef std::vector<Permutation>Permutations;
		Permutations permutations;
		addBuiltInOperatorPermutations(permutations, conversionPairs);
		for(typename Permutations::const_iterator i=permutations.begin();
		i!=permutations.end();
		++i)
		{
			Permutation permutation=*i;
			UserType substituted=overload.substitute(permutation);
			addBuiltInOperatorOverload(resolver, substituted);
		}
	}
}
extern BuiltInTypeArrayRange gUnaryPostIncOperatorTypes;
extern BuiltInTypeArrayRange gUnaryPreIncOperatorTypes;
extern BuiltInTypeArrayRange gUnaryArithmeticOperatorTypes;
extern BuiltInTypeArrayRange gUnaryIntegralOperatorTypes;
extern BuiltInTypeArrayRange gBinaryArithmeticOperatorTypes;
extern BuiltInTypeArrayRange gBinaryIntegralOperatorTypes;
extern BuiltInTypeArrayRange gRelationalArithmeticOperatorTypes;
extern BuiltInTypeArrayRange gShiftOperatorTypes;
extern BuiltInTypeArrayRange gAssignArithmeticOperatorTypes;
extern BuiltInTypeArrayRange gAssignIntegralOperatorTypes;
extern BuiltInTypeArrayRange gBinaryLogicalOperatorTypes;
extern BuiltInTypeArrayRange gUnaryLogicalOperatorTypes;
extern BuiltInGenericType1ArrayRange gPointerAddOperatorTypes;
extern BuiltInGenericType1ArrayRange gPointerSubtractOperatorTypes;
extern BuiltInGenericType1ArrayRange gSubscriptOperatorTypes;
extern BuiltInGenericType1ArrayRange gRelationalOperatorTypes;
extern BuiltInGenericType1ArrayRange gEqualityOperatorTypes;
extern BuiltInGenericType2ArrayRange gMemberPointerOperatorTypes;
inline void addBuiltInOperatorOverloads(OverloadResolver&resolver, const Identifier&id)
{
	if(id.value==gOperatorPlusPlusId||id.value==gOperatorMinusMinusId)
	{
		addBuiltInOperatorOverloads(resolver, gUnaryPreIncOperatorTypes);
		addBuiltInOperatorOverloads(resolver, gUnaryPostIncOperatorTypes);
	}
	else if(id.value==gOperatorStarId||id.value==gOperatorDivideId)
	{
		addBuiltInOperatorOverloads(resolver, gBinaryArithmeticOperatorTypes);
	}
	else if(id.value==gOperatorPlusId||id.value==gOperatorMinusId)
	{
		addBuiltInOperatorOverloads(resolver, gBinaryArithmeticOperatorTypes);
		addBuiltInOperatorOverloads(resolver, gUnaryArithmeticOperatorTypes);
	}
	else if(id.value==gOperatorComplId)
	{
		addBuiltInOperatorOverloads(resolver, gUnaryIntegralOperatorTypes);
	}
	else if(id.value==gOperatorLessId||id.value==gOperatorGreaterId||id.value==gOperatorLessEqualId||id.value==gOperatorGreaterEqualId||id.value==gOperatorEqualId||id.value==gOperatorNotEqualId)
	{
		addBuiltInOperatorOverloads(resolver, gRelationalArithmeticOperatorTypes);
	}
	else if(id.value==gOperatorPercentId||id.value==gOperatorAndId||id.value==gOperatorXorId||id.value==gOperatorOrId)
	{
		addBuiltInOperatorOverloads(resolver, gBinaryIntegralOperatorTypes);
	}
	else if(id.value==gOperatorShiftLeftId||id.value==gOperatorShiftRightId)
	{
		addBuiltInOperatorOverloads(resolver, gShiftOperatorTypes);
	}
	else if(id.value==gOperatorAssignId||id.value==gOperatorStarAssignId||id.value==gOperatorDivideAssignId||id.value==gOperatorPlusAssignId||id.value==gOperatorMinusAssignId)
	{
		addBuiltInOperatorOverloads(resolver, gAssignArithmeticOperatorTypes);
	}
	else if(id.value==gOperatorPercentAssignId||id.value==gOperatorShiftLeftAssignId||id.value==gOperatorShiftRightAssignId||id.value==gOperatorAndAssignId||id.value==gOperatorXorAssignId||id.value==gOperatorOrAssignId)
	{
		addBuiltInOperatorOverloads(resolver, gAssignIntegralOperatorTypes);
	}
	else if(id.value==gOperatorAndAndId||id.value==gOperatorOrOrId)
	{
		addBuiltInOperatorOverloads(resolver, gBinaryLogicalOperatorTypes);
	}
	else if(id.value==gOperatorNotId)
	{
		addBuiltInOperatorOverloads(resolver, gUnaryLogicalOperatorTypes);
	}
	if(id.value==gOperatorPlusId)
	{
		addBuiltInOperatorOverloads(resolver, gPointerAddOperatorTypes);
	}
	else if(id.value==gOperatorMinusId)
	{
		addBuiltInOperatorOverloads(resolver, gPointerSubtractOperatorTypes);
	}
	else if(id.value==gOperatorSubscriptId)
	{
		addBuiltInOperatorOverloads(resolver, gSubscriptOperatorTypes);
	}
	else if(id.value==gOperatorLessId||id.value==gOperatorGreaterId||id.value==gOperatorLessEqualId||id.value==gOperatorGreaterEqualId)
	{
		addBuiltInOperatorOverloads(resolver, gRelationalOperatorTypes);
	}
	else if(id.value==gOperatorEqualId||id.value==gOperatorNotEqualId)
	{
		addBuiltInOperatorOverloads(resolver, gEqualityOperatorTypes);
	}
	else if(id.value==gOperatorArrowStarId)
	{
		addBuiltInOperatorOverloads(resolver, gMemberPointerOperatorTypes);
	}
}
inline FunctionOverload findBestOverloadedOperator(const Identifier&id, const Arguments&arguments, const InstantiationContext&context)
{
	Arguments::const_iterator i=arguments.begin();
	UniqueTypeWrapper left=(*i++).type;
	UniqueTypeWrapper right=i==arguments.end()?gUniqueTypeNull: (*i).type;
	if(!isClass(left)&&!isEnumeration(left)&&!isClass(right)&&!isEnumeration(right))
	{
		return FunctionOverload(&gUnknown, gUniqueTypeNull);
	}
	OverloadResolver resolver(arguments, 0, context);
	if(isClass(left)&&isComplete(left))
	{
		const SimpleType&operand=getSimpleType(left.value);
		instantiateClass(operand, context);
		LookupResultRef declaration=::findDeclaration(operand, id, IsAny());
		if(declaration!=0)
		{
			const SimpleType*memberEnclosing=findEnclosingType(&operand, declaration->scope);
			if(!(memberEnclosing!=0))
			{
				throw SemanticError();
			};
			addOverloads(resolver, declaration, setEnclosingTypeSafe(context, memberEnclosing));
		}
	}
	OverloadSet overloads;
	LookupResultRef declaration=findClassOrNamespaceMemberDeclaration(*context.enclosingScope, id, IsNonMemberName());
	if(declaration!=0)
	{
		addOverloaded(overloads, declaration);
	}
	argumentDependentLookup(overloads, id, arguments);
	addOverloads(resolver, overloads, setEnclosingType(context, 0));
	addBuiltInOperatorOverloads(resolver, id);
	return resolver.get();
}
inline UniqueTypeWrapper getBuiltInUnaryOperatorReturnType(Name operatorName, UniqueTypeWrapper type)
{
	if(operatorName==gOperatorAndId)
	{
		UniqueTypeId result=type;
		result.push_front(PointerType());
		return result;
	}
	else if(operatorName==gOperatorStarId)
	{
		UniqueTypeId result=applyLvalueToRvalueConversion(type);
		if(!(!result.empty()))
		{
			throw SemanticError();
		};
		if(!(result.isPointer()))
		{
			throw SemanticError();
		};
		result.pop_front();
		return result;
	}
	else if(operatorName==gOperatorPlusId||operatorName==gOperatorMinusId)
	{
		if(!isFloating(type))
		{
			return promoteToIntegralType(type);
		}
		return type;
	}
	else if(operatorName==gOperatorNotId)
	{
		return gBool;
	}
	else if(operatorName==gOperatorComplId)
	{
		return promoteToIntegralType(type);
	}
	if(!(operatorName==gOperatorPlusPlusId||operatorName==gOperatorMinusMinusId))
	{
		throw SemanticError();
	};
	return type;
}
inline UniqueTypeWrapper typeOfUnaryExpression(Name operatorName, Argument operand, const InstantiationContext&context)
{
	Identifier id;
	id.value=operatorName;
	id.source=context.source;
	Arguments arguments(1, operand);
	FunctionOverload overload=findBestOverloadedOperator(id, arguments, context);
	if(overload.declaration==&gUnknown||(overload.declaration==0&&operatorName==gOperatorAndId))
	{
		if(operatorName==gOperatorAndId&&operand.isQualifiedNonStaticMemberName)
		{
			UniqueTypeWrapper classType=makeUniqueSimpleType(*getIdExpression(operand).enclosing);
			UniqueTypeWrapper type=operand.type;
			type.push_front(MemberPointerType(classType));
			return type;
		}
		else
		{
			return getBuiltInUnaryOperatorReturnType(operatorName, operand.type);
		}
	}
	else
	{
		if(!(overload.declaration!=0))
		{
			throw SemanticError();
		};
		if(!(overload.type!=gUniqueTypeNull))
		{
			throw SemanticError();
		};
		return overload.type;
	}
}
inline UniqueTypeWrapper typeOfPostfixOperatorExpression(Name operatorName, Argument operand, const InstantiationContext&context)
{
	Identifier id;
	id.value=operatorName;
	id.source=context.source;
	ExpressionWrapper zero=ExpressionWrapper(makeUniqueExpression(IntegralConstantExpression(gSignedInt, IntegralConstant(0))), true);
	Arguments arguments;
	arguments.push_back(operand);
	arguments.push_back(Argument(zero, gSignedInt));
	FunctionOverload overload=findBestOverloadedOperator(id, arguments, context);
	if(overload.declaration==&gUnknown)
	{
		UniqueTypeWrapper type=operand.type;
		type.value.setQualifiers(CvQualifiers());
		requireCompleteObjectType(type, context);
		return operand.type;
	}
	else
	{
		if(!(overload.declaration!=0))
		{
			throw SemanticError();
		};
		if(!(overload.type!=gUniqueTypeNull))
		{
			throw SemanticError();
		};
		return overload.type;
	}
}
typedef UniqueTypeWrapper(*BuiltInBinaryTypeOp)(UniqueTypeWrapper, UniqueTypeWrapper);
template<BuiltInBinaryTypeOp typeOp>
inline UniqueTypeWrapper typeOfBinaryExpression(Name operatorName, Argument left, Argument right, const InstantiationContext&context)
{
	if(!(left.type!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	if(!(right.type!=gUniqueTypeNull))
	{
		throw AllocatorError();
	};
	Identifier id;
	id.value=operatorName;
	id.source=context.source;
	FunctionOverload overload(&gUnknown, gUniqueTypeNull);
	if(!id.value.empty())
	{
		Arguments arguments;
		arguments.push_back(left);
		arguments.push_back(right);
		overload=findBestOverloadedOperator(id, arguments, context);
	}
	if(overload.declaration==&gUnknown||(overload.declaration==0&&id.value==gOperatorAssignId))
	{
		return typeOp(left.type, right.type);
	}
	if(!(overload.declaration!=0))
	{
		throw SemanticError();
	};
	return overload.type;
}
inline bool isSpecialMember(const Declaration&declaration)
{
	return &declaration==gDestructorInstance.p||&declaration==gCopyAssignmentOperatorInstance.p;
}
inline const SimpleType*getIdExpressionClass(const SimpleType*qualifying, const DeclarationInstance&declaration, const SimpleType*enclosingType)
{
	if(!(!isSpecialMember(*declaration)))
	{
		throw SemanticError();
	}
	if(!isMember(*declaration))
	{
		return 0;
	}
	const SimpleType*idEnclosing=qualifying!=0?qualifying: enclosingType;
	if(!(idEnclosing!=0))
	{
		throw AllocatorError();
	};
	idEnclosing=findEnclosingType(idEnclosing, declaration->scope);
	if(!(idEnclosing!=0))
	{
		throw AllocatorError();
	};
	return idEnclosing;
}
inline UniqueTypeWrapper typeOfIdExpression(const SimpleType*qualifying, const DeclarationInstance&declaration, const InstantiationContext&context)
{
	if(declaration==gDestructorInstance.p)
	{
		return pushType(gUniqueTypeNull, FunctionType());
	}
	else if(declaration==gCopyAssignmentOperatorInstance.p)
	{
		const SimpleType*idEnclosing=qualifying!=0?qualifying: context.enclosingType;
		if(!(idEnclosing!=0))
		{
			throw AllocatorError();
		};
		return makeCopyAssignmentOperatorType(*idEnclosing);
	}
	const SimpleType*idEnclosing=getIdExpressionClass(qualifying, declaration, context.enclosingType);
	return getUniqueType(declaration->type, setEnclosingType(context, idEnclosing), declaration->isTemplate);
}
UniqueTypeWrapper getOverloadedMemberOperatorType(UniqueTypeWrapper operand, const InstantiationContext&context)
{
	const SimpleType&classType=getSimpleType(operand.value);
	if(!(isClass(*classType.declaration)))
	{
		throw SemanticError();
	};
	instantiateClass(classType, context);
	Identifier id;
	id.value=gOperatorArrowId;
	id.source=context.source;
	ExpressionNodeGeneric<ExplicitTypeExpression>transientExpression=ExplicitTypeExpression(operand);
	Arguments arguments(1, Argument(ExpressionWrapper(&transientExpression, false), operand));
	OverloadResolver resolver(arguments, 0, context);
	LookupResultRef declaration=::findDeclaration(classType, id, IsAny());
	if(declaration!=0)
	{
		const SimpleType*memberEnclosing=findEnclosingType(&classType, declaration->scope);
		if(!(memberEnclosing!=0))
		{
			throw SemanticError();
		};
		addOverloads(resolver, declaration, setEnclosingTypeSafe(context, memberEnclosing));
	}
	FunctionOverload result=resolver.get();
	if(!(result.declaration!=0))
	{
		throw SemanticError();
	};
	return result.type;
}
inline const SimpleType&getMemberOperatorType(Argument operand, bool isArrow, const InstantiationContext&context)
{
	UniqueTypeWrapper type=operand.type;
	if(isArrow)
	{
		while(isClass(type))
		{
			type=getOverloadedMemberOperatorType(type, context);
		}
	}
	bool isPointer=type.isPointer();
	if(!(isPointer==isArrow))
	{
		throw SemanticError();
	};
	if(isPointer)
	{
		type.pop_front();
	}
	if(!(type.isSimple()))
	{
		throw SemanticError();
	};
	const SimpleType&result=getSimpleType(type.value);
	if(!(isClass(*result.declaration)))
	{
		throw SemanticError();
	};
	instantiateClass(result, context);
	return result;
}
inline UniqueTypeWrapper makeCopyAssignmentOperatorType(const SimpleType&classType)
{
	UniqueTypeWrapper type=makeUniqueSimpleType(classType);
	UniqueTypeWrapper parameter=type;
	parameter.value.setQualifiers(CvQualifiers(true, false));
	parameter.push_front(ReferenceType());
	type.push_front(ReferenceType());
	FunctionType function;
	function.parameterTypes.push_back(parameter);
	type.push_front(function);
	return type;
}
inline UniqueTypeWrapper binaryOperatorArithmeticType(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	return usualArithmeticConversions(left, right);
}
inline UniqueTypeWrapper binaryOperatorAdditiveType(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	if(!(left!=gUniqueTypeNull))
	{
		throw SemanticError();
	};
	if(!(right!=gUniqueTypeNull))
	{
		throw SemanticError();
	};
	left=applyLvalueToRvalueConversion(left);
	right=applyLvalueToRvalueConversion(right);
	if(left.isPointer())
	{
		if(isIntegral(right)||isEnumeration(right))
		{
			return left;
		}
		if(right.isPointer())
		{
			return gSignedLongLongInt;
		}
	}
	return usualArithmeticConversions(left, right);
}
inline UniqueTypeWrapper makePointerCvUnion(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	CvQualifiers qualifiers=left.value.getQualifiers();
	qualifiers.isConst|=right.value.getQualifiers().isConst;
	qualifiers.isVolatile|=right.value.getQualifiers().isVolatile;
	UniqueTypeWrapper result=left;
	if((left.isPointer()&&right.isPointer())||(left.isMemberPointer()&&right.isMemberPointer()&&getMemberPointerType(left.value).type==getMemberPointerType(right.value).type))
	{
		result=makePointerCvUnion(popType(left), popType(right));
		if(left.isPointer())
		{
			result.push_front(PointerType());
		}
		else
		{
			result.push_front(getMemberPointerType(left.value));
		}
	}
	else
	{
		if(!(left.value.getPointer()==right.value.getPointer()))
		{
			throw SemanticError();
		};
	}
	result.value.setQualifiers(qualifiers);
	return result;
}
inline UniqueTypeWrapper binaryOperatorPointerType(UniqueTypeWrapper left, UniqueTypeWrapper right)
{
	if(!(left.isPointer()||left.isMemberPointer()))
	{
		throw SemanticError();
	};
	if(!(right.isPointer()||right.isMemberPointer()))
	{
		throw SemanticError();
	};
	UniqueTypeWrapper result=left;
	if(isVoidPointer(left)||isVoidPointer(right))
	{
		if(!(left.isPointer()&&right.isPointer()))
		{
			throw SemanticError();
		};
		CvQualifiers qualifiers=left.value.getQualifiers();
		qualifiers.isConst|=right.value.getQualifiers().isConst;
		qualifiers.isVolatile|=right.value.getQualifiers().isVolatile;
		left.value.setQualifiers(qualifiers);
		left.push_front(PointerType());
		return left;
	}
	return makePointerCvUnion(left, right);
}
inline UniqueTypeWrapper getConditionalOperatorType(UniqueTypeWrapper leftType, UniqueTypeWrapper rightType)
{
	if(!(leftType!=gUniqueTypeNull))
	{
		throw SemanticError();
	};
	if(!(rightType!=gUniqueTypeNull))
	{
		throw SemanticError();
	};
	leftType.value.setQualifiers(CvQualifiers());
	rightType.value.setQualifiers(CvQualifiers());
	if(leftType==gVoid)
	{
		return rightType;
	}
	if(rightType==gVoid)
	{
		return leftType;
	}
	if(leftType==rightType)
	{
		return leftType;
	}
	if(isClass(leftType)||isClass(rightType))
	{
		if(!(false))
		{
			throw SemanticError();
		};
		return gUniqueTypeNull;
	}
	UniqueTypeWrapper left=applyLvalueToRvalueConversion(leftType);
	UniqueTypeWrapper right=applyLvalueToRvalueConversion(rightType);
	if(left==right)
	{
		return left;
	}
	if((isArithmetic(left)||isEnumeration(left))&&(isArithmetic(right)||isEnumeration(right)))
	{
		return binaryOperatorArithmeticType(left, right);
	}
	bool leftPointer=left.isPointer()||left.isMemberPointer();
	bool rightPointer=right.isPointer()||right.isMemberPointer();
	if(!(leftPointer||rightPointer))
	{
		throw SemanticError();
	};
	if(leftPointer&&!right.isPointer())
	{
		return left;
	}
	if(rightPointer&&!left.isPointer())
	{
		return right;
	}
	if(!(leftPointer&&rightPointer))
	{
		throw SemanticError();
	};
	return binaryOperatorPointerType(left, right);
}
inline UniqueTypeWrapper typeOfSubscriptExpression(Argument left, Argument right, const InstantiationContext&context)
{
	if(!(left.type!=gUniqueTypeNull))
	{
		throw SemanticError();
	};
	if(isClass(left.type))
	{
		if(!(isComplete(left.type)))
		{
			throw SemanticError();
		};
		const SimpleType&object=getSimpleType(left.type.value);
		instantiateClass(object, context);
		Identifier tmp;
		tmp.value=gOperatorSubscriptId;
		tmp.source=context.source;
		LookupResultRef declaration=::findDeclaration(object, tmp, IsAny());
		if(!(declaration!=0))
		{
			throw SemanticError();
		};
		const SimpleType*memberEnclosing=findEnclosingType(&object, declaration->scope);
		if(!(memberEnclosing!=0))
		{
			throw SemanticError();
		};
		Arguments arguments;
		arguments.push_back(left);
		arguments.push_back(right);
		OverloadSet overloads;
		addOverloaded(overloads, declaration, memberEnclosing);
		FunctionOverload overload=findBestMatch(overloads, 0, arguments, setEnclosingTypeSafe(context, memberEnclosing));
		if(!(overload.declaration!=0))
		{
			throw SemanticError();
		};
		return overload.type;
	}
	UniqueTypeWrapper type=left.type;
	if(!(type.isArray()||type.isPointer()))
	{
		throw SemanticError();
	};
	type.pop_front();
	requireCompleteObjectType(type, context);
	return type;
}
inline UniqueTypeWrapper typeOfFunctionCallExpression(Argument left, const Arguments&arguments, const InstantiationContext&context)
{
	ExpressionWrapper expression=left;
	UniqueTypeWrapper type=left.type;
	if(!(expression.p!=0))
	{
		throw SemanticError();
	};
	if(isDependentIdExpression(expression))
	{
		if(!(!arguments.empty()))
		{
			throw SemanticError();
		};
		if(!(getDependentIdExpression(expression).templateArguments.empty()))
		{
			throw SemanticError();
		};
		if(!(getDependentIdExpression(expression).qualifying==gUniqueTypeNull))
		{
			throw SemanticError();
		};
		Identifier id;
		id.value=getDependentIdExpression(expression).name;
		OverloadSet overloads;
		argumentDependentLookup(overloads, id, arguments);
		if(!(!overloads.empty()))
		{
			throw SemanticError();
		};
		FunctionOverload overload=findBestMatch(overloads, 0, arguments, context);
		if(!(overload.declaration!=0))
		{
			throw SemanticError();
		};
		return overload.type;
	}
	type=removeReference(type);
	if(isClass(type))
	{
		if(!(isComplete(type)))
		{
			throw SemanticError();
		};
		const SimpleType&object=getSimpleType(type.value);
		instantiateClass(object, context);
		Identifier tmp;
		tmp.value=gOperatorFunctionId;
		tmp.source=context.source;
		LookupResultRef declaration=::findDeclaration(object, tmp, IsAny());
		if(!(declaration!=0))
		{
			throw SemanticError();
		};
		const SimpleType*memberEnclosing=findEnclosingType(&object, declaration->scope);
		if(!(memberEnclosing!=0))
		{
			throw SemanticError();
		};
		Arguments augmentedArguments;
		augmentedArguments.push_back(left);
		augmentedArguments.insert(augmentedArguments.end(), arguments.begin(), arguments.end());
		OverloadSet overloads;
		addOverloaded(overloads, declaration, memberEnclosing);
		if(!(!overloads.empty()))
		{
			throw SemanticError();
		};
		FunctionOverload overload=findBestMatch(overloads, 0, augmentedArguments, setEnclosingTypeSafe(context, memberEnclosing));
		if(!(overload.declaration!=0))
		{
			throw SemanticError();
		};
		return overload.type;
	}
	if(type.isPointer())
	{
		type.pop_front();
		if(!(type.isFunction()))
		{
			throw SemanticError();
		};
		return popType(type);
	}
	if(!(type.isFunction()))
	{
		throw SemanticError();
	};
	bool isClassMemberAccess=isClassMemberAccessExpression(expression);
	bool isNamed=isClassMemberAccess||isIdExpression(expression);
	if(!isNamed)
	{
		if(!(type.isFunction()))
		{
			throw SemanticError();
		};
		return popType(type);
	}
	const IdExpression&idExpression=getIdExpression(isClassMemberAccess?getClassMemberAccessExpression(expression).right: expression);
	DeclarationInstanceRef declaration=idExpression.declaration;
	const TemplateArgumentsInstance&templateArguments=idExpression.templateArguments;
	if(!(declaration.p!=0))
	{
		throw SemanticError();
	};
	const SimpleType*memberClass=isClassMemberAccess?getObjectExpression(getClassMemberAccessExpression(expression).left).classType: 0;
	if(declaration.p==&gDestructorInstance)
	{
		return gUniqueTypeNull;
	}
	if(declaration.p==&gCopyAssignmentOperatorInstance)
	{
		if(!(memberClass!=0||context.enclosingType!=0))
		{
			throw SemanticError();
		};
		if(!(memberClass==0||memberClass!=&gDependentSimpleType))
		{
			throw SemanticError();
		};
		return popType(type);
	}
	if(!(declaration!=&gDependentObject))
	{
		throw SemanticError();
	};
	const SimpleType*memberEnclosing=getIdExpressionClass(idExpression.enclosing, idExpression.declaration, memberClass!=0?memberClass: context.enclosingType);
	ExpressionNodeGeneric<ObjectExpression>transientExpression=ObjectExpression(0);
	Arguments augmentedArguments;
	if(isMember(*declaration))
	{
		if(!(memberClass!=0||context.enclosingType!=0||isStatic(*declaration)))
		{
			throw SemanticError();
		};
		if(!(memberClass==0||memberClass!=&gDependentSimpleType))
		{
			throw SemanticError();
		};
		const SimpleType&classType=memberClass!=0?*memberClass: context.enclosingType!=0?*context.enclosingType: *memberEnclosing;
		transientExpression=ObjectExpression(&classType);
		augmentedArguments.push_back(Argument(ExpressionWrapper(&transientExpression, false), makeUniqueSimpleType(classType)));
	}
	augmentedArguments.insert(augmentedArguments.end(), arguments.begin(), arguments.end());
	OverloadSet overloads;
	addOverloaded(overloads, declaration, memberEnclosing);
	if(!isMember(*declaration))
	{
		argumentDependentLookup(overloads, declaration->getName(), augmentedArguments);
	}
	if(!(!overloads.empty()))
	{
		throw SemanticError();
	};
	FunctionOverload overload=findBestMatch(overloads, templateArguments.empty()?0: &templateArguments, augmentedArguments, context);
	if(!(overload.declaration!=0))
	{
		throw SemanticError();
	};
	if(!(!::isDependent(overload.type)))
	{
		throw SemanticError();
	};
	return overload.type;
}
inline bool isIntegralConstant(UniqueTypeWrapper type)
{
	return type.isSimple()&&type.value.getQualifiers().isConst&&(isIntegral(type)||isEnumeration(type));
}
struct WalkerContext: public ParserAllocatorWrapper<int>
{
	ParserContext&parserContext;
	Scope global;
	Declaration globalDecl;
	TypeRef globalType;
	std::size_t declarationCount;
	UniqueTypeWrapper typeInfoType;
	WalkerContext(ParserContext&parserContext, const ParserAllocatorWrapper<int>&allocator): ParserAllocatorWrapper<int>(allocator), parserContext(parserContext), global(allocator, gGlobalId, SCOPETYPE_NAMESPACE), globalDecl(allocator, 0, gGlobalId, TypeId(0, ParserAllocatorWrapper<int>(NullParserAllocator())), &global), globalType(Type(&globalDecl, allocator), allocator), declarationCount(0)
	{
	}
};
typedef std::list<DeferredParse<struct WalkerState> >DeferredSymbolsList;
struct DeferredSymbols
{
	DeferredSymbolsList first;
	DeferredSymbolsList second;
	void splice(DeferredSymbols&other)
	{
		first.splice(first.end(), other.first);
		second.splice(second.end(), other.second);
	}
	bool empty()const
	{
		return first.empty()&&second.empty();
	}
};
typedef bool(*IdentifierFunc)(const Declaration&declaration);
const char*getIdentifierType(IdentifierFunc func);
struct WalkerState: public ContextBase
{
	typedef WalkerState State;
	WalkerContext&context;
	ScopePtr enclosing;
	const SimpleType*enclosingType;
	Dependent enclosingDependent;
	TypePtr qualifying_p;
	DeclarationPtr qualifyingScope;
	const SimpleType*qualifyingClass;
	const SimpleType*memberClass;
	UniqueTypeWrapper memberType;
	ExpressionWrapper objectExpression;
	SafePtr<const TemplateParameters>templateParams;
	ScopePtr templateParamScope;
	DeferredSymbols*enclosingDeferred;
	std::size_t templateDepth;
	bool isExplicitInstantiation;
	WalkerState(WalkerContext&context): context(context), enclosing(0), enclosingType(0), qualifying_p(0), qualifyingScope(0), qualifyingClass(0), memberClass(0), templateParams(0), templateParamScope(0), enclosingDeferred(0), templateDepth(0), isExplicitInstantiation(false)
	{
	}
	const WalkerState&getState()const
	{
		return *this;
	}
	Location getLocation()const
	{
		return Location(context.parserContext.get_source(), context.declarationCount);
	}
	InstantiationContext getInstantiationContext()const
	{
		return InstantiationContext(getLocation(), enclosingType, enclosing);
	}
	UniqueTypeWrapper getTypeInfoType()
	{
		if(context.typeInfoType==gUniqueTypeNull)
		{
			Identifier stdId=makeIdentifier(context.parserContext.makeIdentifier("std"));
			LookupResultRef declaration=::findDeclaration(context.global, stdId, IsNestedName());
			if(!(declaration!=0))
			{
				throw SemanticError();
			};
			if(!(declaration->enclosed!=0))
			{
				throw SemanticError();
			};
			if(!(declaration->enclosed->type==SCOPETYPE_NAMESPACE))
			{
				throw SemanticError();
			};
			Identifier typeInfoId=makeIdentifier(context.parserContext.makeIdentifier("type_info"));
			declaration=::findDeclaration(*declaration->enclosed, typeInfoId);
			if(!(declaration!=0))
			{
				throw SemanticError();
			};
			if(!(isClass(*declaration)))
			{
				throw SemanticError();
			};
			Type type(declaration, context);
			context.typeInfoType=makeUniqueType(type, InstantiationContext(Location(), 0, 0), false);
			context.typeInfoType.value.setQualifiers(CvQualifiers(true, false));
		}
		return context.typeInfoType;
	}
	bool objectExpressionIsDependent()const
	{
		return objectExpression.p!=0&&objectExpression.isTypeDependent&&memberClass!=0;
	}
	bool allowNameLookup()const
	{
		if(isDependent(qualifying_p))
		{
			return false;
		}
		if(objectExpressionIsDependent())
		{
			return false;
		}
		return true;
	}
	LookupResult lookupQualified(const Identifier&id, bool isDeclarator, LookupFilter filter=IsAny())
	{
		return isDeclarator?findDeclaratorDeclaration(id, filter): lookupQualified(id, filter);
	}
	LookupResult findDeclaratorDeclaration(const Identifier&id, LookupFilter filter=IsAny())
	{
		if(!(getQualifyingScope()!=0))
		{
			throw SemanticError();
		};
		LookupResult result;
		if(result.append(::findDeclaration(*getQualifyingScope(), id, filter)))
		{
			return result;
		}
		result.filtered=&gUndeclaredInstance;
		return result;
	}
	LookupResult lookupQualified(const Identifier&id, LookupFilter filter=IsAny())
	{
		if(!(getQualifyingScope()!=0))
		{
			throw SemanticError();
		};
		LookupResult result;
		if(qualifyingClass!=0)
		{
			instantiateClass(*qualifyingClass, getInstantiationContext());
			if(result.append(::findDeclaration(*qualifyingClass, id, filter)))
			{
				return result;
			}
		}
		else if(result.append(::findNamespaceDeclaration(*getQualifyingScope(), id, filter)))
		{
			return result;
		}
		result.filtered=&gUndeclaredInstance;
		return result;
	}
	LookupResult findDeclaration(const Identifier&id, LookupFilter filter=IsAny(), bool isUnqualifiedId=false)
	{
		ProfileScope profile(gProfileLookup);
		LookupResult result;
		if(getQualifyingScope()!=0)
		{
			return lookupQualified(id, filter);
		}
		else
		{
			bool isQualified=objectExpression.p!=0&&memberClass!=0;
			if(!(!(isUnqualifiedId&&objectExpression.isTypeDependent)))
			{
				throw AllocatorError();
			};
			if(isQualified&&!objectExpression.isTypeDependent)
			{
				if(!(memberClass!=&gDependentSimpleType))
				{
					throw AllocatorError();
				};
				if(result.append(::findDeclaration(*memberClass, id, filter)))
				{
					return result;
				}
			}
			if(!isQualified||!isUnqualifiedId)
			{
				if(templateParamScope!=0)
				{
					if(result.append(::findDeclaration(*templateParamScope, id, filter)))
					{
						return result;
					}
				}
				if(result.append(::findClassOrNamespaceMemberDeclaration(*enclosing, id, filter)))
				{
					return result;
				}
			}
		}
		result.filtered=&gUndeclaredInstance;
		return result;
	}
	const DeclarationInstance&pointOfDeclaration(const ParserAllocatorWrapper<int>&allocator, Scope*parent, Identifier&name, const TypeId&type, Scope*enclosed, DeclSpecifiers specifiers=DeclSpecifiers(), bool isTemplate=false, const TemplateParameters&params=TEMPLATEPARAMETERS_NULL, bool isSpecialization=false, const TemplateArguments&arguments=TEMPLATEARGUMENTS_NULL, size_t templateParameter=INDEX_INVALID, const Dependent&valueDependent=Dependent())
	{
		if(!(parent!=0))
		{
			throw SemanticError();
		};
		if(!(templateParameter==INDEX_INVALID||::isTemplate(*parent)))
		{
			throw SemanticError();
		};
		if(!(isTemplate||params.empty()))
		{
			throw SemanticError();
		};
		if(!(isClassKey(*type.declaration)||!hasTemplateParamDefaults(params)))
		{
			throw SemanticError();
		};
		if(!(!isSpecialization||isTemplate))
		{
			throw SemanticError();
		};
		if(!(!isTemplate||isSpecialization||!params.empty()))
		{
			throw SemanticError();
		};
		context.parserContext.allocator.deferredBacktrack();
		static size_t uniqueId=0;
		if(!(!name.value.empty()))
		{
			throw SemanticError();
		};
		Declaration declaration(allocator, parent, name, type, enclosed, specifiers, isTemplate, params, isSpecialization, arguments, templateParameter, valueDependent);
		if(!(!isTemplate||(isClass(declaration)||isFunction(declaration)||declaration.templateParameter!=INDEX_INVALID)))
		{
			throw SemanticError();
		};
		declaration.uniqueId=++uniqueId;
		DeclarationInstance instance;
		const DeclarationInstance*existing=0;
		if(!isAnonymous(declaration))
		{
			LookupFilter filter=IsAny();
			if(type.declaration==&gCtor)
			{
				filter=IsConstructor();
			}
			existing=::findDeclaration(parent->declarations, name, filter);
		}
		if(existing!=0)
		{
			instance=*existing;
			try
			{
				const Declaration&primary=getPrimaryDeclaration(*instance, declaration);
				if(&primary==instance)
				{
					return *existing;
				}
			}
			catch(DeclarationError&e)
			{
				printPosition(name.source);
				std::cout<<"'"<<name.value.c_str()<<"': "<<e.description<<std::endl;
				printPosition(instance->getName().source);
				throw SemanticError();
			}
			if(isFunction(declaration)&&instance->isTemplateName)
			{
				declaration.isTemplateName=true;
			}
			declaration.overloaded=findOverloaded(instance);
			instance.p=0;
			instance.overloaded=existing;
			instance.redeclared=findRedeclared(declaration, existing);
			if(instance.redeclared!=0)
			{
				instance.p=*instance.redeclared;
				if(isClass(declaration)&&declaration.isTemplate)
				{
					TemplateParameters tmp(context);
					tmp.swap(instance->templateParams);
					instance->templateParams=declaration.templateParams;
					if(declaration.isSpecialization)
					{
						if(!(!hasTemplateParamDefaults(declaration.templateParams)))
						{
							throw SemanticError();
						};
					}
					else
					{
						if(!(!declaration.templateParams.empty()))
						{
							throw SemanticError();
						};
						mergeTemplateParamDefaults(*instance, tmp);
					}
				}
				if(isClass(declaration)&&isIncomplete(*instance))
				{
					instance->enclosed=declaration.enclosed;
					instance->setName(declaration.getName());
				}
			}
		}
		if(instance.p==0)
		{
			instance.p=allocatorNew(context, Declaration());
			instance->swap(declaration);
		}
		instance.name=&name;
		instance.visibility=context.declarationCount++;
		const DeclarationInstance&result=parent->declarations.insert(instance);
		parent->declarationList.push_back(instance);
		return result;
	}
	ParserAllocatorWrapper<int>getAllocator()
	{
		return context.parserContext.allocator;
	}
	void pushScope(Scope*scope)
	{
		if(!(findScope(enclosing, scope)==0))
		{
			throw SemanticError();
		};
		scope->parent=enclosing;
		enclosing=scope;
	}
	void addBase(Declaration*declaration, const Type&base)
	{
		declaration->enclosed->bases.push_front(base);
	}
	Declaration*getDeclaratorQualifying()
	{
		if(qualifying_p==TypePtr(0))
		{
			return 0;
		}
		Declaration*declaration=qualifying_p->declaration;
		if(isNamespace(*declaration))
		{
			return declaration;
		}
		if(!(isClass(*declaration)))
		{
			throw SemanticError();
		};
		if(declaration->isTemplate)
		{
			Declaration*specialization=findTemplateSpecialization(declaration, qualifying_p->templateArguments);
			if(specialization!=0)
			{
				return specialization;
			}
			return findPrimaryTemplate(declaration);
		}
		return declaration;
	}
	Scope*getQualifyingScope()
	{
		if(qualifyingScope==0)
		{
			return 0;
		}
		if(!(qualifyingScope->enclosed!=0))
		{
			throw SemanticError();
		};
		return qualifyingScope->enclosed;
	}
	void clearQualifying()
	{
		qualifying_p=0;
		qualifyingScope=0;
		qualifyingClass=0;
		memberType=gUniqueTypeNull;
		memberClass=0;
		objectExpression=ExpressionWrapper();
	}
	const TemplateParameters&getTemplateParams()const
	{
		if(templateParams==0)
		{
			return TEMPLATEPARAMETERS_NULL;
		}
		return *templateParams;
	}
	void clearTemplateParams()
	{
		templateParamScope=0;
		templateParams=0;
	}
	template<typename T>
	bool reportIdentifierMismatch(T*symbol, const Identifier&id, Declaration*declaration, const char*expected)
	{
		return false;
	}
	Scope*getEtsScope()const
	{
		Scope*scope=enclosing;
		for(;
		!enclosesEts(scope->type);
		scope=scope->parent)
		{
		}
		return scope;
	}
	Scope*getFriendScope()const
	{
		if(!(enclosing->type==SCOPETYPE_CLASS))
		{
			throw SemanticError();
		};
		Scope*scope=enclosing;
		for(;
		scope->type!=SCOPETYPE_NAMESPACE;
		scope=scope->parent)
		{
			if(scope->type==SCOPETYPE_LOCAL)
			{
				return enclosing;
			}
		}
		return scope;
	}
	Scope*getClassScope()const
	{
		return ::getEnclosingClass(enclosing);
	}
	void printScope()
	{
		if(templateParamScope!=0)
		{
			std::cout<<"template-params:"<<std::endl;
			::printScope(*templateParamScope);
		}
		if(getQualifyingScope()!=0)
		{
			std::cout<<"qualifying:"<<std::endl;
			::printScope(*getQualifyingScope());
		}
		else
		{
			std::cout<<"enclosing:"<<std::endl;
			::printScope(*enclosing);
		}
	}
	bool isDependent(Declaration*dependent)const
	{
		return ::isDependentImpl(dependent, enclosing, templateParamScope);
	}
	bool isDependent(const Type&type)const
	{
		return isDependent(type.dependent);
	}
	bool isDependent(const Types&bases)const
	{
		DeclarationPtr dependent(0);
		setDependent(dependent, bases);
		return isDependent(dependent);
	}
	bool isDependent(const TypePtr&qualifying)const
	{
		DeclarationPtr dependent(0);
		setDependent(dependent, qualifying.get());
		return isDependent(dependent);
	}
	bool isDependent(const TemplateArguments&arguments)const
	{
		DeclarationPtr dependent(0);
		setDependent(dependent, arguments);
		return isDependent(dependent);
	}
	bool isDependent(const Dependent&dependent)const
	{
		return isDependent(static_cast<Declaration*>(dependent));
	}
	void setDependent(DeclarationPtr&dependent, Declaration*candidate)const
	{
		if(!(dependent==DeclarationPtr(0)||isDependent(dependent)))
		{
			throw SemanticError();
		};
		if(!isDependent(candidate))
		{
			return ;
		}
		if(!(candidate->scope->type!=SCOPETYPE_NAMESPACE))
		{
			throw SemanticError();
		};
		if(dependent!=0&&findScope(candidate->scope, dependent->scope))
		{
			return ;
		}
		dependent=candidate;
	}
	void setDependentEnclosingTemplate(DeclarationPtr&dependent, Declaration*enclosingTemplate)const
	{
		if(enclosingTemplate!=0)
		{
			if(!(enclosingTemplate->isTemplate))
			{
				throw SemanticError();
			};
			if(!(enclosingTemplate->isSpecialization||!enclosingTemplate->templateParams.empty()))
			{
				throw SemanticError();
			};
			if(!enclosingTemplate->templateParams.empty())
			{
				setDependent(dependent, enclosingTemplate->templateParams.back().declaration);
			}
		}
	}
	void setDependent(DeclarationPtr&dependent, Declaration&declaration)const
	{
		if(declaration.templateParameter!=INDEX_INVALID)
		{
			setDependent(dependent, &declaration);
		}
		else if(declaration.specifiers.isTypedef)
		{
			setDependent(dependent, declaration.type.dependent);
		}
		else if(isClass(declaration)&&isComplete(declaration))
		{
			setDependent(dependent, declaration.enclosed->bases);
		}
		setDependentEnclosingTemplate(dependent, findEnclosingClassTemplate(&declaration));
		setDependent(dependent, declaration.valueDependent);
	}
	void setDependent(DeclarationPtr&dependent, const Type*qualifying)const
	{
		if(qualifying==0)
		{
			return ;
		}
		setDependent(dependent, qualifying->dependent);
		setDependent(dependent, qualifying->qualifying.get());
	}
	void setDependent(DeclarationPtr&dependent, const Qualifying&qualifying)const
	{
		setDependent(dependent, qualifying.get());
	}
	void setDependent(DeclarationPtr&dependent, const Types&bases)const
	{
		for(Types::const_iterator i=bases.begin();
		i!=bases.end();
		++i)
		{
			setDependent(dependent, (*i).dependent);
		}
	}
	void setDependent(DeclarationPtr&dependent, const TemplateArguments&arguments)const
	{
		for(TemplateArguments::const_iterator i=arguments.begin();
		i!=arguments.end();
		++i)
		{
			setDependent(dependent, (*i).type.dependent);
			setDependent(dependent, (*i).valueDependent);
		}
	}
	void setDependent(DeclarationPtr&dependent, const Parameters&parameters)const
	{
		for(Parameters::const_iterator i=parameters.begin();
		i!=parameters.end();
		++i)
		{
			setDependent(dependent, (*i).declaration->type.dependent);
		}
	}
	void setDependent(Type&type, Declaration*declaration)const
	{
		setDependent(type.dependent, declaration);
	}
	void setDependent(Type&type)const
	{
		setDependent(type.dependent, *type.declaration);
	}
	void addDependentName(Dependent&dependent, Declaration*declaration)
	{
		Declaration*old=dependent.p;
		setDependent(dependent, *declaration);
		if(!(old==0||dependent.p!=0))
		{
			throw SemanticError();
		};
	}
	void addDependentType(Dependent&dependent, Declaration*declaration)
	{
		Declaration*old=dependent.p;
		setDependent(dependent, declaration->type.dependent);
		if(!(old==0||dependent.p!=0))
		{
			throw SemanticError();
		};
	}
	void addDependent(Dependent&dependent, const Type&type)
	{
		Declaration*old=dependent.p;
		setDependent(dependent, type.dependent);
		if(!(old==0||dependent.p!=0))
		{
			throw SemanticError();
		};
	}
	void addDependent(Dependent&dependent, Scope*scope)
	{
		Declaration*old=dependent.p;
		setDependent(dependent, scope->bases);
		if(!(old==0||dependent.p!=0))
		{
			throw SemanticError();
		};
	}
	void addDependent(Dependent&dependent, const Dependent&other)
	{
		Declaration*old=dependent.p;
		setDependent(dependent, other);
		if(!(old==0||dependent.p!=0))
		{
			throw SemanticError();
		};
	}
};
inline const char*getIdentifierType(IdentifierFunc func)
{
	if(func==isTypeName)
	{
		return "type-name";
	}
	if(func==isNamespaceName)
	{
		return "namespace-name";
	}
	if(func==isTemplateName)
	{
		return "template-name";
	}
	if(func==isNestedName)
	{
		return "nested-name";
	}
	return "<unknown>";
}
struct WalkerBase: public WalkerState
{
	typedef WalkerBase Base;
	WalkerBase(WalkerContext&context): WalkerState(context)
	{
	}
	WalkerBase(const WalkerState&state): WalkerState(state)
	{
	}
	Scope*newScope(const Identifier&name, ScopeType type=SCOPETYPE_UNKNOWN)
	{
		return allocatorNew(context, Scope(context, name, type));
	}
	template<typename T>
	ExpressionWrapper makeExpression(const T&value, bool isConstant=false, bool isTypeDependent=false, bool isValueDependent=false)
	{
		ExpressionNode*node=isConstant?makeUniqueExpression(value): allocatorNew(context, ExpressionNodeGeneric<T>(value));
		return ExpressionWrapper(node, isConstant, isTypeDependent, isValueDependent);
	}
	void addBacktrackCallback(const BacktrackCallback&callback)
	{
		context.parserContext.allocator.addBacktrackCallback(context.parserContext.allocator.position, callback);
	}
	void disableBacktrack()
	{
		addBacktrackCallback(makeBacktrackErrorCallback());
	}
	void trackDeclaration(const DeclarationInstance&declaration)
	{
		addBacktrackCallback(makeUndeclareCallback(&declaration));
	}
	Declaration*declareClass(Scope*parent, Identifier*id, bool isSpecialization, TemplateArguments&arguments)
	{
		Scope*enclosed=newScope(makeIdentifier("$class"), SCOPETYPE_CLASS);
		DeclarationInstanceRef declaration=pointOfDeclaration(context, parent, id==0?parent->getUniqueName(): *id, TypeId(&gClass, ParserAllocatorWrapper<int>(NullParserAllocator())), enclosed, DeclSpecifiers(), templateParams!=0, getTemplateParams(), isSpecialization, arguments);
		trackDeclaration(declaration);
		if(id!=0)
		{
			setDecoration(id, declaration);
		}
		enclosed->name=declaration->getName();
		return declaration;
	}
	Declaration*declareObject(Scope*parent, Identifier*id, const TypeId&type, Scope*enclosed, DeclSpecifiers specifiers, size_t templateParameter, const Dependent&valueDependent)
	{
		if(specifiers.isFriend&&parent==enclosing)
		{
			parent=getFriendScope();
		}
		bool isTemplate=templateParams!=0;
		bool isExplicitSpecialization=isTemplate&&templateParams->empty();
		DeclarationInstanceRef declaration=pointOfDeclaration(context, parent, *id, type, enclosed, specifiers, isTemplate, getTemplateParams(), isExplicitSpecialization, TEMPLATEARGUMENTS_NULL, templateParameter, valueDependent);
		trackDeclaration(declaration);
		if(id!=&gAnonymousId)
		{
			setDecoration(id, declaration);
		}
		if(declaration->templateParamScope==0)
		{
			declaration->templateParamScope=templateParamScope;
		}
		if(!(type.unique!=0))
		{
			throw SemanticError();
		};
		UniqueTypeWrapper uniqueType=UniqueTypeWrapper(type.unique);
		if(parent->type==SCOPETYPE_CLASS&&!uniqueType.isFunction()&&!isStatic(*declaration)&&type.declaration!=&gCtor)
		{
			SimpleType*enclosingClass=const_cast<SimpleType*>(getEnclosingType(enclosingType));
			std::size_t size=0;
			if(!type.isDependent)
			{
				if(!(parent->type==SCOPETYPE_CLASS&&isStatic(*declaration))&&!specifiers.isTypedef&&(uniqueType.isSimple()||uniqueType.isArray()))
				{
					size=requireCompleteObjectType(uniqueType, getInstantiationContext());
				}
			}
			else if(enclosingClass!=0&&templateParams==0)
			{
				enclosingClass->children.push_back(uniqueType);
				enclosingClass->childLocations.push_back(getLocation());
			}
			if(enclosingClass!=0)
			{
				enclosingClass->size+=size;
			}
		}
		return declaration;
	}
	bool declareEts(Type&type, Identifier*forward)
	{
		if(isClassKey(*type.declaration))
		{
			if(!(forward!=0))
			{
				throw SemanticError();
			};
			DeclarationInstanceRef declaration=pointOfDeclaration(context, getEtsScope(), *forward, TypeId(&gClass, ParserAllocatorWrapper<int>(NullParserAllocator())), 0);
			trackDeclaration(declaration);
			setDecoration(forward, declaration);
			type=declaration;
			return true;
		}
		return false;
	}
	bool consumeTemplateParams(const Qualifying&qualifying)
	{
		if(qualifying.empty())
		{
			return false;
		}
		const Type&type=qualifying.back();
		if(!type.declaration->isTemplate)
		{
			return consumeTemplateParams(type.qualifying);
		}
		Declaration*primary=findPrimaryTemplate(type.declaration);
		if(!(primary->templateParamScope->templateDepth<=templateDepth))
		{
			throw SemanticError();
		};
		return primary->templateParamScope->templateDepth==templateDepth;
	}
	LookupResultRef lookupTemplate(const Identifier&id, LookupFilter filter)
	{
		if(!isDependent(qualifying_p))
		{
			return LookupResultRef(findDeclaration(id, filter));
		}
		return gDependentTemplateInstance;
	}
	void addDependentOverloads(Dependent&dependent, Declaration*declaration)
	{
		for(Declaration*p=declaration;
		p!=0;
		p=p->overloaded)
		{
			setDependent(dependent, p->type.dependent);
		}
	}
	static UniqueTypeWrapper binaryOperatorIntegralType(UniqueTypeWrapper left, UniqueTypeWrapper right)
	{
		if(!(!isFloating(left)))
		{
			throw SemanticError();
		};
		if(!(!isFloating(right)))
		{
			throw SemanticError();
		};
		return usualArithmeticConversions(left, right);
	}
	template<typename T>
	void makeUniqueTypeImpl(T&type)
	{
		if(!(type.unique==0))
		{
			throw AllocatorError();
		};
		type.isDependent=isDependent(type)||objectExpressionIsDependent();
		type.unique=makeUniqueType(type, getInstantiationContext(), type.isDependent).value;
	}
	void makeUniqueTypeSafe(Type&type)
	{
		makeUniqueTypeImpl(type);
	}
	void makeUniqueTypeSafe(TypeId&type)
	{
		makeUniqueTypeImpl(type);
	}
	UniqueTypeWrapper getUniqueTypeSafe(const TypeId&type)
	{
		if(!(type.unique!=0))
		{
			throw SemanticError();
		};
		return type.isDependent?gUniqueTypeNull: UniqueTypeWrapper(type.unique);
	}
};
struct WalkerQualified: public WalkerBase
{
	Qualifying qualifying;
	WalkerQualified(const WalkerState&state): WalkerBase(state), qualifying(context)
	{
	}
	void setQualifyingGlobal()
	{
		if(!(qualifying.empty()))
		{
			throw SemanticError();
		};
		qualifying_p=context.globalType.get_ref();
		qualifyingScope=qualifying_p->declaration;
		qualifyingClass=0;
	}
	void swapQualifying(const Type&type, bool isDeclarator=false)
	{
		Qualifying tmp(type, context);
		swapQualifying(tmp, isDeclarator);
	}
	void swapQualifying(Qualifying&other, bool isDeclarator=false)
	{
		qualifying.swap(other);
		qualifying_p=qualifying.get_ref();
		if(isDeclarator)
		{
			qualifyingScope=getDeclaratorQualifying();
		}
		else if(qualifying_p!=TypePtr(0))
		{
			Declaration*declaration=qualifying_p->declaration;
			if(isNamespace(*declaration))
			{
				qualifyingScope=declaration;
			}
			else if(isDependent(qualifying_p))
			{
				qualifyingScope=0;
			}
			else
			{
				qualifyingClass=&getSimpleType(getUniqueType(*qualifying_p, getInstantiationContext(), isDeclarator).value);
				qualifyingScope=qualifyingClass->declaration;
			}
		}
	}
};
struct Args0
{
};
template<typename A1>
struct Args1
{
	A1 a1;
	Args1(A1 a1): a1(a1)
	{
	}
};
template<typename A1, typename A2>
struct Args2
{
	A1 a1;
	A2 a2;
	Args2(A1 a1, A2 a2): a1(a1), a2(a2)
	{
	}
};
struct InvokeChecked
{
	template<typename WalkerType, typename T, typename Result>
	static bool invokeAction(WalkerType&walker, T*symbol, Result&result)
	{
		return walker.action(symbol);
	}
};
struct InvokeUnchecked
{
	template<typename WalkerType, typename T, typename Result>
	static bool invokeAction(WalkerType&walker, T*symbol, Result&result)
	{
		walker.action(symbol);
		return true;
	}
};
struct InvokeCheckedResult
{
	template<typename WalkerType, typename T, typename Result>
	static bool invokeAction(WalkerType&walker, T*symbol, Result&result)
	{
		return walker.action(symbol, result);
	}
};
struct InvokeUncheckedResult
{
	template<typename WalkerType, typename T, typename Result>
	static bool invokeAction(WalkerType&walker, T*symbol, Result&result)
	{
		walker.action(symbol, result);
		return true;
	}
};
template<typename Inner, typename Args=Args0>
struct SemaPush: Args
{
	typedef Args ArgsType;
	SemaPush(const Args&args): Args(args)
	{
	}
};
template<typename Inner>
struct SemaPush<Inner, Args0>
{
	typedef SemaPush ArgsType;
};
template<typename WalkerType, typename Inner>
Inner makeInnerWalker(WalkerType&walker, const SemaPush<Inner, Args0>&args)
{
	return Inner(walker.getState());
}
template<typename WalkerType, typename Inner, typename A1>
Inner makeInnerWalker(WalkerType&walker, const SemaPush<Inner, Args1<A1> >&args)
{
	return Inner(walker.getState(), args.a1);
}
template<typename WalkerType, typename Inner, typename A1, typename A2>
Inner makeInnerWalker(WalkerType&walker, const SemaPush<Inner, Args2<A1, A2> >&args)
{
	return Inner(walker.getState(), args.a1, args.a2);
}
struct SemaIdentity
{
	typedef SemaIdentity ArgsType;
};
template<typename WalkerType>
WalkerType&makeInnerWalker(WalkerType&walker, const SemaIdentity&)
{
	return walker;
}
struct Nothing
{
};
struct AnnotateNull
{
	typedef Nothing Data;
	static Data makeData(const Token&token)
	{
		return Nothing();
	}
	template<typename T>
	static void annotate(T*symbol, const Nothing&)
	{
	}
};
struct AnnotateSrc
{
	typedef Source Data;
	static Data makeData(const Token&token)
	{
		return token.source;
	}
	template<typename T>
	static void annotate(T*symbol, const Source&source)
	{
		symbol->source=source;
	}
};
struct AnnotateId
{
	typedef Source Data;
	static Data makeData(const Token&token)
	{
		return token.source;
	}
	template<typename T>
	static void annotate(T*symbol, const Source&source)
	{
		symbol->source=source;
	}
};
struct SourceEvents: Source, IncludeEvents
{
	SourceEvents(const Source&source, const IncludeEvents&events): Source(source), IncludeEvents(events)
	{
	}
};
struct AnnotateTop
{
	typedef SourceEvents Data;
	static Data makeData(const Token&token)
	{
		return SourceEvents(token.source, token.events);
	}
	static void annotate(cpp::declaration*symbol, const Data&data)
	{
		symbol->source=data;
		symbol->events=data;
	}
};
template<typename Inner, typename Annotate=AnnotateNull, typename Invoke=InvokeUncheckedResult, typename Cache=DisableCache, typename Defer=DeferDefault>
struct SemaPolicyGeneric: Inner, Annotate, Invoke, Cache, Defer
{
	typedef typename Inner::ArgsType ArgsType;
	SemaPolicyGeneric(const ArgsType&args=ArgsType()): Inner(args)
	{
	}
	const Inner&getInnerPolicy()const
	{
		return *this;
	}
	typedef Annotate AnnotateType;
	const Annotate&getAnnotatePolicy()const
	{
		return *this;
	}
	const Cache&getCachePolicy()const
	{
		return *this;
	}
	const Defer&getDeferPolicy()const
	{
		return *this;
	}
	const Invoke&getActionPolicy()const
	{
		return *this;
	}
};
typedef SemaPolicyGeneric<SemaIdentity, AnnotateNull, InvokeUnchecked>SemaPolicyIdentity;
typedef SemaPolicyGeneric<SemaIdentity, AnnotateSrc, InvokeUnchecked>SemaPolicySrc;
typedef SemaPolicyGeneric<SemaIdentity, AnnotateNull, InvokeChecked>SemaPolicyIdentityChecked;
typedef SemaPolicyGeneric<SemaIdentity, AnnotateNull, InvokeUnchecked, EnableCache>SemaPolicyIdentityCached;
typedef SemaPolicyGeneric<SemaIdentity, AnnotateNull, InvokeChecked, EnableCache>SemaPolicyIdentityCachedChecked;
template<typename WalkerType>
struct SemaPolicyPush: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateNull>
{
};
template<typename WalkerType>
struct SemaPolicyPushSrc: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateSrc>
{
};
template<typename WalkerType>
struct SemaPolicyPushId: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateId>
{
};
template<typename WalkerType>
struct SemaPolicyPushTop: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateTop>
{
};
template<typename WalkerType>
struct SemaPolicyPushSrcChecked: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateSrc, InvokeCheckedResult>
{
};
template<typename WalkerType>
struct SemaPolicyPushIdChecked: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateId, InvokeCheckedResult>
{
};
template<typename WalkerType>
struct SemaPolicyPushChecked: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateNull, InvokeCheckedResult>
{
};
template<typename WalkerType>
struct SemaPolicyPushCached: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateNull, InvokeUncheckedResult, CachedWalk>
{
};
template<typename WalkerType>
struct SemaPolicyPushCachedChecked: SemaPolicyGeneric<SemaPush<WalkerType>, AnnotateNull, InvokeCheckedResult, CachedWalk>
{
};
template<typename WalkerType>
struct SemaPolicyPushBool: SemaPolicyGeneric<SemaPush<WalkerType, Args1<bool> >, AnnotateNull, InvokeUncheckedResult, DisableCache>
{
	SemaPolicyPushBool(bool value): SemaPolicyGeneric(Args1<bool>(value))
	{
	}
};
template<typename WalkerType>
struct SemaPolicyPushCheckedBool: SemaPolicyGeneric<SemaPush<WalkerType, Args1<bool> >, AnnotateNull, InvokeCheckedResult, DisableCache>
{
	SemaPolicyPushCheckedBool(bool value): SemaPolicyGeneric(Args1<bool>(value))
	{
	}
};
template<typename WalkerType>
struct SemaPolicyPushCachedBool: SemaPolicyGeneric<SemaPush<WalkerType, Args1<bool> >, AnnotateNull, InvokeUncheckedResult, CachedWalk>
{
	SemaPolicyPushCachedBool(bool value): SemaPolicyGeneric(Args1<bool>(value))
	{
	}
};
template<typename WalkerType>
struct SemaPolicyPushCachedCheckedBool: SemaPolicyGeneric<SemaPush<WalkerType, Args1<bool> >, AnnotateNull, InvokeCheckedResult, CachedWalk>
{
	SemaPolicyPushCachedCheckedBool(bool value): SemaPolicyGeneric(Args1<bool>(value))
	{
	}
};
template<typename WalkerType>
struct SemaPolicyPushIndex: SemaPolicyGeneric<SemaPush<WalkerType, Args1<std::size_t> >, AnnotateNull, InvokeUncheckedResult, DisableCache>
{
	SemaPolicyPushIndex(std::size_t value): SemaPolicyGeneric(Args1<std::size_t>(value))
	{
	}
};
template<typename WalkerType, typename Defer>
struct SemaPolicyPushDeferred: SemaPolicyGeneric<SemaPush<WalkerType, Args0>, AnnotateNull, InvokeUncheckedResult, DisableCache, Defer>
{
};
bool isUnqualified(cpp::elaborated_type_specifier_default*symbol)
{
	return symbol!=0&&symbol->isGlobal.value.empty()&&symbol->context.p==0;
}
struct DeclSpecifierSeq
{
	Type type;
	IdentifierPtr forward;
	CvQualifiers qualifiers;
	DeclSpecifiers specifiers;
	bool isUnion;
	DeclSpecifierSeq(Declaration*declaration, const ParserAllocatorWrapper<int>&allocator): type(declaration, allocator), forward(0), isUnion(false)
	{
	}
};
struct DeclarationWalkerArgs
{
	bool isParameter;
	size_t templateParameter;
	DeclarationWalkerArgs(bool isParameter=false, size_t templateParameter=INDEX_INVALID): isParameter(isParameter), templateParameter(templateParameter)
	{
	}
};
template<typename WalkerType>
struct SemaPolicyParameterDeclaration: SemaPolicyGeneric<SemaPush<WalkerType, Args1<DeclarationWalkerArgs> > >
{
	SemaPolicyParameterDeclaration(DeclarationWalkerArgs value): SemaPolicyGeneric(value)
	{
	}
};
struct Walker
{
	struct NamespaceNameWalker;
	struct TemplateArgumentListWalker;
	struct OverloadableOperatorWalker;
	struct OperatorFunctionIdWalker;
	struct TemplateIdWalker;
	struct UnqualifiedIdWalker;
	struct QualifiedIdWalker;
	struct IdExpressionWalker;
	struct ExplicitTypeExpressionWalker;
	struct ArgumentListWalker;
	struct LiteralWalker;
	struct PrimaryExpressionWalker;
	struct TypeTraitsIntrinsicWalker;
	struct PostfixExpressionWalker;
	struct SizeofTypeExpressionWalker;
	struct ConditionalExpressionWalker;
	struct ExpressionWalker;
	struct TypeNameWalker;
	struct NestedNameSpecifierSuffixWalker;
	struct NestedNameSpecifierPrefixWalker;
	struct UnqualifiedDeclaratorIdWalker;
	struct ParameterDeclarationListWalker;
	struct ParameterDeclarationClauseWalker;
	struct ExceptionSpecificationWalker;
	struct DeclaratorFunctionWalker;
	struct DeclaratorArrayWalker;
	struct DeclaratorWalker;
	struct ClassHeadWalker;
	struct MemberDeclarationWalker;
	struct ClassSpecifierWalker;
	struct EnumeratorDefinitionWalker;
	struct EnumSpecifierWalker;
	struct DeclSpecifierSeqWalker;
	struct TryBlockWalker;
	struct LabeledStatementWalker;
	struct StatementWalker;
	struct ControlStatementWalker;
	struct CompoundStatementWalker;
	struct HandlerWalker;
	struct HandlerSeqWalker;
	struct MemInitializerWalker;
	struct MemberDeclaratorBitfieldWalker;
	struct TypeIdWalker;
	struct NewTypeWalker;
	struct InitializerWalker;
	struct SimpleDeclarationWalker;
	struct TypeParameterWalker;
	struct TemplateParameterListWalker;
	struct TemplateParameterClauseWalker;
	struct TemplateDeclarationWalker;
	struct ExplicitInstantiationWalker;
	struct DeclarationWalker;
	struct NamespaceWalker;
	struct PostfixExpressionMemberWalker;
	struct NestedNameSpecifierWalker;
	struct TypeSpecifierWalker;
	struct QualifiedDeclaratorIdWalker;
	struct DeclaratorIdWalker;
	struct PtrOperatorWalker;
	struct BaseSpecifierWalker;
	struct UsingDeclarationWalker;
	struct UsingDirectiveWalker;
	struct NamespaceAliasDefinitionWalker;
	struct ElaboratedTypeSpecifierWalker;
	struct TypenameSpecifierWalker;
	struct QualifiedTypeNameWalker;
	struct IsHiddenNamespaceName
	{
		DeclarationPtr hidingType;
		IsHiddenNamespaceName(): hidingType(0)
		{
		}
		bool operator()(const Declaration&declaration)
		{
			if(isNamespaceName(declaration))
			{
				return true;
			}
			if(hidingType==0&&isTypeName(declaration))
			{
				hidingType=const_cast<Declaration*>(&declaration);
			}
			return false;
		}
	};
	struct NamespaceNameWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		LookupResultRef declaration;
		IsHiddenNamespaceName filter;
		NamespaceNameWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyIdentityCachedChecked makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCachedChecked();
		}
		bool action(cpp::identifier*symbol)
		{
			declaration=findDeclaration(symbol->value, makeLookupFilter(filter));
			if(declaration==&gUndeclared)
			{
				return reportIdentifierMismatch(symbol, symbol->value, declaration, "namespace-name");
			}
			setDecoration(&symbol->value, declaration);
			return true;
		}
	};
	struct TemplateArgumentListWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		TemplateArgument argument;
		TemplateArguments arguments;
		TemplateArgumentListWalker(const WalkerState&state): WalkerBase(state), argument(context), arguments(context)
		{
			clearQualifying();
		}
		void commit()
		{
			arguments.push_front(argument);
		}
		SemaPolicyPush<TypeIdWalker>makePolicy(cpp::type_id*)
		{
			return SemaPolicyPush<TypeIdWalker>();
		}
		void action(cpp::type_id*symbol, TypeIdWalker&walker)
		{
			walker.commit();
			argument.type.swap(walker.type);
			argument.source=getLocation();
		}
		SemaPolicyPushChecked<ExpressionWalker>makePolicy(cpp::assignment_expression*)
		{
			return SemaPolicyPushChecked<ExpressionWalker>();
		}
		bool action(cpp::assignment_expression*symbol, ExpressionWalker&walker)
		{
			if(walker.expression.isTemplateArgumentAmbiguity)
			{
				return false;
			}
			addDependent(argument.valueDependent, walker.valueDependent);
			argument.type=&gNonType;
			argument.expression=walker.expression;
			argument.source=getLocation();
			return true;
		}
		SemaPolicyPush<TemplateArgumentListWalker>makePolicy(cpp::template_argument_list*)
		{
			return SemaPolicyPush<TemplateArgumentListWalker>();
		}
		void action(cpp::template_argument_list*symbol, TemplateArgumentListWalker&walker)
		{
			walker.commit();
			arguments.swap(walker.arguments);
		}
	};
	struct OverloadableOperatorWalker: public WalkerBase
	{
		Name name;
		OverloadableOperatorWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T symbol)
		{
			return SemaPolicyIdentity();
		}
		template<typename T>
		void action(T*symbol)
		{
			name=getOverloadableOperatorId(symbol);
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
	};
	struct OperatorFunctionIdWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Name name;
		OperatorFunctionIdWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<OverloadableOperatorWalker>makePolicy(cpp::overloadable_operator*)
		{
			return SemaPolicyPush<OverloadableOperatorWalker>();
		}
		void action(cpp::overloadable_operator*symbol, OverloadableOperatorWalker&walker)
		{
			name=walker.name;
		}
	};
	struct TemplateIdWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		IdentifierPtr id;
		TemplateArguments arguments;
		bool isTemplate;
		TemplateIdWalker(const WalkerState&state, bool isTemplate=false): WalkerBase(state), id(0), arguments(context), isTemplate(isTemplate)
		{
		}
		template<typename T>
		bool verifyTemplateName(T*symbol)
		{
			if(!isTemplate&&!isDependent(qualifying_p))
			{
				if(qualifyingClass==0&&getQualifyingScope()!=0&&getQualifyingScope()->type==SCOPETYPE_CLASS)
				{
					return true;
				}
				LookupResultRef declaration=findDeclaration(symbol->value, IsAny());
				if(declaration==&gUndeclared||!isTemplateName(*declaration))
				{
					return reportIdentifierMismatch(symbol, symbol->value, declaration, "template-name");
				}
			}
			return true;
		}
		SemaPolicyIdentityCachedChecked makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCachedChecked();
		}
		bool action(cpp::identifier*symbol)
		{
			id=&symbol->value;
			return verifyTemplateName(symbol);
		}
		SemaPolicyPushIdChecked<OperatorFunctionIdWalker>makePolicy(cpp::operator_function_id*)
		{
			return SemaPolicyPushIdChecked<OperatorFunctionIdWalker>();
		}
		bool action(cpp::operator_function_id*symbol, OperatorFunctionIdWalker&walker)
		{
			symbol->value.value=walker.name;
			id=&symbol->value;
			return verifyTemplateName(symbol);
		}
		SemaPolicyPushCached<TemplateArgumentListWalker>makePolicy(cpp::template_argument_clause*)
		{
			return SemaPolicyPushCached<TemplateArgumentListWalker>();
		}
		void action(cpp::template_argument_clause*symbol, TemplateArgumentListWalker&walker)
		{
			arguments.swap(walker.arguments);
		}
	};
	struct UnqualifiedIdWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		LookupResultRef declaration;
		IdentifierPtr id;
		TemplateArguments arguments;
		bool isIdentifier;
		bool isTemplate;
		UnqualifiedIdWalker(const WalkerState&state, bool isTemplate=false): WalkerBase(state), id(0), arguments(context), isIdentifier(false), isTemplate(isTemplate)
		{
		}
		SemaPolicyIdentityCached makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCached();
		}
		void action(cpp::identifier*symbol)
		{
			id=&symbol->value;
			isIdentifier=true;
			if(allowNameLookup())
			{
				declaration=findDeclaration(*id, IsAny(), true);
			}
		}
		SemaPolicyPushCachedCheckedBool<TemplateIdWalker>makePolicy(cpp::simple_template_id*)
		{
			return SemaPolicyPushCachedCheckedBool<TemplateIdWalker>(isTemplate);
		}
		bool action(cpp::simple_template_id*symbol, TemplateIdWalker&walker)
		{
			if(allowNameLookup())
			{
				LookupResultRef declaration=findDeclaration(*walker.id, IsAny(), true);
				if(declaration==&gUndeclared||!isTemplateName(*declaration))
				{
					return reportIdentifierMismatch(symbol, *walker.id, declaration, "template-name");
				}
				this->declaration=declaration;
			}
			id=walker.id;
			arguments.swap(walker.arguments);
			return true;
		}
		SemaPolicyPushCachedCheckedBool<TemplateIdWalker>makePolicy(cpp::template_id_operator_function*)
		{
			return SemaPolicyPushCachedCheckedBool<TemplateIdWalker>(isTemplate);
		}
		bool action(cpp::template_id_operator_function*symbol, TemplateIdWalker&walker)
		{
			if(allowNameLookup())
			{
				LookupResultRef declaration=findDeclaration(*walker.id, IsAny(), true);
				if(declaration==&gUndeclared||!isTemplateName(*declaration))
				{
					return reportIdentifierMismatch(symbol, *walker.id, declaration, "template-name");
				}
				this->declaration=declaration;
			}
			id=walker.id;
			arguments.swap(walker.arguments);
			return true;
		}
		SemaPolicyPushId<OperatorFunctionIdWalker>makePolicy(cpp::operator_function_id*)
		{
			return SemaPolicyPushId<OperatorFunctionIdWalker>();
		}
		void action(cpp::operator_function_id*symbol, OperatorFunctionIdWalker&walker)
		{
			symbol->value.value=walker.name;
			id=&symbol->value;
			if(allowNameLookup())
			{
				declaration=findDeclaration(*id, IsAny(), true);
				if(declaration==&gUndeclared&&id->value==gOperatorAssignId)
				{
					declaration=gCopyAssignmentOperatorInstance;
				}
			}
		}
		SemaPolicyPushId<TypeIdWalker>makePolicy(cpp::conversion_function_id*)
		{
			return SemaPolicyPushId<TypeIdWalker>();
		}
		void action(cpp::conversion_function_id*symbol, TypeIdWalker&walker)
		{
			walker.commit();
			symbol->value=gConversionFunctionId;
			id=&symbol->value;
			if(allowNameLookup())
			{
				declaration=findDeclaration(*id, IsAny(), true);
			}
		}
		SemaPolicyIdentityChecked makePolicy(cpp::destructor_id*)
		{
			return SemaPolicyIdentityChecked();
		}
		bool action(cpp::destructor_id*symbol)
		{
			id=&symbol->name->value;
			if(objectExpression.p==0)
			{
				return reportIdentifierMismatch(symbol, *id, declaration, "class member access expression");
			}
			declaration=gDestructorInstance;
			return true;
		}
	};
	struct QualifiedIdWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		LookupResultRef declaration;
		IdentifierPtr id;
		TemplateArguments arguments;
		bool isTemplate;
		QualifiedIdWalker(const WalkerState&state): WalkerQualified(state), id(0), arguments(context), isTemplate(false)
		{
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		void action(cpp::terminal<boost::wave::T_TEMPLATE>symbol)
		{
			isTemplate=true;
		}
		SemaPolicyPushBool<UnqualifiedIdWalker>makePolicy(cpp::unqualified_id*)
		{
			return SemaPolicyPushBool<UnqualifiedIdWalker>(isTemplate);
		}
		void action(cpp::unqualified_id*symbol, UnqualifiedIdWalker&walker)
		{
			declaration=walker.declaration;
			id=walker.id;
			arguments.swap(walker.arguments);
		}
		SemaPolicyPushBool<UnqualifiedIdWalker>makePolicy(cpp::qualified_id_suffix*)
		{
			return SemaPolicyPushBool<UnqualifiedIdWalker>(isTemplate);
		}
		void action(cpp::qualified_id_suffix*symbol, UnqualifiedIdWalker&walker)
		{
			declaration=walker.declaration;
			id=walker.id;
			arguments.swap(walker.arguments);
		}
	};
	struct IdExpressionWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		ExpressionWrapper expression;
		LookupResultRef declaration;
		IdentifierPtr id;
		TemplateArguments arguments;
		Dependent typeDependent;
		Dependent valueDependent;
		bool isIdentifier;
		bool isUndeclared;
		bool isTemplate;
		IdExpressionWalker(const WalkerState&state, bool isTemplate=false): WalkerQualified(state), id(0), arguments(context), isIdentifier(false), isUndeclared(false), isTemplate(isTemplate)
		{
		}
		SemaPolicyPush<QualifiedIdWalker>makePolicy(cpp::qualified_id_default*)
		{
			return SemaPolicyPush<QualifiedIdWalker>();
		}
		void action(cpp::qualified_id_default*symbol, QualifiedIdWalker&walker)
		{
			declaration=walker.declaration;
			id=walker.id;
			arguments.swap(walker.arguments);
			swapQualifying(walker.qualifying);
		}
		SemaPolicyPush<QualifiedIdWalker>makePolicy(cpp::qualified_id_global*)
		{
			return SemaPolicyPush<QualifiedIdWalker>();
		}
		void action(cpp::qualified_id_global*symbol, QualifiedIdWalker&walker)
		{
			declaration=walker.declaration;
			id=walker.id;
			arguments.swap(walker.arguments);
			swapQualifying(walker.qualifying);
		}
		SemaPolicyIdentity makePolicy(cpp::qualified_id*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::qualified_id*symbol)
		{
			setDependent(typeDependent, qualifying.get());
			setDependent(valueDependent, qualifying.get());
		}
		SemaPolicyPushBool<UnqualifiedIdWalker>makePolicy(cpp::unqualified_id*)
		{
			return SemaPolicyPushBool<UnqualifiedIdWalker>(isTemplate);
		}
		void action(cpp::unqualified_id*symbol, UnqualifiedIdWalker&walker)
		{
			declaration=walker.declaration;
			id=walker.id;
			arguments.swap(walker.arguments);
			isIdentifier=walker.isIdentifier;
		}
		bool commit()
		{
			UniqueTypeWrapper qualifyingType=makeUniqueQualifying(qualifying, getInstantiationContext(), isDependent(qualifying.get_ref()));
			TemplateArgumentsInstance templateArguments;
			makeUniqueTemplateArguments(arguments, templateArguments, getInstantiationContext(), isDependent(arguments));
			expression=ExpressionWrapper();
			if(isDependent(typeDependent)||objectExpressionIsDependent())
			{
				setDecoration(id, gDependentObjectInstance);
				expression=makeExpression(DependentIdExpression(id->value, qualifyingType, templateArguments), true, true, true);
			}
			else if(isIdentifier&&declaration==&gUndeclared)
			{
				isUndeclared=true;
				setDecoration(id, gDependentObjectInstance);
				expression=makeExpression(DependentIdExpression(id->value, gUniqueTypeNull, TemplateArgumentsInstance()));
			}
			else
			{
				if(!(declaration!=0))
				{
					throw SemanticError();
				};
				if(declaration==&gUndeclared||!isObject(*declaration))
				{
					return false;
				}
				addDependentType(typeDependent, declaration);
				setDependent(typeDependent, arguments);
				addDependentOverloads(typeDependent, declaration);
				addDependentType(valueDependent, declaration);
				addDependentName(valueDependent, declaration);
				setDecoration(id, declaration);
				if(!(!isDependent(qualifying.get_ref())))
				{
					throw SemanticError();
				};
				const SimpleType*qualifyingClass=qualifyingType==gUniqueTypeNull?0: &getSimpleType(qualifyingType.value);
				if(!(qualifyingClass==this->qualifyingClass))
				{
					throw SemanticError();
				};
				if(!(declaration->templateParameter==INDEX_INVALID||qualifying.empty()))
				{
					throw SemanticError();
				};
				expression=declaration->templateParameter==INDEX_INVALID?makeExpression(IdExpression(declaration, qualifyingClass, templateArguments), false, isDependent(typeDependent), isDependent(valueDependent)): makeExpression(NonTypeTemplateParameter(declaration), true, isDependent(typeDependent), isDependent(valueDependent));
				expression.isNonStaticMemberName=isMember(*declaration)&&!isStatic(*declaration);
				expression.isQualifiedNonStaticMemberName=expression.isNonStaticMemberName&&qualifyingType!=gUniqueTypeNull;
			}
			return true;
		}
	};
	struct ExplicitTypeExpressionWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		TypeId type;
		Dependent typeDependent;
		Dependent valueDependent;
		ExpressionWrapper expression;
		ExplicitTypeExpressionWalker(const WalkerState&state): WalkerBase(state), type(0, context)
		{
		}
		SemaPolicyPush<TypeSpecifierWalker>makePolicy(cpp::simple_type_specifier*)
		{
			return SemaPolicyPush<TypeSpecifierWalker>();
		}
		void action(cpp::simple_type_specifier*symbol, TypeSpecifierWalker&walker)
		{
			type.swap(walker.type);
			if(type.declaration==0)
			{
				type=getFundamentalType(walker.fundamental);
			}
			addDependent(typeDependent, type);
			makeUniqueTypeSafe(type);
		}
		SemaPolicyPush<TypenameSpecifierWalker>makePolicy(cpp::typename_specifier*)
		{
			return SemaPolicyPush<TypenameSpecifierWalker>();
		}
		void action(cpp::typename_specifier*symbol, TypenameSpecifierWalker&walker)
		{
			type.swap(walker.type);
			addDependent(typeDependent, type);
			makeUniqueTypeSafe(type);
		}
		SemaPolicyPush<TypeIdWalker>makePolicy(cpp::type_id*)
		{
			return SemaPolicyPush<TypeIdWalker>();
		}
		void action(cpp::type_id*symbol, TypeIdWalker&walker)
		{
			walker.commit();
			type.swap(walker.type);
			addDependent(typeDependent, type);
		}
		SemaPolicyPush<NewTypeWalker>makePolicy(cpp::new_type*)
		{
			return SemaPolicyPush<NewTypeWalker>();
		}
		void action(cpp::new_type*symbol, NewTypeWalker&walker)
		{
			type.swap(walker.type);
			addDependent(typeDependent, type);
			addDependent(typeDependent, walker.valueDependent);
			makeUniqueTypeSafe(type);
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::assignment_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::assignment_expression*symbol, ExpressionWalker&walker)
		{
			expression=walker.expression;
			addDependent(valueDependent, walker.valueDependent);
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::cast_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::cast_expression*symbol, ExpressionWalker&walker)
		{
			expression=walker.expression;
			addDependent(valueDependent, walker.valueDependent);
		}
	};
	struct ArgumentListWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Arguments arguments;
		Dependent typeDependent;
		Dependent valueDependent;
		ArgumentListWalker(const WalkerState&state): WalkerBase(state)
		{
			clearQualifying();
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::assignment_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::assignment_expression*symbol, ExpressionWalker&walker)
		{
			arguments.push_back(Argument(walker.expression, walker.type));
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
		}
	};
	struct SubscriptWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		ExpressionWrapper expression;
		UniqueTypeWrapper type;
		Dependent typeDependent;
		Dependent valueDependent;
		SubscriptWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		void action(cpp::terminal<boost::wave::T_LEFTBRACKET>)
		{
			clearQualifying();
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::expression*symbol, ExpressionWalker&walker)
		{
			expression=walker.expression;
			type=walker.type;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
		}
	};
	struct LiteralWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		ExpressionWrapper expression;
		LiteralWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::numeric_literal*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::numeric_literal*symbol)
		{
			if(symbol->id==cpp::numeric_literal::UNKNOWN)
			{
				symbol->id=isFloatingLiteral(symbol->value.value.c_str())?cpp::numeric_literal::FLOATING: cpp::numeric_literal::INTEGER;
			}
			expression=makeUniqueExpression(parseNumericLiteral(symbol));
		}
		SemaPolicyIdentity makePolicy(cpp::string_literal*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::string_literal*symbol)
		{
			expression=makeUniqueExpression(IntegralConstantExpression(getStringLiteralType(symbol), IntegralConstant()));
		}
	};
	struct PrimaryExpressionWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		UniqueTypeId type;
		ExpressionWrapper expression;
		IdentifierPtr id;
		TemplateArguments arguments;
		const SimpleType*idEnclosing;
		Dependent typeDependent;
		Dependent valueDependent;
		bool isUndeclared;
		PrimaryExpressionWalker(const WalkerState&state): WalkerBase(state), id(0), arguments(context), idEnclosing(0), isUndeclared(false)
		{
		}
		SemaPolicyPush<LiteralWalker>makePolicy(cpp::literal*)
		{
			return SemaPolicyPush<LiteralWalker>();
		}
		void action(cpp::literal*symbol, LiteralWalker&walker)
		{
			expression=walker.expression;
			type=typeOfExpression(expression, getInstantiationContext());
			if(!(!type.empty()))
			{
				throw SemanticError();
			};
		}
		SemaPolicyPushChecked<IdExpressionWalker>makePolicy(cpp::id_expression*)
		{
			return SemaPolicyPushChecked<IdExpressionWalker>();
		}
		bool action(cpp::id_expression*symbol, IdExpressionWalker&walker)
		{
			if(!walker.commit())
			{
				return reportIdentifierMismatch(symbol, *walker.id, walker.declaration, "object-name");
			}
			id=walker.id;
			arguments.swap(walker.arguments);
			type=gUniqueTypeNull;
			LookupResultRef declaration=walker.declaration;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			expression=walker.expression;
			isUndeclared=walker.isUndeclared;
			if(!(memberClass==0))
			{
				throw SemanticError();
			};
			if(isUndeclared)
			{
				type=gUniqueTypeNull;
				idEnclosing=0;
			}
			else if(expression.p!=0&&!isDependent(typeDependent))
			{
				UniqueTypeWrapper qualifyingType=makeUniqueQualifying(walker.qualifying, getInstantiationContext());
				const SimpleType*qualifyingClass=qualifyingType==gUniqueTypeNull?0: &getSimpleType(qualifyingType.value);
				type=typeOfIdExpression(qualifyingClass, declaration, getInstantiationContext());
				idEnclosing=isSpecialMember(*declaration)?0: getIdExpressionClass(qualifyingClass, declaration, enclosingType);
				if(!type.isFunction())
				{
					expression.isConstant|=(isIntegralConstant(type)&&declaration->initializer.isConstant);
				}
			}
			return true;
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::primary_expression_parenthesis*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::primary_expression_parenthesis*symbol, ExpressionWalker&walker)
		{
			type.swap(walker.type);
			expression=walker.expression;
			id=walker.id;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
		}
		SemaPolicyIdentity makePolicy(cpp::primary_expression_builtin*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::primary_expression_builtin*symbol)
		{
			if(!(enclosingType!=0))
			{
				throw SemanticError();
			};
			type=UniqueTypeWrapper(pushUniqueType(gUniqueTypes, makeUniqueSimpleType(*enclosingType).value, PointerType()));
			addDependent(typeDependent, enclosingDependent);
			expression=makeExpression(ExplicitTypeExpression(type), false, isDependent(typeDependent));
			setExpressionType(symbol, type);
		}
	};
	struct PostfixExpressionMemberWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		ExpressionWrapper expression;
		LookupResultRef declaration;
		IdentifierPtr id;
		TemplateArguments arguments;
		Dependent typeDependent;
		Dependent valueDependent;
		bool isTemplate;
		PostfixExpressionMemberWalker(const WalkerState&state): WalkerQualified(state), id(0), arguments(context), isTemplate(false)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::member_operator*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::member_operator*symbol)
		{
			bool isArrow=symbol->id==cpp::member_operator::ARROW;
			memberClass=&gDependentSimpleType;
			if(!(objectExpression.p!=0))
			{
				throw SemanticError();
			};
			if(!objectExpression.isTypeDependent)
			{
				UniqueTypeWrapper operand=removeReference(memberType);
				memberClass=&getMemberOperatorType(Argument(expression, operand), isArrow, getInstantiationContext());
				objectExpression=makeExpression(ObjectExpression(memberClass));
			}
		}
		void action(cpp::terminal<boost::wave::T_TEMPLATE>symbol)
		{
			isTemplate=true;
		}
		SemaPolicyPushBool<IdExpressionWalker>makePolicy(cpp::id_expression*)
		{
			return SemaPolicyPushBool<IdExpressionWalker>(isTemplate);
		}
		void action(cpp::id_expression*symbolm, IdExpressionWalker&walker)
		{
			bool isObjectName=walker.commit();
			if(!(isObjectName))
			{
				throw SemanticError();
			};
			id=walker.id;
			arguments.swap(walker.arguments);
			declaration=walker.declaration;
			swapQualifying(walker.qualifying);
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			expression=walker.expression;
		}
	};
	struct TypeTraitsIntrinsicWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Dependent valueDependent;
		UniqueTypeWrapper first;
		UniqueTypeWrapper second;
		TypeTraitsIntrinsicWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		void action(cpp::terminal<boost::wave::T_LEFTPAREN>symbol)
		{
		}
		SemaPolicyPush<TypeIdWalker>makePolicy(cpp::type_id*)
		{
			return SemaPolicyPush<TypeIdWalker>();
		}
		void action(cpp::type_id*symbol, TypeIdWalker&walker)
		{
			walker.commit();
			addDependent(valueDependent, walker.type);
			UniqueTypeWrapper type=UniqueTypeWrapper(walker.type.unique);
			setExpressionType(symbol, type);
			(first==gUniqueTypeNull?first: second)=type;
		}
	};
	struct PostfixExpressionWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		UniqueTypeId type;
		ExpressionWrapper expression;
		IdentifierPtr id;
		TemplateArguments arguments;
		const SimpleType*idEnclosing;
		Dependent typeDependent;
		Dependent valueDependent;
		bool isUndeclared;
		PostfixExpressionWalker(const WalkerState&state): WalkerBase(state), id(0), arguments(context), idEnclosing(0), isUndeclared(false)
		{
		}
		void clearMemberType()
		{
			memberType=gUniqueTypeNull;
			objectExpression=ExpressionWrapper();
		}
		void updateMemberType()
		{
			memberClass=0;
			if(type.isFunction())
			{
				memberType=gUniqueTypeNull;
				objectExpression=ExpressionWrapper();
			}
			else
			{
				memberType=type;
				objectExpression=makeExpression(ExplicitTypeExpression(type), false, isDependent(typeDependent), isDependent(valueDependent));
				if(!(objectExpression.isTypeDependent||!::isDependent(type)))
				{
					throw SemanticError();
				};
			}
		}
		SemaPolicyPush<PrimaryExpressionWalker>makePolicy(cpp::primary_expression*)
		{
			return SemaPolicyPush<PrimaryExpressionWalker>();
		}
		void action(cpp::primary_expression*symbol, PrimaryExpressionWalker&walker)
		{
			type.swap(walker.type);
			expression=walker.expression;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			id=walker.id;
			arguments.swap(walker.arguments);
			idEnclosing=walker.idEnclosing;
			isUndeclared=walker.isUndeclared;
			setExpressionType(symbol, type);
			updateMemberType();
		}
		SemaPolicyPushSrc<ExplicitTypeExpressionWalker>makePolicy(cpp::postfix_expression_construct*)
		{
			return SemaPolicyPushSrc<ExplicitTypeExpressionWalker>();
		}
		void action(cpp::postfix_expression_construct*symbol, ExplicitTypeExpressionWalker&walker)
		{
			addDependent(typeDependent, walker.typeDependent);
			type=getUniqueTypeSafe(walker.type);
			requireCompleteObjectType(type, getInstantiationContext());
			expression=makeExpression(CastExpression(type, walker.expression), walker.expression.isConstant, isDependent(typeDependent), false);
			expression.isTemplateArgumentAmbiguity=symbol->args==0;
			setExpressionType(symbol, type);
			updateMemberType();
		}
		SemaPolicyPushSrc<ExplicitTypeExpressionWalker>makePolicy(cpp::postfix_expression_cast*)
		{
			return SemaPolicyPushSrc<ExplicitTypeExpressionWalker>();
		}
		void action(cpp::postfix_expression_cast*symbol, ExplicitTypeExpressionWalker&walker)
		{
			type=getUniqueTypeSafe(walker.type);
			requireCompleteObjectType(type, getInstantiationContext());
			if(symbol->op->id!=cpp::cast_operator::DYNAMIC)
			{
				Dependent tmp(walker.typeDependent);
				addDependent(valueDependent, tmp);
			}
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			expression=makeExpression(CastExpression(type, walker.expression), walker.expression.isConstant, isDependent(typeDependent), isDependent(valueDependent));
			setExpressionType(symbol, type);
			updateMemberType();
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::postfix_expression_typeid*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::postfix_expression_typeid*symbol, ExpressionWalker&walker)
		{
			type=getTypeInfoType();
			expression=makeExpression(ExplicitTypeExpression(type));
			updateMemberType();
		}
		SemaPolicyPush<TypeIdWalker>makePolicy(cpp::postfix_expression_typeidtype*)
		{
			return SemaPolicyPush<TypeIdWalker>();
		}
		void action(cpp::postfix_expression_typeidtype*symbol, TypeIdWalker&walker)
		{
			type=getTypeInfoType();
			expression=makeExpression(ExplicitTypeExpression(type));
			updateMemberType();
		}
		SemaPolicyPushSrc<SubscriptWalker>makePolicy(cpp::postfix_expression_subscript*)
		{
			return SemaPolicyPushSrc<SubscriptWalker>();
		}
		void action(cpp::postfix_expression_subscript*symbol, SubscriptWalker&walker)
		{
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			id=0;
			if(isDependent(typeDependent))
			{
				type=gUniqueTypeNull;
			}
			else
			{
				if(!(type!=gUniqueTypeNull))
				{
					throw SemanticError();
				};
				type=removeReference(type);
				type=typeOfSubscriptExpression(Argument(expression, type), Argument(walker.expression, walker.type), getInstantiationContext());
			}
			expression=makeExpression(SubscriptExpression(expression, walker.expression), false, isDependent(typeDependent), isDependent(valueDependent));
			setExpressionType(symbol, type);
			updateMemberType();
		}
		SemaPolicyPushSrc<ArgumentListWalker>makePolicy(cpp::postfix_expression_call*)
		{
			return SemaPolicyPushSrc<ArgumentListWalker>();
		}
		void action(cpp::postfix_expression_call*symbol, ArgumentListWalker&walker)
		{
			setExpressionType(symbol, type);
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			if(!isDependent(typeDependent)&&expression.isNonStaticMemberName&&memberClass==0)
			{
				if(!(enclosingType!=0))
				{
					throw SemanticError();
				};
				addDependent(typeDependent, enclosingDependent);
			}
			if(isDependent(typeDependent))
			{
				if(id!=0)
				{
					id->dec.deferred=true;
				}
				type=gUniqueTypeNull;
				expression=ExpressionWrapper();
			}
			else
			{

				{
					if(!(isUndeclared==isDependentIdExpression(expression)))
					{
						throw SemanticError();
					};
					if(!(!isUndeclared||getDependentIdExpression(expression).name==id->value))
					{
						throw SemanticError();
					};
					TemplateArgumentsInstance templateArguments;
					makeUniqueTemplateArguments(arguments, templateArguments, getInstantiationContext());
					if(isUndeclared)
					{
						if(!(templateArguments.empty()))
						{
							throw SemanticError();
						};
					}
					else
					{
						bool isCallToNamedFunction=expression.p!=0&&(isIdExpression(expression)||isClassMemberAccessExpression(expression));
						if(!((id!=0)==(isCallToNamedFunction||(expression.p!=0&&isNonTypeTemplateParameter(expression)))))
						{
							throw SemanticError();
						};
						if(!isCallToNamedFunction)
						{
							if(!(templateArguments.empty()))
							{
								throw SemanticError();
							};
						}
						else
						{
							bool isCallToNamedMemberFunction=isClassMemberAccessExpression(expression);
							const IdExpression&idExpression=getIdExpression(isCallToNamedMemberFunction?getClassMemberAccessExpression(expression).right: expression);
							if(!(idExpression.declaration.p==&getDeclaration(*id)))
							{
								throw SemanticError();
							};
							if(!(idExpression.templateArguments==templateArguments))
							{
								throw SemanticError();
							};
							if(type.isFunction())
							{
								const SimpleType*tmp=isCallToNamedMemberFunction?getObjectExpression(getClassMemberAccessExpression(expression).left).classType: 0;
								if(!(memberClass==tmp))
								{
									throw SemanticError();
								};
								if(!isSpecialMember(*idExpression.declaration))
								{
									const SimpleType*tmp=getIdExpressionClass(idExpression.enclosing, idExpression.declaration, memberClass!=0?memberClass: enclosingType);
									if(!(idEnclosing==tmp))
									{
										throw SemanticError();
									};
								}
							}
						}
					}
				}
				type=typeOfFunctionCallExpression(Argument(expression, type), walker.arguments, getInstantiationContext());
				expression=makeExpression(FunctionCallExpression(expression, walker.arguments), false, isDependent(typeDependent), isDependent(valueDependent));
			}
			id=0;
			idEnclosing=0;
			updateMemberType();
			isUndeclared=false;
		}
		SemaPolicyPushSrc<PostfixExpressionMemberWalker>makePolicy(cpp::postfix_expression_member*)
		{
			return SemaPolicyPushSrc<PostfixExpressionMemberWalker>();
		}
		void action(cpp::postfix_expression_member*symbol, PostfixExpressionMemberWalker&walker)
		{
			setExpressionType(symbol, type);
			id=walker.id;
			arguments.swap(walker.arguments);
			type=gUniqueTypeNull;
			LookupResultRef declaration=walker.declaration;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			expression=ExpressionWrapper();
			if(walker.expression.p!=0&&!isDependent(typeDependent))
			{
				if(!(objectExpression.p!=0))
				{
					throw SemanticError();
				};
				if(!(!objectExpression.isTypeDependent))
				{
					throw SemanticError();
				};
				if(!(walker.memberClass!=0))
				{
					throw SemanticError();
				};
				if(!(walker.memberClass!=&gDependentSimpleType))
				{
					throw SemanticError();
				};
				UniqueTypeWrapper qualifyingType=makeUniqueQualifying(walker.qualifying, getInstantiationContext());
				const SimpleType*qualifyingClass=qualifyingType==gUniqueTypeNull?0: &getSimpleType(qualifyingType.value);
				type=typeOfIdExpression(qualifyingClass, declaration, setEnclosingTypeSafe(getInstantiationContext(), walker.memberClass));
				idEnclosing=isSpecialMember(*declaration)?0: getIdExpressionClass(qualifyingClass, declaration, walker.memberClass);
				expression=makeExpression(ClassMemberAccessExpression(walker.objectExpression, walker.expression), false, isDependent(typeDependent), isDependent(valueDependent));
			}
			updateMemberType();
			if(type.isFunction())
			{
				memberClass=walker.memberClass;
			}
		}
		SemaPolicySrc makePolicy(cpp::postfix_expression_destructor*)
		{
			return SemaPolicySrc();
		}
		void action(cpp::postfix_expression_destructor*symbol)
		{
			setExpressionType(symbol, type);
			type=gVoid;
			id=0;
			expression=ExpressionWrapper();
			clearMemberType();
		}
		SemaPolicySrc makePolicy(cpp::postfix_operator*)
		{
			return SemaPolicySrc();
		}
		void action(cpp::postfix_operator*symbol)
		{
			if(isDependent(typeDependent))
			{
				type=gUniqueTypeNull;
				expression=ExpressionWrapper();
			}
			else
			{
				type=removeReference(type);
				type=typeOfPostfixOperatorExpression(getOverloadedOperatorId(symbol), Argument(expression, type), getInstantiationContext());
				expression=makeExpression(PostfixOperatorExpression(getOverloadedOperatorId(symbol), expression));
			}
			setExpressionType(symbol, type);
			id=0;
			updateMemberType();
		}
		SemaPolicyPush<TypeTraitsIntrinsicWalker>makePolicy(cpp::postfix_expression_typetraits_unary*)
		{
			return SemaPolicyPush<TypeTraitsIntrinsicWalker>();
		}
		void action(cpp::postfix_expression_typetraits_unary*symbol, TypeTraitsIntrinsicWalker&walker)
		{
			addDependent(valueDependent, walker.valueDependent);
			type=gBool;
			UnaryTypeTraitsOp operation=getUnaryTypeTraitsOp(symbol->trait);
			Name name=getTypeTraitName(symbol);
			expression=makeExpression(TypeTraitsUnaryExpression(name, operation, walker.first), true, false, isDependent(valueDependent));
		}
		SemaPolicyPush<TypeTraitsIntrinsicWalker>makePolicy(cpp::postfix_expression_typetraits_binary*)
		{
			return SemaPolicyPush<TypeTraitsIntrinsicWalker>();
		}
		void action(cpp::postfix_expression_typetraits_binary*symbol, TypeTraitsIntrinsicWalker&walker)
		{
			addDependent(valueDependent, walker.valueDependent);
			type=gBool;
			BinaryTypeTraitsOp operation=getBinaryTypeTraitsOp(symbol->trait);
			Name name=getTypeTraitName(symbol);
			expression=makeExpression(TypeTraitsBinaryExpression(name, operation, walker.first, walker.second), true, false, isDependent(valueDependent));
		}
	};
	struct SizeofTypeExpressionWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Dependent valueDependent;
		ExpressionWrapper expression;
		SizeofTypeExpressionWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<TypeIdWalker>makePolicy(cpp::type_id*)
		{
			return SemaPolicyPush<TypeIdWalker>();
		}
		void action(cpp::type_id*symbol, TypeIdWalker&walker)
		{
			walker.commit();
			addDependent(valueDependent, walker.type);
			UniqueTypeId type=getUniqueTypeSafe(walker.type);
			setExpressionType(symbol, type);
			expression=makeExpression(SizeofTypeExpression(type), true, false, isDependent(valueDependent));
		}
	};
	struct ConditionalExpressionWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Dependent typeDependent;
		Dependent valueDependent;
		ExpressionWrapper left;
		ExpressionWrapper right;
		UniqueTypeWrapper leftType;
		UniqueTypeWrapper rightType;
		ConditionalExpressionWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::expression*symbol, ExpressionWalker&walker)
		{
			left=walker.expression;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			leftType=walker.type;
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::assignment_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::assignment_expression*symbol, ExpressionWalker&walker)
		{
			right=walker.expression;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			rightType=walker.type;
		}
	};
	struct ExpressionWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		IdentifierPtr id;
		UniqueTypeId type;
		ExpressionWrapper expression;
		Dependent typeDependent;
		Dependent valueDependent;
		ExpressionWalker(const WalkerState&state): WalkerBase(state), id(0)
		{
		}
		template<BuiltInBinaryTypeOp typeOp, typename T>
		void walkBinaryExpression(T*&symbol, const ExpressionWalker&walker)
		{
			id=walker.id;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			BinaryIceOp iceOp=getBinaryIceOp(symbol);
			ExpressionWrapper leftExpression=expression;
			expression=makeExpression(BinaryExpression(getOverloadedOperatorId(symbol), iceOp, typeOfBinaryExpression<typeOp>, expression, walker.expression), expression.isConstant&&walker.expression.isConstant&&iceOp!=0, isDependent(typeDependent), isDependent(valueDependent));
			if(!expression.isTypeDependent)
			{
				UniqueTypeWrapper left=removeReference(type);
				UniqueTypeWrapper right=removeReference(walker.type);
				type=typeOfBinaryExpression<typeOp>(getOverloadedOperatorId(symbol), Argument(leftExpression, left), Argument(walker.expression, right), getInstantiationContext());
				if(!(type!=gUniqueTypeNull))
				{
					throw AllocatorError();
				};
			}
			ExpressionType<T>::set(symbol, type);
		}
		template<typename T>
		void walkBinaryArithmeticExpression(T*symbol, const ExpressionWalker&walker)
		{
			walkBinaryExpression<binaryOperatorArithmeticType>(symbol, walker);
		}
		template<typename T>
		void walkBinaryAdditiveExpression(T*symbol, const ExpressionWalker&walker)
		{
			walkBinaryExpression<binaryOperatorAdditiveType>(symbol, walker);
		}
		template<typename T>
		void walkBinaryIntegralExpression(T*symbol, const ExpressionWalker&walker)
		{
			walkBinaryExpression<binaryOperatorIntegralType>(symbol, walker);
		}
		template<typename T>
		void walkBinaryBooleanExpression(T*symbol, const ExpressionWalker&walker)
		{
			walkBinaryExpression<binaryOperatorBoolean>(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::assignment_expression_suffix*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::assignment_expression_suffix*symbol, ExpressionWalker&walker)
		{
			walkBinaryExpression<binaryOperatorAssignment>(symbol, walker);
		}
		SemaPolicyPush<ConditionalExpressionWalker>makePolicy(cpp::conditional_expression_suffix*)
		{
			return SemaPolicyPush<ConditionalExpressionWalker>();
		}
		void action(cpp::conditional_expression_suffix*symbol, ConditionalExpressionWalker&walker)
		{
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			expression=makeExpression(TernaryExpression(conditional, expression, walker.left, walker.right), expression.isConstant&&walker.left.isConstant&&walker.right.isConstant, isDependent(typeDependent), isDependent(valueDependent));
			if(!expression.isTypeDependent)
			{
				type=getConditionalOperatorType(removeReference(walker.leftType), removeReference(walker.rightType));
			}
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::logical_or_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::logical_or_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryIntegralExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::logical_and_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::logical_and_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryBooleanExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::inclusive_or_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::inclusive_or_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryIntegralExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::exclusive_or_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::exclusive_or_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryIntegralExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::and_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::and_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryIntegralExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::equality_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::equality_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryBooleanExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::relational_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::relational_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryBooleanExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::shift_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::shift_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryIntegralExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::additive_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::additive_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryAdditiveExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::multiplicative_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::multiplicative_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryArithmeticExpression(symbol, walker);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::pm_expression_default*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::pm_expression_default*symbol, ExpressionWalker&walker)
		{
			walkBinaryExpression<binaryOperatorMemberPointer>(symbol, walker);
			id=0;
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::assignment_expression*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::assignment_expression*symbol, ExpressionWalker&walker)
		{
			expression=walker.expression;
			type=walker.type;
			id=walker.id;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			setExpressionType(symbol, type);
		}
		SemaPolicyIdentity makePolicy(cpp::expression_list*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::expression_list*symbol)
		{
			setExpressionType(symbol, type);
		}
		SemaPolicyPushSrcChecked<PostfixExpressionWalker>makePolicy(cpp::postfix_expression*)
		{
			return SemaPolicyPushSrcChecked<PostfixExpressionWalker>();
		}
		bool action(cpp::postfix_expression*symbol, PostfixExpressionWalker&walker)
		{
			if(walker.isUndeclared)
			{
				return reportIdentifierMismatch(symbol, *id, &gUndeclared, "object-name");
			}
			id=walker.id;
			type.swap(walker.type);
			expression=walker.expression;
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			setExpressionType(symbol, type);
			return true;
		}
		SemaPolicyIdentity makePolicy(cpp::unary_expression_op*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::unary_expression_op*symbol)
		{
			id=0;
			if(!isDependent(typeDependent))
			{
				if(!(type!=gUniqueTypeNull))
				{
					throw SemanticError();
				};
				if(!(!::isDependent(type)))
				{
					throw SemanticError();
				};
				if(!(getQualifyingScope()==0))
				{
					throw SemanticError();
				};
				if(!(!(objectExpression.p!=0&&memberClass!=0)))
				{
					throw SemanticError();
				};
				type=removeReference(type);
				type=typeOfUnaryExpression(getOverloadedOperatorId(symbol->op), Argument(expression, type), getInstantiationContext());
			}
			else
			{
				type=gUniqueTypeNull;
			}
			UnaryIceOp iceOp=getUnaryIceOp(symbol);
			expression=makeExpression(UnaryExpression(getOverloadedOperatorId(symbol->op), iceOp, expression), expression.isConstant&&iceOp!=0, isDependent(typeDependent), isDependent(valueDependent));
			setExpressionType(symbol, type);
		}
		SemaPolicyPushSrc<ExplicitTypeExpressionWalker>makePolicy(cpp::new_expression_placement*)
		{
			return SemaPolicyPushSrc<ExplicitTypeExpressionWalker>();
		}
		void action(cpp::new_expression_placement*symbol, ExplicitTypeExpressionWalker&walker)
		{
			type=getUniqueTypeSafe(walker.type);
			requireCompleteObjectType(type, getInstantiationContext());
			type.push_front(PointerType());
			addDependent(typeDependent, walker.typeDependent);
			expression=makeExpression(ExplicitTypeExpression(type), false, isDependent(typeDependent));
			setExpressionType(symbol, type);
		}
		SemaPolicyPushSrc<ExplicitTypeExpressionWalker>makePolicy(cpp::new_expression_default*)
		{
			return SemaPolicyPushSrc<ExplicitTypeExpressionWalker>();
		}
		void action(cpp::new_expression_default*symbol, ExplicitTypeExpressionWalker&walker)
		{
			type=getUniqueTypeSafe(walker.type);
			requireCompleteObjectType(type, getInstantiationContext());
			type.push_front(PointerType());
			addDependent(typeDependent, walker.typeDependent);
			expression=makeExpression(ExplicitTypeExpression(type), false, isDependent(typeDependent));
			setExpressionType(symbol, type);
		}
		SemaPolicyPushSrc<ExplicitTypeExpressionWalker>makePolicy(cpp::cast_expression_default*)
		{
			return SemaPolicyPushSrc<ExplicitTypeExpressionWalker>();
		}
		void action(cpp::cast_expression_default*symbol, ExplicitTypeExpressionWalker&walker)
		{
			type=getUniqueTypeSafe(walker.type);
			requireCompleteObjectType(type, getInstantiationContext());
			Dependent tmp(walker.typeDependent);
			addDependent(valueDependent, tmp);
			addDependent(typeDependent, walker.typeDependent);
			addDependent(valueDependent, walker.valueDependent);
			expression=makeExpression(CastExpression(type, walker.expression), walker.expression.isConstant, isDependent(typeDependent), isDependent(valueDependent));
			setExpressionType(symbol, type);
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::unary_expression_sizeof*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::unary_expression_sizeof*symbol, ExpressionWalker&walker)
		{
			addDependent(valueDependent, walker.typeDependent);
			type=gUnsignedInt;
			setExpressionType(symbol, type);
			expression=makeExpression(SizeofExpression(walker.expression), true, false, isDependent(valueDependent));
		}
		SemaPolicyPushSrc<SizeofTypeExpressionWalker>makePolicy(cpp::unary_expression_sizeoftype*)
		{
			return SemaPolicyPushSrc<SizeofTypeExpressionWalker>();
		}
		void action(cpp::unary_expression_sizeoftype*symbol, SizeofTypeExpressionWalker&walker)
		{
			addDependent(valueDependent, walker.valueDependent);
			type=gUnsignedInt;
			setExpressionType(symbol, type);
			expression=walker.expression;
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::delete_expression*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::delete_expression*symbol, ExpressionWalker&walker)
		{
			type=gVoid;
			setExpressionType(symbol, type);
			expression=ExpressionWrapper();
		}
		SemaPolicyPushSrc<ExpressionWalker>makePolicy(cpp::throw_expression*)
		{
			return SemaPolicyPushSrc<ExpressionWalker>();
		}
		void action(cpp::throw_expression*symbol, ExpressionWalker&walker)
		{
			type=gVoid;
			expression=ExpressionWrapper();
		}
	};
	struct IsHiddenTypeName
	{
		DeclarationPtr nonType;
		DeclarationPtr hidingNamespace;
		IsHiddenTypeName(): nonType(0), hidingNamespace(0)
		{
		}
		bool operator()(const Declaration&declaration)
		{
			if(isTypeName(declaration))
			{
				return true;
			}
			if(nonType==0&&isAny(declaration))
			{
				nonType=const_cast<Declaration*>(&declaration);
			}
			if(hidingNamespace==0&&isNamespaceName(declaration))
			{
				hidingNamespace=const_cast<Declaration*>(&declaration);
			}
			return false;
		}
	};
	struct TypeNameWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Type type;
		IsHiddenTypeName filter;
		bool isTypename;
		TypeNameWalker(const WalkerState&state, bool isTypename=false): WalkerBase(state), type(0, context), isTypename(isTypename)
		{
		}
		SemaPolicyIdentityCachedChecked makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCachedChecked();
		}
		bool action(cpp::identifier*symbol)
		{
			LookupResultRef declaration=gDependentTypeInstance;
			if(!isDependent(qualifying_p))
			{
				declaration=findDeclaration(symbol->value, makeLookupFilter(filter));
				if(declaration==&gUndeclared)
				{
					return reportIdentifierMismatch(symbol, symbol->value, declaration, "type-name");
				}
			}
			else if(!isTypename)
			{
				return reportIdentifierMismatch(symbol, symbol->value, &gUndeclared, "typename");
			}
			type.id=&symbol->value;
			type.declaration=declaration;
			if(type.declaration->isTemplate)
			{
				type.isImplicitTemplateId=true;
				const SimpleType*enclosingTemplate=findEnclosingTemplate(enclosingType, type.declaration);
				if(enclosingTemplate!=0)
				{
					type.isEnclosingClass=true;
					type.declaration=enclosingTemplate->declaration;
				}
			}
			setDecoration(&symbol->value, declaration);
			setDependent(type);
			if(type.declaration->isTemplate&&type.declaration->templateParameter==INDEX_INVALID)
			{
				if(type.declaration->isSpecialization)
				{
					setDependent(type.dependent, type.declaration->templateArguments);
				}
				else
				{
					if(!(!type.declaration->templateParams.empty()))
					{
						throw SemanticError();
					};
					setDependent(type.dependent, *type.declaration->templateParams.front().declaration);
				}
			}
			return true;
		}
		SemaPolicyPushCachedChecked<TemplateIdWalker>makePolicy(cpp::simple_template_id*)
		{
			return SemaPolicyPushCachedChecked<TemplateIdWalker>();
		}
		bool action(cpp::simple_template_id*symbol, TemplateIdWalker&walker)
		{
			LookupResultRef declaration=lookupTemplate(*walker.id, makeLookupFilter(filter));
			if(declaration==&gUndeclared)
			{
				return reportIdentifierMismatch(symbol, *walker.id, &gUndeclared, "type-name");
			}
			if(declaration==&gDependentTemplate&&!isTypename)
			{
				return reportIdentifierMismatch(symbol, *walker.id, &gUndeclared, "typename");
			}
			setDecoration(walker.id, declaration);
			type.id=walker.id;
			type.declaration=findOverloaded(declaration);
			type.templateArguments.swap(walker.arguments);
			setDependent(type);
			setDependent(type.dependent, type.templateArguments);
			return true;
		}
	};
	struct NestedNameSpecifierSuffixWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Type type;
		bool isDeclarator;
		bool isTemplate;
		NestedNameSpecifierSuffixWalker(const WalkerState&state, bool isDeclarator=false): WalkerBase(state), type(0, context), isDeclarator(isDeclarator), isTemplate(false)
		{
		}
		void action(cpp::terminal<boost::wave::T_TEMPLATE>symbol)
		{
			isTemplate=true;
		}
		SemaPolicyIdentityCachedChecked makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCachedChecked();
		}
		bool action(cpp::identifier*symbol)
		{
			LookupResultRef declaration=gDependentNestedInstance;
			if(isDeclarator||!isDependent(qualifying_p))
			{
				declaration=lookupQualified(symbol->value, isDeclarator, IsNestedName());
				if(declaration==&gUndeclared)
				{
					return reportIdentifierMismatch(symbol, symbol->value, declaration, "nested-name");
				}
			}
			type=declaration;
			type.id=&symbol->value;
			setDecoration(&symbol->value, declaration);
			if(declaration!=&gDependentNested)
			{
				setDependent(type);
			}
			return true;
		}
		SemaPolicyPushCachedCheckedBool<TemplateIdWalker>makePolicy(cpp::simple_template_id*)
		{
			return SemaPolicyPushCachedCheckedBool<TemplateIdWalker>(isTemplate);
		}
		bool action(cpp::simple_template_id*symbol, TemplateIdWalker&walker)
		{
			LookupResultRef declaration=gDependentNestedTemplateInstance;
			if(isDeclarator||!isDependent(qualifying_p))
			{
				declaration=lookupQualified(*walker.id, isDeclarator, IsNestedName());
				if(declaration==&gUndeclared)
				{
					return reportIdentifierMismatch(symbol, *walker.id, declaration, "nested-name");
				}
			}
			type=declaration;
			type.id=walker.id;
			type.templateArguments.swap(walker.arguments);
			if(declaration!=&gDependentNestedTemplate)
			{
				setDependent(type);
			}
			setDependent(type.dependent, type.templateArguments);
			return true;
		}
	};
	struct NestedNameSpecifierPrefixWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Type type;
		bool isDeclarator;
		NestedNameSpecifierPrefixWalker(const WalkerState&state, bool isDeclarator=false): WalkerBase(state), type(0, context), isDeclarator(isDeclarator)
		{
		}
		SemaPolicyPushChecked<NamespaceNameWalker>makePolicy(cpp::namespace_name*)
		{
			return SemaPolicyPushChecked<NamespaceNameWalker>();
		}
		bool action(cpp::namespace_name*symbol, NamespaceNameWalker&walker)
		{
			if(walker.filter.hidingType!=0)
			{
				return reportIdentifierMismatch(symbol, walker.filter.hidingType->getName(), walker.filter.hidingType, "namespace-name");
			}
			type.declaration=walker.declaration;
			return true;
		}
		SemaPolicyPushCheckedBool<TypeNameWalker>makePolicy(cpp::type_name*)
		{
			return SemaPolicyPushCheckedBool<TypeNameWalker>(true);
		}
		bool action(cpp::type_name*symbol, TypeNameWalker&walker)
		{
			if(walker.filter.hidingNamespace!=0)
			{
				return reportIdentifierMismatch(symbol, walker.filter.hidingNamespace->getName(), walker.filter.hidingNamespace, "type-name");
			}
			if(isDeclarator&&!isClass(*walker.type.declaration))
			{
				return reportIdentifierMismatch(symbol, walker.type.declaration->getName(), walker.type.declaration, "class-name");
			}
			type.swap(walker.type);
			return true;
		}
	};
	struct NestedNameSpecifierWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		bool isDeclarator;
		NestedNameSpecifierWalker(const WalkerState&state, bool isDeclarator=false): WalkerQualified(state), isDeclarator(isDeclarator)
		{
		}
		SemaPolicyPushBool<NestedNameSpecifierPrefixWalker>makePolicy(cpp::nested_name_specifier_prefix*)
		{
			return SemaPolicyPushBool<NestedNameSpecifierPrefixWalker>(isDeclarator);
		}
		void action(cpp::nested_name_specifier_prefix*symbol, NestedNameSpecifierPrefixWalker&walker)
		{
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			makeUniqueTypeSafe(walker.type);
			swapQualifying(walker.type, isDeclarator);
		}
		SemaPolicyPushBool<NestedNameSpecifierSuffixWalker>makePolicy(cpp::nested_name_specifier_suffix_template*)
		{
			return SemaPolicyPushBool<NestedNameSpecifierSuffixWalker>(isDeclarator);
		}
		void action(cpp::nested_name_specifier_suffix_template*symbol, NestedNameSpecifierSuffixWalker&walker)
		{
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			walker.type.qualifying.swap(qualifying);
			setDependent(walker.type.dependent, walker.type.qualifying);
			makeUniqueTypeSafe(walker.type);
			swapQualifying(walker.type, isDeclarator);
		}
		SemaPolicyPushBool<NestedNameSpecifierSuffixWalker>makePolicy(cpp::nested_name_specifier_suffix_default*)
		{
			return SemaPolicyPushBool<NestedNameSpecifierSuffixWalker>(isDeclarator);
		}
		void action(cpp::nested_name_specifier_suffix_default*symbol, NestedNameSpecifierSuffixWalker&walker)
		{
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			walker.type.qualifying.swap(qualifying);
			setDependent(walker.type.dependent, walker.type.qualifying);
			makeUniqueTypeSafe(walker.type);
			swapQualifying(walker.type, isDeclarator);
		}
	};
	struct TypeSpecifierWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Type type;
		unsigned fundamental;
		TypeSpecifierWalker(const WalkerState&state): WalkerQualified(state), type(0, context), fundamental(0)
		{
		}
		SemaPolicyPush<TypeSpecifierWalker>makePolicy(cpp::simple_type_specifier_name*)
		{
			return SemaPolicyPush<TypeSpecifierWalker>();
		}
		void action(cpp::simple_type_specifier_name*symbol, TypeSpecifierWalker&walker)
		{
			type.swap(walker.type);
			fundamental=walker.fundamental;
		}
		SemaPolicyPush<TypeSpecifierWalker>makePolicy(cpp::simple_type_specifier_template*)
		{
			return SemaPolicyPush<TypeSpecifierWalker>();
		}
		void action(cpp::simple_type_specifier_template*symbol, TypeSpecifierWalker&walker)
		{
			type.swap(walker.type);
			fundamental=walker.fundamental;
		}
		SemaPolicyPushChecked<TypeNameWalker>makePolicy(cpp::type_name*)
		{
			return SemaPolicyPushChecked<TypeNameWalker>();
		}
		bool action(cpp::type_name*symbol, TypeNameWalker&walker)
		{
			if(walker.filter.nonType!=0)
			{
				return reportIdentifierMismatch(symbol, walker.filter.nonType->getName(), walker.filter.nonType, "type-name");
			}
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			type.swap(walker.type);
			type.qualifying.swap(qualifying);
			setDependent(type.dependent, type.qualifying);
			return true;
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyPushCachedChecked<TemplateIdWalker>makePolicy(cpp::simple_template_id*)
		{
			return SemaPolicyPushCachedChecked<TemplateIdWalker>();
		}
		bool action(cpp::simple_template_id*symbol, TemplateIdWalker&walker)
		{
			LookupResultRef declaration=lookupTemplate(*walker.id, IsAny());
			if(declaration==&gUndeclared||!isTypeName(*declaration)||!isTemplateName(*declaration))
			{
				return reportIdentifierMismatch(symbol, *walker.id, declaration, "class-template-name");
			}
			if(declaration==&gDependentTemplate)
			{
				return reportIdentifierMismatch(symbol, *walker.id, &gUndeclared, "typename");
			}
			setDecoration(walker.id, declaration);
			type.declaration=declaration;
			type.templateArguments.swap(walker.arguments);
			type.qualifying.swap(qualifying);
			setDependent(type);
			setDependent(type.dependent, type.templateArguments);
			setDependent(type.dependent, type.qualifying);
			return true;
		}
		SemaPolicyIdentity makePolicy(cpp::simple_type_specifier_builtin*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::simple_type_specifier_builtin*symbol)
		{
			fundamental=combineFundamental(0, symbol->id);
		}
	};
	struct UnqualifiedDeclaratorIdWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		IdentifierPtr id;
		TypeId conversionType;
		UnqualifiedDeclaratorIdWalker(const WalkerState&state): WalkerBase(state), id(&gAnonymousId), conversionType(0, context)
		{
		}
		SemaPolicyIdentityCached makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCached();
		}
		void action(cpp::identifier*symbol)
		{
			id=&symbol->value;
		}
		SemaPolicyPushCached<TemplateIdWalker>makePolicy(cpp::template_id*)
		{
			return SemaPolicyPushCached<TemplateIdWalker>();
		}
		void action(cpp::template_id*symbol, TemplateIdWalker&walker)
		{
			id=walker.id;
		}
		SemaPolicyPushId<OperatorFunctionIdWalker>makePolicy(cpp::operator_function_id*)
		{
			return SemaPolicyPushId<OperatorFunctionIdWalker>();
		}
		void action(cpp::operator_function_id*symbol, OperatorFunctionIdWalker&walker)
		{
			symbol->value.value=walker.name;
			id=&symbol->value;
		}
		SemaPolicyPushId<TypeIdWalker>makePolicy(cpp::conversion_function_id*)
		{
			return SemaPolicyPushId<TypeIdWalker>();
		}
		void action(cpp::conversion_function_id*symbol, TypeIdWalker&walker)
		{
			symbol->value=gConversionFunctionId;
			id=&symbol->value;
			conversionType.swap(walker.type);
		}
		SemaPolicyIdentity makePolicy(cpp::destructor_id*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::destructor_id*symbol)
		{
			id=&symbol->name->value;
		}
	};
	struct QualifiedDeclaratorIdWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		IdentifierPtr id;
		QualifiedDeclaratorIdWalker(const WalkerState&state): WalkerQualified(state), id(&gAnonymousId)
		{
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		SemaPolicyPushBool<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushBool<NestedNameSpecifierWalker>(true);
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying, true);
		}
		SemaPolicyPush<UnqualifiedDeclaratorIdWalker>makePolicy(cpp::unqualified_id*)
		{
			return SemaPolicyPush<UnqualifiedDeclaratorIdWalker>();
		}
		void action(cpp::unqualified_id*symbol, UnqualifiedDeclaratorIdWalker&walker)
		{
			id=walker.id;
		}
	};
	struct DeclaratorIdWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		IdentifierPtr id;
		TypeId conversionType;
		DeclaratorIdWalker(const WalkerState&state): WalkerQualified(state), id(&gAnonymousId), conversionType(0, context)
		{
		}
		SemaPolicyPush<QualifiedDeclaratorIdWalker>makePolicy(cpp::qualified_id_default*)
		{
			return SemaPolicyPush<QualifiedDeclaratorIdWalker>();
		}
		void action(cpp::qualified_id_default*symbol, QualifiedDeclaratorIdWalker&walker)
		{
			id=walker.id;
			swapQualifying(walker.qualifying, true);
		}
		SemaPolicyPush<QualifiedDeclaratorIdWalker>makePolicy(cpp::qualified_id_global*)
		{
			return SemaPolicyPush<QualifiedDeclaratorIdWalker>();
		}
		void action(cpp::qualified_id_global*symbol, QualifiedDeclaratorIdWalker&walker)
		{
			id=walker.id;
			swapQualifying(walker.qualifying, true);
		}
		SemaPolicyPush<UnqualifiedDeclaratorIdWalker>makePolicy(cpp::unqualified_id*)
		{
			return SemaPolicyPush<UnqualifiedDeclaratorIdWalker>();
		}
		void action(cpp::unqualified_id*symbol, UnqualifiedDeclaratorIdWalker&walker)
		{
			id=walker.id;
			conversionType.swap(walker.conversionType);
		}
	};
	struct ParameterDeclarationListWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Parameters parameters;
		ParameterDeclarationListWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPushBool<SimpleDeclarationWalker>makePolicy(cpp::parameter_declaration*)
		{
			return SemaPolicyPushBool<SimpleDeclarationWalker>(true);
		}
		void action(cpp::parameter_declaration*symbol, SimpleDeclarationWalker&walker)
		{
			if(!isVoidParameter(walker.declaration->type))
			{
				parameters.push_back(Parameter(walker.declaration, walker.defaultArgument));
			}
		}
	};
	struct ParameterDeclarationClauseWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Parameters parameters;
		ParameterDeclarationClauseWalker(const WalkerState&state): WalkerBase(state)
		{
			pushScope(newScope(makeIdentifier("$prototype"), SCOPETYPE_PROTOTYPE));
			if(templateParamScope!=0)
			{
				templateParamScope->parent=enclosing->parent;
				enclosing->parent=templateParamScope;
				enclosing->templateDepth=templateParamScope->templateDepth;
			}
			clearTemplateParams();
		}
		SemaPolicyPush<ParameterDeclarationListWalker>makePolicy(cpp::parameter_declaration_list*)
		{
			return SemaPolicyPush<ParameterDeclarationListWalker>();
		}
		void action(cpp::parameter_declaration_list*symbol, ParameterDeclarationListWalker&walker)
		{
			parameters=walker.parameters;
		}
		void action(cpp::terminal<boost::wave::T_ELLIPSIS>symbol)
		{
			parameters.isEllipsis=true;
		}
	};
	struct ExceptionSpecificationWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		ExceptionSpecificationWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<TypeIdWalker>makePolicy(cpp::type_id*)
		{
			return SemaPolicyPush<TypeIdWalker>();
		}
		void action(cpp::type_id*symbol, TypeIdWalker&walker)
		{
		}
	};
	struct CvQualifierSeqWalker: WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		CvQualifiers qualifiers;
		CvQualifierSeqWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::cv_qualifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::cv_qualifier*symbol)
		{
			if(symbol->id==cpp::cv_qualifier::CONST)
			{
				qualifiers.isConst=true;
			}
			else if(symbol->id==cpp::cv_qualifier::VOLATILE)
			{
				qualifiers.isVolatile=true;
			}
		}
	};
	struct PtrOperatorWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		CvQualifiers qualifiers;
		PtrOperatorWalker(const WalkerState&state): WalkerQualified(state)
		{
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyPush<CvQualifierSeqWalker>makePolicy(cpp::cv_qualifier_seq*)
		{
			return SemaPolicyPush<CvQualifierSeqWalker>();
		}
		void action(cpp::cv_qualifier_seq*symbol, CvQualifierSeqWalker&walker)
		{
			qualifiers=walker.qualifiers;
		}
	};
	struct DeclaratorFunctionWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		ScopePtr paramScope;
		Parameters parameters;
		CvQualifiers qualifiers;
		DeclaratorFunctionWalker(const WalkerState&state): WalkerBase(state), paramScope(0)
		{
		}
		SemaPolicyPush<ParameterDeclarationClauseWalker>makePolicy(cpp::parameter_declaration_clause*)
		{
			return SemaPolicyPush<ParameterDeclarationClauseWalker>();
		}
		void action(cpp::parameter_declaration_clause*symbol, ParameterDeclarationClauseWalker&walker)
		{
			paramScope=walker.enclosing;
			parameters=walker.parameters;
		}
		SemaPolicyPush<ExceptionSpecificationWalker>makePolicy(cpp::exception_specification*)
		{
			return SemaPolicyPush<ExceptionSpecificationWalker>();
		}
		void action(cpp::exception_specification*symbol, ExceptionSpecificationWalker&walker)
		{
		}
		SemaPolicyPush<CvQualifierSeqWalker>makePolicy(cpp::cv_qualifier_seq*)
		{
			return SemaPolicyPush<CvQualifierSeqWalker>();
		}
		void action(cpp::cv_qualifier_seq*symbol, CvQualifierSeqWalker&walker)
		{
			qualifiers=walker.qualifiers;
		}
	};
	struct DeclaratorArrayWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Dependent valueDependent;
		ArrayRank rank;
		ExpressionWrapper expression;
		DeclaratorArrayWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		void action(cpp::terminal<boost::wave::T_LEFTBRACKET>symbol)
		{
			expression=ExpressionWrapper();
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::constant_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::constant_expression*symbol, ExpressionWalker&walker)
		{
			if(!(isDependent(walker.valueDependent)||walker.expression.isConstant))
			{
				throw SemanticError();
			};
			addDependent(valueDependent, walker.valueDependent);
			expression=walker.expression;
		}
		void action(cpp::terminal<boost::wave::T_RIGHTBRACKET>symbol)
		{
			rank.push_back(expression);
		}
	};
	struct DeclaratorWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		IdentifierPtr id;
		UniqueTypeWrapper qualifying;
		ScopePtr paramScope;
		Dependent valueDependent;
		TypeSequence typeSequence;
		CvQualifiers qualifiers;
		Qualifying memberPointer;
		Dependent dependent;
		TypeId conversionType;
		DeclaratorWalker(const WalkerState&state): WalkerBase(state), id(&gAnonymousId), paramScope(0), typeSequence(context), memberPointer(context), conversionType(0, context)
		{
		}
		void pushPointerType(cpp::ptr_operator*op)
		{
			if(op->key->id==cpp::ptr_operator_key::REF)
			{
				typeSequence.push_front(DeclaratorReferenceType());
			}
			else
			{
				if(memberPointer.empty())
				{
					typeSequence.push_front(DeclaratorPointerType(qualifiers));
				}
				else
				{
					typeSequence.push_front(DeclaratorMemberPointerType(memberPointer.back(), qualifiers));
					setDependent(dependent, memberPointer);
				}
			}
		}
		SemaPolicyPush<PtrOperatorWalker>makePolicy(cpp::ptr_operator*)
		{
			return SemaPolicyPush<PtrOperatorWalker>();
		}
		void action(cpp::ptr_operator*symbol, PtrOperatorWalker&walker)
		{
			qualifiers=walker.qualifiers;
			memberPointer.swap(walker.qualifying);
		}
		template<typename T>
		void walkDeclaratorPtr(T*symbol, DeclaratorWalker&walker)
		{
			walker.pushPointerType(symbol->op);
			id=walker.id;
			qualifying=walker.qualifying;
			enclosing=walker.enclosing;
			paramScope=walker.paramScope;
			templateParams=walker.templateParams;
			addDependent(dependent, walker.dependent);
			addDependent(valueDependent, walker.valueDependent);
			addDependent(enclosingDependent, walker.enclosingDependent);
			if(!(typeSequence.empty()))
			{
				throw AllocatorError();
			};
			typeSequence=walker.typeSequence;
			qualifiers=walker.qualifiers;
			memberPointer.swap(walker.memberPointer);
			conversionType.swap(walker.conversionType);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::declarator_ptr*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::declarator_ptr*symbol, DeclaratorWalker&walker)
		{
			return walkDeclaratorPtr(symbol, walker);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::abstract_declarator_ptr*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::abstract_declarator_ptr*symbol, DeclaratorWalker&walker)
		{
			return walkDeclaratorPtr(symbol, walker);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::new_declarator_ptr*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::new_declarator_ptr*symbol, DeclaratorWalker&walker)
		{
			return walkDeclaratorPtr(symbol, walker);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::conversion_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::conversion_declarator*symbol, DeclaratorWalker&walker)
		{
			return walkDeclaratorPtr(symbol, walker);
		}
		SemaPolicyPush<DeclaratorIdWalker>makePolicy(cpp::declarator_id*)
		{
			return SemaPolicyPush<DeclaratorIdWalker>();
		}
		void action(cpp::declarator_id*symbol, DeclaratorIdWalker&walker)
		{
			id=walker.id;
			qualifying=walker.qualifying.empty()||isNamespace(*walker.qualifying.back().declaration)?gUniqueTypeNull: UniqueTypeWrapper(walker.qualifying.back().unique);
			if(walker.getQualifyingScope()&&enclosing->type!=SCOPETYPE_CLASS)
			{
				enclosing=walker.getQualifyingScope();
			}
			if(qualifying!=gUniqueTypeNull)
			{
				enclosingType=&getSimpleType(qualifying.value);
				if(enclosingType->declaration->isTemplate&&!enclosingType->declaration->templateParams.empty())
				{
					setDependent(enclosingDependent, enclosingType->declaration->templateParams.back().declaration);
				}
			}
			if(templateParams!=0&&!templateParams->empty()&&consumeTemplateParams(walker.qualifying))
			{
				templateParams=0;
			}
			if(walker.conversionType.declaration!=0)
			{
				conversionType.swap(walker.conversionType);
			}
			addDependent(dependent, conversionType);
		}
		template<typename T>
		void walkDeclaratorArray(T*symbol, DeclaratorArrayWalker&walker)
		{
			addDependent(dependent, walker.valueDependent);
			addDependent(valueDependent, walker.valueDependent);
			typeSequence.push_front(DeclaratorArrayType(walker.rank));
		}
		SemaPolicyPushCached<DeclaratorArrayWalker>makePolicy(cpp::declarator_suffix_array*)
		{
			return SemaPolicyPushCached<DeclaratorArrayWalker>();
		}
		void action(cpp::declarator_suffix_array*symbol, DeclaratorArrayWalker&walker)
		{
			return walkDeclaratorArray(symbol, walker);
		}
		SemaPolicyPushCached<DeclaratorFunctionWalker>makePolicy(cpp::declarator_suffix_function*)
		{
			return SemaPolicyPushCached<DeclaratorFunctionWalker>();
		}
		void action(cpp::declarator_suffix_function*symbol, DeclaratorFunctionWalker&walker)
		{
			if(paramScope==0)
			{
				paramScope=walker.paramScope;
			}
			typeSequence.push_front(DeclaratorFunctionType(walker.parameters, walker.qualifiers));
			setDependent(dependent, walker.parameters);
		}
		SemaPolicyPushCached<DeclaratorArrayWalker>makePolicy(cpp::new_declarator_suffix*)
		{
			return SemaPolicyPushCached<DeclaratorArrayWalker>();
		}
		void action(cpp::new_declarator_suffix*symbol, DeclaratorArrayWalker&walker)
		{
			return walkDeclaratorArray(symbol, walker);
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::expression*symbol, ExpressionWalker&walker)
		{
		}
		template<typename T>
		void walkDeclarator(T*symbol, DeclaratorWalker&walker)
		{
			id=walker.id;
			qualifying=walker.qualifying;
			enclosing=walker.enclosing;
			paramScope=walker.paramScope;
			templateParams=walker.templateParams;
			addDependent(dependent, walker.dependent);
			addDependent(valueDependent, walker.valueDependent);
			addDependent(enclosingDependent, walker.enclosingDependent);
			if(!(typeSequence.empty()))
			{
				throw AllocatorError();
			};
			typeSequence=walker.typeSequence;
			conversionType.swap(walker.conversionType);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::direct_abstract_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::direct_abstract_declarator*symbol, DeclaratorWalker&walker)
		{
			return walkDeclarator(symbol, walker);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::direct_abstract_declarator_parenthesis*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::direct_abstract_declarator_parenthesis*symbol, DeclaratorWalker&walker)
		{
			return walkDeclarator(symbol, walker);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::direct_new_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::direct_new_declarator*symbol, DeclaratorWalker&walker)
		{
			return walkDeclarator(symbol, walker);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::declarator*symbol, DeclaratorWalker&walker)
		{
			return walkDeclarator(symbol, walker);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::abstract_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::abstract_declarator*symbol, DeclaratorWalker&walker)
		{
			return walkDeclarator(symbol, walker);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::new_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::new_declarator*symbol, DeclaratorWalker&walker)
		{
			return walkDeclarator(symbol, walker);
		}
	};
	struct BaseSpecifierWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Type type;
		BaseSpecifierWalker(const WalkerState&state): WalkerQualified(state), type(0, context)
		{
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyPushBool<TypeNameWalker>makePolicy(cpp::class_name*)
		{
			return SemaPolicyPushBool<TypeNameWalker>(true);
		}
		void action(cpp::class_name*symbol, TypeNameWalker&walker)
		{
			type.swap(walker.type);
			type.qualifying.swap(qualifying);
			setDependent(type.dependent, type.qualifying);
			makeUniqueTypeSafe(type);
		}
	};
	struct ClassHeadWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		IdentifierPtr id;
		ScopePtr parent;
		TemplateArguments arguments;
		bool isUnion;
		bool isSpecialization;
		ClassHeadWalker(const WalkerState&state): WalkerBase(state), declaration(0), id(0), parent(enclosing), arguments(context), isUnion(false), isSpecialization(false)
		{
		}
		SemaPolicyIdentityCached makePolicy(cpp::class_key*)
		{
			return SemaPolicyIdentityCached();
		}
		void action(cpp::class_key*symbol)
		{
			isUnion=symbol->id==cpp::class_key::UNION;
		}
		SemaPolicyIdentityCached makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCached();
		}
		void action(cpp::identifier*symbol)
		{
			id=&symbol->value;
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			if(walker.getDeclaratorQualifying()!=0)
			{
				parent=walker.getDeclaratorQualifying()->enclosed;
			}
			if(templateParams!=0&&!templateParams->empty()&&consumeTemplateParams(walker.qualifying))
			{
				templateParams=0;
			}
		}
		SemaPolicyPushCachedBool<TemplateIdWalker>makePolicy(cpp::simple_template_id*)
		{
			return SemaPolicyPushCachedBool<TemplateIdWalker>(true);
		}
		void action(cpp::simple_template_id*symbol, TemplateIdWalker&walker)
		{
			id=walker.id;
			arguments.swap(walker.arguments);
			isSpecialization=true;
		}
		void action(cpp::terminal<boost::wave::T_COLON>symbol)
		{
			declaration=declareClass(parent, id, isSpecialization, arguments);
		}
		SemaPolicyPush<BaseSpecifierWalker>makePolicy(cpp::base_specifier*)
		{
			return SemaPolicyPush<BaseSpecifierWalker>();
		}
		void action(cpp::base_specifier*symbol, BaseSpecifierWalker&walker)
		{
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			if(!(declaration->enclosed!=0))
			{
				throw SemanticError();
			};
			if(!(walker.type.unique!=0))
			{
				throw SemanticError();
			};
			addBase(declaration, walker.type);
			setExpressionType(symbol, walker.type.isDependent?gUniqueTypeNull: UniqueTypeWrapper(walker.type.unique));
		}
	};
	struct UsingDeclarationWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		bool isTypename;
		UsingDeclarationWalker(const WalkerState&state): WalkerQualified(state), isTypename(false)
		{
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyPushChecked<UnqualifiedIdWalker>makePolicy(cpp::unqualified_id*)
		{
			return SemaPolicyPushChecked<UnqualifiedIdWalker>();
		}
		bool action(cpp::unqualified_id*symbol, UnqualifiedIdWalker&walker)
		{
			if(!isTypename&&!isDependent(qualifying_p))
			{
				LookupResultRef declaration=walker.declaration;
				if(declaration==&gUndeclared||!(isObject(*declaration)||isTypeName(*declaration)))
				{
					return reportIdentifierMismatch(symbol, *walker.id, declaration, "object-name or type-name");
				}
				setDecoration(walker.id, declaration);
				DeclarationInstance instance(declaration);
				instance.name=walker.id;
				instance.overloaded=declaration.p;
				instance.redeclared=declaration.p;
				DeclarationInstanceRef redeclaration=enclosing->declarations.insert(instance);
				enclosing->declarationList.push_back(instance);
				trackDeclaration(redeclaration);
			}
			else
			{
				setDecoration(walker.id, gDependentTypeInstance);
			}
			return true;
		}
		void action(cpp::terminal<boost::wave::T_TYPENAME>symbol)
		{
			isTypename=true;
		}
	};
	struct UsingDirectiveWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		UsingDirectiveWalker(const WalkerState&state): WalkerQualified(state)
		{
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyPush<NamespaceNameWalker>makePolicy(cpp::namespace_name*)
		{
			return SemaPolicyPush<NamespaceNameWalker>();
		}
		void action(cpp::namespace_name*symbol, NamespaceNameWalker&walker)
		{
			if(!findScope(enclosing, walker.declaration->enclosed))
			{
				enclosing->usingDirectives.push_back(walker.declaration->enclosed);
			}
		}
	};
	struct NamespaceAliasDefinitionWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		IdentifierPtr id;
		NamespaceAliasDefinitionWalker(const WalkerState&state): WalkerQualified(state), id(0)
		{
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyIdentityChecked makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityChecked();
		}
		bool action(cpp::identifier*symbol)
		{
			if(id==0)
			{
				id=&symbol->value;
			}
			else
			{
				LookupResultRef declaration=findDeclaration(symbol->value, IsNamespaceName());
				if(declaration==&gUndeclared)
				{
					return reportIdentifierMismatch(symbol, symbol->value, declaration, "namespace-name");
				}
				declaration=pointOfDeclaration(context, enclosing, *id, TypeId(&gNamespace, ParserAllocatorWrapper<int>(NullParserAllocator())), declaration->enclosed);
				trackDeclaration(declaration);
				setDecoration(id, declaration);
			}
			return true;
		}
	};
	struct MemberDeclarationWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		MemberDeclarationWalker(const WalkerState&state): WalkerBase(state), declaration(0)
		{
		}
		SemaPolicyPush<TemplateDeclarationWalker>makePolicy(cpp::member_template_declaration*)
		{
			return SemaPolicyPush<TemplateDeclarationWalker>();
		}
		void action(cpp::member_template_declaration*symbol, TemplateDeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::member_declaration_implicit*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::member_declaration_implicit*symbol, SimpleDeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::member_declaration_default*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::member_declaration_default*symbol, SimpleDeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<QualifiedIdWalker>makePolicy(cpp::member_declaration_nested*)
		{
			return SemaPolicyPush<QualifiedIdWalker>();
		}
		void action(cpp::member_declaration_nested*symbol, QualifiedIdWalker&walker)
		{
		}
		SemaPolicyPush<UsingDeclarationWalker>makePolicy(cpp::using_declaration*)
		{
			return SemaPolicyPush<UsingDeclarationWalker>();
		}
		void action(cpp::using_declaration*symbol, UsingDeclarationWalker&walker)
		{
		}
	};
	struct ClassSpecifierWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		IdentifierPtr id;
		TemplateArguments arguments;
		DeferredSymbols deferred;
		bool isUnion;
		bool isSpecialization;
		ClassSpecifierWalker(const WalkerState&state): WalkerBase(state), declaration(0), id(0), arguments(context), isUnion(false), isSpecialization(false)
		{
		}
		SemaPolicyPush<ClassHeadWalker>makePolicy(cpp::class_head*)
		{
			return SemaPolicyPush<ClassHeadWalker>();
		}
		void action(cpp::class_head*symbol, ClassHeadWalker&walker)
		{
			declaration=walker.declaration;
			id=walker.id;
			isUnion=walker.isUnion;
			isSpecialization=walker.isSpecialization;
			arguments.swap(walker.arguments);
			enclosing=walker.parent;
			templateParams=walker.templateParams;
		}
		void action(cpp::terminal<boost::wave::T_LEFTBRACE>symbol)
		{
			if(declaration==0)
			{
				declaration=declareClass(enclosing, id, isSpecialization, arguments);
			}
			if(!(declaration->enclosed!=0))
			{
				throw SemanticError();
			};
			pushScope(declaration->enclosed);
			if(templateParamScope!=0)
			{
				templateParamScope->parent=enclosing->parent;
				enclosing->parent=templateParamScope;
			}
			if(declaration->isTemplate)
			{
				enclosing->templateDepth=templateDepth;
			}
			declaration->templateParamScope=templateParamScope;
			Type type(declaration, context);
			type.id=&declaration->getName();
			setDependent(type);
			if(declaration->isTemplate)
			{
				setDependentEnclosingTemplate(type.dependent, declaration);
			}
			type.isDependent=isDependent(type);
			type.isImplicitTemplateId=declaration->isTemplate;
			type.isEnclosingClass=true;
			bool isExplicitSpecialization=isSpecialization&&declaration->templateParams.empty();
			bool allowDependent=type.isDependent||(declaration->isTemplate&&!isExplicitSpecialization);
			declaration->type.isDependent=type.isDependent;
			declaration->type.unique=makeUniqueType(type, getInstantiationContext(), allowDependent).value;
			enclosingType=&getSimpleType(declaration->type.unique);
			const_cast<SimpleType*>(enclosingType)->declaration=declaration;
			instantiateClass(*enclosingType, InstantiationContext(getLocation(), 0, 0), allowDependent);
			addDependent(enclosingDependent, type);
			clearTemplateParams();
			if(WalkerState::enclosingDeferred==0)
			{
				WalkerState::enclosingDeferred=&deferred;
			}
		}
		SemaPolicyPush<MemberDeclarationWalker>makePolicy(cpp::member_declaration*)
		{
			return SemaPolicyPush<MemberDeclarationWalker>();
		}
		void action(cpp::member_declaration*symbol, MemberDeclarationWalker&walker)
		{
		}
		void action(cpp::terminal<boost::wave::T_RIGHTBRACE>symbol)
		{
			declaration->isComplete=true;
			parseDeferred(deferred.first, context.parserContext);
			parseDeferred(deferred.second, context.parserContext);
		}
	};
	struct EnumeratorDefinitionWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		EnumeratorDefinitionWalker(const WalkerState&state): WalkerBase(state), declaration(0)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::identifier*symbol)
		{
			DeclarationInstanceRef instance=pointOfDeclaration(context, enclosing, symbol->value, TypeId(&gEnumerator, ParserAllocatorWrapper<int>(NullParserAllocator())), 0, DeclSpecifiers());
			trackDeclaration(instance);
			setDecoration(&symbol->value, instance);
			declaration=instance;
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::constant_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::constant_expression*symbol, ExpressionWalker&walker)
		{
			if(!(isDependent(walker.valueDependent)||walker.expression.isConstant))
			{
				throw SemanticError();
			};
			declaration->initializer=walker.expression;
			addDependent(declaration->valueDependent, walker.valueDependent);
		}
	};
	struct EnumSpecifierWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		IdentifierPtr id;
		ExpressionWrapper value;
		EnumSpecifierWalker(const WalkerState&state): WalkerBase(state), declaration(0), id(0)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::identifier*symbol)
		{
			id=&symbol->value;
		}
		void action(cpp::terminal<boost::wave::T_LEFTBRACE>symbol)
		{
			if(id!=0)
			{
				DeclarationInstanceRef instance=pointOfDeclaration(context, enclosing, *id, TypeId(&gEnum, ParserAllocatorWrapper<int>(NullParserAllocator())), 0);
				setDecoration(id, instance);
				declaration=instance;
			}
			value=makeUniqueExpression(IntegralConstantExpression(gSignedInt, IntegralConstant(0)));
			if(declaration==0)
			{
				DeclarationInstanceRef instance=pointOfDeclaration(context, enclosing, enclosing->getUniqueName(), TypeId(&gEnum, ParserAllocatorWrapper<int>(NullParserAllocator())), 0);
				trackDeclaration(instance);
				declaration=instance;
			}
		}
		SemaPolicyPush<EnumeratorDefinitionWalker>makePolicy(cpp::enumerator_definition*)
		{
			return SemaPolicyPush<EnumeratorDefinitionWalker>();
		}
		void action(cpp::enumerator_definition*symbol, EnumeratorDefinitionWalker&walker)
		{
			Declaration&enumerator=*walker.declaration;
			enumerator.type=declaration;
			enumerator.type.qualifiers=CvQualifiers(true, false);
			setDependent(enumerator.type);
			makeUniqueTypeSafe(enumerator.type);
			if(enumerator.initializer.p!=0)
			{
				if(!(isDependent(enumerator.valueDependent)||enumerator.initializer.isConstant))
				{
					throw SemanticError();
				};
				value=enumerator.initializer;
			}
			else
			{
				enumerator.initializer=value;
			}
			ExpressionWrapper one=makeUniqueExpression(IntegralConstantExpression(gSignedInt, IntegralConstant(1)));
			value=makeExpression(BinaryExpression(Name("+"), operator+, 0, value, one), true, value.isTypeDependent, value.isValueDependent);
		}
	};
	struct ElaboratedTypeSpecifierWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr key;
		Type type;
		IdentifierPtr id;
		ElaboratedTypeSpecifierWalker(const WalkerState&state): WalkerQualified(state), key(0), type(0, context), id(0)
		{
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		SemaPolicyPush<ElaboratedTypeSpecifierWalker>makePolicy(cpp::elaborated_type_specifier_default*)
		{
			return SemaPolicyPush<ElaboratedTypeSpecifierWalker>();
		}
		void action(cpp::elaborated_type_specifier_default*symbol, ElaboratedTypeSpecifierWalker&walker)
		{
			type.swap(walker.type);
			id=walker.id;
			if(!isUnqualified(symbol)||!isClassKey(*type.declaration))
			{
				id=0;
			}
		}
		SemaPolicyPush<ElaboratedTypeSpecifierWalker>makePolicy(cpp::elaborated_type_specifier_template*)
		{
			return SemaPolicyPush<ElaboratedTypeSpecifierWalker>();
		}
		void action(cpp::elaborated_type_specifier_template*symbol, ElaboratedTypeSpecifierWalker&walker)
		{
			type.swap(walker.type);
			id=walker.id;
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyIdentityCached makePolicy(cpp::class_key*)
		{
			return SemaPolicyIdentityCached();
		}
		void action(cpp::class_key*symbol)
		{
			key=&gClass;
		}
		SemaPolicyIdentity makePolicy(cpp::enum_key*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::enum_key*symbol)
		{
			key=&gEnum;
		}
		SemaPolicyPushCachedChecked<TemplateIdWalker>makePolicy(cpp::simple_template_id*)
		{
			return SemaPolicyPushCachedChecked<TemplateIdWalker>();
		}
		bool action(cpp::simple_template_id*symbol, TemplateIdWalker&walker)
		{
			if(!(key==&gClass))
			{
				throw SemanticError();
			};
			LookupResultRef declaration=lookupTemplate(*walker.id, IsTypeName());
			if(declaration==&gUndeclared)
			{
				return reportIdentifierMismatch(symbol, *walker.id, &gUndeclared, "type-name");
			}
			if(declaration==&gDependentTemplate)
			{
				return reportIdentifierMismatch(symbol, *walker.id, &gUndeclared, "typename");
			}
			setDecoration(walker.id, declaration);
			id=walker.id;
			type.declaration=declaration;
			type.templateArguments.swap(walker.arguments);
			type.qualifying.swap(qualifying);
			return true;
		}
		SemaPolicyIdentityCached makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCached();
		}
		void action(cpp::identifier*symbol)
		{
			id=&symbol->value;
			LookupResultRef declaration=findDeclaration(symbol->value, IsTypeName());
			if(declaration==&gUndeclared||isTypedef(*declaration)||declaration->isTemplate||templateParams!=0||(key==&gClass&&declaration->scope==getEtsScope()))
			{
				if(key!=&gClass)
				{
					if(!(key==&gEnum))
					{
						throw SemanticError();
					};
					printPosition(symbol->value.source);
					std::cout<<"'"<<symbol->value.value.c_str()<<"': elaborated-type-specifier refers to undefined enum"<<std::endl;
					throw SemanticError();
				}
				type=key;
			}
			else
			{
				setDecoration(&symbol->value, declaration);
				if(declaration->type.declaration!=key)
				{
					printPosition(symbol->value.source);
					std::cout<<"'"<<symbol->value.value.c_str()<<"': elaborated-type-specifier key does not match declaration"<<std::endl;
					printPosition(declaration->getName().source);
					throw SemanticError();
				}
				type=declaration;
			}
		}
	};
	struct TypenameSpecifierWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		Type type;
		TypenameSpecifierWalker(const WalkerState&state): WalkerQualified(state), type(0, context)
		{
		}
		void action(cpp::terminal<boost::wave::T_TYPENAME>symbol)
		{
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		void action(cpp::terminal<boost::wave::T_TEMPLATE>symbol)
		{
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyPushCheckedBool<TypeNameWalker>makePolicy(cpp::type_name*)
		{
			return SemaPolicyPushCheckedBool<TypeNameWalker>(true);
		}
		bool action(cpp::type_name*symbol, TypeNameWalker&walker)
		{
			if(walker.filter.nonType!=0)
			{
				return reportIdentifierMismatch(symbol, walker.filter.nonType->getName(), walker.filter.nonType, "type-name");
			}
			type.swap(walker.type);
			type.qualifying.swap(qualifying);
			setDependent(type.dependent, type.qualifying);
			return true;
		}
	};
	struct DeclSpecifierSeqWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclSpecifierSeq seq;
		unsigned fundamental;
		DeclSpecifierSeqWalker(const WalkerState&state): WalkerBase(state), seq(0, context), fundamental(0)
		{
		}
		void commit()
		{
			declareEts(seq.type, seq.forward);
		}
		SemaPolicyPush<TypeSpecifierWalker>makePolicy(cpp::simple_type_specifier*)
		{
			return SemaPolicyPush<TypeSpecifierWalker>();
		}
		void action(cpp::simple_type_specifier*symbol, TypeSpecifierWalker&walker)
		{
			seq.type.swap(walker.type);
			if(seq.type.declaration==0)
			{
				fundamental=walker.fundamental;
				seq.type=getFundamentalType(fundamental);
			}
		}
		SemaPolicyIdentity makePolicy(cpp::simple_type_specifier_builtin*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::simple_type_specifier_builtin*symbol)
		{
			fundamental=combineFundamental(fundamental, symbol->id);
			seq.type=getFundamentalType(fundamental);
		}
		SemaPolicyPush<ElaboratedTypeSpecifierWalker>makePolicy(cpp::elaborated_type_specifier*)
		{
			return SemaPolicyPush<ElaboratedTypeSpecifierWalker>();
		}
		void action(cpp::elaborated_type_specifier*symbol, ElaboratedTypeSpecifierWalker&walker)
		{
			seq.forward=walker.id;
			seq.type.swap(walker.type);
		}
		SemaPolicyPush<TypenameSpecifierWalker>makePolicy(cpp::typename_specifier*)
		{
			return SemaPolicyPush<TypenameSpecifierWalker>();
		}
		void action(cpp::typename_specifier*symbol, TypenameSpecifierWalker&walker)
		{
			seq.type.swap(walker.type);
		}
		SemaPolicyPush<ClassSpecifierWalker>makePolicy(cpp::class_specifier*)
		{
			return SemaPolicyPush<ClassSpecifierWalker>();
		}
		void action(cpp::class_specifier*symbol, ClassSpecifierWalker&walker)
		{
			seq.type=walker.declaration;
			setDependent(seq.type);
			templateParams=walker.templateParams;
			seq.isUnion=walker.isUnion;
		}
		SemaPolicyPush<EnumSpecifierWalker>makePolicy(cpp::enum_specifier*)
		{
			return SemaPolicyPush<EnumSpecifierWalker>();
		}
		void action(cpp::enum_specifier*symbol, EnumSpecifierWalker&walker)
		{
			seq.type=walker.declaration;
		}
		SemaPolicyIdentity makePolicy(cpp::decl_specifier_default*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::decl_specifier_default*symbol)
		{
			if(symbol->id==cpp::decl_specifier_default::TYPEDEF)
			{
				seq.specifiers.isTypedef=true;
			}
			else if(symbol->id==cpp::decl_specifier_default::FRIEND)
			{
				seq.specifiers.isFriend=true;
			}
		}
		SemaPolicyIdentity makePolicy(cpp::storage_class_specifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::storage_class_specifier*symbol)
		{
			if(symbol->id==cpp::storage_class_specifier::STATIC)
			{
				seq.specifiers.isStatic=true;
			}
			else if(symbol->id==cpp::storage_class_specifier::EXTERN)
			{
				seq.specifiers.isExtern=true;
			}
		}
		SemaPolicyIdentity makePolicy(cpp::cv_qualifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::cv_qualifier*symbol)
		{
			if(symbol->id==cpp::cv_qualifier::CONST)
			{
				seq.qualifiers.isConst=true;
			}
			else if(symbol->id==cpp::cv_qualifier::VOLATILE)
			{
				seq.qualifiers.isVolatile=true;
			}
		}
	};
	struct TryBlockWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		TryBlockWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<CompoundStatementWalker>makePolicy(cpp::compound_statement*)
		{
			return SemaPolicyPush<CompoundStatementWalker>();
		}
		void action(cpp::compound_statement*symbol, CompoundStatementWalker&walker)
		{
		}
		SemaPolicyPush<HandlerSeqWalker>makePolicy(cpp::handler_seq*)
		{
			return SemaPolicyPush<HandlerSeqWalker>();
		}
		void action(cpp::handler_seq*symbol, HandlerSeqWalker&walker)
		{
		}
	};
	struct LabeledStatementWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		LabeledStatementWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::identifier*symbol)
		{
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::constant_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::constant_expression*symbol, ExpressionWalker&walker)
		{
			if(!(walker.expression.isConstant))
			{
				throw SemanticError();
			};
		}
		SemaPolicyPush<StatementWalker>makePolicy(cpp::statement*)
		{
			return SemaPolicyPush<StatementWalker>();
		}
		void action(cpp::statement*symbol, StatementWalker&walker)
		{
		}
	};
	struct StatementWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		StatementWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::simple_declaration*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::simple_declaration*symbol, SimpleDeclarationWalker&walker)
		{
		}
		SemaPolicyPush<TryBlockWalker>makePolicy(cpp::try_block*)
		{
			return SemaPolicyPush<TryBlockWalker>();
		}
		void action(cpp::try_block*symbol, TryBlockWalker&walker)
		{
		}
		SemaPolicyPush<NamespaceAliasDefinitionWalker>makePolicy(cpp::namespace_alias_definition*)
		{
			return SemaPolicyPush<NamespaceAliasDefinitionWalker>();
		}
		void action(cpp::namespace_alias_definition*symbol, NamespaceAliasDefinitionWalker&walker)
		{
		}
		SemaPolicyPush<ControlStatementWalker>makePolicy(cpp::selection_statement*)
		{
			return SemaPolicyPush<ControlStatementWalker>();
		}
		void action(cpp::selection_statement*symbol, ControlStatementWalker&walker)
		{
		}
		SemaPolicyPush<ControlStatementWalker>makePolicy(cpp::iteration_statement*)
		{
			return SemaPolicyPush<ControlStatementWalker>();
		}
		void action(cpp::iteration_statement*symbol, ControlStatementWalker&walker)
		{
		}
		SemaPolicyPush<CompoundStatementWalker>makePolicy(cpp::compound_statement*)
		{
			return SemaPolicyPush<CompoundStatementWalker>();
		}
		void action(cpp::compound_statement*symbol, CompoundStatementWalker&walker)
		{
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::expression_statement*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::expression_statement*symbol, ExpressionWalker&walker)
		{
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::jump_statement_return*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::jump_statement_return*symbol, ExpressionWalker&walker)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::jump_statement_goto*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::jump_statement_goto*symbol)
		{
		}
		SemaPolicyPush<LabeledStatementWalker>makePolicy(cpp::labeled_statement*)
		{
			return SemaPolicyPush<LabeledStatementWalker>();
		}
		void action(cpp::labeled_statement*symbol, LabeledStatementWalker&walker)
		{
		}
		SemaPolicyPush<UsingDeclarationWalker>makePolicy(cpp::using_declaration*)
		{
			return SemaPolicyPush<UsingDeclarationWalker>();
		}
		void action(cpp::using_declaration*symbol, UsingDeclarationWalker&walker)
		{
		}
		SemaPolicyPush<UsingDirectiveWalker>makePolicy(cpp::using_directive*)
		{
			return SemaPolicyPush<UsingDirectiveWalker>();
		}
		void action(cpp::using_directive*symbol, UsingDirectiveWalker&walker)
		{
		}
	};
	struct ControlStatementWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		ControlStatementWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		void action(cpp::terminal<boost::wave::T_LEFTPAREN>symbol)
		{
			pushScope(newScope(enclosing->getUniqueName(), SCOPETYPE_LOCAL));
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::condition_init*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::condition_init*symbol, SimpleDeclarationWalker&walker)
		{
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::simple_declaration*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::simple_declaration*symbol, SimpleDeclarationWalker&walker)
		{
		}
		SemaPolicyPush<StatementWalker>makePolicy(cpp::statement*)
		{
			return SemaPolicyPush<StatementWalker>();
		}
		void action(cpp::statement*symbol, StatementWalker&walker)
		{
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::expression*symbol, ExpressionWalker&walker)
		{
		}
	};
	struct CompoundStatementWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		CompoundStatementWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		void action(cpp::terminal<boost::wave::T_LEFTBRACE>symbol)
		{
			pushScope(newScope(enclosing->getUniqueName(), SCOPETYPE_LOCAL));
		}
		SemaPolicyPush<StatementWalker>makePolicy(cpp::statement*)
		{
			return SemaPolicyPush<StatementWalker>();
		}
		void action(cpp::statement*symbol, StatementWalker&walker)
		{
		}
	};
	struct HandlerWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		HandlerWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		void action(cpp::terminal<boost::wave::T_CATCH>symbol)
		{
			pushScope(newScope(enclosing->getUniqueName(), SCOPETYPE_LOCAL));
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::exception_declaration_default*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::exception_declaration_default*symbol, SimpleDeclarationWalker&walker)
		{
		}
		SemaPolicyPush<CompoundStatementWalker>makePolicy(cpp::compound_statement*)
		{
			return SemaPolicyPush<CompoundStatementWalker>();
		}
		void action(cpp::compound_statement*symbol, CompoundStatementWalker&walker)
		{
		}
	};
	struct HandlerSeqWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		HandlerSeqWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<HandlerWalker>makePolicy(cpp::handler*)
		{
			return SemaPolicyPush<HandlerWalker>();
		}
		void action(cpp::handler*symbol, HandlerWalker&walker)
		{
		}
	};
	struct QualifiedTypeNameWalker: public WalkerQualified
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		QualifiedTypeNameWalker(const WalkerState&state): WalkerQualified(state)
		{
		}
		void action(cpp::terminal<boost::wave::T_COLON_COLON>symbol)
		{
			setQualifyingGlobal();
		}
		SemaPolicyPushCached<NestedNameSpecifierWalker>makePolicy(cpp::nested_name_specifier*)
		{
			return SemaPolicyPushCached<NestedNameSpecifierWalker>();
		}
		void action(cpp::nested_name_specifier*symbol, NestedNameSpecifierWalker&walker)
		{
			swapQualifying(walker.qualifying);
		}
		SemaPolicyPushChecked<TypeNameWalker>makePolicy(cpp::class_name*)
		{
			return SemaPolicyPushChecked<TypeNameWalker>();
		}
		bool action(cpp::class_name*symbol, TypeNameWalker&walker)
		{
			if(walker.filter.nonType!=0)
			{
				return reportIdentifierMismatch(symbol, walker.filter.nonType->getName(), walker.filter.nonType, "type-name");
			}
			return true;
		}
	};
	struct MemInitializerWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		MemInitializerWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<QualifiedTypeNameWalker>makePolicy(cpp::mem_initializer_id_base*)
		{
			return SemaPolicyPush<QualifiedTypeNameWalker>();
		}
		void action(cpp::mem_initializer_id_base*symbol, QualifiedTypeNameWalker&walker)
		{
		}
		SemaPolicyIdentityChecked makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityChecked();
		}
		bool action(cpp::identifier*symbol)
		{
			if(!(getQualifyingScope()==0))
			{
				throw SemanticError();
			};
			LookupResultRef declaration=findDeclaration(symbol->value);
			if(declaration==&gUndeclared||!isObject(*declaration))
			{
				return reportIdentifierMismatch(symbol, symbol->value, declaration, "object-name");
			}
			setDecoration(&symbol->value, declaration);
			return true;
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::expression_list*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::expression_list*symbol, ExpressionWalker&walker)
		{
		}
	};
	struct MemberDeclaratorBitfieldWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		IdentifierPtr id;
		MemberDeclaratorBitfieldWalker(const WalkerState&state): WalkerBase(state), id(0)
		{
		}
		SemaPolicyIdentityCached makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentityCached();
		}
		void action(cpp::identifier*symbol)
		{
			id=&symbol->value;
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::constant_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::constant_expression*symbol, ExpressionWalker&walker)
		{
			if(!(isDependent(walker.valueDependent)||walker.expression.isConstant))
			{
				throw SemanticError();
			};
		}
	};
	struct TypeIdWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		TypeId type;
		TypeIdWalker(const WalkerState&state): WalkerBase(state), type(0, context)
		{
		}
		void commit()
		{
			makeUniqueTypeSafe(type);
		}
		void action(cpp::terminal<boost::wave::T_OPERATOR>symbol)
		{
		}
		SemaPolicyPush<DeclSpecifierSeqWalker>makePolicy(cpp::type_specifier_seq*)
		{
			return SemaPolicyPush<DeclSpecifierSeqWalker>();
		}
		void action(cpp::type_specifier_seq*symbol, DeclSpecifierSeqWalker&walker)
		{
			walker.commit();
			type.swap(walker.seq.type);
			type.qualifiers=walker.seq.qualifiers;
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::abstract_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::abstract_declarator*symbol, DeclaratorWalker&walker)
		{
			type.typeSequence=walker.typeSequence;
			setDependent(type.dependent, walker.dependent);
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::conversion_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::conversion_declarator*symbol, DeclaratorWalker&walker)
		{
			walker.pushPointerType(symbol->op);
			type.typeSequence=walker.typeSequence;
			setDependent(type.dependent, walker.dependent);
		}
	};
	struct NewTypeWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		TypeId type;
		Dependent valueDependent;
		NewTypeWalker(const WalkerState&state): WalkerBase(state), type(0, context)
		{
		}
		void action(cpp::terminal<boost::wave::T_OPERATOR>symbol)
		{
		}
		SemaPolicyPush<DeclSpecifierSeqWalker>makePolicy(cpp::type_specifier_seq*)
		{
			return SemaPolicyPush<DeclSpecifierSeqWalker>();
		}
		void action(cpp::type_specifier_seq*symbol, DeclSpecifierSeqWalker&walker)
		{
			walker.commit();
			type.swap(walker.seq.type);
			type.qualifiers=walker.seq.qualifiers;
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::new_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::new_declarator*symbol, DeclaratorWalker&walker)
		{
			addDependent(valueDependent, walker.valueDependent);
			type.typeSequence=walker.typeSequence;
			setDependent(type.dependent, walker.dependent);
		}
	};
	struct IsTemplateName
	{
		WalkerState&context;
		IsTemplateName(WalkerState&context): context(context)
		{
		}
		bool operator()(Identifier&id)const
		{
			LookupResultRef declaration=context.findDeclaration(id);
			return declaration!=&gUndeclared&&isTemplateName(*declaration);
		}
	};
	struct InitializerWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		ExpressionWrapper expression;
		Dependent valueDependent;
		InitializerWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::assignment_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::assignment_expression*symbol, ExpressionWalker&walker)
		{
			expression=walker.expression;
			addDependent(valueDependent, walker.valueDependent);
		}
	};
	struct MemInitializerClauseWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		MemInitializerClauseWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<MemInitializerWalker>makePolicy(cpp::mem_initializer*)
		{
			return SemaPolicyPush<MemInitializerWalker>();
		}
		void action(cpp::mem_initializer*symbol, MemInitializerWalker&walker)
		{
		}
	};
	struct StatementSeqWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		StatementSeqWalker(const WalkerState&state): WalkerBase(state)
		{
		}
		SemaPolicyPush<StatementWalker>makePolicy(cpp::statement*)
		{
			return SemaPolicyPush<StatementWalker>();
		}
		void action(cpp::statement*symbol, StatementWalker&walker)
		{
		}
	};
	struct DeclarationSuffixWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationWalkerArgs args;
		const DeclSpecifierSeq&seq;
		TypeId type;
		DeclarationPtr declaration;
		IdentifierPtr id;
		ScopePtr parent;
		ScopePtr enclosed;
		Dependent typeDependent;
		Dependent valueDependent;
		cpp::default_argument*defaultArgument;
		bool isConversionFunction;
		CvQualifiers conversionFunctionQualifiers;
		DeclarationSuffixWalker(const WalkerState&state, DeclarationWalkerArgs args, const DeclSpecifierSeq&seq): WalkerBase(state), args(args), seq(seq), type(0, context), declaration(0), id(&gAnonymousId), parent(state.enclosing), defaultArgument(0), enclosed(0), isConversionFunction(false)
		{
			*static_cast<Type*>(&type)=seq.type;
			type.qualifiers=seq.qualifiers;
			declareEts(type, seq.forward);
		}
		void commit()
		{
			if(id!=0)
			{
				if(id==&gAnonymousId&&!(args.isParameter||args.templateParameter!=INDEX_INVALID))
				{
					id=0;
					return ;
				}
				if(isConversionFunction)
				{
					type.typeSequence.push_back(DeclaratorFunctionType(Parameters(), conversionFunctionQualifiers));
				}
				DeclarationPtr tmpDependent=type.dependent;
				setDependent(type.dependent, typeDependent);
				makeUniqueTypeSafe(type);
				if(enclosed==0&&templateParamScope!=0)
				{
					templateParamScope->parent=parent;
					enclosed=templateParamScope;
				}
				declaration=declareObject(parent, id, type, enclosed, seq.specifiers, args.templateParameter, valueDependent);
				enclosing=parent;
				if(enclosed!=0)
				{
					enclosed->name=declaration->getName();
					enclosing=enclosed;
				}
				clearTemplateParams();
				id=0;
				type.unique=0;
				type.isDependent=false;
				type.dependent=tmpDependent;
			}
		}
		SemaPolicyPushCached<DeclaratorWalker>makePolicy(cpp::declarator*)
		{
			return SemaPolicyPushCached<DeclaratorWalker>();
		}
		void action(cpp::declarator*symbol, DeclaratorWalker&walker)
		{
			parent=walker.enclosing;
			id=walker.id;
			enclosed=walker.paramScope;
			type.typeSequence=walker.typeSequence;
			addDependent(typeDependent, walker.dependent);
			addDependent(valueDependent, walker.valueDependent);
			if(walker.qualifying!=gUniqueTypeNull)
			{
				if(!(walker.qualifying.isSimple()))
				{
					throw SemanticError();
				};
				enclosingType=&getSimpleType(walker.qualifying.value);
				enclosingDependent=walker.enclosingDependent;
			}
			templateParams=walker.templateParams;
			if(walker.conversionType.declaration!=0)
			{
				conversionFunctionQualifiers=getDeclaratorFunctionType(type.typeSequence.get()).qualifiers;
				type.swap(walker.conversionType);
				isConversionFunction=true;
			}
		}
		SemaPolicyPush<DeclaratorWalker>makePolicy(cpp::abstract_declarator*)
		{
			return SemaPolicyPush<DeclaratorWalker>();
		}
		void action(cpp::abstract_declarator*symbol, DeclaratorWalker&walker)
		{
			enclosed=walker.paramScope;
			type.typeSequence=walker.typeSequence;
			addDependent(typeDependent, walker.dependent);
		}
		SemaPolicyPush<MemberDeclaratorBitfieldWalker>makePolicy(cpp::member_declarator_bitfield*)
		{
			return SemaPolicyPush<MemberDeclaratorBitfieldWalker>();
		}
		void action(cpp::member_declarator_bitfield*symbol, MemberDeclaratorBitfieldWalker&walker)
		{
			if(walker.id!=0)
			{
				DeclarationPtr tmpDependent=type.dependent;
				setDependent(type.dependent, typeDependent);
				makeUniqueTypeSafe(type);
				DeclarationInstanceRef instance=pointOfDeclaration(context, enclosing, *walker.id, type, 0, seq.specifiers);
				trackDeclaration(instance);
				setDecoration(walker.id, instance);
				declaration=instance;
				type.unique=0;
				type.isDependent=false;
				type.dependent=tmpDependent;
			}
		}
		void action(cpp::terminal<boost::wave::T_ASSIGN>symbol)
		{
			commit();
		}
		void action(cpp::terminal<boost::wave::T_LEFTPAREN>symbol)
		{
			commit();
		}
		void action(cpp::terminal<boost::wave::T_TRY>symbol)
		{
			commit();
		}
		void action(cpp::terminal<boost::wave::T_LEFTBRACE>symbol)
		{
			commit();
			if(!(declaration!=0))
			{
				throw SemanticError();
			};
			declaration->isFunctionDefinition=true;
			pushScope(newScope(enclosing->getUniqueName(), SCOPETYPE_LOCAL));
		}
		void action(cpp::terminal<boost::wave::T_COMMA>symbol)
		{
			commit();
		}
		void action(cpp::terminal<boost::wave::T_SEMICOLON>symbol)
		{
			commit();
		}
		void action(cpp::terminal<boost::wave::T_COLON>symbol)
		{
			commit();
		}
		struct DeferDefaultArgument
		{
			static bool isDeferredParse(InitializerWalker&walker)
			{
				return walker.enclosingDeferred!=0;
			}
			static SkipDefaultArgument<IsTemplateName>getSkipFunc(InitializerWalker&walker)
			{
				return makeSkipDefaultArgument(IsTemplateName(walker));
			}
			static DeferredSymbolsList&getDeferredSymbolsList(InitializerWalker&walker)
			{
				return walker.enclosingDeferred->first;
			}
		};
		typedef SemaPolicyPushDeferred<InitializerWalker, DeferDefaultArgument>SemaPolicyDefaultArgument;
		SemaPolicyDefaultArgument makePolicy(cpp::default_argument*)
		{
			return SemaPolicyDefaultArgument();
		}
		void action(cpp::default_argument*symbol, InitializerWalker&walker)
		{
			if(!args.isParameter&&WalkerState::enclosingDeferred==0)
			{
				declaration->initializer=walker.expression;
				addDependent(declaration->valueDependent, walker.valueDependent);
			}
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::assignment_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::assignment_expression*symbol, ExpressionWalker&walker)
		{
			if(!args.isParameter)
			{
				declaration->initializer=walker.expression;
				addDependent(declaration->valueDependent, walker.valueDependent);
			}
		}
		SemaPolicyPush<InitializerWalker>makePolicy(cpp::initializer_clause*)
		{
			return SemaPolicyPush<InitializerWalker>();
		}
		void action(cpp::initializer_clause*symbol, InitializerWalker&walker)
		{
			if(!(declaration!=0))
			{
				throw SemanticError();
			};
			declaration->initializer=walker.expression;
			addDependent(declaration->valueDependent, walker.valueDependent);
		}
		SemaPolicyPush<InitializerWalker>makePolicy(cpp::expression_list*)
		{
			return SemaPolicyPush<InitializerWalker>();
		}
		void action(cpp::expression_list*symbol, InitializerWalker&walker)
		{
			if(!(declaration!=0))
			{
				throw SemanticError();
			};
			declaration->initializer=walker.expression;
			addDependent(declaration->valueDependent, walker.valueDependent);
		}
		SemaPolicyPush<ExpressionWalker>makePolicy(cpp::constant_expression*)
		{
			return SemaPolicyPush<ExpressionWalker>();
		}
		void action(cpp::constant_expression*symbol, ExpressionWalker&walker)
		{
			if(!(declaration!=0))
			{
				throw SemanticError();
			};
			if(!(isDependent(walker.valueDependent)||walker.expression.isConstant))
			{
				throw SemanticError();
			};
			declaration->initializer=walker.expression;
			addDependent(declaration->valueDependent, walker.valueDependent);
		}
		typedef void(*SkipFunc)(Parser&);
		template<typename WalkerType, SkipFunc skipFunc>
		struct DeferBody
		{
			static bool isDeferredParse(WalkerType&walker)
			{
				return walker.enclosingDeferred!=0;
			}
			static SkipFunc getSkipFunc(WalkerType&walker)
			{
				return skipFunc;
			}
			static DeferredSymbolsList&getDeferredSymbolsList(WalkerType&walker)
			{
				return walker.enclosingDeferred->second;
			}
		};
		typedef DeferBody<MemInitializerClauseWalker, skipMemInitializerClause>DeferMemInitializerClause;
		typedef SemaPolicyPushDeferred<MemInitializerClauseWalker, DeferMemInitializerClause>SemaPolicyDeferMemInitializerClause;
		SemaPolicyDeferMemInitializerClause makePolicy(cpp::mem_initializer_clause*)
		{
			return SemaPolicyDeferMemInitializerClause();
		}
		void action(cpp::mem_initializer_clause*symbol, MemInitializerClauseWalker&walker)
		{
		}
		typedef DeferBody<StatementSeqWalker, skipBraced>DeferFunctionBody;
		typedef SemaPolicyPushDeferred<StatementSeqWalker, DeferFunctionBody>SemaPolicyDeferFunctionBody;
		SemaPolicyDeferFunctionBody makePolicy(cpp::statement_seq_wrapper*)
		{
			return SemaPolicyDeferFunctionBody();
		}
		void action(cpp::statement_seq_wrapper*symbol, StatementSeqWalker&walker)
		{
		}
		SemaPolicyPush<HandlerSeqWalker>makePolicy(cpp::handler_seq*)
		{
			return SemaPolicyPush<HandlerSeqWalker>();
		}
		void action(cpp::handler_seq*symbol, HandlerSeqWalker&walker)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::parameter_declaration_default*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::parameter_declaration_default*symbol)
		{
			defaultArgument=symbol->init;
		}
		SemaPolicyIdentity makePolicy(cpp::parameter_declaration_abstract*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::parameter_declaration_abstract*symbol)
		{
			defaultArgument=symbol->init;
		}
	};
	struct SimpleDeclarationWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationWalkerArgs args;
		DeclSpecifierSeq seq;
		DeclarationPtr declaration;
		cpp::default_argument*defaultArgument;
		SimpleDeclarationWalker(const WalkerState&state, DeclarationWalkerArgs args=DeclarationWalkerArgs()): WalkerBase(state), args(args), seq(&gCtor, context), declaration(0), defaultArgument(0)
		{
		}
		SemaPolicyPush<DeclSpecifierSeqWalker>makePolicy(cpp::decl_specifier_seq*)
		{
			return SemaPolicyPush<DeclSpecifierSeqWalker>();
		}
		void action(cpp::decl_specifier_seq*symbol, DeclSpecifierSeqWalker&walker)
		{
			seq=walker.seq;
			templateParams=walker.templateParams;
		}
		SemaPolicyPush<DeclSpecifierSeqWalker>makePolicy(cpp::type_specifier_seq*)
		{
			return SemaPolicyPush<DeclSpecifierSeqWalker>();
		}
		void action(cpp::type_specifier_seq*symbol, DeclSpecifierSeqWalker&walker)
		{
			seq=walker.seq;
			templateParams=walker.templateParams;
		}
		SemaPolicyIdentity makePolicy(cpp::function_specifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::function_specifier*symbol)
		{
			if(symbol->id==cpp::function_specifier::EXPLICIT)
			{
				seq.specifiers.isExplicit=true;
			}
		}
		typedef Args2<DeclarationWalkerArgs, const DeclSpecifierSeq&>DeclarationSuffixWalkerArgs;
		typedef SemaPolicyGeneric<SemaPush<DeclarationSuffixWalker, DeclarationSuffixWalkerArgs> >SemaPolicyDeclarationSuffix;
		SemaPolicyDeclarationSuffix makePolicy(cpp::simple_declaration_named*)
		{
			return SemaPolicyDeclarationSuffix(DeclarationSuffixWalkerArgs(args, seq));
		}
		void action(cpp::simple_declaration_named*symbol, DeclarationSuffixWalker&walker)
		{
			walker.commit();
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			declaration=walker.declaration;
		}
		SemaPolicyDeclarationSuffix makePolicy(cpp::member_declaration_named*)
		{
			return SemaPolicyDeclarationSuffix(DeclarationSuffixWalkerArgs(args, seq));
		}
		void action(cpp::member_declaration_named*symbol, DeclarationSuffixWalker&walker)
		{
			walker.commit();
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			declaration=walker.declaration;
		}
		SemaPolicyDeclarationSuffix makePolicy(cpp::member_declaration_bitfield*)
		{
			return SemaPolicyDeclarationSuffix(DeclarationSuffixWalkerArgs(args, seq));
		}
		void action(cpp::member_declaration_bitfield*symbol, DeclarationSuffixWalker&walker)
		{
			walker.commit();
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			declaration=walker.declaration;
		}
		SemaPolicyDeclarationSuffix makePolicy(cpp::parameter_declaration_suffix*)
		{
			return SemaPolicyDeclarationSuffix(DeclarationSuffixWalkerArgs(args, seq));
		}
		void action(cpp::parameter_declaration_suffix*symbol, DeclarationSuffixWalker&walker)
		{
			walker.commit();
			declaration=walker.declaration;
			defaultArgument=walker.defaultArgument;
		}
		SemaPolicyDeclarationSuffix makePolicy(cpp::function_definition*)
		{
			return SemaPolicyDeclarationSuffix(DeclarationSuffixWalkerArgs(args, seq));
		}
		void action(cpp::function_definition*symbol, DeclarationSuffixWalker&walker)
		{
			walker.commit();
			if(!(walker.type.declaration!=0))
			{
				throw SemanticError();
			};
			declaration=walker.declaration;
		}
		SemaPolicyDeclarationSuffix makePolicy(cpp::condition_declarator*)
		{
			return SemaPolicyDeclarationSuffix(DeclarationSuffixWalkerArgs(args, seq));
		}
		void action(cpp::condition_declarator*symbol, DeclarationSuffixWalker&walker)
		{
			walker.commit();
			declaration=walker.declaration;
		}
		SemaPolicyDeclarationSuffix makePolicy(cpp::exception_declarator*)
		{
			return SemaPolicyDeclarationSuffix(DeclarationSuffixWalkerArgs(args, seq));
		}
		void action(cpp::exception_declarator*symbol, DeclarationSuffixWalker&walker)
		{
			walker.commit();
			declaration=walker.declaration;
		}
		SemaPolicyIdentity makePolicy(cpp::type_declaration_suffix*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::type_declaration_suffix*symbol)
		{
			declaration=seq.type.declaration;
			if(seq.forward!=0)
			{
				bool isSpecialization=!isClassKey(*seq.type.declaration);
				if(isSpecialization&&(seq.specifiers.isFriend||isExplicitInstantiation))
				{
				}
				else if(seq.specifiers.isFriend)
				{
				}
				else
				{
					DeclarationInstanceRef instance=pointOfDeclaration(context, enclosing, *seq.forward, TypeId(&gClass, ParserAllocatorWrapper<int>(NullParserAllocator())), 0, DeclSpecifiers(), templateParams!=0, getTemplateParams(), isSpecialization, seq.type.templateArguments);
					trackDeclaration(instance);
					setDecoration(seq.forward, instance);
					declaration=instance;
					if(declaration->templateParamScope==0)
					{
						declaration->templateParamScope=templateParamScope;
					}
				}
				seq.type=TypeId(declaration, context);
			}
			else if(declaration!=0&&declaration->isTemplate&&templateParams!=0)
			{
				if(!(!declaration->isSpecialization))
				{
					throw SemanticError();
				};
				mergeTemplateParamDefaults(*declaration, *templateParams);
			}
			if(seq.isUnion&&isAnonymous(*declaration))
			{
				for(Scope::Declarations::iterator i=declaration->enclosed->declarations.begin();
				i!=declaration->enclosed->declarations.end();
				++i)
				{
					Declaration&member=*(*i).second;
					if(isAnonymous(member))
					{
						member.setName(enclosing->getUniqueName());
						if(member.enclosed!=0)
						{
							member.enclosed->name=member.getName();
						}
					}
					else
					{
						const DeclarationInstance*holder=::findDeclaration(enclosing->declarations, member.getName());
						if(holder!=0)
						{
							Declaration*declaration=*holder;
							printPosition(member.getName().source);
							std::cout<<"'"<<member.getName().value.c_str()<<"': anonymous union member already declared"<<std::endl;
							printPosition(declaration->getName().source);
							throw SemanticError();
						}
					}
					member.scope=enclosing;
					Identifier*id=&member.getName();
					enclosing->declarations.insert(DeclarationInstance(&member, context.declarationCount++));
					enclosing->declarationList.push_back(&member);
				}
				declaration->enclosed=0;
			}
		}
	};
	struct TypeParameterWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		TemplateParameter param;
		IdentifierPtr id;
		TemplateArgument argument;
		TemplateParameters params;
		size_t templateParameter;
		TypeParameterWalker(const WalkerState&state, size_t templateParameter): WalkerBase(state), param(context), id(&gAnonymousId), argument(context), params(context), templateParameter(templateParameter)
		{
		}
		void commit()
		{
			if(!(param.declaration==0))
			{
				throw SemanticError();
			};
			DeclarationInstanceRef instance=pointOfDeclaration(context, enclosing, *id, TypeId(&gParam, ParserAllocatorWrapper<int>(NullParserAllocator())), 0, DECLSPEC_TYPEDEF, !params.empty(), params, false, TEMPLATEARGUMENTS_NULL, templateParameter);
			trackDeclaration(instance);
			if(id!=&gAnonymousId)
			{
				setDecoration(id, instance);
			}
			param=instance;
			setDependent(param);
			makeUniqueTypeSafe(param);
			param.argument.swap(argument);
		}
		SemaPolicyIdentity makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::identifier*symbol)
		{
			id=&symbol->value;
		}
		SemaPolicyPush<TypeIdWalker>makePolicy(cpp::type_id*)
		{
			return SemaPolicyPush<TypeIdWalker>();
		}
		void action(cpp::type_id*symbol, TypeIdWalker&walker)
		{
			if(!(params.empty()))
			{
				throw SemanticError();
			};
			walker.commit();
			argument.type.swap(walker.type);
		}
		SemaPolicyPush<TemplateParameterClauseWalker>makePolicy(cpp::template_parameter_clause*)
		{
			return SemaPolicyPush<TemplateParameterClauseWalker>();
		}
		void action(cpp::template_parameter_clause*symbol, TemplateParameterClauseWalker&walker)
		{
			params.swap(walker.params);
		}
		SemaPolicyPushChecked<IdExpressionWalker>makePolicy(cpp::id_expression*)
		{
			return SemaPolicyPushChecked<IdExpressionWalker>();
		}
		bool action(cpp::id_expression*symbol, IdExpressionWalker&walker)
		{
			LookupResultRef declaration=walker.declaration;
			if(declaration!=0)
			{
				if(declaration==&gUndeclared||!isTemplateName(*declaration))
				{
					return reportIdentifierMismatch(symbol, *walker.id, declaration, "template-name");
				}
				setDecoration(walker.id, declaration);
			}
			return true;
		}
	};
	struct TemplateParameterListWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		TemplateParameter param;
		TemplateParameters params;
		size_t count;
		TemplateParameterListWalker(const WalkerState&state, size_t count): WalkerBase(state), param(context), params(context), count(count)
		{
		}
		void commit()
		{
			params.push_front(param);
		}
		SemaPolicyPushIndex<TypeParameterWalker>makePolicy(cpp::type_parameter_default*)
		{
			return SemaPolicyPushIndex<TypeParameterWalker>(count);
		}
		void action(cpp::type_parameter_default*symbol, TypeParameterWalker&walker)
		{
			walker.commit();
			param.swap(walker.param);
			++count;
		}
		SemaPolicyPushIndex<TypeParameterWalker>makePolicy(cpp::type_parameter_template*)
		{
			return SemaPolicyPushIndex<TypeParameterWalker>(count);
		}
		void action(cpp::type_parameter_template*symbol, TypeParameterWalker&walker)
		{
			walker.commit();
			param.swap(walker.param);
			++count;
		}
		SemaPolicyParameterDeclaration<SimpleDeclarationWalker>makePolicy(cpp::parameter_declaration*)
		{
			return SemaPolicyParameterDeclaration<SimpleDeclarationWalker>(DeclarationWalkerArgs(false, count));
		}
		void action(cpp::parameter_declaration*symbol, SimpleDeclarationWalker&walker)
		{
			if(!(walker.declaration!=0))
			{
				throw SemanticError();
			};
			param=walker.declaration;
			if(walker.defaultArgument!=0)
			{
				addDependent(param.argument.valueDependent, walker.declaration->valueDependent);
				param.argument.type=&gNonType;
				param.argument.expression=walker.declaration->initializer;
			}
			++count;
		}
		SemaPolicyPushIndex<TemplateParameterListWalker>makePolicy(cpp::template_parameter_list*)
		{
			return SemaPolicyPushIndex<TemplateParameterListWalker>(count);
		}
		void action(cpp::template_parameter_list*symbol, TemplateParameterListWalker&walker)
		{
			walker.commit();
			params.swap(walker.params);
		}
	};
	struct TemplateParameterClauseWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		TemplateParameters params;
		TemplateParameterClauseWalker(const WalkerState&state): WalkerBase(state), params(context)
		{
			if(templateParamScope!=0)
			{
				pushScope(templateParamScope);
			}
			pushScope(newScope(makeIdentifier("$template"), SCOPETYPE_TEMPLATE));
			clearTemplateParams();
			enclosing->templateDepth=templateDepth;
			enclosingDeferred=0;
		}
		SemaPolicyPushIndex<TemplateParameterListWalker>makePolicy(cpp::template_parameter_list*)
		{
			return SemaPolicyPushIndex<TemplateParameterListWalker>(0);
		}
		void action(cpp::template_parameter_list*symbol, TemplateParameterListWalker&walker)
		{
			walker.commit();
			params.swap(walker.params);
		}
	};
	struct TemplateDeclarationWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		TemplateParameters params;
		TemplateDeclarationWalker(const WalkerState&state): WalkerBase(state), declaration(0), params(context)
		{
			++templateDepth;
			templateParams=&TEMPLATEPARAMETERS_NULL;
		}
		SemaPolicyPush<TemplateParameterClauseWalker>makePolicy(cpp::template_parameter_clause*)
		{
			return SemaPolicyPush<TemplateParameterClauseWalker>();
		}
		void action(cpp::template_parameter_clause*symbol, TemplateParameterClauseWalker&walker)
		{
			templateParamScope=walker.enclosing;
			enclosing=walker.enclosing->parent;
			params.swap(walker.params);
			templateParams=&params;
		}
		SemaPolicyPushSrc<DeclarationWalker>makePolicy(cpp::declaration*)
		{
			return SemaPolicyPushSrc<DeclarationWalker>();
		}
		void action(cpp::declaration*symbol, DeclarationWalker&walker)
		{
			declaration=walker.declaration;
			if(!(declaration!=0))
			{
				throw SemanticError();
			};
		}
		SemaPolicyPush<MemberDeclarationWalker>makePolicy(cpp::member_declaration*)
		{
			return SemaPolicyPush<MemberDeclarationWalker>();
		}
		void action(cpp::member_declaration*symbol, MemberDeclarationWalker&walker)
		{
			declaration=walker.declaration;
			if(!(declaration!=0))
			{
				throw SemanticError();
			};
		}
	};
	struct ExplicitInstantiationWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		ExplicitInstantiationWalker(const WalkerState&state): WalkerBase(state), declaration(0)
		{
		}
		void action(cpp::terminal<boost::wave::T_TEMPLATE>symbol)
		{
			isExplicitInstantiation=true;
		}
		SemaPolicyPush<DeclarationWalker>makePolicy(cpp::declaration*)
		{
			return SemaPolicyPush<DeclarationWalker>();
		}
		void action(cpp::declaration*symbol, DeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
	};
	struct DeclarationWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		DeclarationWalker(const WalkerState&state): WalkerBase(state), declaration(0)
		{
		}
		SemaPolicyPush<NamespaceWalker>makePolicy(cpp::linkage_specification*)
		{
			return SemaPolicyPush<NamespaceWalker>();
		}
		void action(cpp::linkage_specification*symbol, NamespaceWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<NamespaceWalker>makePolicy(cpp::namespace_definition*)
		{
			return SemaPolicyPush<NamespaceWalker>();
		}
		void action(cpp::namespace_definition*symbol, NamespaceWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<NamespaceAliasDefinitionWalker>makePolicy(cpp::namespace_alias_definition*)
		{
			return SemaPolicyPush<NamespaceAliasDefinitionWalker>();
		}
		void action(cpp::namespace_alias_definition*symbol, NamespaceAliasDefinitionWalker&walker)
		{
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::general_declaration*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::general_declaration*symbol, SimpleDeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::simple_declaration*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::simple_declaration*symbol, SimpleDeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<SimpleDeclarationWalker>makePolicy(cpp::constructor_definition*)
		{
			return SemaPolicyPush<SimpleDeclarationWalker>();
		}
		void action(cpp::constructor_definition*symbol, SimpleDeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<TemplateDeclarationWalker>makePolicy(cpp::template_declaration*)
		{
			return SemaPolicyPush<TemplateDeclarationWalker>();
		}
		void action(cpp::template_declaration*symbol, TemplateDeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<ExplicitInstantiationWalker>makePolicy(cpp::explicit_instantiation*)
		{
			return SemaPolicyPush<ExplicitInstantiationWalker>();
		}
		void action(cpp::explicit_instantiation*symbol, ExplicitInstantiationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<TemplateDeclarationWalker>makePolicy(cpp::explicit_specialization*)
		{
			return SemaPolicyPush<TemplateDeclarationWalker>();
		}
		void action(cpp::explicit_specialization*symbol, TemplateDeclarationWalker&walker)
		{
			declaration=walker.declaration;
		}
		SemaPolicyPush<UsingDeclarationWalker>makePolicy(cpp::using_declaration*)
		{
			return SemaPolicyPush<UsingDeclarationWalker>();
		}
		void action(cpp::using_declaration*symbol, UsingDeclarationWalker&walker)
		{
		}
		SemaPolicyPush<UsingDirectiveWalker>makePolicy(cpp::using_directive*)
		{
			return SemaPolicyPush<UsingDirectiveWalker>();
		}
		void action(cpp::using_directive*symbol, UsingDirectiveWalker&walker)
		{
		}
	};
	struct NamespaceWalker: public WalkerBase
	{
		template<typename T>
		void action(T*symbol)
		{
		}
		template<LexTokenId id>
		void action(cpp::terminal<id>symbol)
		{
		}
		template<typename T>
		SemaPolicyIdentity makePolicy(T*symbol)
		{
			return SemaPolicyIdentity();
		};
		DeclarationPtr declaration;
		IdentifierPtr id;
		NamespaceWalker(WalkerContext&context): WalkerBase(context), declaration(0), id(0)
		{
			pushScope(&context.global);
		}
		NamespaceWalker(const WalkerState&state): WalkerBase(state), declaration(0), id(0)
		{
		}
		SemaPolicyIdentity makePolicy(cpp::identifier*)
		{
			return SemaPolicyIdentity();
		}
		void action(cpp::identifier*symbol)
		{
			id=&symbol->value;
		}
		void action(cpp::terminal<boost::wave::T_LEFTBRACE>symbol)
		{
			if(id!=0)
			{
				DeclarationInstanceRef instance=pointOfDeclaration(context, enclosing, *id, TypeId(&gNamespace, ParserAllocatorWrapper<int>(NullParserAllocator())), 0);
				trackDeclaration(instance);
				setDecoration(id, instance);
				declaration=instance;
				if(declaration->enclosed==0)
				{
					declaration->enclosed=newScope(*id, SCOPETYPE_NAMESPACE);
				}
				pushScope(declaration->enclosed);
			}
		}
		SemaPolicyPushTop<DeclarationWalker>makePolicy(cpp::declaration*)
		{
			return SemaPolicyPushTop<DeclarationWalker>();
		}
		void action(cpp::declaration*symbol, DeclarationWalker&walker)
		{
		}
	};
};
ParserAllocatorWrapper<int>getAllocator(ParserContext&context)
{
	return context.allocator;
}
cpp::declaration_seq*parseFile(ParserContext&context)
{
	gUniqueNames.clear();
	gUniqueTypes.clear();
	gUniqueExpressions.clear();
	WalkerContext&globals=*new WalkerContext(context, getAllocator(context));
	Walker::NamespaceWalker&walker=*new Walker::NamespaceWalker(globals);
	ParserGeneric<Walker::NamespaceWalker>parser(context, walker);
	cpp::symbol_sequence<cpp::declaration_seq>result(0);
	try
	{
		ProfileScope profile(gProfileParser);
		parser.parse(checkSymbolSequence(result));
	}
	catch(ParseError&)
	{
	}
	catch(SemanticError&)
	{
		printPosition(parser.context.getErrorPosition());
		std::cout<<"caught SemanticError"<<std::endl;
		throw;
	}
	catch(SymbolsError&)
	{
		printPosition(parser.context.getErrorPosition());
		std::cout<<"caught SymbolsError"<<std::endl;
		throw;
	}
	catch(TypeError&e)
	{
		e.report();
	}
	if(!context.finished())
	{
		printError(parser);
	}
	dumpProfile(gProfileIo);
	dumpProfile(gProfileWave);
	dumpProfile(gProfileParser);
	dumpProfile(gProfileLookup);
	dumpProfile(gProfileDiagnose);
	dumpProfile(gProfileAllocator);
	dumpProfile(gProfileIdentifier);
	dumpProfile(gProfileTemplateId);
	return result;
}
cpp::statement_seq*parseFunction(ParserContext&context)
{
	gUniqueNames.clear();
	gUniqueTypes.clear();
	gUniqueExpressions.clear();
	WalkerContext&globals=*new WalkerContext(context, getAllocator(context));
	Walker::CompoundStatementWalker&walker=*new Walker::CompoundStatementWalker(globals);
	ParserGeneric<Walker::CompoundStatementWalker>parser(context, walker);
	cpp::symbol_sequence<cpp::statement_seq>result(0);
	try
	{
		ProfileScope profile(gProfileParser);
		parser.parse(checkSymbolSequence(result));
	}
	catch(ParseError&)
	{
	}
	catch(TypeError&e)
	{
		e.report();
	}
	if(!context.finished())
	{
		printError(parser);
	}
	return result;
}