
extern "C"
{
	typedef unsigned int uintptr_t;
	typedef char*va_list;
}
extern "C"
{
	typedef unsigned int size_t;
	typedef size_t rsize_t;
	typedef int intptr_t;
	typedef int ptrdiff_t;
	typedef unsigned short wint_t;
	typedef unsigned short wctype_t;
	typedef int errcode;
	typedef int errno_t;
	typedef long __time32_t;
	typedef __int64 __time64_t;
	typedef __time64_t time_t;
	struct threadlocaleinfostruct;
	struct threadmbcinfostruct;
	typedef struct threadlocaleinfostruct*pthreadlocinfo;
	typedef struct threadmbcinfostruct*pthreadmbcinfo;
	struct __lc_time_data;
	typedef struct localeinfo_struct
	{
		pthreadlocinfo locinfo;
		pthreadmbcinfo mbcinfo;
	}
	_locale_tstruct, *_locale_t;
	typedef struct tagLC_ID
	{
		unsigned short wLanguage;
		unsigned short wCountry;
		unsigned short wCodePage;
	}
	LC_ID, *LPLC_ID;
	typedef struct threadlocaleinfostruct
	{
		int refcount;
		unsigned int lc_codepage;
		unsigned int lc_collate_cp;
		unsigned long lc_handle[6];
		LC_ID lc_id[6];
		struct
		{
			char*locale;
			wchar_t*wlocale;
			int*refcount;
			int*wrefcount;
		}
		lc_category[6];
		int lc_clike;
		int mb_cur_max;
		int*lconv_intl_refcount;
		int*lconv_num_refcount;
		int*lconv_mon_refcount;
		struct lconv*lconv;
		int*ctype1_refcount;
		unsigned short*ctype1;
		const unsigned short*pctype;
		const unsigned char*pclmap;
		const unsigned char*pcumap;
		struct __lc_time_data*lc_time_curr;
	}
	threadlocinfo;
}
extern "C" void _invalid_parameter(const wchar_t*, const wchar_t*, const wchar_t*, unsigned int, uintptr_t);
namespace std
{
	typedef bool _Bool;
}
typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;
namespace std
{
	class _Lockit
	{
	public:
		explicit _Lockit();
		explicit _Lockit(int);
		~_Lockit();
		static void _Lockit_ctor(int);
		static void _Lockit_dtor(int);
	private:
		static void _Lockit_ctor(_Lockit*);
		static void _Lockit_ctor(_Lockit*, int);
		static void _Lockit_dtor(_Lockit*);
		_Lockit(const _Lockit&);
		_Lockit&operator=(const _Lockit&);
		int _Locktype;
	};
	class _Mutex
	{
	public:
		_Mutex();
		~_Mutex();
		void _Lock();
		void _Unlock();
	private:
		static void _Mutex_ctor(_Mutex*);
		static void _Mutex_dtor(_Mutex*);
		static void _Mutex_Lock(_Mutex*);
		static void _Mutex_Unlock(_Mutex*);
		_Mutex(const _Mutex&);
		_Mutex&operator=(const _Mutex&);
		void*_Mtx;
	};
	class _Init_locks
	{
	public:
		_Init_locks();
		~_Init_locks();
	private:
		static void _Init_locks_ctor(_Init_locks*);
		static void _Init_locks_dtor(_Init_locks*);
	};
}
void _Atexit(void(*)(void));
typedef int _Mbstatet;
extern "C"
{
	struct _iobuf
	{
		char*_ptr;
		int _cnt;
		char*_base;
		int _flag;
		int _file;
		int _charbuf;
		int _bufsiz;
		char*_tmpfname;
	};
	typedef struct _iobuf FILE;
	FILE*__iob_func(void);
	typedef long long fpos_t;
	int _filbuf(FILE*_File);
	int _flsbuf(int _Ch, FILE*_File);
	FILE*_fsopen(const char*_Filename, const char*_Mode, int _ShFlag);
	void clearerr(FILE*_File);
	errno_t clearerr_s(FILE*_File);
	int fclose(FILE*_File);
	int _fcloseall(void);
	FILE*_fdopen(int _FileHandle, const char*_Mode);
	int feof(FILE*_File);
	int ferror(FILE*_File);
	int fflush(FILE*_File);
	int fgetc(FILE*_File);
	int _fgetchar(void);
	int fgetpos(FILE*_File, fpos_t*_Pos);
	char*fgets(char*_Buf, int _MaxCount, FILE*_File);
	int _fileno(FILE*_File);
	char*_tempnam(const char*_DirName, const char*_FilePrefix);
	int _flushall(void);
	FILE*fopen(const char*_Filename, const char*_Mode);
	errno_t fopen_s(FILE**_File, const char*_Filename, const char*_Mode);
	int fprintf(FILE*_File, const char*_Format, ...);
	int fprintf_s(FILE*_File, const char*_Format, ...);
	int fputc(int _Ch, FILE*_File);
	int _fputchar(int _Ch);
	int fputs(const char*_Str, FILE*_File);
	size_t fread(void*_DstBuf, size_t _ElementSize, size_t _Count, FILE*_File);
	size_t fread_s(void*_DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE*_File);
	FILE*freopen(const char*_Filename, const char*_Mode, FILE*_File);
	errno_t freopen_s(FILE**_File, const char*_Filename, const char*_Mode, FILE*_OldFile);
	int fscanf(FILE*_File, const char*_Format, ...);
	int _fscanf_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int fscanf_s(FILE*_File, const char*_Format, ...);
	int _fscanf_s_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int fsetpos(FILE*_File, const fpos_t*_Pos);
	int fseek(FILE*_File, long _Offset, int _Origin);
	long ftell(FILE*_File);
	int _fseeki64(FILE*_File, __int64 _Offset, int _Origin);
	__int64 _ftelli64(FILE*_File);
	size_t fwrite(const void*_Str, size_t _Size, size_t _Count, FILE*_File);
	int getc(FILE*_File);
	int getchar(void);
	int _getmaxstdio(void);
	char*gets_s(char*_Buf, rsize_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline char*gets_s(char(&_Buffer)[_SizeFIXED])
		{
			return gets_s(_Buffer, _SizeFIXED);
		}
	}
	char*gets(char*_Buffer);
	int _getw(FILE*_File);
	void perror(const char*_ErrMsg);
	int _pclose(FILE*_File);
	FILE*_popen(const char*_Command, const char*_Mode);
	int printf(const char*_Format, ...);
	int printf_s(const char*_Format, ...);
	int putc(int _Ch, FILE*_File);
	int putchar(int _Ch);
	int puts(const char*_Str);
	int _putw(int _Word, FILE*_File);
	int remove(const char*_Filename);
	int rename(const char*_OldFilename, const char*_NewFilename);
	int _unlink(const char*_Filename);
	void rewind(FILE*_File);
	int _rmtmp(void);
	int scanf(const char*_Format, ...);
	int _scanf_l(const char*_Format, _locale_t _Locale, ...);
	int scanf_s(const char*_Format, ...);
	int _scanf_s_l(const char*_Format, _locale_t _Locale, ...);
	void setbuf(FILE*_File, char*_Buffer);
	int _setmaxstdio(int _Max);
	unsigned int _set_output_format(unsigned int _Format);
	unsigned int _get_output_format(void);
	int setvbuf(FILE*_File, char*_Buf, int _Mode, size_t _Size);
	int _snprintf_s(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, ...);
	int sprintf_s(char*_DstBuf, size_t _DstSize, const char*_Format, ...);
	int _scprintf(const char*_Format, ...);
	int sscanf(const char*_Src, const char*_Format, ...);
	int _sscanf_l(const char*_Src, const char*_Format, _locale_t _Locale, ...);
	int sscanf_s(const char*_Src, const char*_Format, ...);
	int _sscanf_s_l(const char*_Src, const char*_Format, _locale_t _Locale, ...);
	int _snscanf(const char*_Src, size_t _MaxCount, const char*_Format, ...);
	int _snscanf_l(const char*_Src, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _snscanf_s(const char*_Src, size_t _MaxCount, const char*_Format, ...);
	int _snscanf_s_l(const char*_Src, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	FILE*tmpfile(void);
	errno_t tmpfile_s(FILE**_File);
	errno_t tmpnam_s(char*_Buf, rsize_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t tmpnam_s(char(&_Buf)[_SizeFIXED])
		{
			return tmpnam_s(_Buf, _SizeFIXED);
		}
	}
	char*tmpnam(char*_Buffer);
	int ungetc(int _Ch, FILE*_File);
	int vfprintf(FILE*_File, const char*_Format, va_list _ArgList);
	int vfprintf_s(FILE*_File, const char*_Format, va_list _ArgList);
	int vprintf(const char*_Format, va_list _ArgList);
	int vprintf_s(const char*_Format, va_list _ArgList);
	int vsnprintf(char*_DstBuf, size_t _MaxCount, const char*_Format, va_list _ArgList);
	int vsnprintf_s(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, va_list _ArgList);
	int _vsnprintf_s(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, va_list _ArgList);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline int _vsnprintf_s(char(&_Dest)[_SizeFIXED], size_t _Size, const char*_Format, va_list _Args)
		{
			return _vsnprintf_s(_Dest, _SizeFIXED, _Size, _Format, _Args);
		}
	}
	int _snprintf(char*_Dest, size_t _Count, const char*_Format, ...);
	int _vsnprintf(char*_Dest, size_t _Count, const char*_Format, va_list _Args);
	int vsprintf_s(char*_DstBuf, size_t _Size, const char*_Format, va_list _ArgList);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline int vsprintf_s(char(&_Dest)[_SizeFIXED], const char*_Format, va_list _Args)
		{
			return vsprintf_s(_Dest, _SizeFIXED, _Format, _Args);
		}
	}
	int sprintf(char*_Dest, const char*_Format, ...);
	int vsprintf(char*_Dest, const char*_Format, va_list _Args);
	extern "C++"
	{
		;
		;
		template<size_t _SizeFIXED>
		inline int _snprintf_s(char(&_Dest)[_SizeFIXED], size_t _Size, const char*_Format, ...)
		{
			va_list _ArgList;
			(_ArgList=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
			return _vsnprintf_s(_Dest, _SizeFIXED, _Size, _Format, _ArgList);
		};
	}
	extern "C++"
	{
		;
		;
		template<size_t _SizeFIXED>
		inline int sprintf_s(char(&_Dest)[_SizeFIXED], const char*_Format, ...)
		{
			va_list _ArgList;
			(_ArgList=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
			return vsprintf_s(_Dest, _SizeFIXED, _Format, _ArgList);
		};
	}
	int _vscprintf(const char*_Format, va_list _ArgList);
	int _snprintf_c(char*_DstBuf, size_t _MaxCount, const char*_Format, ...);
	int _vsnprintf_c(char*_DstBuf, size_t _MaxCount, const char*_Format, va_list _ArgList);
	int _fprintf_p(FILE*_File, const char*_Format, ...);
	int _printf_p(const char*_Format, ...);
	int _sprintf_p(char*_Dst, size_t _MaxCount, const char*_Format, ...);
	int _vfprintf_p(FILE*_File, const char*_Format, va_list _ArgList);
	int _vprintf_p(const char*_Format, va_list _ArgList);
	int _vsprintf_p(char*_Dst, size_t _MaxCount, const char*_Format, va_list _ArgList);
	int _scprintf_p(const char*_Format, ...);
	int _vscprintf_p(const char*_Format, va_list _ArgList);
	int _set_printf_count_output(int _Value);
	int _get_printf_count_output();
	int _printf_l(const char*_Format, _locale_t _Locale, ...);
	int _printf_p_l(const char*_Format, _locale_t _Locale, ...);
	int _printf_s_l(const char*_Format, _locale_t _Locale, ...);
	int _vprintf_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vprintf_p_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vprintf_s_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _fprintf_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int _fprintf_p_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int _fprintf_s_l(FILE*_File, const char*_Format, _locale_t _Locale, ...);
	int _vfprintf_l(FILE*_File, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vfprintf_p_l(FILE*_File, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vfprintf_s_l(FILE*_File, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _sprintf_l(char*_DstBuf, const char*_Format, _locale_t _Locale, ...);
	int _sprintf_p_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _sprintf_s_l(char*_DstBuf, size_t _DstSize, const char*_Format, _locale_t _Locale, ...);
	int _vsprintf_l(char*_DstBuf, const char*_Format, _locale_t, va_list _ArgList);
	int _vsprintf_p_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vsprintf_s_l(char*_DstBuf, size_t _DstSize, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _scprintf_l(const char*_Format, _locale_t _Locale, ...);
	int _scprintf_p_l(const char*_Format, _locale_t _Locale, ...);
	int _vscprintf_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vscprintf_p_l(const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _snprintf_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _snprintf_c_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _snprintf_s_l(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, _locale_t _Locale, ...);
	int _vsnprintf_l(char*_DstBuf, size_t _MaxCount, const char*_Format, _locale_t _Locale, va_list _ArgList);
	int _vsnprintf_c_l(char*_DstBuf, size_t _MaxCount, const char*, _locale_t _Locale, va_list _ArgList);
	int _vsnprintf_s_l(char*_DstBuf, size_t _DstSize, size_t _MaxCount, const char*_Format, _locale_t _Locale, va_list _ArgList);
	FILE*_wfsopen(const wchar_t*_Filename, const wchar_t*_Mode, int _ShFlag);
	wint_t fgetwc(FILE*_File);
	wint_t _fgetwchar(void);
	wint_t fputwc(wchar_t _Ch, FILE*_File);
	wint_t _fputwchar(wchar_t _Ch);
	wint_t getwc(FILE*_File);
	wint_t getwchar(void);
	wint_t putwc(wchar_t _Ch, FILE*_File);
	wint_t putwchar(wchar_t _Ch);
	wint_t ungetwc(wint_t _Ch, FILE*_File);
	wchar_t*fgetws(wchar_t*_Dst, int _SizeInWords, FILE*_File);
	int fputws(const wchar_t*_Str, FILE*_File);
	wchar_t*_getws_s(wchar_t*_Str, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline wchar_t*_getws_s(wchar_t(&_String)[_SizeFIXED])
		{
			return _getws_s(_String, _SizeFIXED);
		}
	}
	wchar_t*_getws(wchar_t*_String);
	int _putws(const wchar_t*_Str);
	int fwprintf(FILE*_File, const wchar_t*_Format, ...);
	int fwprintf_s(FILE*_File, const wchar_t*_Format, ...);
	int wprintf(const wchar_t*_Format, ...);
	int wprintf_s(const wchar_t*_Format, ...);
	int _scwprintf(const wchar_t*_Format, ...);
	int vfwprintf(FILE*_File, const wchar_t*_Format, va_list _ArgList);
	int vfwprintf_s(FILE*_File, const wchar_t*_Format, va_list _ArgList);
	int vwprintf(const wchar_t*_Format, va_list _ArgList);
	int vwprintf_s(const wchar_t*_Format, va_list _ArgList);
	int swprintf_s(wchar_t*_Dst, size_t _SizeInWords, const wchar_t*_Format, ...);
	int vswprintf_s(wchar_t*_Dst, size_t _SizeInWords, const wchar_t*_Format, va_list _ArgList);
	extern "C++"
	{
		;
		;
		template<size_t _SizeFIXED>
		inline int swprintf_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Format, ...)
		{
			va_list _ArgList;
			(_ArgList=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
			return vswprintf_s(_Dest, _SizeFIXED, _Format, _ArgList);
		};
	}
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline int vswprintf_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Format, va_list _Args)
		{
			return vswprintf_s(_Dest, _SizeFIXED, _Format, _Args);
		}
	}
	int _swprintf_c(wchar_t*_DstBuf, size_t _SizeInWords, const wchar_t*_Format, ...);
	int _vswprintf_c(wchar_t*_DstBuf, size_t _SizeInWords, const wchar_t*_Format, va_list _ArgList);
	int _snwprintf_s(wchar_t*_DstBuf, size_t _DstSizeInWords, size_t _MaxCount, const wchar_t*_Format, ...);
	int _vsnwprintf_s(wchar_t*_DstBuf, size_t _DstSizeInWords, size_t _MaxCount, const wchar_t*_Format, va_list _ArgList);
	extern "C++"
	{
		;
		;
		template<size_t _SizeFIXED>
		inline int _snwprintf_s(wchar_t(&_Dest)[_SizeFIXED], size_t _Count, const wchar_t*_Format, ...)
		{
			va_list _ArgList;
			(_ArgList=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
			return _vsnwprintf_s(_Dest, _SizeFIXED, _Count, _Format, _ArgList);
		};
	}
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline int _vsnwprintf_s(wchar_t(&_Dest)[_SizeFIXED], size_t _Count, const wchar_t*_Format, va_list _Args)
		{
			return _vsnwprintf_s(_Dest, _SizeFIXED, _Count, _Format, _Args);
		}
	}
	int _snwprintf(wchar_t*_Dest, size_t _Count, const wchar_t*_Format, ...);
	int _vsnwprintf(wchar_t*_Dest, size_t _Count, const wchar_t*_Format, va_list _Args);
	int _fwprintf_p(FILE*_File, const wchar_t*_Format, ...);
	int _wprintf_p(const wchar_t*_Format, ...);
	int _vfwprintf_p(FILE*_File, const wchar_t*_Format, va_list _ArgList);
	int _vwprintf_p(const wchar_t*_Format, va_list _ArgList);
	int _swprintf_p(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, ...);
	int _vswprintf_p(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, va_list _ArgList);
	int _scwprintf_p(const wchar_t*_Format, ...);
	int _vscwprintf_p(const wchar_t*_Format, va_list _ArgList);
	int _wprintf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _wprintf_p_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _wprintf_s_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vwprintf_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vwprintf_s_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _fwprintf_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int _fwprintf_p_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int _fwprintf_s_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int _vfwprintf_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vfwprintf_p_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vfwprintf_s_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _swprintf_c_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _swprintf_p_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _swprintf_s_l(wchar_t*_DstBuf, size_t _DstSize, const wchar_t*_Format, _locale_t _Locale, ...);
	int _vswprintf_c_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vswprintf_p_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vswprintf_s_l(wchar_t*_DstBuf, size_t _DstSize, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _scwprintf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _scwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vscwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _snwprintf_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _snwprintf_s_l(wchar_t*_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _vsnwprintf_l(wchar_t*_DstBuf, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vsnwprintf_s_l(wchar_t*_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _swprintf(wchar_t*_Dest, const wchar_t*_Format, ...);
	int _vswprintf(wchar_t*_Dest, const wchar_t*_Format, va_list _Args);
	int __swprintf_l(wchar_t*_Dest, const wchar_t*_Format, _locale_t _Plocinfo, ...);
	int __vswprintf_l(wchar_t*_Dest, const wchar_t*_Format, _locale_t _Plocinfo, va_list _Args);
	static int swprintf(wchar_t*_String, size_t _Count, const wchar_t*_Format, ...)
	{
		va_list _Arglist;
		int _Ret;
		(_Arglist=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
		_Ret=_vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
		(_Arglist=(va_list)0);
		return _Ret;
	}
	static int vswprintf(wchar_t*_String, size_t _Count, const wchar_t*_Format, va_list _Ap)
	{
		return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
	}
	static int _swprintf_l(wchar_t*_String, size_t _Count, const wchar_t*_Format, _locale_t _Plocinfo, ...)
	{
		va_list _Arglist;
		int _Ret;
		(_Arglist=(va_list)(&reinterpret_cast<const char&>(_Plocinfo))+((sizeof(_Plocinfo)+sizeof(int)-1)&~(sizeof(int)-1)));
		_Ret=_vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
		(_Arglist=(va_list)0);
		return _Ret;
	}
	static int _vswprintf_l(wchar_t*_String, size_t _Count, const wchar_t*_Format, _locale_t _Plocinfo, va_list _Ap)
	{
		return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
	}
	extern "C++" int swprintf(wchar_t*_String, const wchar_t*_Format, ...)
	{
		va_list _Arglist;
		(_Arglist=(va_list)(&reinterpret_cast<const char&>(_Format))+((sizeof(_Format)+sizeof(int)-1)&~(sizeof(int)-1)));
		int _Ret=_vswprintf(_String, _Format, _Arglist);
		(_Arglist=(va_list)0);
		return _Ret;
	}
	extern "C++" int vswprintf(wchar_t*_String, const wchar_t*_Format, va_list _Ap)
	{
		return _vswprintf(_String, _Format, _Ap);
	}
	extern "C++" int _swprintf_l(wchar_t*_String, const wchar_t*_Format, _locale_t _Plocinfo, ...)
	{
		va_list _Arglist;
		(_Arglist=(va_list)(&reinterpret_cast<const char&>(_Plocinfo))+((sizeof(_Plocinfo)+sizeof(int)-1)&~(sizeof(int)-1)));
		int _Ret=__vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
		(_Arglist=(va_list)0);
		return _Ret;
	}
	extern "C++" int _vswprintf_l(wchar_t*_String, const wchar_t*_Format, _locale_t _Plocinfo, va_list _Ap)
	{
		return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
	}
	wchar_t*_wtempnam(const wchar_t*_Directory, const wchar_t*_FilePrefix);
	int _vscwprintf(const wchar_t*_Format, va_list _ArgList);
	int _vscwprintf_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int fwscanf(FILE*_File, const wchar_t*_Format, ...);
	int _fwscanf_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int fwscanf_s(FILE*_File, const wchar_t*_Format, ...);
	int _fwscanf_s_l(FILE*_File, const wchar_t*_Format, _locale_t _Locale, ...);
	int swscanf(const wchar_t*_Src, const wchar_t*_Format, ...);
	int _swscanf_l(const wchar_t*_Src, const wchar_t*_Format, _locale_t _Locale, ...);
	int swscanf_s(const wchar_t*_Src, const wchar_t*_Format, ...);
	int _swscanf_s_l(const wchar_t*_Src, const wchar_t*_Format, _locale_t _Locale, ...);
	int _snwscanf(const wchar_t*_Src, size_t _MaxCount, const wchar_t*_Format, ...);
	int _snwscanf_l(const wchar_t*_Src, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int _snwscanf_s(const wchar_t*_Src, size_t _MaxCount, const wchar_t*_Format, ...);
	int _snwscanf_s_l(const wchar_t*_Src, size_t _MaxCount, const wchar_t*_Format, _locale_t _Locale, ...);
	int wscanf(const wchar_t*_Format, ...);
	int _wscanf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int wscanf_s(const wchar_t*_Format, ...);
	int _wscanf_s_l(const wchar_t*_Format, _locale_t _Locale, ...);
	FILE*_wfdopen(int _FileHandle, const wchar_t*_Mode);
	FILE*_wfopen(const wchar_t*_Filename, const wchar_t*_Mode);
	errno_t _wfopen_s(FILE**_File, const wchar_t*_Filename, const wchar_t*_Mode);
	FILE*_wfreopen(const wchar_t*_Filename, const wchar_t*_Mode, FILE*_OldFile);
	errno_t _wfreopen_s(FILE**_File, const wchar_t*_Filename, const wchar_t*_Mode, FILE*_OldFile);
	void _wperror(const wchar_t*_ErrMsg);
	FILE*_wpopen(const wchar_t*_Command, const wchar_t*_Mode);
	int _wremove(const wchar_t*_Filename);
	errno_t _wtmpnam_s(wchar_t*_DstBuf, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wtmpnam_s(wchar_t(&_Buffer)[_SizeFIXED])
		{
			return _wtmpnam_s(_Buffer, _SizeFIXED);
		}
	}
	wchar_t*_wtmpnam(wchar_t*_Buffer);
	wint_t _fgetwc_nolock(FILE*_File);
	wint_t _fputwc_nolock(wchar_t _Ch, FILE*_File);
	wint_t _ungetwc_nolock(wint_t _Ch, FILE*_File);
	inline wint_t getwchar()
	{
		return (fgetwc((&__iob_func()[0])));
	}
	inline wint_t putwchar(wchar_t _C)
	{
		return (fputwc(_C, (&__iob_func()[1])));
	}
	int _fclose_nolock(FILE*_File);
	int _fflush_nolock(FILE*_File);
	size_t _fread_nolock(void*_DstBuf, size_t _ElementSize, size_t _Count, FILE*_File);
	size_t _fread_nolock_s(void*_DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE*_File);
	int _fseek_nolock(FILE*_File, long _Offset, int _Origin);
	long _ftell_nolock(FILE*_File);
	int _fseeki64_nolock(FILE*_File, __int64 _Offset, int _Origin);
	__int64 _ftelli64_nolock(FILE*_File);
	size_t _fwrite_nolock(const void*_DstBuf, size_t _Size, size_t _Count, FILE*_File);
	int _ungetc_nolock(int _Ch, FILE*_File);
}
namespace std
{
	using::size_t;
	using::fpos_t;
	using::FILE;
	using::clearerr;
	using::fclose;
	using::feof;
	using::ferror;
	using::fflush;
	using::fgetc;
	using::fgetpos;
	using::fgets;
	using::fopen;
	using::fprintf;
	using::fputc;
	using::fputs;
	using::fread;
	using::freopen;
	using::fscanf;
	using::fseek;
	using::fsetpos;
	using::ftell;
	using::fwrite;
	using::getc;
	using::getchar;
	using::gets;
	using::perror;
	using::putc;
	using::putchar;
	using::printf;
	using::puts;
	using::remove;
	using::rename;
	using::rewind;
	using::scanf;
	using::setbuf;
	using::setvbuf;
	using::sprintf;
	using::sscanf;
	using::tmpfile;
	using::tmpnam;
	using::ungetc;
	using::vfprintf;
	using::vprintf;
	using::vsprintf;
}
extern "C"
{
	typedef int(*_onexit_t)(void);
	typedef struct _div_t
	{
		int quot;
		int rem;
	}
	div_t;
	typedef struct _ldiv_t
	{
		long quot;
		long rem;
	}
	ldiv_t;
	typedef struct
	{
		unsigned char ld[10];
	}
	_LDOUBLE;
	typedef struct
	{
		double x;
	}
	_CRT_DOUBLE;
	typedef struct
	{
		float f;
	}
	_CRT_FLOAT;
	typedef struct
	{
		long double x;
	}
	_LONGDOUBLE;
	typedef struct
	{
		unsigned char ld12[12];
	}
	_LDBL12;
	extern int __mb_cur_max;
	int ___mb_cur_max_func(void);
	int ___mb_cur_max_l_func(_locale_t);
	typedef void(*_purecall_handler)(void);
	_purecall_handler _set_purecall_handler(_purecall_handler _Handler);
	_purecall_handler _get_purecall_handler();
	extern "C++"
	{
	}
	typedef void(*_invalid_parameter_handler)(const wchar_t*, const wchar_t*, const wchar_t*, unsigned int, uintptr_t);
	_invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
	_invalid_parameter_handler _get_invalid_parameter_handler(void);
	extern "C++"
	{
	}
	extern int*_errno(void);
	errno_t _set_errno(int _Value);
	errno_t _get_errno(int*_Value);
	unsigned long*__doserrno(void);
	errno_t _set_doserrno(unsigned long _Value);
	errno_t _get_doserrno(unsigned long*_Value);
	char**__sys_errlist(void);
	int*__sys_nerr(void);
	extern int __argc;
	extern char**__argv;
	extern wchar_t**__wargv;
	extern char**_environ;
	extern wchar_t**_wenviron;
	extern char*_pgmptr;
	extern wchar_t*_wpgmptr;
	errno_t _get_pgmptr(char**_Value);
	errno_t _get_wpgmptr(wchar_t**_Value);
	extern int _fmode;
	errno_t _set_fmode(int _Mode);
	errno_t _get_fmode(int*_PMode);
	extern unsigned int _osplatform;
	extern unsigned int _osver;
	extern unsigned int _winver;
	extern unsigned int _winmajor;
	extern unsigned int _winminor;
	errno_t _get_osplatform(unsigned int*_Value);
	errno_t _get_osver(unsigned int*_Value);
	errno_t _get_winver(unsigned int*_Value);
	errno_t _get_winmajor(unsigned int*_Value);
	errno_t _get_winminor(unsigned int*_Value);
	extern "C++"
	{
		template<typename _CountofType, size_t _SizeOfArray>
		char(*__countof_helper(_CountofType(&_Array)[_SizeOfArray]))[_SizeOfArray];
	}
	void exit(int _Code);
	void _exit(int _Code);
	void abort(void);
	unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask);
	int abs(int _X);
	long labs(long _X);
	__int64 _abs64(__int64);
	int atexit(void(*)(void));
	double atof(const char*_String);
	double _atof_l(const char*_String, _locale_t _Locale);
	int atoi(const char*_Str);
	int _atoi_l(const char*_Str, _locale_t _Locale);
	long atol(const char*_Str);
	long _atol_l(const char*_Str, _locale_t _Locale);
	void*bsearch_s(const void*_Key, const void*_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, int(*_PtFuncCompare)(void*, const void*, const void*), void*_Context);
	void*bsearch(const void*_Key, const void*_Base, size_t _NumOfElements, size_t _SizeOfElements, int(*_PtFuncCompare)(const void*, const void*));
	void qsort_s(void*_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, int(*_PtFuncCompare)(void*, const void*, const void*), void*_Context);
	void qsort(void*_Base, size_t _NumOfElements, size_t _SizeOfElements, int(*_PtFuncCompare)(const void*, const void*));
	unsigned short _byteswap_ushort(unsigned short _Short);
	unsigned long _byteswap_ulong(unsigned long _Long);
	unsigned __int64 _byteswap_uint64(unsigned __int64 _Int64);
	div_t div(int _Numerator, int _Denominator);
	char*getenv(const char*_VarName);
	errno_t getenv_s(size_t*_ReturnSize, char*_DstBuf, rsize_t _DstSize, const char*_VarName);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t getenv_s(size_t*_ReturnSize, char(&_Dest)[_SizeFIXED], const char*_VarName)
		{
			return getenv_s(_ReturnSize, _Dest, _SizeFIXED, _VarName);
		}
	}
	errno_t _dupenv_s(char**_PBuffer, size_t*_PBufferSizeInBytes, const char*_VarName);
	errno_t _itoa_s(int _Value, char*_DstBuf, size_t _Size, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _itoa_s(int _Value, char(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _itoa_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	char*_itoa(int _Value, char*_Dest, int _Radix);
	errno_t _i64toa_s(__int64 _Val, char*_DstBuf, size_t _Size, int _Radix);
	char*_i64toa(__int64 _Val, char*_DstBuf, int _Radix);
	errno_t _ui64toa_s(unsigned __int64 _Val, char*_DstBuf, size_t _Size, int _Radix);
	char*_ui64toa(unsigned __int64 _Val, char*_DstBuf, int _Radix);
	__int64 _atoi64(const char*_String);
	__int64 _atoi64_l(const char*_String, _locale_t _Locale);
	__int64 _strtoi64(const char*_String, char**_EndPtr, int _Radix);
	__int64 _strtoi64_l(const char*_String, char**_EndPtr, int _Radix, _locale_t _Locale);
	unsigned __int64 _strtoui64(const char*_String, char**_EndPtr, int _Radix);
	unsigned __int64 _strtoui64_l(const char*_String, char**_EndPtr, int _Radix, _locale_t _Locale);
	ldiv_t ldiv(long _Numerator, long _Denominator);
	extern "C++"
	{
		inline ldiv_t div(long _A1, long _A2)
		{
			return ldiv(_A1, _A2);
		}
	}
	errno_t _ltoa_s(long _Val, char*_DstBuf, size_t _Size, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ltoa_s(long _Value, char(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _ltoa_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	char*_ltoa(long _Value, char*_Dest, int _Radix);
	int mblen(const char*_Ch, size_t _MaxCount);
	int _mblen_l(const char*_Ch, size_t _MaxCount, _locale_t _Locale);
	size_t _mbstrlen(const char*_Str);
	size_t _mbstrlen_l(const char*_Str, _locale_t _Locale);
	size_t _mbstrnlen(const char*_Str, size_t _MaxCount);
	size_t _mbstrnlen_l(const char*_Str, size_t _MaxCount, _locale_t _Locale);
	int mbtowc(wchar_t*_DstCh, const char*_SrcCh, size_t _SrcSizeInBytes);
	int _mbtowc_l(wchar_t*_DstCh, const char*_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale);
	errno_t mbstowcs_s(size_t*_PtNumOfCharConverted, wchar_t*_DstBuf, size_t _SizeInWords, const char*_SrcBuf, size_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t mbstowcs_s(size_t*_PtNumOfCharConverted, wchar_t(&_Dest)[_SizeFIXED], const char*_Source, size_t _MaxCount)
		{
			return mbstowcs_s(_PtNumOfCharConverted, _Dest, _SizeFIXED, _Source, _MaxCount);
		}
	}
	size_t mbstowcs(wchar_t*_Dest, const char*_Source, size_t _MaxCount);
	errno_t _mbstowcs_s_l(size_t*_PtNumOfCharConverted, wchar_t*_DstBuf, size_t _SizeInWords, const char*_SrcBuf, size_t _MaxCount, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _mbstowcs_s_l(size_t*_PtNumOfCharConverted, wchar_t(&_Dest)[_SizeFIXED], const char*_Source, size_t _MaxCount, _locale_t _Locale)
		{
			return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _SizeFIXED, _Source, _MaxCount, _Locale);
		}
	}
	size_t _mbstowcs_l(wchar_t*_Dest, const char*_Source, size_t _MaxCount, _locale_t _Locale);
	int rand(void);
	int _set_error_mode(int _Mode);
	void srand(unsigned int _Seed);
	double strtod(const char*_Str, char**_EndPtr);
	double _strtod_l(const char*_Str, char**_EndPtr, _locale_t _Locale);
	long strtol(const char*_Str, char**_EndPtr, int _Radix);
	long _strtol_l(const char*_Str, char**_EndPtr, int _Radix, _locale_t _Locale);
	unsigned long strtoul(const char*_Str, char**_EndPtr, int _Radix);
	unsigned long _strtoul_l(const char*_Str, char**_EndPtr, int _Radix, _locale_t _Locale);
	int system(const char*_Command);
	errno_t _ultoa_s(unsigned long _Val, char*_DstBuf, size_t _Size, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ultoa_s(unsigned long _Value, char(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _ultoa_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	char*_ultoa(unsigned long _Value, char*_Dest, int _Radix);
	int wctomb(char*_MbCh, wchar_t _WCh);
	int _wctomb_l(char*_MbCh, wchar_t _WCh, _locale_t _Locale);
	errno_t wctomb_s(int*_SizeConverted, char*_MbCh, rsize_t _SizeInBytes, wchar_t _WCh);
	errno_t _wctomb_s_l(int*_SizeConverted, char*_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale);
	errno_t wcstombs_s(size_t*_PtNumOfCharConverted, char*_Dst, size_t _DstSizeInBytes, const wchar_t*_Src, size_t _MaxCountInBytes);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcstombs_s(size_t*_PtNumOfCharConverted, char(&_Dest)[_SizeFIXED], const wchar_t*_Source, size_t _MaxCount)
		{
			return wcstombs_s(_PtNumOfCharConverted, _Dest, _SizeFIXED, _Source, _MaxCount);
		}
	}
	size_t wcstombs(char*_Dest, const wchar_t*_Source, size_t _MaxCount);
	errno_t _wcstombs_s_l(size_t*_PtNumOfCharConverted, char*_Dst, size_t _DstSizeInBytes, const wchar_t*_Src, size_t _MaxCountInBytes, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcstombs_s_l(size_t*_PtNumOfCharConverted, char(&_Dest)[_SizeFIXED], const wchar_t*_Source, size_t _MaxCount, _locale_t _Locale)
		{
			return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _SizeFIXED, _Source, _MaxCount, _Locale);
		}
	}
	size_t _wcstombs_l(char*_Dest, const wchar_t*_Source, size_t _MaxCount, _locale_t _Locale);
	void*calloc(size_t _NumOfElements, size_t _SizeOfElements);
	void free(void*_Memory);
	void*malloc(size_t _Size);
	void*realloc(void*_Memory, size_t _NewSize);
	void*_recalloc(void*_Memory, size_t _Count, size_t _Size);
	void _aligned_free(void*_Memory);
	void*_aligned_malloc(size_t _Size, size_t _Alignment);
	void*_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset);
	void*_aligned_realloc(void*_Memory, size_t _Size, size_t _Alignment);
	void*_aligned_recalloc(void*_Memory, size_t _Count, size_t _Size, size_t _Alignment);
	void*_aligned_offset_realloc(void*_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
	void*_aligned_offset_recalloc(void*_Memory, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset);
	errno_t _itow_s(int _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _itow_s(int _Value, wchar_t(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _itow_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	wchar_t*_itow(int _Value, wchar_t*_Dest, int _Radix);
	errno_t _ltow_s(long _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ltow_s(long _Value, wchar_t(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _ltow_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	wchar_t*_ltow(long _Value, wchar_t*_Dest, int _Radix);
	errno_t _ultow_s(unsigned long _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ultow_s(unsigned long _Value, wchar_t(&_Dest)[_SizeFIXED], int _Radix)
		{
			return _ultow_s(_Value, _Dest, _SizeFIXED, _Radix);
		}
	}
	wchar_t*_ultow(unsigned long _Value, wchar_t*_Dest, int _Radix);
	double wcstod(const wchar_t*_Str, wchar_t**_EndPtr);
	double _wcstod_l(const wchar_t*_Str, wchar_t**_EndPtr, _locale_t _Locale);
	long wcstol(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix);
	long _wcstol_l(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix, _locale_t _Locale);
	unsigned long wcstoul(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix);
	unsigned long _wcstoul_l(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix, _locale_t _Locale);
	wchar_t*_wgetenv(const wchar_t*_VarName);
	errno_t _wgetenv_s(size_t*_ReturnSize, wchar_t*_DstBuf, size_t _DstSizeInWords, const wchar_t*_VarName);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wgetenv_s(size_t*_ReturnSize, wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_VarName)
		{
			return _wgetenv_s(_ReturnSize, _Dest, _SizeFIXED, _VarName);
		}
	}
	errno_t _wdupenv_s(wchar_t**_Buffer, size_t*_BufferSizeInWords, const wchar_t*_VarName);
	int _wsystem(const wchar_t*_Command);
	double _wtof(const wchar_t*_Str);
	double _wtof_l(const wchar_t*_Str, _locale_t _Locale);
	int _wtoi(const wchar_t*_Str);
	int _wtoi_l(const wchar_t*_Str, _locale_t _Locale);
	long _wtol(const wchar_t*_Str);
	long _wtol_l(const wchar_t*_Str, _locale_t _Locale);
	errno_t _i64tow_s(__int64 _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	wchar_t*_i64tow(__int64 _Val, wchar_t*_DstBuf, int _Radix);
	errno_t _ui64tow_s(unsigned __int64 _Val, wchar_t*_DstBuf, size_t _SizeInWords, int _Radix);
	wchar_t*_ui64tow(unsigned __int64 _Val, wchar_t*_DstBuf, int _Radix);
	__int64 _wtoi64(const wchar_t*_Str);
	__int64 _wtoi64_l(const wchar_t*_Str, _locale_t _Locale);
	__int64 _wcstoi64(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix);
	__int64 _wcstoi64_l(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix, _locale_t _Locale);
	unsigned __int64 _wcstoui64(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix);
	unsigned __int64 _wcstoui64_l(const wchar_t*_Str, wchar_t**_EndPtr, int _Radix, _locale_t _Locale);
	char*_fullpath(char*_FullPath, const char*_Path, size_t _SizeInBytes);
	errno_t _ecvt_s(char*_DstBuf, size_t _Size, double _Val, int _NumOfDights, int*_PtDec, int*_PtSign);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ecvt_s(char(&_Dest)[_SizeFIXED], double _Value, int _NumOfDigits, int*_PtDec, int*_PtSign)
		{
			return _ecvt_s(_Dest, _SizeFIXED, _Value, _NumOfDigits, _PtDec, _PtSign);
		}
	}
	char*_ecvt(double _Val, int _NumOfDigits, int*_PtDec, int*_PtSign);
	errno_t _fcvt_s(char*_DstBuf, size_t _Size, double _Val, int _NumOfDec, int*_PtDec, int*_PtSign);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _fcvt_s(char(&_Dest)[_SizeFIXED], double _Value, int _NumOfDigits, int*_PtDec, int*_PtSign)
		{
			return _fcvt_s(_Dest, _SizeFIXED, _Value, _NumOfDigits, _PtDec, _PtSign);
		}
	}
	char*_fcvt(double _Val, int _NumOfDec, int*_PtDec, int*_PtSign);
	errno_t _gcvt_s(char*_DstBuf, size_t _Size, double _Val, int _NumOfDigits);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _gcvt_s(char(&_Dest)[_SizeFIXED], double _Value, int _NumOfDigits)
		{
			return _gcvt_s(_Dest, _SizeFIXED, _Value, _NumOfDigits);
		}
	}
	char*_gcvt(double _Val, int _NumOfDigits, char*_DstBuf);
	int _atodbl(_CRT_DOUBLE*_Result, char*_Str);
	int _atoldbl(_LDOUBLE*_Result, char*_Str);
	int _atoflt(_CRT_FLOAT*_Result, char*_Str);
	int _atodbl_l(_CRT_DOUBLE*_Result, char*_Str, _locale_t _Locale);
	int _atoldbl_l(_LDOUBLE*_Result, char*_Str, _locale_t _Locale);
	int _atoflt_l(_CRT_FLOAT*_Result, char*_Str, _locale_t _Locale);
	unsigned long _lrotl(unsigned long _Val, int _Shift);
	unsigned long _lrotr(unsigned long _Val, int _Shift);
	errno_t _makepath_s(char*_PathResult, size_t _Size, const char*_Drive, const char*_Dir, const char*_Filename, const char*_Ext);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _makepath_s(char(&_Path)[_SizeFIXED], const char*_Drive, const char*_Dir, const char*_Filename, const char*_Ext)
		{
			return _makepath_s(_Path, _SizeFIXED, _Drive, _Dir, _Filename, _Ext);
		}
	}
	void _makepath(char*_Path, const char*_Drive, const char*_Dir, const char*_Filename, const char*_Ext);
	_onexit_t _onexit(_onexit_t _Func);
	int _putenv(const char*_EnvString);
	errno_t _putenv_s(const char*_Name, const char*_Value);
	unsigned int _rotl(unsigned int _Val, int _Shift);
	unsigned __int64 _rotl64(unsigned __int64 _Val, int _Shift);
	unsigned int _rotr(unsigned int _Val, int _Shift);
	unsigned __int64 _rotr64(unsigned __int64 _Val, int _Shift);
	errno_t _searchenv_s(const char*_Filename, const char*_EnvVar, char*_ResultPath, size_t _SizeInBytes);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _searchenv_s(const char*_Filename, const char*_EnvVar, char(&_ResultPath)[_SizeFIXED])
		{
			return _searchenv_s(_Filename, _EnvVar, _ResultPath, _SizeFIXED);
		}
	}
	void _searchenv(const char*_Filename, const char*_EnvVar, char*_ResultPath);
	void _splitpath(const char*_FullPath, char*_Drive, char*_Dir, char*_Filename, char*_Ext);
	errno_t _splitpath_s(const char*_FullPath, char*_Drive, size_t _DriveSize, char*_Dir, size_t _DirSize, char*_Filename, size_t _FilenameSize, char*_Ext, size_t _ExtSize);
	extern "C++"
	{
		template<size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>
		inline errno_t _splitpath_s(const char*_Dest, char(&_Drive)[_DriveSize], char(&_Dir)[_DirSize], char(&_Name)[_NameSize], char(&_Ext)[_ExtSize])
		{
			return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize);
		}
	}
	void _swab(char*_Buf1, char*_Buf2, int _SizeInBytes);
	wchar_t*_wfullpath(wchar_t*_FullPath, const wchar_t*_Path, size_t _SizeInWords);
	errno_t _wmakepath_s(wchar_t*_PathResult, size_t _SizeInWords, const wchar_t*_Drive, const wchar_t*_Dir, const wchar_t*_Filename, const wchar_t*_Ext);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wmakepath_s(wchar_t(&_ResultPath)[_SizeFIXED], const wchar_t*_Drive, const wchar_t*_Dir, const wchar_t*_Filename, const wchar_t*_Ext)
		{
			return _wmakepath_s(_ResultPath, _SizeFIXED, _Drive, _Dir, _Filename, _Ext);
		}
	}
	void _wmakepath(wchar_t*_ResultPath, const wchar_t*_Drive, const wchar_t*_Dir, const wchar_t*_Filename, const wchar_t*_Ext);
	int _wputenv(const wchar_t*_EnvString);
	errno_t _wputenv_s(const wchar_t*_Name, const wchar_t*_Value);
	errno_t _wsearchenv_s(const wchar_t*_Filename, const wchar_t*_EnvVar, wchar_t*_ResultPath, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wsearchenv_s(const wchar_t*_Filename, const wchar_t*_EnvVar, wchar_t(&_ResultPath)[_SizeFIXED])
		{
			return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _SizeFIXED);
		}
	}
	void _wsearchenv(const wchar_t*_Filename, const wchar_t*_EnvVar, wchar_t*_ResultPath);
	void _wsplitpath(const wchar_t*_FullPath, wchar_t*_Drive, wchar_t*_Dir, wchar_t*_Filename, wchar_t*_Ext);
	errno_t _wsplitpath_s(const wchar_t*_FullPath, wchar_t*_Drive, size_t _DriveSizeInWords, wchar_t*_Dir, size_t _DirSizeInWords, wchar_t*_Filename, size_t _FilenameSizeInWords, wchar_t*_Ext, size_t _ExtSizeInWords);
	extern "C++"
	{
		template<size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>
		inline errno_t _wsplitpath_s(const wchar_t*_Path, wchar_t(&_Drive)[_DriveSize], wchar_t(&_Dir)[_DirSize], wchar_t(&_Name)[_NameSize], wchar_t(&_Ext)[_ExtSize])
		{
			return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize);
		}
	}
	void _seterrormode(int _Mode);
	void _beep(unsigned _Frequency, unsigned _Duration);
	void _sleep(unsigned long _Duration);
}
namespace std
{
	using::size_t;
	using::div_t;
	using::ldiv_t;
	using::abort;
	using::abs;
	using::atexit;
	using::atof;
	using::atoi;
	using::atol;
	using::bsearch;
	using::calloc;
	using::div;
	using::exit;
	using::free;
	using::getenv;
	using::labs;
	using::ldiv;
	using::malloc;
	using::mblen;
	using::mbstowcs;
	using::mbtowc;
	using::qsort;
	using::rand;
	using::realloc;
	using::srand;
	using::strtod;
	using::strtol;
	using::strtoul;
	using::system;
	using::wcstombs;
	using::wctomb;
}
extern "C"
{
	void*_memccpy(void*_Dst, const void*_Src, int _Val, size_t _MaxCount);
	const void*memchr(const void*_Buf, int _Val, size_t _MaxCount);
	int _memicmp(const void*_Buf1, const void*_Buf2, size_t _Size);
	int _memicmp_l(const void*_Buf1, const void*_Buf2, size_t _Size, _locale_t _Locale);
	int memcmp(const void*_Buf1, const void*_Buf2, size_t _Size);
	void*memcpy(void*_Dst, const void*_Src, size_t _Size);
	errno_t memcpy_s(void*_Dst, rsize_t _DstSize, const void*_Src, rsize_t _MaxCount);
	void*memset(void*_Dst, int _Val, size_t _Size);
	char*_strset(char*_Str, int _Val);
	errno_t _strset_s(char*_Dst, size_t _DstSize, int _Value);
	errno_t strcpy_s(char*_Dst, rsize_t _DstSize, const char*_Src);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strcpy_s(char(&_Dest)[_SizeFIXED], const char*_Source)
		{
			return strcpy_s(_Dest, _SizeFIXED, _Source);
		}
	}
	char*strcpy(char*_Dest, const char*_Source);
	errno_t strcat_s(char*_Dst, rsize_t _DstSize, const char*_Src);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strcat_s(char(&_Dest)[_SizeFIXED], const char*_Source)
		{
			return strcat_s(_Dest, _SizeFIXED, _Source);
		}
	}
	char*strcat(char*_Dest, const char*_Source);
	int strcmp(const char*_Str1, const char*_Str2);
	size_t strlen(const char*_Str);
	size_t strnlen(const char*_Str, size_t _MaxCount);
	static size_t strnlen_s(const char*_Str, size_t _MaxCount)
	{
		return strnlen(_Str, _MaxCount);
	}
	errno_t memmove_s(void*_Dst, rsize_t _DstSize, const void*_Src, rsize_t _MaxCount);
	void*memmove(void*_Dst, const void*_Src, size_t _Size);
	char*_strdup(const char*_Src);
	const char*strchr(const char*_Str, int _Val);
	int _stricmp(const char*_Str1, const char*_Str2);
	int _strcmpi(const char*_Str1, const char*_Str2);
	int _stricmp_l(const char*_Str1, const char*_Str2, _locale_t _Locale);
	int strcoll(const char*_Str1, const char*_Str2);
	int _strcoll_l(const char*_Str1, const char*_Str2, _locale_t _Locale);
	int _stricoll(const char*_Str1, const char*_Str2);
	int _stricoll_l(const char*_Str1, const char*_Str2, _locale_t _Locale);
	int _strncoll(const char*_Str1, const char*_Str2, size_t _MaxCount);
	int _strncoll_l(const char*_Str1, const char*_Str2, size_t _MaxCount, _locale_t _Locale);
	int _strnicoll(const char*_Str1, const char*_Str2, size_t _MaxCount);
	int _strnicoll_l(const char*_Str1, const char*_Str2, size_t _MaxCount, _locale_t _Locale);
	size_t strcspn(const char*_Str, const char*_Control);
	char*_strerror(const char*_ErrMsg);
	errno_t _strerror_s(char*_Buf, size_t _SizeInBytes, const char*_ErrMsg);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strerror_s(char(&_Buffer)[_SizeFIXED], const char*_ErrorMessage)
		{
			return _strerror_s(_Buffer, _SizeFIXED, _ErrorMessage);
		}
	}
	char*strerror(int);
	errno_t strerror_s(char*_Buf, size_t _SizeInBytes, int _ErrNum);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strerror_s(char(&_Buffer)[_SizeFIXED], int _ErrorMessage)
		{
			return strerror_s(_Buffer, _SizeFIXED, _ErrorMessage);
		}
	}
	errno_t _strlwr_s(char*_Str, size_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strlwr_s(char(&_String)[_SizeFIXED])
		{
			return _strlwr_s(_String, _SizeFIXED);
		}
	}
	char*_strlwr(char*_String);
	errno_t _strlwr_s_l(char*_Str, size_t _Size, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strlwr_s_l(char(&_String)[_SizeFIXED], _locale_t _Locale)
		{
			return _strlwr_s_l(_String, _SizeFIXED, _Locale);
		}
	}
	char*_strlwr_l(char*_String, _locale_t _Locale);
	errno_t strncat_s(char*_Dst, rsize_t _DstSize, const char*_Src, rsize_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strncat_s(char(&_Dest)[_SizeFIXED], const char*_Source, size_t _Count)
		{
			return strncat_s(_Dest, _SizeFIXED, _Source, _Count);
		}
	}
	char*strncat(char*_Dest, const char*_Source, size_t _Count);
	int strncmp(const char*_Str1, const char*_Str2, size_t _MaxCount);
	int _strnicmp(const char*_Str1, const char*_Str2, size_t _MaxCount);
	int _strnicmp_l(const char*_Str1, const char*_Str2, size_t _MaxCount, _locale_t _Locale);
	errno_t strncpy_s(char*_Dst, rsize_t _DstSize, const char*_Src, rsize_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t strncpy_s(char(&_Dest)[_SizeFIXED], const char*_Source, size_t _Count)
		{
			return strncpy_s(_Dest, _SizeFIXED, _Source, _Count);
		}
	}
	char*strncpy(char*_Dest, const char*_Source, size_t _Count);
	char*_strnset(char*_Str, int _Val, size_t _MaxCount);
	errno_t _strnset_s(char*_Str, size_t _Size, int _Val, size_t _MaxCount);
	const char*strpbrk(const char*_Str, const char*_Control);
	const char*strrchr(const char*_Str, int _Ch);
	char*_strrev(char*_Str);
	size_t strspn(const char*_Str, const char*_Control);
	const char*strstr(const char*_Str, const char*_SubStr);
	char*strtok(char*_Str, const char*_Delim);
	char*strtok_s(char*_Str, const char*_Delim, char**_Context);
	errno_t _strupr_s(char*_Str, size_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strupr_s(char(&_String)[_SizeFIXED])
		{
			return _strupr_s(_String, _SizeFIXED);
		}
	}
	char*_strupr(char*_String);
	errno_t _strupr_s_l(char*_Str, size_t _Size, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strupr_s_l(char(&_String)[_SizeFIXED], _locale_t _Locale)
		{
			return _strupr_s_l(_String, _SizeFIXED, _Locale);
		}
	}
	char*_strupr_l(char*_String, _locale_t _Locale);
	size_t strxfrm(char*_Dst, const char*_Src, size_t _MaxCount);
	size_t _strxfrm_l(char*_Dst, const char*_Src, size_t _MaxCount, _locale_t _Locale);
	extern "C++"
	{
		inline char*strchr(char*_Str, int _Ch)
		{
			return (char*)strchr((const char*)_Str, _Ch);
		}
		inline char*strpbrk(char*_Str, const char*_Control)
		{
			return (char*)strpbrk((const char*)_Str, _Control);
		}
		inline char*strrchr(char*_Str, int _Ch)
		{
			return (char*)strrchr((const char*)_Str, _Ch);
		}
		inline char*strstr(char*_Str, const char*_SubStr)
		{
			return (char*)strstr((const char*)_Str, _SubStr);
		}
		inline void*memchr(void*_Pv, int _C, size_t _N)
		{
			return (void*)memchr((const void*)_Pv, _C, _N);
		}
	}
	wchar_t*_wcsdup(const wchar_t*_Str);
	errno_t wcscat_s(wchar_t*_Dst, rsize_t _DstSize, const wchar_t*_Src);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcscat_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Source)
		{
			return wcscat_s(_Dest, _SizeFIXED, _Source);
		}
	}
	wchar_t*wcscat(wchar_t*_Dest, const wchar_t*_Source);
	const wchar_t*wcschr(const wchar_t*_Str, wchar_t _Ch);
	int wcscmp(const wchar_t*_Str1, const wchar_t*_Str2);
	errno_t wcscpy_s(wchar_t*_Dst, rsize_t _DstSize, const wchar_t*_Src);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcscpy_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Source)
		{
			return wcscpy_s(_Dest, _SizeFIXED, _Source);
		}
	}
	wchar_t*wcscpy(wchar_t*_Dest, const wchar_t*_Source);
	size_t wcscspn(const wchar_t*_Str, const wchar_t*_Control);
	size_t wcslen(const wchar_t*_Str);
	size_t wcsnlen(const wchar_t*_Src, size_t _MaxCount);
	static size_t wcsnlen_s(const wchar_t*_Src, size_t _MaxCount)
	{
		return wcsnlen(_Src, _MaxCount);
	}
	errno_t wcsncat_s(wchar_t*_Dst, rsize_t _DstSize, const wchar_t*_Src, rsize_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcsncat_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Source, size_t _Count)
		{
			return wcsncat_s(_Dest, _SizeFIXED, _Source, _Count);
		}
	}
	wchar_t*wcsncat(wchar_t*_Dest, const wchar_t*_Source, size_t _Count);
	int wcsncmp(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount);
	errno_t wcsncpy_s(wchar_t*_Dst, rsize_t _DstSize, const wchar_t*_Src, rsize_t _MaxCount);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcsncpy_s(wchar_t(&_Dest)[_SizeFIXED], const wchar_t*_Source, size_t _Count)
		{
			return wcsncpy_s(_Dest, _SizeFIXED, _Source, _Count);
		}
	}
	wchar_t*wcsncpy(wchar_t*_Dest, const wchar_t*_Source, size_t _Count);
	const wchar_t*wcspbrk(const wchar_t*_Str, const wchar_t*_Control);
	const wchar_t*wcsrchr(const wchar_t*_Str, wchar_t _Ch);
	size_t wcsspn(const wchar_t*_Str, const wchar_t*_Control);
	const wchar_t*wcsstr(const wchar_t*_Str, const wchar_t*_SubStr);
	wchar_t*wcstok(wchar_t*_Str, const wchar_t*_Delim);
	wchar_t*wcstok_s(wchar_t*_Str, const wchar_t*_Delim, wchar_t**_Context);
	wchar_t*_wcserror(int _ErrNum);
	errno_t _wcserror_s(wchar_t*_Buf, size_t _SizeInWords, int _ErrNum);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcserror_s(wchar_t(&_Buffer)[_SizeFIXED], int _Error)
		{
			return _wcserror_s(_Buffer, _SizeFIXED, _Error);
		}
	}
	wchar_t*__wcserror(const wchar_t*_Str);
	errno_t __wcserror_s(wchar_t*_Buffer, size_t _SizeInWords, const wchar_t*_ErrMsg);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t __wcserror_s(wchar_t(&_Buffer)[_SizeFIXED], const wchar_t*_ErrorMessage)
		{
			return __wcserror_s(_Buffer, _SizeFIXED, _ErrorMessage);
		}
	}
	int _wcsicmp(const wchar_t*_Str1, const wchar_t*_Str2);
	int _wcsicmp_l(const wchar_t*_Str1, const wchar_t*_Str2, _locale_t _Locale);
	int _wcsnicmp(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount);
	int _wcsnicmp_l(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount, _locale_t _Locale);
	wchar_t*_wcsnset(wchar_t*_Str, wchar_t _Val, size_t _MaxCount);
	errno_t _wcsnset_s(wchar_t*_Dst, size_t _DstSizeInWords, wchar_t _Val, size_t _MaxCount);
	wchar_t*_wcsrev(wchar_t*_Str);
	wchar_t*_wcsset(wchar_t*_Str, wchar_t _Val);
	errno_t _wcsset_s(wchar_t*_Str, size_t _SizeInWords, wchar_t _Val);
	errno_t _wcslwr_s(wchar_t*_Str, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcslwr_s(wchar_t(&_String)[_SizeFIXED])
		{
			return _wcslwr_s(_String, _SizeFIXED);
		}
	}
	wchar_t*_wcslwr(wchar_t*_String);
	errno_t _wcslwr_s_l(wchar_t*_Str, size_t _SizeInWords, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcslwr_s_l(wchar_t(&_String)[_SizeFIXED], _locale_t _Locale)
		{
			return _wcslwr_s_l(_String, _SizeFIXED, _Locale);
		}
	}
	wchar_t*_wcslwr_l(wchar_t*_String, _locale_t _Locale);
	errno_t _wcsupr_s(wchar_t*_Str, size_t _Size);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcsupr_s(wchar_t(&_String)[_SizeFIXED])
		{
			return _wcsupr_s(_String, _SizeFIXED);
		}
	}
	wchar_t*_wcsupr(wchar_t*_String);
	errno_t _wcsupr_s_l(wchar_t*_Str, size_t _Size, _locale_t _Locale);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wcsupr_s_l(wchar_t(&_String)[_SizeFIXED], _locale_t _Locale)
		{
			return _wcsupr_s_l(_String, _SizeFIXED, _Locale);
		}
	}
	wchar_t*_wcsupr_l(wchar_t*_String, _locale_t _Locale);
	size_t wcsxfrm(wchar_t*_Dst, const wchar_t*_Src, size_t _MaxCount);
	size_t _wcsxfrm_l(wchar_t*_Dst, const wchar_t*_Src, size_t _MaxCount, _locale_t _Locale);
	int wcscoll(const wchar_t*_Str1, const wchar_t*_Str2);
	int _wcscoll_l(const wchar_t*_Str1, const wchar_t*_Str2, _locale_t _Locale);
	int _wcsicoll(const wchar_t*_Str1, const wchar_t*_Str2);
	int _wcsicoll_l(const wchar_t*_Str1, const wchar_t*_Str2, _locale_t _Locale);
	int _wcsncoll(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount);
	int _wcsncoll_l(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount, _locale_t _Locale);
	int _wcsnicoll(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount);
	int _wcsnicoll_l(const wchar_t*_Str1, const wchar_t*_Str2, size_t _MaxCount, _locale_t _Locale);
	extern "C++"
	{
		inline wchar_t*wcschr(wchar_t*_Str, wchar_t _Ch)
		{
			return ((wchar_t*)wcschr((const wchar_t*)_Str, _Ch));
		}
		inline wchar_t*wcspbrk(wchar_t*_Str, const wchar_t*_Control)
		{
			return ((wchar_t*)wcspbrk((const wchar_t*)_Str, _Control));
		}
		inline wchar_t*wcsrchr(wchar_t*_Str, wchar_t _Ch)
		{
			return ((wchar_t*)wcsrchr((const wchar_t*)_Str, _Ch));
		}
		inline wchar_t*wcsstr(wchar_t*_Str, const wchar_t*_SubStr)
		{
			return ((wchar_t*)wcsstr((const wchar_t*)_Str, _SubStr));
		}
	}
}
namespace std
{
	using::size_t;
	using::memchr;
	using::memcmp;
	using::memcpy;
	using::memmove;
	using::memset;
	using::strcat;
	using::strchr;
	using::strcmp;
	using::strcoll;
	using::strcpy;
	using::strcspn;
	using::strerror;
	using::strlen;
	using::strncat;
	using::strncmp;
	using::strncpy;
	using::strpbrk;
	using::strrchr;
	using::strspn;
	using::strstr;
	using::strtok;
	using::strxfrm;
}
extern "C"
{
}
namespace std
{
	using::ptrdiff_t;
	using::size_t;
}
namespace std
{
	enum _Uninitialized
	{
		_Noinit
	};
}
namespace std
{
}
typedef void(*terminate_function)();
typedef void(*terminate_handler)();
typedef void(*unexpected_function)();
typedef void(*unexpected_handler)();
struct _EXCEPTION_POINTERS;
typedef void(*_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
void terminate(void);
void unexpected(void);
int _is_exception_typeof(const type_info&_Type, struct _EXCEPTION_POINTERS*_ExceptionPtr);
terminate_function set_terminate(terminate_function _NewPtFunc);
extern "C" terminate_function _get_terminate(void);
unexpected_function set_unexpected(unexpected_function _NewPtFunc);
extern "C" unexpected_function _get_unexpected(void);
_se_translator_function _set_se_translator(_se_translator_function _NewPtFunc);
bool __uncaught_exception();
extern "C"
{
	typedef struct _heapinfo
	{
		int*_pentry;
		size_t _size;
		int _useflag;
	}
	_HEAPINFO;
	extern unsigned int _amblksiz;
	int _resetstkoflw(void);
	unsigned long _set_malloc_crt_max_wait(unsigned long _NewValue);
	void*_expand(void*_Memory, size_t _NewSize);
	size_t _msize(void*_Memory);
	void*_alloca(size_t _Size);
	size_t _get_sbh_threshold(void);
	int _set_sbh_threshold(size_t _NewValue);
	errno_t _set_amblksiz(size_t _Value);
	errno_t _get_amblksiz(size_t*_Value);
	int _heapadd(void*_Memory, size_t _Size);
	int _heapchk(void);
	int _heapmin(void);
	int _heapset(unsigned int _Fill);
	int _heapwalk(_HEAPINFO*_EntryInfo);
	size_t _heapused(size_t*_Used, size_t*_Commit);
	intptr_t _get_heap_handle(void);
	typedef char __static_assert_t[(sizeof(unsigned int)<=8)];
	void*_MarkAllocaS(void*_Ptr, unsigned int _Marker)
	{
		if(_Ptr)
		{
			*((unsigned int*)_Ptr)=_Marker;
			_Ptr=(char*)_Ptr+8;
		}
		return _Ptr;
	}
	void _freea(void*_Memory)
	{
		unsigned int _Marker;
		if(_Memory)
		{
			_Memory=(char*)_Memory-8;
			_Marker=*(unsigned int*)_Memory;
			if(_Marker==0xDDDD)
			{
				free(_Memory);
			}
		}
	}
}
typedef const char*__exString;
extern "C" size_t strlen(const char*);
extern "C" errno_t strcpy_s(char*_Dst, size_t _DstSize, const char*_Src);
namespace std
{
	class exception
	{
	public:
		exception();
		exception(const char*const&);
		exception(const char*const&, int);
		exception(const exception&);
		exception&operator=(const exception&);
		virtual~exception();
		virtual const char*what()const;
	private:
		const char*_m_what;
		int _m_doFree;
	};
	using::set_terminate;
	using::terminate_handler;
	using::terminate;
	using::set_unexpected;
	using::unexpected_handler;
	using::unexpected;
	typedef void(*_Prhand)(const exception&);
	bool uncaught_exception();
	class bad_exception: public exception
	{
	public:
		bad_exception(const char*_Message="bad exception")throw(): exception(_Message)
		{
		}
		virtual~bad_exception()throw()
		{
		}
	};
	static const char*_bad_alloc_Message="bad allocation";
	class bad_alloc: public exception
	{
	public:
		bad_alloc(const char*_Message)throw(): exception(_Message)
		{
		}
		bad_alloc()throw(): exception(_bad_alloc_Message, 1)
		{
		}
		virtual~bad_alloc()throw()
		{
		}
	};
}
namespace std
{
	typedef void(*new_handler)();
	struct nothrow_t
	{
	};
	extern const nothrow_t nothrow;
	new_handler set_new_handler(new_handler)throw();
}
void operator delete(void*)throw();
void*operator new(size_t _Size)throw(...);
inline void*operator new(size_t, void*_Where)throw()
{
	return (_Where);
}
inline void operator delete(void*, void*)throw()
{
}
inline void*operator new[](size_t, void*_Where)throw()
{
	return (_Where);
}
inline void operator delete[](void*, void*)throw()
{
}
void operator delete[](void*)throw();
void*operator new[](size_t _Size)throw(...);
void*operator new(size_t _Size, const std::nothrow_t&)throw();
void*operator new[](size_t _Size, const std::nothrow_t&)throw();
void operator delete(void*, const std::nothrow_t&)throw();
void operator delete[](void*, const std::nothrow_t&)throw();
using std::new_handler;
extern "C"
{
	typedef unsigned long _fsize_t;
	struct _wfinddata32_t
	{
		unsigned attrib;
		__time32_t time_create;
		__time32_t time_access;
		__time32_t time_write;
		_fsize_t size;
		wchar_t name[260];
	};
	struct _wfinddata32i64_t
	{
		unsigned attrib;
		__time32_t time_create;
		__time32_t time_access;
		__time32_t time_write;
		__int64 size;
		wchar_t name[260];
	};
	struct _wfinddata64i32_t
	{
		unsigned attrib;
		__time64_t time_create;
		__time64_t time_access;
		__time64_t time_write;
		_fsize_t size;
		wchar_t name[260];
	};
	struct _wfinddata64_t
	{
		unsigned attrib;
		__time64_t time_create;
		__time64_t time_access;
		__time64_t time_write;
		__int64 size;
		wchar_t name[260];
	};
	const unsigned short*__pctype_func(void);
	extern const unsigned short*_pctype;
	extern const unsigned short _wctype[];
	const wctype_t*__pwctype_func(void);
	extern const wctype_t*_pwctype;
	int iswalpha(wint_t _C);
	int _iswalpha_l(wint_t _C, _locale_t _Locale);
	int iswupper(wint_t _C);
	int _iswupper_l(wint_t _C, _locale_t _Locale);
	int iswlower(wint_t _C);
	int _iswlower_l(wint_t _C, _locale_t _Locale);
	int iswdigit(wint_t _C);
	int _iswdigit_l(wint_t _C, _locale_t _Locale);
	int iswxdigit(wint_t _C);
	int _iswxdigit_l(wint_t _C, _locale_t _Locale);
	int iswspace(wint_t _C);
	int _iswspace_l(wint_t _C, _locale_t _Locale);
	int iswpunct(wint_t _C);
	int _iswpunct_l(wint_t _C, _locale_t _Locale);
	int iswalnum(wint_t _C);
	int _iswalnum_l(wint_t _C, _locale_t _Locale);
	int iswprint(wint_t _C);
	int _iswprint_l(wint_t _C, _locale_t _Locale);
	int iswgraph(wint_t _C);
	int _iswgraph_l(wint_t _C, _locale_t _Locale);
	int iswcntrl(wint_t _C);
	int _iswcntrl_l(wint_t _C, _locale_t _Locale);
	int iswascii(wint_t _C);
	int isleadbyte(int _C);
	int _isleadbyte_l(int _C, _locale_t _Locale);
	wint_t towupper(wint_t _C);
	wint_t _towupper_l(wint_t _C, _locale_t _Locale);
	wint_t towlower(wint_t _C);
	wint_t _towlower_l(wint_t _C, _locale_t _Locale);
	int iswctype(wint_t _C, wctype_t _Type);
	int _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale);
	int __iswcsymf(wint_t _C);
	int _iswcsymf_l(wint_t _C, _locale_t _Locale);
	int __iswcsym(wint_t _C);
	int _iswcsym_l(wint_t _C, _locale_t _Locale);
	int is_wctype(wint_t _C, wctype_t _Type);
	wchar_t*_wgetcwd(wchar_t*_DstBuf, int _SizeInWords);
	wchar_t*_wgetdcwd(int _Drive, wchar_t*_DstBuf, int _SizeInWords);
	wchar_t*_wgetdcwd_nolock(int _Drive, wchar_t*_DstBuf, int _SizeInWords);
	int _wchdir(const wchar_t*_Path);
	int _wmkdir(const wchar_t*_Path);
	int _wrmdir(const wchar_t*_Path);
	int _waccess(const wchar_t*_Filename, int _AccessMode);
	errno_t _waccess_s(const wchar_t*_Filename, int _AccessMode);
	int _wchmod(const wchar_t*_Filename, int _Mode);
	int _wcreat(const wchar_t*_Filename, int _PermissionMode);
	intptr_t _wfindfirst32(const wchar_t*_Filename, struct _wfinddata32_t*_FindData);
	int _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t*_FindData);
	int _wunlink(const wchar_t*_Filename);
	int _wrename(const wchar_t*_NewFilename, const wchar_t*_OldFilename);
	errno_t _wmktemp_s(wchar_t*_TemplateName, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wmktemp_s(wchar_t(&_TemplateName)[_SizeFIXED])
		{
			return _wmktemp_s(_TemplateName, _SizeFIXED);
		}
	}
	wchar_t*_wmktemp(wchar_t*_TemplateName);
	intptr_t _wfindfirst32i64(const wchar_t*_Filename, struct _wfinddata32i64_t*_FindData);
	intptr_t _wfindfirst64i32(const wchar_t*_Filename, struct _wfinddata64i32_t*_FindData);
	intptr_t _wfindfirst64(const wchar_t*_Filename, struct _wfinddata64_t*_FindData);
	int _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t*_FindData);
	int _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t*_FindData);
	int _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t*_FindData);
	errno_t _wsopen_s(int*_FileHandle, const wchar_t*_Filename, int _OpenFlag, int _ShareFlag, int _PermissionFlag);
	extern "C++" int _wopen(const wchar_t*_Filename, int _OpenFlag, int _PermissionMode=0);
	extern "C++" int _wsopen(const wchar_t*_Filename, int _OpenFlag, int _ShareFlag, int _PermissionMode=0);
	wchar_t*_wsetlocale(int _Category, const wchar_t*_Locale);
	intptr_t _wexecl(const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wexecle(const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wexeclp(const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wexeclpe(const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wexecv(const wchar_t*_Filename, const wchar_t*const*_ArgList);
	intptr_t _wexecve(const wchar_t*_Filename, const wchar_t*const*_ArgList, const wchar_t*const*_Env);
	intptr_t _wexecvp(const wchar_t*_Filename, const wchar_t*const*_ArgList);
	intptr_t _wexecvpe(const wchar_t*_Filename, const wchar_t*const*_ArgList, const wchar_t*const*_Env);
	intptr_t _wspawnl(int _Mode, const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wspawnle(int _Mode, const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wspawnlp(int _Mode, const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wspawnlpe(int _Mode, const wchar_t*_Filename, const wchar_t*_ArgList, ...);
	intptr_t _wspawnv(int _Mode, const wchar_t*_Filename, const wchar_t*const*_ArgList);
	intptr_t _wspawnve(int _Mode, const wchar_t*_Filename, const wchar_t*const*_ArgList, const wchar_t*const*_Env);
	intptr_t _wspawnvp(int _Mode, const wchar_t*_Filename, const wchar_t*const*_ArgList);
	intptr_t _wspawnvpe(int _Mode, const wchar_t*_Filename, const wchar_t*const*_ArgList, const wchar_t*const*_Env);
	typedef unsigned short _ino_t;
	typedef unsigned int _dev_t;
	typedef long _off_t;
	struct _stat32
	{
		_dev_t st_dev;
		_ino_t st_ino;
		unsigned short st_mode;
		short st_nlink;
		short st_uid;
		short st_gid;
		_dev_t st_rdev;
		_off_t st_size;
		__time32_t st_atime;
		__time32_t st_mtime;
		__time32_t st_ctime;
	};
	struct _stat32i64
	{
		_dev_t st_dev;
		_ino_t st_ino;
		unsigned short st_mode;
		short st_nlink;
		short st_uid;
		short st_gid;
		_dev_t st_rdev;
		__int64 st_size;
		__time32_t st_atime;
		__time32_t st_mtime;
		__time32_t st_ctime;
	};
	struct _stat64i32
	{
		_dev_t st_dev;
		_ino_t st_ino;
		unsigned short st_mode;
		short st_nlink;
		short st_uid;
		short st_gid;
		_dev_t st_rdev;
		_off_t st_size;
		__time64_t st_atime;
		__time64_t st_mtime;
		__time64_t st_ctime;
	};
	struct _stat64
	{
		_dev_t st_dev;
		_ino_t st_ino;
		unsigned short st_mode;
		short st_nlink;
		short st_uid;
		short st_gid;
		_dev_t st_rdev;
		__int64 st_size;
		__time64_t st_atime;
		__time64_t st_mtime;
		__time64_t st_ctime;
	};
	int _wstat32(const wchar_t*_Name, struct _stat32*_Stat);
	int _wstat32i64(const wchar_t*_Name, struct _stat32i64*_Stat);
	int _wstat64i32(const wchar_t*_Name, struct _stat64i32*_Stat);
	int _wstat64(const wchar_t*_Name, struct _stat64*_Stat);
	errno_t _cgetws_s(wchar_t*_Buffer, size_t _SizeInWords, size_t*_SizeRead);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _cgetws_s(wchar_t(&_Buffer)[_SizeFIXED], size_t*_Size)
		{
			return _cgetws_s(_Buffer, _SizeFIXED, _Size);
		}
	}
	wchar_t*_cgetws(wchar_t*_Buffer);
	wint_t _getwch(void);
	wint_t _getwche(void);
	wint_t _putwch(wchar_t _WCh);
	wint_t _ungetwch(wint_t _WCh);
	int _cputws(const wchar_t*_String);
	int _cwprintf(const wchar_t*_Format, ...);
	int _cwprintf_s(const wchar_t*_Format, ...);
	int _cwscanf(const wchar_t*_Format, ...);
	int _cwscanf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _cwscanf_s(const wchar_t*_Format, ...);
	int _cwscanf_s_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vcwprintf(const wchar_t*_Format, va_list _ArgList);
	int _vcwprintf_s(const wchar_t*_Format, va_list _ArgList);
	int _cwprintf_p(const wchar_t*_Format, ...);
	int _vcwprintf_p(const wchar_t*_Format, va_list _ArgList);
	int _cwprintf_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _cwprintf_s_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vcwprintf_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _vcwprintf_s_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	int _cwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, ...);
	int _vcwprintf_p_l(const wchar_t*_Format, _locale_t _Locale, va_list _ArgList);
	wint_t _putwch_nolock(wchar_t _WCh);
	wint_t _getwch_nolock(void);
	wint_t _getwche_nolock(void);
	wint_t _ungetwch_nolock(wint_t _WCh);
	struct tm
	{
		int tm_sec;
		int tm_min;
		int tm_hour;
		int tm_mday;
		int tm_mon;
		int tm_year;
		int tm_wday;
		int tm_yday;
		int tm_isdst;
	};
	wchar_t*_wasctime(const struct tm*_Tm);
	errno_t _wasctime_s(wchar_t*_Buf, size_t _SizeInWords, const struct tm*_Tm);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wasctime_s(wchar_t(&_Buffer)[_SizeFIXED], const struct tm*_Time)
		{
			return _wasctime_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	wchar_t*_wctime32(const __time32_t*_Time);
	errno_t _wctime32_s(wchar_t*_Buf, size_t _SizeInWords, const __time32_t*_Time);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wctime32_s(wchar_t(&_Buffer)[_SizeFIXED], const __time32_t*_Time)
		{
			return _wctime32_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	size_t wcsftime(wchar_t*_Buf, size_t _SizeInWords, const wchar_t*_Format, const struct tm*_Tm);
	size_t _wcsftime_l(wchar_t*_Buf, size_t _SizeInWords, const wchar_t*_Format, const struct tm*_Tm, _locale_t _Locale);
	errno_t _wstrdate_s(wchar_t*_Buf, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wstrdate_s(wchar_t(&_Buffer)[_SizeFIXED])
		{
			return _wstrdate_s(_Buffer, _SizeFIXED);
		}
	}
	wchar_t*_wstrdate(wchar_t*_Buffer);
	errno_t _wstrtime_s(wchar_t*_Buf, size_t _SizeInWords);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wstrtime_s(wchar_t(&_Buffer)[_SizeFIXED])
		{
			return _wstrtime_s(_Buffer, _SizeFIXED);
		}
	}
	wchar_t*_wstrtime(wchar_t*_Buffer);
	wchar_t*_wctime64(const __time64_t*_Time);
	errno_t _wctime64_s(wchar_t*_Buf, size_t _SizeInWords, const __time64_t*_Time);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _wctime64_s(wchar_t(&_Buffer)[_SizeFIXED], const __time64_t*_Time)
		{
			return _wctime64_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	static wchar_t*_wctime(const time_t*_Time)
	{
		return _wctime64(_Time);
	}
	static errno_t _wctime_s(wchar_t*_Buffer, size_t _SizeInWords, const time_t*_Time)
	{
		return _wctime64_s(_Buffer, _SizeInWords, _Time);
	}
	typedef int mbstate_t;
	typedef wchar_t _Wint_t;
	wint_t btowc(int);
	size_t mbrlen(const char*_Ch, size_t _SizeInBytes, mbstate_t*_State);
	size_t mbrtowc(wchar_t*_DstCh, const char*_SrcCh, size_t _SizeInBytes, mbstate_t*_State);
	errno_t mbsrtowcs_s(size_t*_Retval, wchar_t*_Dst, size_t _SizeInWords, const char**_PSrc, size_t _N, mbstate_t*_State);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t mbsrtowcs_s(size_t*_Retval, wchar_t(&_Dest)[_SizeFIXED], const char**_PSource, size_t _Count, mbstate_t*_State)
		{
			return mbsrtowcs_s(_Retval, _Dest, _SizeFIXED, _PSource, _Count, _State);
		}
	}
	size_t mbsrtowcs(wchar_t*_Dest, const char**_PSrc, size_t _Count, mbstate_t*_State);
	errno_t wcrtomb_s(size_t*_Retval, char*_Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t*_State);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcrtomb_s(size_t*_Retval, char(&_Dest)[_SizeFIXED], wchar_t _Source, mbstate_t*_State)
		{
			return wcrtomb_s(_Retval, _Dest, _SizeFIXED, _Source, _State);
		}
	}
	size_t wcrtomb(char*_Dest, wchar_t _Source, mbstate_t*_State);
	errno_t wcsrtombs_s(size_t*_Retval, char*_Dst, size_t _SizeInBytes, const wchar_t**_Src, size_t _Size, mbstate_t*_State);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t wcsrtombs_s(size_t*_Retval, char(&_Dest)[_SizeFIXED], const wchar_t**_PSrc, size_t _Count, mbstate_t*_State)
		{
			return wcsrtombs_s(_Retval, _Dest, _SizeFIXED, _PSrc, _Count, _State);
		}
	}
	size_t wcsrtombs(char*_Dest, const wchar_t**_PSource, size_t _Count, mbstate_t*_State);
	int wctob(wint_t _WCh);
	void*memmove(void*_Dst, const void*_Src, size_t _MaxCount);
	void*memcpy(void*_Dst, const void*_Src, size_t _MaxCount);
	errno_t memcpy_s(void*_Dst, rsize_t _DstSize, const void*_Src, rsize_t _MaxCount);
	errno_t memmove_s(void*_Dst, rsize_t _DstSize, const void*_Src, rsize_t _MaxCount);
	int fwide(FILE*_F, int _M)
	{
		(void)_F;
		return (_M);
	}
	int mbsinit(const mbstate_t*_P)
	{
		return (_P==0||*_P==0);
	}
	const wchar_t*wmemchr(const wchar_t*_S, wchar_t _C, size_t _N)
	{
		for(;
		0<_N;
		++_S, --_N)if(*_S==_C)return (const wchar_t*)(_S);
		return (0);
	}
	int wmemcmp(const wchar_t*_S1, const wchar_t*_S2, size_t _N)
	{
		for(;
		0<_N;
		++_S1, ++_S2, --_N)if(*_S1!=*_S2)return (*_S1<*_S2?-1: +1);
		return (0);
	}
	wchar_t*wmemcpy(wchar_t*_S1, const wchar_t*_S2, size_t _N)
	{
		return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
	}
	errno_t wmemcpy_s(wchar_t*_S1, rsize_t _N1, const wchar_t*_S2, rsize_t _N)
	{
		return memcpy_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
	}
	wchar_t*wmemmove(wchar_t*_S1, const wchar_t*_S2, size_t _N)
	{
		return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
	}
	errno_t wmemmove_s(wchar_t*_S1, rsize_t _N1, const wchar_t*_S2, rsize_t _N)
	{
		return memmove_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
	}
	wchar_t*wmemset(wchar_t*_S, wchar_t _C, size_t _N)
	{
		wchar_t*_Su=_S;
		for(;
		0<_N;
		++_Su, --_N)
		{
			*_Su=_C;
		}
		return (_S);
	}
	extern "C++"
	{
		inline wchar_t*wmemchr(wchar_t*_S, wchar_t _C, size_t _N)
		{
			return (wchar_t*)wmemchr((const wchar_t*)_S, _C, _N);
		}
	}
}
typedef mbstate_t _Mbstatet;
namespace std
{
	using::mbstate_t;
	using::size_t;
	using::tm;
	using::wint_t;
	using::btowc;
	using::fgetwc;
	using::fgetws;
	using::fputwc;
	using::fputws;
	using::fwide;
	using::fwprintf;
	using::fwscanf;
	using::getwc;
	using::getwchar;
	using::mbrlen;
	using::mbrtowc;
	using::mbsrtowcs;
	using::mbsinit;
	using::putwc;
	using::putwchar;
	using::swprintf;
	using::swscanf;
	using::ungetwc;
	using::vfwprintf;
	using::vswprintf;
	using::vwprintf;
	using::wcrtomb;
	using::wprintf;
	using::wscanf;
	using::wcsrtombs;
	using::wcstol;
	using::wcscat;
	using::wcschr;
	using::wcscmp;
	using::wcscoll;
	using::wcscpy;
	using::wcscspn;
	using::wcslen;
	using::wcsncat;
	using::wcsncmp;
	using::wcsncpy;
	using::wcspbrk;
	using::wcsrchr;
	using::wcsspn;
	using::wcstod;
	using::wcstoul;
	using::wcsstr;
	using::wcstok;
	using::wcsxfrm;
	using::wctob;
	using::wmemchr;
	using::wmemcmp;
	using::wmemcpy;
	using::wmemmove;
	using::wmemset;
	using::wcsftime;
}
extern "C"
{
	typedef void*_HFILE;
	typedef int(*_CRT_REPORT_HOOK)(int, char*, int*);
	typedef int(*_CRT_REPORT_HOOKW)(int, wchar_t*, int*);
	typedef int(*_CRT_ALLOC_HOOK)(int, void*, size_t, int, long, const unsigned char*, int);
	typedef void(*_CRT_DUMP_CLIENT)(void*, size_t);
	struct _CrtMemBlockHeader;
	typedef struct _CrtMemState
	{
		struct _CrtMemBlockHeader*pBlockHeader;
		size_t lCounts[5];
		size_t lSizes[5];
		size_t lHighWaterCount;
		size_t lTotalCount;
	}
	_CrtMemState;
	extern long _crtAssertBusy;
	_CRT_REPORT_HOOK _CrtGetReportHook(void);
	_CRT_REPORT_HOOK _CrtSetReportHook(_CRT_REPORT_HOOK _PFnNewHook);
	int _CrtSetReportHook2(int _Mode, _CRT_REPORT_HOOK _PFnNewHook);
	int _CrtSetReportHookW2(int _Mode, _CRT_REPORT_HOOKW _PFnNewHook);
	int _CrtSetReportMode(int _ReportType, int _ReportMode);
	_HFILE _CrtSetReportFile(int _ReportType, _HFILE _ReportFile);
	int _CrtDbgReport(int _ReportType, const char*_Filename, int _Linenumber, const char*_ModuleName, const char*_Format, ...);
	size_t _CrtSetDebugFillThreshold(size_t _NewDebugFillThreshold);
	int _CrtDbgReportW(int _ReportType, const wchar_t*_Filename, int _LineNumber, const wchar_t*_ModuleName, const wchar_t*_Format, ...);
	extern long _crtBreakAlloc;
	long _CrtSetBreakAlloc(long _BreakAlloc);
	void*_malloc_dbg(size_t _Size, int _BlockType, const char*_Filename, int _LineNumber);
	void*_calloc_dbg(size_t _NumOfElements, size_t _SizeOfElements, int _BlockType, const char*_Filename, int _LineNumber);
	void*_realloc_dbg(void*_Memory, size_t _NewSize, int _BlockType, const char*_Filename, int _LineNumber);
	void*_recalloc_dbg(void*_Memory, size_t _NumOfElements, size_t _SizeOfElements, int _BlockType, const char*_Filename, int _LineNumber);
	void*_expand_dbg(void*_Memory, size_t _NewSize, int _BlockType, const char*_Filename, int _LineNumber);
	void _free_dbg(void*_Memory, int _BlockType);
	size_t _msize_dbg(void*_Memory, int _BlockType);
	void*_aligned_malloc_dbg(size_t _Size, size_t _Alignment, const char*_Filename, int _LineNumber);
	void*_aligned_realloc_dbg(void*_Memory, size_t _Size, size_t _Alignment, const char*_Filename, int _LineNumber);
	void*_aligned_recalloc_dbg(void*_Memory, size_t _NumOfElements, size_t _SizeOfElements, size_t _Alignment, const char*_Filename, int _LineNumber);
	void*_aligned_offset_malloc_dbg(size_t _Size, size_t _Alignment, size_t _Offset, const char*_Filename, int _LineNumber);
	void*_aligned_offset_realloc_dbg(void*_Memory, size_t _Size, size_t _Alignment, size_t _Offset, const char*_Filename, int _LineNumber);
	void*_aligned_offset_recalloc_dbg(void*_Memory, size_t _NumOfElements, size_t _SizeOfElements, size_t _Alignment, size_t _Offset, const char*_Filename, int _LineNumber);
	void _aligned_free_dbg(void*_Memory);
	char*_strdup_dbg(const char*_Str, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wcsdup_dbg(const wchar_t*_Str, int _BlockType, const char*_Filename, int _LineNumber);
	char*_tempnam_dbg(const char*_DirName, const char*_FilePrefix, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wtempnam_dbg(const wchar_t*_DirName, const wchar_t*_FilePrefix, int _BlockType, const char*_Filename, int _LineNumber);
	char*_fullpath_dbg(char*_FullPath, const char*_Path, size_t _SizeInBytes, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wfullpath_dbg(wchar_t*_FullPath, const wchar_t*_Path, size_t _SizeInWords, int _BlockType, const char*_Filename, int _LineNumber);
	char*_getcwd_dbg(char*_DstBuf, int _SizeInBytes, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wgetcwd_dbg(wchar_t*_DstBuf, int _SizeInWords, int _BlockType, const char*_Filename, int _LineNumber);
	char*_getdcwd_dbg(int _Drive, char*_DstBuf, int _SizeInBytes, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wgetdcwd_dbg(int _Drive, wchar_t*_DstBuf, int _SizeInWords, int _BlockType, const char*_Filename, int _LineNumber);
	char*_getdcwd_lk_dbg(int _Drive, char*_DstBuf, int _SizeInBytes, int _BlockType, const char*_Filename, int _LineNumber);
	wchar_t*_wgetdcwd_lk_dbg(int _Drive, wchar_t*_DstBuf, int _SizeInWords, int _BlockType, const char*_Filename, int _LineNumber);
	errno_t _dupenv_s_dbg(char**_PBuffer, size_t*_PBufferSizeInBytes, const char*_VarName, int _BlockType, const char*_Filename, int _LineNumber);
	errno_t _wdupenv_s_dbg(wchar_t**_PBuffer, size_t*_PBufferSizeInWords, const wchar_t*_VarName, int _BlockType, const char*_Filename, int _LineNumber);
	_CRT_ALLOC_HOOK _CrtGetAllocHook(void);
	_CRT_ALLOC_HOOK _CrtSetAllocHook(_CRT_ALLOC_HOOK _PfnNewHook);
	extern int _crtDbgFlag;
	int _CrtCheckMemory(void);
	int _CrtSetDbgFlag(int _NewFlag);
	void _CrtDoForAllClientObjects(void(*_PFn)(void*, void*), void*_Context);
	int _CrtIsValidPointer(const void*_Ptr, unsigned int _Bytes, int _ReadWrite);
	int _CrtIsValidHeapPointer(const void*_HeapPtr);
	int _CrtIsMemoryBlock(const void*_Memory, unsigned int _Bytes, long*_RequestNumber, char**_Filename, int*_LineNumber);
	int _CrtReportBlockType(const void*_Memory);
	_CRT_DUMP_CLIENT _CrtGetDumpClient(void);
	_CRT_DUMP_CLIENT _CrtSetDumpClient(_CRT_DUMP_CLIENT _PFnNewDump);
	void _CrtMemCheckpoint(_CrtMemState*_State);
	int _CrtMemDifference(_CrtMemState*_State, const _CrtMemState*_OldState, const _CrtMemState*_NewState);
	void _CrtMemDumpAllObjectsSince(const _CrtMemState*_State);
	void _CrtMemDumpStatistics(const _CrtMemState*_State);
	int _CrtDumpMemoryLeaks(void);
	int _CrtSetCheckCount(int _CheckCount);
	int _CrtGetCheckCount(void);
}
extern "C++"
{
	void*operator new[](size_t _Size);
	void*operator new(size_t _Size, int, const char*, int);
	void*operator new[](size_t _Size, int, const char*, int);
	void operator delete[](void*);
	inline void operator delete(void*_P, int, const char*, int)
	{
		::operator delete(_P);
	}
	inline void operator delete[](void*_P, int, const char*, int)
	{
		::operator delete[](_P);
	}
}
namespace std
{
	typedef long streamoff;
	typedef int streamsize;
	extern fpos_t _Fpz;
	extern const streamoff _BADOFF;
	template<class _Statetype>
	class fpos
	{
		typedef fpos<_Statetype>_Myt;
	public:
		fpos(streamoff _Off=0): _Myoff(_Off), _Fpos(0), _Mystate(_Stz)
		{
		}
		fpos(_Statetype _State, fpos_t _Fileposition): _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{
		}
		_Statetype state()const
		{
			return (_Mystate);
		}
		void state(_Statetype _State)
		{
			_Mystate=_State;
		}
		fpos_t seekpos()const
		{
			return (_Fpos);
		}
		operator streamoff()const
		{
			return (_Myoff+((long)(_Fpos)));
		}
		streamoff operator-(const _Myt&_Right)const
		{
			return ((streamoff)*this-(streamoff)_Right);
		}
		_Myt&operator+=(streamoff _Off)
		{
			_Myoff+=_Off;
			return (*this);
		}
		_Myt&operator-=(streamoff _Off)
		{
			_Myoff-=_Off;
			return (*this);
		}
		_Myt operator+(streamoff _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt operator-(streamoff _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		bool operator==(const _Myt&_Right)const
		{
			return ((streamoff)*this==(streamoff)_Right);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
	private:
		static const _Statetype _Stz;
		streamoff _Myoff;
		fpos_t _Fpos;
		_Statetype _Mystate;
	};
	template<class _Statetype>
	const _Statetype fpos<_Statetype>::_Stz=_Statetype();
	typedef fpos<_Mbstatet>streampos;
	typedef streampos wstreampos;
	struct _Unsecure_char_traits_tag
	{
	};
	struct _Secure_char_traits_tag
	{
	};
	struct _Char_traits_base
	{
		typedef _Unsecure_char_traits_tag _Secure_char_traits;
	};
	template<class _Elem>
	struct char_traits: public _Char_traits_base
	{
		typedef _Elem char_type;
		typedef long int_type;
		typedef streampos pos_type;
		typedef streamoff off_type;
		typedef _Mbstatet state_type;
		static void assign(_Elem&_Left, const _Elem&_Right)
		{
			_Left=_Right;
		}
		static bool eq(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left==_Right);
		}
		static bool lt(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left<_Right);
		}
		static int compare(const _Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			for(;
			0<_Count;
			--_Count, ++_First1, ++_First2)if(!eq(*_First1, *_First2))return (lt(*_First1, *_First2)?-1: +1);
			return (0);
		}
		static size_t length(const _Elem*_First)
		{
			size_t _Count;
			for(_Count=0;
			!eq(*_First, _Elem());
			++_First)++_Count;
			return (_Count);
		}
		static _Elem*copy(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Copy_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Copy_s(_Elem*_First1, size_t _Dest_size, const _Elem*_First2, size_t _Count)
		{

			{
				if(!(_Dest_size>=_Count))
				{
					(void)((!!((("_Dest_size >= _Count", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iosfwd", 212, 0, L"(\"_Dest_size >= _Count\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"_Dest_size >= _Count", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iosfwd", 212, 0);
					return (0);
				}
			};
			_Elem*_Next=_First1;
			for(;
			0<_Count;
			--_Count, ++_Next, ++_First2)assign(*_Next, *_First2);
			return (_First1);
		}
		static const _Elem*find(const _Elem*_First, size_t _Count, const _Elem&_Ch)
		{
			for(;
			0<_Count;
			--_Count, ++_First)if(eq(*_First, _Ch))return (_First);
			return (0);
		}
		static _Elem*move(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Move_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Move_s(_Elem*_First1, size_t _Dest_size, const _Elem*_First2, size_t _Count)
		{

			{
				if(!(_Dest_size>=_Count))
				{
					(void)((!!((("_Dest_size >= _Count", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iosfwd", 242, 0, L"(\"_Dest_size >= _Count\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"_Dest_size >= _Count", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iosfwd", 242, 0);
					return (0);
				}
			};
			_Elem*_Next=_First1;
			if(_First2<_Next&&_Next<_First2+_Count)for(_Next+=_Count, _First2+=_Count;
			0<_Count;
			--_Count)assign(*--_Next, *--_First2);
			else for(;
			0<_Count;
			--_Count, ++_Next, ++_First2)assign(*_Next, *_First2);
			return (_First1);
		}
		static _Elem*assign(_Elem*_First, size_t _Count, _Elem _Ch)
		{
			_Elem*_Next=_First;
			for(;
			0<_Count;
			--_Count, ++_Next)assign(*_Next, _Ch);
			return (_First);
		}
		static _Elem to_char_type(const int_type&_Meta)
		{
			return ((_Elem)_Meta);
		}
		static int_type to_int_type(const _Elem&_Ch)
		{
			return ((int_type)_Ch);
		}
		static bool eq_int_type(const int_type&_Left, const int_type&_Right)
		{
			return (_Left==_Right);
		}
		static int_type eof()
		{
			return ((int_type)(-1));
		}
		static int_type not_eof(const int_type&_Meta)
		{
			return (_Meta!=eof()?(int_type)_Meta: (int_type)!eof());
		}
	};
	template<>
	struct char_traits<wchar_t>: public _Char_traits_base
	{
		typedef wchar_t _Elem;
		typedef _Elem char_type;
		typedef wint_t int_type;
		typedef streampos pos_type;
		typedef streamoff off_type;
		typedef _Mbstatet state_type;
		static void assign(_Elem&_Left, const _Elem&_Right)
		{
			_Left=_Right;
		}
		static bool eq(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left==_Right);
		}
		static bool lt(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left<_Right);
		}
		static int compare(const _Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return (::wmemcmp(_First1, _First2, _Count));
		}
		static size_t length(const _Elem*_First)
		{
			return (::wcslen(_First));
		}
		static _Elem*copy(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Copy_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Copy_s(_Elem*_First1, size_t _Size_in_words, const _Elem*_First2, size_t _Count)
		{
			::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
			return _First1;
		}
		static const _Elem*find(const _Elem*_First, size_t _Count, const _Elem&_Ch)
		{
			return ((const _Elem*)::wmemchr(_First, _Ch, _Count));
		}
		static _Elem*move(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Move_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Move_s(_Elem*_First1, size_t _Size_in_words, const _Elem*_First2, size_t _Count)
		{
			::wmemmove_s((_First1), (_Size_in_words), (_First2), (_Count));
			return (_Elem*)_First1;
		}
		static _Elem*assign(_Elem*_First, size_t _Count, _Elem _Ch)
		{
			return ((_Elem*)::wmemset(_First, _Ch, _Count));
		}
		static _Elem to_char_type(const int_type&_Meta)
		{
			return (_Meta);
		}
		static int_type to_int_type(const _Elem&_Ch)
		{
			return (_Ch);
		}
		static bool eq_int_type(const int_type&_Left, const int_type&_Right)
		{
			return (_Left==_Right);
		}
		static int_type eof()
		{
			return ((wint_t)(0xFFFF));
		}
		static int_type not_eof(const int_type&_Meta)
		{
			return (_Meta!=eof()?_Meta: !eof());
		}
	};
	template<>
	struct char_traits<char>: public _Char_traits_base
	{
		typedef char _Elem;
		typedef _Elem char_type;
		typedef int int_type;
		typedef streampos pos_type;
		typedef streamoff off_type;
		typedef _Mbstatet state_type;
		static void assign(_Elem&_Left, const _Elem&_Right)
		{
			_Left=_Right;
		}
		static bool eq(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left==_Right);
		}
		static bool lt(const _Elem&_Left, const _Elem&_Right)
		{
			return (_Left<_Right);
		}
		static int compare(const _Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return (::memcmp(_First1, _First2, _Count));
		}
		static size_t length(const _Elem*_First)
		{
			return (::strlen(_First));
		}
		static _Elem*copy(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Copy_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Copy_s(_Elem*_First1, size_t _Size_in_bytes, const _Elem*_First2, size_t _Count)
		{
			::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
			return _First1;
		}
		static const _Elem*find(const _Elem*_First, size_t _Count, const _Elem&_Ch)
		{
			return ((const _Elem*)::memchr(_First, _Ch, _Count));
		}
		static _Elem*move(_Elem*_First1, const _Elem*_First2, size_t _Count)
		{
			return _Move_s(_First1, _Count, _First2, _Count);
		}
		static _Elem*_Move_s(_Elem*_First1, size_t _Size_in_bytes, const _Elem*_First2, size_t _Count)
		{
			::memmove_s((_First1), (_Size_in_bytes), (_First2), (_Count));
			return _First1;
		}
		static _Elem*assign(_Elem*_First, size_t _Count, _Elem _Ch)
		{
			return ((_Elem*)::memset(_First, _Ch, _Count));
		}
		static _Elem to_char_type(const int_type&_Meta)
		{
			return ((_Elem)_Meta);
		}
		static int_type to_int_type(const _Elem&_Ch)
		{
			return ((unsigned char)_Ch);
		}
		static bool eq_int_type(const int_type&_Left, const int_type&_Right)
		{
			return (_Left==_Right);
		}
		static int_type eof()
		{
			return ((-1));
		}
		static int_type not_eof(const int_type&_Meta)
		{
			return (_Meta!=eof()?_Meta: !eof());
		}
	};
	template<class _Traits>
	class _Inherits_from_char_traits_base
	{
		typedef char _True;
		class _False
		{
			char _Dummy[2];
		};
		static _True _Inherits(_Char_traits_base);
		static _False _Inherits(...);
		static _Traits _Make_traits();
	public:
		enum
		{
			_Exists=sizeof(_Inherits(_Make_traits()))==sizeof(_True)
		};
	};
	template<class _Traits, bool _Inherits_from_char_traits_base>
	class _Char_traits_category_helper
	{
	public:
		typedef _Unsecure_char_traits_tag _Secure_char_traits;
	};
	template<class _Elem>
	class _Char_traits_category_helper<char_traits<_Elem>, true>
	{
	public:
		typedef _Secure_char_traits_tag _Secure_char_traits;
	};
	template<class _Traits>
	class _Char_traits_category_helper<_Traits, true>
	{
	public:
		typedef typename _Traits::_Secure_char_traits _Secure_char_traits;
	};
	template<class _Traits>
	class _Char_traits_category
	{
	public:
		typedef typename _Char_traits_category_helper<_Traits, _Inherits_from_char_traits_base<_Traits>::_Exists>::_Secure_char_traits _Secure_char_traits;
	};
	template<class _Traits>
	inline typename _Char_traits_category<_Traits>::_Secure_char_traits _Char_traits_cat()
	{
		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
		return (_Secure);
	}
	namespace _Traits_helper
	{
		template<class _Traits>
		inline typename _Traits::char_type*copy_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count)
		{
			return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());
		}
		template<class _Traits>
		inline typename _Traits::char_type*copy_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count, _Secure_char_traits_tag)
		{
			return _Traits::_Copy_s(_First1, _Size, _First2, _Count);
		}
		template<class _Traits>
		inline typename _Traits::char_type*copy_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count, _Unsecure_char_traits_tag)
		{
			return _Traits::copy(_First1, _First2, _Count);
		}
		template<class _Traits>
		inline typename _Traits::char_type*move_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count)
		{
			return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());
		}
		template<class _Traits>
		inline typename _Traits::char_type*move_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count, _Secure_char_traits_tag)
		{
			return _Traits::_Move_s(_First1, _Size, _First2, _Count);
		}
		template<class _Traits>
		inline typename _Traits::char_type*move_s(typename _Traits::char_type*_First1, size_t _Size, const typename _Traits::char_type*_First2, size_t _Count, _Unsecure_char_traits_tag)
		{
			return _Traits::move(_First1, _First2, _Count);
		}
	}
	template<class _Ty>
	class allocator;
	class ios_base;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_ios;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class istreambuf_iterator;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class ostreambuf_iterator;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_streambuf;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_istream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_ostream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_iostream;
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Alloc=allocator<_Elem> >
	class basic_stringbuf;
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Alloc=allocator<_Elem> >
	class basic_istringstream;
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Alloc=allocator<_Elem> >
	class basic_ostringstream;
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Alloc=allocator<_Elem> >
	class basic_stringstream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_filebuf;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_ifstream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_ofstream;
	template<class _Elem, class _Traits=char_traits<_Elem> >
	class basic_fstream;
	typedef basic_ios<char, char_traits<char> >ios;
	typedef basic_streambuf<char, char_traits<char> >streambuf;
	typedef basic_istream<char, char_traits<char> >istream;
	typedef basic_ostream<char, char_traits<char> >ostream;
	typedef basic_iostream<char, char_traits<char> >iostream;
	typedef basic_stringbuf<char, char_traits<char>, allocator<char> >stringbuf;
	typedef basic_istringstream<char, char_traits<char>, allocator<char> >istringstream;
	typedef basic_ostringstream<char, char_traits<char>, allocator<char> >ostringstream;
	typedef basic_stringstream<char, char_traits<char>, allocator<char> >stringstream;
	typedef basic_filebuf<char, char_traits<char> >filebuf;
	typedef basic_ifstream<char, char_traits<char> >ifstream;
	typedef basic_ofstream<char, char_traits<char> >ofstream;
	typedef basic_fstream<char, char_traits<char> >fstream;
	typedef basic_ios<wchar_t, char_traits<wchar_t> >wios;
	typedef basic_streambuf<wchar_t, char_traits<wchar_t> >wstreambuf;
	typedef basic_istream<wchar_t, char_traits<wchar_t> >wistream;
	typedef basic_ostream<wchar_t, char_traits<wchar_t> >wostream;
	typedef basic_iostream<wchar_t, char_traits<wchar_t> >wiostream;
	typedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wstringbuf;
	typedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wistringstream;
	typedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wostringstream;
	typedef basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wstringstream;
	typedef basic_filebuf<wchar_t, char_traits<wchar_t> >wfilebuf;
	typedef basic_ifstream<wchar_t, char_traits<wchar_t> >wifstream;
	typedef basic_ofstream<wchar_t, char_traits<wchar_t> >wofstream;
	typedef basic_fstream<wchar_t, char_traits<wchar_t> >wfstream;
}
namespace std
{
	template<class _Ty>
	inline void swap(_Ty&_Left, _Ty&_Right)
	{
		_Ty _Tmp=_Left;
		_Left=_Right, _Right=_Tmp;
	}
	template<class _Ty1, class _Ty2>
	struct pair
	{
		typedef pair<_Ty1, _Ty2>_Myt;
		typedef _Ty1 first_type;
		typedef _Ty2 second_type;
		pair(): first(_Ty1()), second(_Ty2())
		{
		}
		pair(const _Ty1&_Val1, const _Ty2&_Val2): first(_Val1), second(_Val2)
		{
		}
		template<class _Other1, class _Other2>
		pair(const pair<_Other1, _Other2>&_Right): first(_Right.first), second(_Right.second)
		{
		}
		void swap(_Myt&_Right)
		{
			std::swap(first, _Right.first);
			std::swap(second, _Right.second);
		}
		_Ty1 first;
		_Ty2 second;
	};
	template<class _Ty1, class _Ty2>
	inline bool operator==(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (_Left.first==_Right.first&&_Left.second==_Right.second);
	}
	template<class _Ty1, class _Ty2>
	inline bool operator!=(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty1, class _Ty2>
	inline bool operator<(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (_Left.first<_Right.first||!(_Right.first<_Left.first)&&_Left.second<_Right.second);
	}
	template<class _Ty1, class _Ty2>
	inline bool operator>(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Ty1, class _Ty2>
	inline bool operator<=(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Ty1, class _Ty2>
	inline bool operator>=(const pair<_Ty1, _Ty2>&_Left, const pair<_Ty1, _Ty2>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Ty1, class _Ty2>
	inline pair<_Ty1, _Ty2>make_pair(_Ty1 _Val1, _Ty2 _Val2)
	{
		return (pair<_Ty1, _Ty2>(_Val1, _Val2));
	}
	template<class _Ty1, class _Ty2>
	inline void swap(pair<_Ty1, _Ty2>&_Left, pair<_Ty1, _Ty2>&_Right)
	{
		_Left.swap(_Right);
	}
	namespace rel_ops
	{
		template<class _Ty>
		inline bool operator!=(const _Ty&_Left, const _Ty&_Right)
		{
			return (!(_Left==_Right));
		}
		template<class _Ty>
		inline bool operator>(const _Ty&_Left, const _Ty&_Right)
		{
			return (_Right<_Left);
		}
		template<class _Ty>
		inline bool operator<=(const _Ty&_Left, const _Ty&_Right)
		{
			return (!(_Right<_Left));
		}
		template<class _Ty>
		inline bool operator>=(const _Ty&_Left, const _Ty&_Right)
		{
			return (!(_Left<_Right));
		}
	}
}
namespace std
{
	struct _Unchecked_iterator_tag
	{
	};
	struct _Range_checked_iterator_tag
	{
	};
	struct _Unchanged_checked_iterator_base_type_tag
	{
	};
	struct _Different_checked_iterator_base_type_tag
	{
	};
	struct _Undefined_inner_type_tag
	{
	};
	struct _Undefined_move_tag
	{
	};
	struct _Swap_move_tag
	{
	};
	void _Debug_message(const char*, const char*);
	void _Debug_message(const wchar_t*, const wchar_t*, unsigned int line);
	class _Iterator_base;
	class _Container_base
	{
	public:
		friend class _Iterator_base;
		typedef _Undefined_move_tag _Move_category;
		_Container_base(): _Myfirstiter(0)
		{
		}
		_Container_base(const _Container_base&): _Myfirstiter(0)
		{
		}
		_Container_base&operator=(const _Container_base&)
		{
			return (*this);
		}
		~_Container_base()
		{
			_Orphan_all();
		}
		void _Orphan_all()const;
		void _Swap_all(_Container_base&)const;
		_Iterator_base*_Myfirstiter;
	};
	class _Iterator_base
	{
	public:
		typedef _Unchecked_iterator_tag _Checked_iterator_category;
		typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type;
		typedef _Undefined_inner_type_tag _Inner_type;
		friend class _Container_base;
		_Iterator_base(): _Mycont(0), _Mynextiter(0)
		{
		}
		_Iterator_base(const _Iterator_base&_Right): _Mycont(0), _Mynextiter(0)
		{
			*this=_Right;
		}
		_Iterator_base&operator=(const _Iterator_base&_Right)
		{
			if(_Mycont!=_Right._Mycont)
			{
				_Lockit _Lock(3);
				_Orphan_me();
				_Adopt(_Right._Mycont);
			}
			return (*this);
		}
		~_Iterator_base()
		{
			_Lockit _Lock(3);
			_Orphan_me();
		}
		void _Adopt(const _Container_base*_Parent)
		{
			if(_Mycont!=_Parent)
			{
				_Lockit _Lock(3);
				_Orphan_me();
				if(_Parent!=0&&_Parent->_Myfirstiter!=((_Iterator_base*)-3))
				{
					_Mynextiter=_Parent->_Myfirstiter;
					((_Container_base*)_Parent)->_Myfirstiter=this;
				}
				_Mycont=_Parent;
			}
		}
		void _Orphan_me()
		{
			if(_Mycont!=0&&_Mycont->_Myfirstiter!=((_Iterator_base*)-3))
			{
				_Iterator_base**_Pnext=(_Iterator_base**)&_Mycont->_Myfirstiter;
				while(*_Pnext!=0&&*_Pnext!=this)_Pnext=&(*_Pnext)->_Mynextiter;
				if(*_Pnext==0)_Debug_message(L"ITERATOR LIST CORRUPTED!", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 178);
				*_Pnext=_Mynextiter;
				_Mycont=0;
			}
		}
		const _Container_base*_Mycont;
		_Iterator_base*_Mynextiter;
	};
	typedef _Iterator_base _Iterator_base_secure;
	inline void _Container_base::_Orphan_all()const
	{
		_Lockit _Lock(3);
		if(_Myfirstiter!=((_Iterator_base*)-3))
		{
			for(_Iterator_base**_Pnext=(_Iterator_base**)&_Myfirstiter;
			*_Pnext!=0;
			*_Pnext=(*_Pnext)->_Mynextiter)(*_Pnext)->_Mycont=0;
			*(_Iterator_base**)&_Myfirstiter=0;
		}
	}
	inline void _Container_base::_Swap_all(_Container_base&_Right)const
	{
		_Lockit _Lock(3);
		_Iterator_base*_Pnext;
		_Iterator_base*_Temp=(_Iterator_base*)_Myfirstiter;
		*(_Iterator_base**)&_Myfirstiter=(_Iterator_base*)_Right._Myfirstiter;
		*(_Iterator_base**)&_Right._Myfirstiter=_Temp;
		if(_Myfirstiter!=((_Iterator_base*)-3))
		{
			for(_Pnext=(_Iterator_base*)_Myfirstiter;
			_Pnext!=0;
			_Pnext=_Pnext->_Mynextiter)_Pnext->_Mycont=this;
		}
		if(_Right._Myfirstiter!=((_Iterator_base*)-3))
		{
			for(_Pnext=(_Iterator_base*)_Right._Myfirstiter;
			_Pnext!=0;
			_Pnext=_Pnext->_Mynextiter)_Pnext->_Mycont=&_Right;
		}
	}
	template<class _Iter>
	inline const _Container_base*_Debug_get_cont(const _Iter&)
	{
		return (0);
	}
	inline const _Container_base*_Debug_get_cont(const _Iterator_base&_Where)
	{
		return (_Where._Mycont);
	}
	template<class _Ty1, class _Ty2>
	inline bool _Debug_lt(const _Ty1&_Left, const _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!(_Left<_Right))return (false);
		else if(_Right<_Left)_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Ty1, class _Ty2>
	inline bool _Debug_lt(const _Ty1&_Left, _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!(_Left<_Right))return (false);
		else if(_Right<_Left)_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Ty1, class _Ty2>
	inline bool _Debug_lt(_Ty1&_Left, const _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!(_Left<_Right))return (false);
		else if(_Right<_Left)_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Ty1, class _Ty2>
	inline bool _Debug_lt(_Ty1&_Left, _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!(_Left<_Right))return (false);
		else if(_Right<_Left)_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Pr, class _Ty1, class _Ty2>
	inline bool _Debug_lt_pred(_Pr _Pred, const _Ty1&_Left, const _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!_Pred(_Left, _Right))return (false);
		else if(_Pred(_Right, _Left))_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Pr, class _Ty1, class _Ty2>
	inline bool _Debug_lt_pred(_Pr _Pred, const _Ty1&_Left, _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!_Pred(_Left, _Right))return (false);
		else if(_Pred(_Right, _Left))_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Pr, class _Ty1, class _Ty2>
	inline bool _Debug_lt_pred(_Pr _Pred, _Ty1&_Left, const _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!_Pred(_Left, _Right))return (false);
		else if(_Pred(_Right, _Left))_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	template<class _Pr, class _Ty1, class _Ty2>
	inline bool _Debug_lt_pred(_Pr _Pred, _Ty1&_Left, _Ty2&_Right, const wchar_t*_Where, unsigned int _Line)
	{
		if(!_Pred(_Left, _Right))return (false);
		else if(_Pred(_Right, _Left))_Debug_message(L"invalid operator<", _Where, _Line);
		return (true);
	}
	struct input_iterator_tag
	{
	};
	struct output_iterator_tag
	{
	};
	struct forward_iterator_tag: public input_iterator_tag
	{
	};
	struct bidirectional_iterator_tag: public forward_iterator_tag
	{
	};
	struct random_access_iterator_tag: public bidirectional_iterator_tag
	{
	};
	struct _Int_iterator_tag
	{
	};
	struct _Float_iterator_tag
	{
	};
	struct _Nonscalar_ptr_iterator_tag
	{
	};
	struct _Scalar_ptr_iterator_tag
	{
	};
	template<class _Category, class _Ty, class _Diff=ptrdiff_t, class _Pointer=_Ty*, class _Reference=_Ty&>
	struct iterator: public _Iterator_base
	{
		typedef _Category iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template<class _Category, class _Ty, class _Diff=ptrdiff_t, class _Pointer=_Ty*, class _Reference=_Ty&, class _Base_class=_Iterator_base>
	struct _Iterator_with_base: public _Base_class
	{
		typedef _Category iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template<class _Ty, class _Diff, class _Pointer, class _Reference>
	struct _Bidit: public _Iterator_base
	{
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template<class _Ty, class _Diff, class _Pointer, class _Reference>
	struct _Ranit: public _Iterator_base
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	template<class _Ty, class _Diff, class _Pointer, class _Reference, class _Base_class>
	struct _Ranit_base: public _Base_class
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Diff difference_type;
		typedef _Diff distance_type;
		typedef _Pointer pointer;
		typedef _Reference reference;
	};
	struct _Outit: public iterator<output_iterator_tag, void, void, void, void>
	{
	};
	template<class _Base_class>
	struct _Outit_with_base: public _Iterator_with_base<output_iterator_tag, void, void, void, void, _Base_class>
	{
	};
	template<class _Iter>
	struct iterator_traits
	{
		typedef typename _Iter::iterator_category iterator_category;
		typedef typename _Iter::value_type value_type;
		typedef typename _Iter::difference_type difference_type;
		typedef difference_type distance_type;
		typedef typename _Iter::pointer pointer;
		typedef typename _Iter::reference reference;
	};
	template<class _Ty>
	struct iterator_traits<_Ty*>
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef ptrdiff_t difference_type;
		typedef ptrdiff_t distance_type;
		typedef _Ty*pointer;
		typedef _Ty&reference;
	};
	template<class _Ty>
	struct iterator_traits<const _Ty*>
	{
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef ptrdiff_t difference_type;
		typedef ptrdiff_t distance_type;
		typedef const _Ty*pointer;
		typedef const _Ty&reference;
	};
	template<>
	struct iterator_traits<_Bool>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef _Bool difference_type;
		typedef _Bool distance_type;
		typedef _Bool*pointer;
		typedef _Bool&reference;
	};
	template<>
	struct iterator_traits<char>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef char value_type;
		typedef char difference_type;
		typedef char distance_type;
		typedef char*pointer;
		typedef char&reference;
	};
	template<>
	struct iterator_traits<signed char>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef signed char value_type;
		typedef signed char difference_type;
		typedef signed char distance_type;
		typedef signed char*pointer;
		typedef signed char&reference;
	};
	template<>
	struct iterator_traits<unsigned char>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned char value_type;
		typedef unsigned char difference_type;
		typedef unsigned char distance_type;
		typedef unsigned char*pointer;
		typedef unsigned char&reference;
	};
	template<>
	struct iterator_traits<wchar_t>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef wchar_t value_type;
		typedef wchar_t difference_type;
		typedef wchar_t distance_type;
		typedef wchar_t*pointer;
		typedef wchar_t&reference;
	};
	template<>
	struct iterator_traits<short>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef short value_type;
		typedef short difference_type;
		typedef short distance_type;
		typedef short*pointer;
		typedef short&reference;
	};
	template<>
	struct iterator_traits<unsigned short>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned short value_type;
		typedef unsigned short difference_type;
		typedef unsigned short distance_type;
		typedef unsigned short*pointer;
		typedef unsigned short&reference;
	};
	template<>
	struct iterator_traits<int>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef int value_type;
		typedef int difference_type;
		typedef int distance_type;
		typedef int*pointer;
		typedef int&reference;
	};
	template<>
	struct iterator_traits<unsigned int>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned int value_type;
		typedef unsigned int difference_type;
		typedef unsigned int distance_type;
		typedef unsigned int*pointer;
		typedef unsigned int&reference;
	};
	template<>
	struct iterator_traits<long>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef long value_type;
		typedef long difference_type;
		typedef long distance_type;
		typedef long*pointer;
		typedef long&reference;
	};
	template<>
	struct iterator_traits<unsigned long>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned long value_type;
		typedef unsigned long difference_type;
		typedef unsigned long distance_type;
		typedef unsigned long*pointer;
		typedef unsigned long&reference;
	};
	template<>
	struct iterator_traits<double>
	{
		typedef _Float_iterator_tag iterator_category;
		typedef double value_type;
		typedef double difference_type;
		typedef double distance_type;
		typedef double*pointer;
		typedef double&reference;
	};
	template<>
	struct iterator_traits<float>
	{
		typedef _Float_iterator_tag iterator_category;
		typedef float value_type;
		typedef float difference_type;
		typedef float distance_type;
		typedef float*pointer;
		typedef float&reference;
	};
	template<>
	struct iterator_traits<__int64>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef __int64 value_type;
		typedef __int64 difference_type;
		typedef __int64 distance_type;
		typedef __int64*pointer;
		typedef __int64&reference;
	};
	template<>
	struct iterator_traits<unsigned __int64>
	{
		typedef _Int_iterator_tag iterator_category;
		typedef unsigned __int64 value_type;
		typedef unsigned __int64 difference_type;
		typedef unsigned __int64 distance_type;
		typedef unsigned __int64*pointer;
		typedef unsigned __int64&reference;
	};
	template<class _Iter>
	inline typename iterator_traits<_Iter>::iterator_category _Iter_cat(const _Iter&)
	{
		typename iterator_traits<_Iter>::iterator_category _Cat;
		return (_Cat);
	}
	template<class _Cat1, class _Cat2>
	class _Iter_random_helper
	{
	public:
		typedef forward_iterator_tag _Iter_random_cat;
	};
	template<>
	class _Iter_random_helper<random_access_iterator_tag, random_access_iterator_tag>
	{
	public:
		typedef random_access_iterator_tag _Iter_random_cat;
	};
	template<class _Cat1, class _Cat2, class _Cat3>
	class _Iter_random_helper3
	{
	public:
		typedef forward_iterator_tag _Iter_random_cat;
	};
	template<>
	class _Iter_random_helper3<random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag>
	{
	public:
		typedef random_access_iterator_tag _Iter_random_cat;
	};
	template<class _Iter1, class _Iter2>
	inline typename _Iter_random_helper<typename iterator_traits<_Iter1>::iterator_category, typename iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Iter_random(const _Iter1&, const _Iter2&)
	{
		typename _Iter_random_helper<iterator_traits<_Iter1>::iterator_category, iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
		return (_Cat);
	}
	template<class _Iter1, class _Iter2, class _Iter3>
	inline typename _Iter_random_helper3<typename iterator_traits<_Iter1>::iterator_category, typename iterator_traits<_Iter2>::iterator_category, typename iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Iter_random(const _Iter1&, const _Iter2&, const _Iter3&)
	{
		typename _Iter_random_helper3<iterator_traits<_Iter1>::iterator_category, iterator_traits<_Iter2>::iterator_category, iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
		return (_Cat);
	}
	template<bool _Cond, class _Ty1, class _Ty2>
	class _If
	{
	public:
		typedef _Ty2 _Result;
	};
	template<class _Ty1, class _Ty2>
	class _If<true, _Ty1, _Ty2>
	{
	public:
		typedef _Ty1 _Result;
	};
	template<bool _Secure_validation>
	class _Secure_validation_helper
	{
	public:
		typedef _Unchecked_iterator_tag _Checked_iterator_category;
	};
	template<>
	class _Secure_validation_helper<true>
	{
	public:
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
	};
	template<class _Iter, bool _Inherits_from_iterator_base>
	class _Checked_iterator_category_helper
	{
	public:
		typedef _Unchecked_iterator_tag _Checked_cat;
	};
	template<class _Iter>
	class _Checked_iterator_category_helper<_Iter, true>
	{
	public:
		typedef typename _Iter::_Checked_iterator_category _Checked_cat;
	};
	template<class _Iter>
	class _Checked_iterator_category
	{
	public:
		typedef typename _Checked_iterator_category_helper<_Iter, __is_base_of(_Iterator_base, _Iter)>::_Checked_cat _Checked_cat;
	};
	template<class _Iter>
	inline typename _Checked_iterator_category<_Iter>::_Checked_cat _Checked_cat(const _Iter&)
	{
		typename _Checked_iterator_category<_Iter>::_Checked_cat _Cat;
		return (_Cat);
	}
	template<class _Iter, bool _Inherits_from_iterator_base>
	class _Checked_iterator_base_helper2
	{
	public:
		typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type;
	};
	template<class _Iter>
	class _Checked_iterator_base_helper2<_Iter, true>
	{
	public:
		typedef typename _Iter::_Checked_iterator_base_type _Checked_iterator_base_type;
	};
	template<class _Iter, class _Base_type>
	class _Checked_iterator_base_helper1
	{
	public:
		typedef _Different_checked_iterator_base_type_tag _Base_type_tag;
		typedef _Base_type _Checked_iterator_base_type;
	};
	template<class _Iter>
	class _Checked_iterator_base_helper1<_Iter, _Unchanged_checked_iterator_base_type_tag>
	{
	public:
		typedef _Unchanged_checked_iterator_base_type_tag _Base_type_tag;
		typedef _Iter _Checked_iterator_base_type;
	};
	template<class _Iter>
	class _Checked_iterator_base_helper
	{
	public:
		typedef _Checked_iterator_base_helper2<_Iter, __is_base_of(_Iterator_base, _Iter)>_Base_helper2;
		typedef _Checked_iterator_base_helper1<_Iter, typename _Base_helper2::_Checked_iterator_base_type>_Base_helper1;
		typedef typename _Base_helper1::_Base_type_tag _Checked_iterator_base_type_tag;
		typedef typename _Base_helper1::_Checked_iterator_base_type _Checked_iterator_base_type;
	};
	template<class _Iter, class _Base_tag>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(const _Iter&_It, _Base_tag)
	{
		return _It._Checked_iterator_base();
	}
	template<class _Iter>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(const _Iter&_It, _Unchanged_checked_iterator_base_type_tag)
	{
		return _It;
	}
	template<class _Iter, class _Base_tag>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(_Iter&_It, _Base_tag)
	{
		return _It._Checked_iterator_base();
	}
	template<class _Iter>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(_Iter&_It, _Unchanged_checked_iterator_base_type_tag)
	{
		return _It;
	}
	template<class _Iter>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(const _Iter&_It)
	{
		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
		return _Checked_base(_It, _Base_tag);
	}
	template<class _Iter>
	inline typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type _Checked_base(_Iter&_It)
	{
		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
		return _Checked_base(_It, _Base_tag);
	}
	template<class _DstIter, class _BaseIter>
	inline void _Checked_assign_from_base(_DstIter&_Dest, const _BaseIter&_Src)
	{
		_Dest._Checked_iterator_assign_from_base(_Src);
	}
	template<class _Iter>
	inline void _Checked_assign_from_base(_Iter&_Dest, const _Iter&_Src)
	{
		_Dest=_Src;
	}
	template<class _Value>
	class _Move_operation_category
	{
	public:
		typedef _Undefined_move_tag _Move_cat;
	};
	template<class _Iter>
	inline typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Move_cat(const _Iter&)
	{
		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
		return (_Cat);
	}
	template<class _T1, class _T2, class _Checked_Cat1, class _Checked_Cat2>
	struct _Ptr_cat_with_checked_cat_helper
	{
		typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _T1, class _T2>
	struct _Ptr_cat_helper
	{
		typedef typename _Ptr_cat_with_checked_cat_helper<_T1, _T2, typename _Checked_iterator_category<_T1>::_Checked_cat, typename _Checked_iterator_category<_T2>::_Checked_cat>::_Ptr_cat _Ptr_cat;
	};
	template<class _T1, class _T2, class _Checked_Cat1>
	struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Checked_Cat1, _Range_checked_iterator_tag>
	{
		typedef typename _Ptr_cat_helper<_T1, typename _T2::_Inner_type>::_Ptr_cat _Ptr_cat;
	};
	template<class _T1, class _T2, class _Checked_Cat2>
	struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Range_checked_iterator_tag, _Checked_Cat2>
	{
		typedef typename _Ptr_cat_helper<typename _T1::_Inner_type, _T2>::_Ptr_cat _Ptr_cat;
	};
	template<class _T1, class _T2>
	struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Range_checked_iterator_tag, _Range_checked_iterator_tag>
	{
		typedef typename _Ptr_cat_helper<typename _T1::_Inner_type, typename _T2::_Inner_type>::_Ptr_cat _Ptr_cat;
	};
	template<class _T1>
	struct _Ptr_cat_helper<_T1, _Undefined_inner_type_tag>
	{
		typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _T2>
	struct _Ptr_cat_helper<_Undefined_inner_type_tag, _T2>
	{
		typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<_Undefined_inner_type_tag, _Undefined_inner_type_tag>
	{
		typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<_Bool*, _Bool*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const _Bool*, _Bool*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<char*, char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const char*, char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<signed char*, signed char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const signed char*, signed char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned char*, unsigned char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned char*, unsigned char*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<wchar_t*, wchar_t*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const wchar_t*, wchar_t*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<short*, short*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const short*, short*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned short*, unsigned short*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned short*, unsigned short*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<int*, int*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const int*, int*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned int*, unsigned int*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned int*, unsigned int*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<long*, long*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const long*, long*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned long*, unsigned long*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned long*, unsigned long*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<float*, float*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const float*, float*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<double*, double*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const double*, double*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<long double*, long double*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const long double*, long double*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<__int64*, __int64*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const __int64*, __int64*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<unsigned __int64*, unsigned __int64*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<>
	struct _Ptr_cat_helper<const unsigned __int64*, unsigned __int64*>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _Ty>
	struct _Ptr_cat_helper<_Ty**, _Ty**>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _Ty>
	struct _Ptr_cat_helper<_Ty**, const _Ty**>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _Ty>
	struct _Ptr_cat_helper<_Ty*const*, _Ty**>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _Ty>
	struct _Ptr_cat_helper<_Ty*const*, const _Ty**>
	{
		typedef _Scalar_ptr_iterator_tag _Ptr_cat;
	};
	template<class _T1, class _T2>
	inline typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Ptr_cat(_T1&, _T2&)
	{
		typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
		return (_Cat);
	}
	template<class _InIt>
	inline void _Debug_pointer(_InIt&, const wchar_t*, unsigned int)
	{
	}
	template<class _Ty>
	inline void _Debug_pointer(const _Ty*_First, const wchar_t*_File, unsigned int _Line)
	{
		if(_First==0)_Debug_message(L"invalid null pointer", _File, _Line);
	}
	template<class _Ty>
	inline void _Debug_pointer(_Ty*_First, const wchar_t*_File, unsigned int _Line)
	{
		if(_First==0)_Debug_message(L"invalid null pointer", _File, _Line);
	}
	template<class _InIt>
	inline void _Debug_range2(_InIt, _InIt, const wchar_t*, unsigned int, input_iterator_tag)
	{
	}
	template<class _RanIt>
	inline void _Debug_range2(_RanIt _First, _RanIt _Last, const wchar_t*_File, unsigned int _Line, random_access_iterator_tag)
	{
		if(_First!=_Last)
		{
			_Debug_pointer(_First, _File, _Line);
			_Debug_pointer(_Last, _File, _Line);
			if(_Last<_First)_Debug_message(L"invalid iterator range", _File, _Line);
		}
	}
	template<class _InIt>
	inline void _Debug_range(_InIt _First, _InIt _Last, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}
	template<class _InIt>
	inline void _Debug_order2(_InIt _First, _InIt _Last, const wchar_t*_File, unsigned int _Line, input_iterator_tag)
	{
	}
	template<class _FwdIt>
	inline void _Debug_order2(_FwdIt _First, _FwdIt _Last, const wchar_t*_File, unsigned int _Line, forward_iterator_tag)
	{
		if(_First!=_Last)for(_FwdIt _Next=_First;
		++_Next!=_Last;
		++_First)if(_Debug_lt(*_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1384))_Debug_message(L"sequence not ordered", _File, _Line);
	}
	template<class _InIt>
	inline void _Debug_order(_InIt _First, _InIt _Last, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_range(_First, _Last, _File, _Line);
		_Debug_order2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}
	template<class _InIt, class _Pr>
	inline void _Debug_order2(_InIt _First, _InIt _Last, _Pr _Pred, const wchar_t*_File, unsigned int _Line, input_iterator_tag)
	{
	}
	template<class _FwdIt, class _Pr>
	inline void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const wchar_t*_File, unsigned int _Line, forward_iterator_tag)
	{
		if(_First!=_Last)for(_FwdIt _Next=_First;
		++_Next!=_Last;
		++_First)if(_Debug_lt_pred(_Pred, *_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1411))_Debug_message(L"sequence not ordered", _File, _Line);
	}
	template<class _InIt, class _Pr>
	inline void _Debug_order(_InIt _First, _InIt _Last, _Pr _Pred, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_range(_First, _Last, _File, _Line);
		_Debug_pointer(_Pred, _File, _Line);
		_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat(_First));
	}
	template<class _InIt>
	inline void _Debug_order_single2(_InIt _First, _InIt _Last, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line, input_iterator_tag)
	{
	}
	template<class _FwdIt>
	inline void _Debug_order_single2(_FwdIt _First, _FwdIt _Last, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line, forward_iterator_tag)
	{
		if(_First!=_Last)
		{
			_FwdIt _Next=_First;
			if(++_Next!=_Last)if(_Debug_lt(*_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1440))_Debug_message(L"sequence not ordered", _File, _Line);
		}
	}
	template<class _InIt>
	inline void _Debug_order_single(_InIt _First, _InIt _Last, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_order_single2(_First, _Last, _IsFirstIteration, _File, _Line, _Iter_cat(_First));
	}
	template<class _InIt, class _Pr>
	inline void _Debug_order_single2(_InIt _First, _InIt _Last, _Pr _Pred, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line, input_iterator_tag)
	{
	}
	template<class _FwdIt, class _Pr>
	inline void _Debug_order_single2(_FwdIt _First, _FwdIt _Last, _Pr _Pred, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line, forward_iterator_tag)
	{
		if(_First!=_Last)
		{
			_FwdIt _Next=_First;
			if(++_Next!=_Last)if(_Debug_lt_pred(_Pred, *_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1469))_Debug_message(L"sequence not ordered", _File, _Line);
		}
	}
	template<class _InIt, class _Pr>
	inline void _Debug_order_single(_InIt _First, _InIt _Last, _Pr _Pred, bool _IsFirstIteration, const wchar_t*_File, unsigned int _Line)
	{
		_Debug_order_single2(_First, _Last, _Pred, _IsFirstIteration, _File, _Line, _Iter_cat(_First));
	}
	template<class _Iter>
	inline typename iterator_traits<_Iter>::value_type*_Val_type(_Iter)
	{
		return (0);
	}
	template<class _InIt, class _Diff>
	inline void _Advance(_InIt&_Where, _Diff _Off, input_iterator_tag)
	{
		for(;
		0<_Off;
		--_Off)++_Where;
	}
	template<class _InIt, class _Diff>
	inline void advance(_InIt&_Where, _Diff _Off)
	{
		_Advance(_Where, _Off, _Iter_cat(_Where));
	}
	template<class _FI, class _Diff>
	inline void _Advance(_FI&_Where, _Diff _Off, forward_iterator_tag)
	{
		for(;
		0<_Off;
		--_Off)++_Where;
	}
	template<class _BI, class _Diff>
	inline void _Advance(_BI&_Where, _Diff _Off, bidirectional_iterator_tag)
	{
		for(;
		0<_Off;
		--_Off)++_Where;
		for(;
		_Off<0;
		++_Off)--_Where;
	}
	template<class _RI, class _Diff>
	inline void _Advance(_RI&_Where, _Diff _Off, random_access_iterator_tag)
	{
		_Where+=_Off;
	}
	template<class _Iter>
	inline typename iterator_traits<_Iter>::difference_type*_Dist_type(_Iter)
	{
		return (0);
	}
	template<class _InIt, class _Diff>
	inline void _Distance2(_InIt _First, _InIt _Last, _Diff&_Off, input_iterator_tag)
	{
		for(;
		_First!=_Last;
		++_First)++_Off;
	}
	template<class _FwdIt, class _Diff>
	inline void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff&_Off, forward_iterator_tag)
	{
		for(;
		_First!=_Last;
		++_First)++_Off;
	}
	template<class _BidIt, class _Diff>
	inline void _Distance2(_BidIt _First, _BidIt _Last, _Diff&_Off, bidirectional_iterator_tag)
	{
		for(;
		_First!=_Last;
		++_First)++_Off;
	}
	template<class _RanIt, class _Diff>
	inline void _Distance2(_RanIt _First, _RanIt _Last, _Diff&_Off, random_access_iterator_tag)
	{
		if(_First!=_Last)
		{
			_Debug_pointer(_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1642);
			_Debug_pointer(_Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 1643);
		}
		_Off+=_Last-_First;
	}
	template<class _InIt>
	inline typename iterator_traits<_InIt>::difference_type distance(_InIt _First, _InIt _Last)
	{
		typename iterator_traits<_InIt>::difference_type _Off=0;
		_Distance2(_First, _Last, _Off, _Iter_cat(_First));
		return (_Off);
	}
	template<class _InIt, class _Diff>
	inline void _Distance(_InIt _First, _InIt _Last, _Diff&_Off)
	{
		_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}
	template<class _RanIt>
	class reverse_iterator: public _Iterator_base_secure
	{
	public:
		typedef reverse_iterator<_RanIt>_Myt;
		typedef typename iterator_traits<_RanIt>::iterator_category iterator_category;
		typedef typename iterator_traits<_RanIt>::value_type value_type;
		typedef typename iterator_traits<_RanIt>::difference_type difference_type;
		typedef typename iterator_traits<_RanIt>::difference_type distance_type;
		typedef typename iterator_traits<_RanIt>::pointer pointer;
		typedef typename iterator_traits<_RanIt>::reference reference;
		typedef _RanIt iterator_type;
		reverse_iterator()
		{
		}
		explicit reverse_iterator(_RanIt _Right): current(_Right)
		{
		}
		template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>&_Right): current(_Right.base())
		{
		}
		_RanIt base()const
		{
			return (current);
		}
		typedef typename::std::_Checked_iterator_category<_RanIt>::_Checked_cat _Checked_iterator_category;
		typedef reverse_iterator<typename _Checked_iterator_base_helper<_RanIt>::_Checked_iterator_base_type>_Checked_iterator_base_type;
		_Checked_iterator_base_type _Checked_iterator_base()const
		{
			typename _Checked_iterator_base_type _Base(::std::_Checked_base(current));
			return _Base;
		}
		void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
		{
			::std::_Checked_assign_from_base(current, _Base.base());
		}
		reference operator*()const
		{
			_RanIt _Tmp=current;
			return (*--_Tmp);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			--current;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			--current;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			++current;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			++current;
			return (_Tmp);
		}
		template<class _Other>
		bool _Equal(const reverse_iterator<_Other>&_Right)const
		{
			return (current==_Right.base());
		}
		_Myt&operator+=(difference_type _Off)
		{
			current-=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			return (_Myt(current-_Off));
		}
		_Myt&operator-=(difference_type _Off)
		{
			current+=_Off;
			return (*this);
		}
		_Myt operator-(difference_type _Off)const
		{
			return (_Myt(current+_Off));
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		template<class _Other>
		bool _Less(const reverse_iterator<_Other>&_Right)const
		{
			return (_Right.base()<current);
		}
		template<class _Other>
		difference_type _Minus(const reverse_iterator<_Other>&_Right)const
		{
			return (_Right.base()-current);
		}
		protected: _RanIt current;
	};
	template<class _RanIt, class _Diff>
	inline reverse_iterator<_RanIt>operator+(_Diff _Off, const reverse_iterator<_RanIt>&_Right)
	{
		return (_Right+_Off);
	}
	template<class _RanIt1, class _RanIt2>
	inline typename reverse_iterator<_RanIt1>::difference_type operator-(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (_Left._Minus(_Right));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator==(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (_Left._Equal(_Right));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator!=(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator<(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (_Left._Less(_Right));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator>(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator<=(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _RanIt1, class _RanIt2>
	inline bool operator>=(const reverse_iterator<_RanIt1>&_Left, const reverse_iterator<_RanIt2>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _BidIt, class _Ty, class _Reference=_Ty&, class _Pointer=_Ty*, class _Diff=ptrdiff_t>
	class reverse_bidirectional_iterator: public iterator<bidirectional_iterator_tag, _Ty, _Diff, _Pointer, _Reference>
	{
	public:
		typedef reverse_bidirectional_iterator<_BidIt, _Ty, _Reference, _Pointer, _Diff>_Myt;
		typedef _BidIt iterator_type;
		reverse_bidirectional_iterator()
		{
		}
		explicit reverse_bidirectional_iterator(_BidIt _Right): current(_Right)
		{
		}
		_BidIt base()const
		{
			return (current);
		}
		_Reference operator*()const
		{
			_BidIt _Tmp=current;
			return (*--_Tmp);
		}
		_Pointer operator->()const
		{
			_Reference _Tmp=**this;
			return (&_Tmp);
		}
		_Myt&operator++()
		{
			--current;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			--current;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			++current;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			++current;
			return (_Tmp);
		}
		bool operator==(const _Myt&_Right)const
		{
			return (current==_Right.current);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		protected: _BidIt current;
	};
	template<class _BidIt, class _BidIt2=_BidIt>
	class _Revbidit: public iterator<typename iterator_traits<_BidIt>::iterator_category, typename iterator_traits<_BidIt>::value_type, typename iterator_traits<_BidIt>::difference_type, typename iterator_traits<_BidIt>::pointer, typename iterator_traits<_BidIt>::reference>
	{
	public:
		typedef _Revbidit<_BidIt, _BidIt2>_Myt;
		typedef typename iterator_traits<_BidIt>::difference_type _Diff;
		typedef typename iterator_traits<_BidIt>::pointer _Pointer;
		typedef typename iterator_traits<_BidIt>::reference _Reference;
		typedef _BidIt iterator_type;
		_Revbidit()
		{
		}
		explicit _Revbidit(_BidIt _Right): current(_Right)
		{
		}
		_Revbidit(const _Revbidit<_BidIt2>&_Other): current(_Other.base())
		{
		}
		_BidIt base()const
		{
			return (current);
		}
		_Reference operator*()const
		{
			_BidIt _Tmp=current;
			return (*--_Tmp);
		}
		_Pointer operator->()const
		{
			_Reference _Tmp=**this;
			return (&_Tmp);
		}
		_Myt&operator++()
		{
			--current;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			--current;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			++current;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			++current;
			return (_Tmp);
		}
		bool operator==(const _Myt&_Right)const
		{
			return (current==_Right.current);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		protected: _BidIt current;
	};
	template<class _Elem, class _Traits>
	class istreambuf_iterator: public _Iterator_with_base<input_iterator_tag, _Elem, typename _Traits::off_type, _Elem*, _Elem&, _Iterator_base_secure>
	{
		typedef istreambuf_iterator<_Elem, _Traits>_Myt;
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef basic_streambuf<_Elem, _Traits>streambuf_type;
		typedef basic_istream<_Elem, _Traits>istream_type;
		typedef typename traits_type::int_type int_type;
		istreambuf_iterator(streambuf_type*_Sb=0)throw(): _Strbuf(_Sb), _Got(_Sb==0)
		{
		}
		istreambuf_iterator(istream_type&_Istr)throw(): _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf()==0)
		{
		}
		_Elem operator*()const
		{
			if(!_Got)((_Myt*)this)->_Peek();
			if(_Strbuf==0)_Debug_message(L"istreambuf_iterator is not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2074);
			return (_Val);
		}
		_Myt&operator++()
		{
			if(_Strbuf==0)_Debug_message(L"istreambuf_iterator is not incrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2085);
			_Inc();
			return (*this);
		}
		_Myt operator++(int)
		{
			if(!_Got)_Peek();
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		bool equal(const _Myt&_Right)const
		{
			if(!_Got)((_Myt*)this)->_Peek();
			if(!_Right._Got)((_Myt*)&_Right)->_Peek();
			return (_Strbuf==0&&_Right._Strbuf==0||_Strbuf!=0&&_Right._Strbuf!=0);
		}
	private:
		void _Inc()
		{
			if(_Strbuf==0||traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc()))_Strbuf=0, _Got=true;
			else _Got=false;
		}
		_Elem _Peek()
		{
			int_type _Meta;
			if(_Strbuf==0||traits_type::eq_int_type(traits_type::eof(), _Meta=_Strbuf->sgetc()))_Strbuf=0;
			else _Val=traits_type::to_char_type(_Meta);
			_Got=true;
			return (_Val);
		}
		streambuf_type*_Strbuf;
		bool _Got;
		_Elem _Val;
	};
	template<class _Elem, class _Traits>
	inline bool operator==(const istreambuf_iterator<_Elem, _Traits>&_Left, const istreambuf_iterator<_Elem, _Traits>&_Right)
	{
		return (_Left.equal(_Right));
	}
	template<class _Elem, class _Traits>
	inline bool operator!=(const istreambuf_iterator<_Elem, _Traits>&_Left, const istreambuf_iterator<_Elem, _Traits>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Elem, class _Traits>
	class ostreambuf_iterator: public _Outit_with_base<_Iterator_base_secure>
	{
		typedef ostreambuf_iterator<_Elem, _Traits>_Myt;
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef basic_streambuf<_Elem, _Traits>streambuf_type;
		typedef basic_ostream<_Elem, _Traits>ostream_type;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		ostreambuf_iterator(streambuf_type*_Sb)throw(): _Failed(false), _Strbuf(_Sb)
		{
		}
		ostreambuf_iterator(ostream_type&_Ostr)throw(): _Failed(false), _Strbuf(_Ostr.rdbuf())
		{
		}
		_Myt&operator=(_Elem _Right)
		{
			if(_Strbuf==0||traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right)))_Failed=true;
			return (*this);
		}
		_Myt&operator*()
		{
			return (*this);
		}
		_Myt&operator++()
		{
			return (*this);
		}
		_Myt&operator++(int)
		{
			return (*this);
		}
		bool failed()const throw()
		{
			return (_Failed);
		}
	private:
		bool _Failed;
		streambuf_type*_Strbuf;
	};
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2226);
		for(;
		_First!=_Last;
		++_Dest, ++_First)*_Dest=*_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest, random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Copy_opt(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2253);
		if(_First!=_Last)_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2255);
		ptrdiff_t _Off=_Last-_First;
		_OutIt _Result=_Dest+_Off;
		if(_Off>0)::memmove_s((&*_Dest), (_Off*sizeof(*_First)), (&*_First), (_Off*sizeof(*_First)));
		return _Result;
	}
	template<class _InIt, class _OutIt, class _InOutItCat, class _Ty>
	inline _OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat _First_dest_cat, _Ty _PtrCat, _Unchecked_iterator_tag)
	{
		return _Copy_opt(_First, _Last, _Dest, _First_dest_cat, _PtrCat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt>
	inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (_Copy_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy>
	inline _OutIt _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag)
	{
		return _Copy_opt(_First, _Last, _Dest, _First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2300);
		for(;
		_First!=_Last;
		++_Dest, ++_First)::std::swap(*_Dest, *_First);
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest, random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Move_opt(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy>
	inline _OutIt _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat _First_dest_cat, _MoveCatTy _Move_cat, _Unchecked_iterator_tag)
	{
		return _Move_opt(_First, _Last, _Dest, _First_dest_cat, _Move_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return _Move_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), _Move_cat(_Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat>
	inline _BidIt2 _Copy_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2345);
		while(_First!=_Last)*--_Dest=*--_Last;
		return (_Dest);
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest, random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest-(_Last-_First);
		_Copy_backward_opt(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest, _InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2372);
		if(_First!=_Last)_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2374);
		ptrdiff_t _Off=_Last-_First;
		_OutIt _Result=_Dest-_Off;
		if(_Off>0)::memmove_s((&*_Result), (_Off*sizeof(*_First)), (&*_First), (_Off*sizeof(*_First)));
		return _Result;
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat, class _Ty>
	inline _BidIt2 _Copy_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat _First_dest_cat, _Ty _PtrCat, _Unchecked_iterator_tag)
	{
		return _Copy_backward_opt(_First, _Last, _Dest, _First_dest_cat, _PtrCat, _Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return _Copy_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy>
	inline _BidIt2 _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag)
	{
		return _Copy_backward_opt(_First, _Last, _Dest, _First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat>
	inline _BidIt2 _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2422);
		while(_First!=_Last)::std::swap(*--_Dest, *--_Last);
		return (_Dest);
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag)
	{
		_BidIt2 _Result=_Dest-(_Last-_First);
		_Move_backward_opt(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy>
	inline _BidIt2 _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest, _InOutItCat _First_dest_cat, _MoveCatTy _Move_cat, _Unchecked_iterator_tag)
	{
		return _Move_backward_opt(_First, _Last, _Dest, _First_dest_cat, _Move_cat, _Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return _Move_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), _Move_cat(_Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _InItCats>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InItCats, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2471);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2473);
		for(;
		_First1!=_Last1&&*_First1==*_First2;
		)++_First1, ++_First2;
		return (pair<_InIt1, _InIt2>(_First1, _First2));
	}
	template<class _InIt1, class _InIt2>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		pair<_InIt1, typename::std::_Checked_iterator_base_helper<_InIt2>::_Checked_iterator_base_type>_Result=_Mismatch(_First1, _Last1, ::std::_Checked_base(_First2), forward_iterator_tag(), _Range_checked_iterator_tag());
		::std::_Checked_assign_from_base(_First2, _Result.second);
		return (pair<_InIt1, _InIt2>(_Result.first, _First2));
	}
	template<class _InIt1, class _InIt2, class _InItCats>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InItCats _InIt_cats, _Unchecked_iterator_tag)
	{
		return _Mismatch(_First1, _Last1, _First2, _InIt_cats, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2>
	inline pair<_InIt1, _InIt2>mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, _InItCats, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2537);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2539);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2540);
		for(;
		_First1!=_Last1&&_Pred(*_First1, *_First2);
		)++_First1, ++_First2;
		return (pair<_InIt1, _InIt2>(_First1, _First2));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		pair<_InIt1, typename::std::_Checked_iterator_base_helper<_InIt2>::_Checked_iterator_base_type>_Result=_Mismatch(_First1, _Last1, ::std::_Checked_base(_First2), _Pred, forward_iterator_tag(), _Range_checked_iterator_tag());
		::std::_Checked_assign_from_base(_First2, _Result.second);
		return (pair<_InIt1, _InIt2>(_Result.first, _First2));
	}
	template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
	inline pair<_InIt1, _InIt2>_Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, _InItCats _InIt_cats, _Unchecked_iterator_tag)
	{
		return _Mismatch(_First1, _Last1, _First2, _Pred, _InIt_cats, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline pair<_InIt1, _InIt2>mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2, class _InItCats>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InItCats, _Range_checked_iterator_tag)
	{
		return (_Mismatch(_First1, _Last1, _First2, forward_iterator_tag(), _Range_checked_iterator_tag()).first==_Last1);
	}
	inline bool _Equal(const char*_First1, const char*_Last1, const char*_First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2610);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2612);
		return (::memcmp(_First1, _First2, _Last1-_First1)==0);
	}
	inline bool _Equal(const signed char*_First1, const signed char*_Last1, const signed char*_First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2623);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2625);
		return (::memcmp(_First1, _First2, _Last1-_First1)==0);
	}
	inline bool _Equal(const unsigned char*_First1, const unsigned char*_Last1, const unsigned char*_First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2636);
		if(_First1!=_Last1)_Debug_pointer(_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2638);
		return (::memcmp(_First1, _First2, _Last1-_First1)==0);
	}
	template<class _InIt1, class _InIt2>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		return _Equal(_First1, _Last1, ::std::_Checked_base(_First2), forward_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _InItCats>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InItCats _InIt_cats, _Unchecked_iterator_tag)
	{
		return _Equal(_First1, _Last1, _First2, _InIt_cats, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2>
	inline bool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		return _Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
	template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, _InItCats, _Range_checked_iterator_tag)
	{
		return (_Mismatch(_First1, _Last1, _First2, _Pred, forward_iterator_tag(), _Range_checked_iterator_tag()).first==_Last1);
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		return _Equal(_First1, _Last1, ::std::_Checked_base(_First2), _Pred, forward_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
	inline bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred, _InItCats _InIt_cats, _Unchecked_iterator_tag)
	{
		return _Equal(_First1, _Last1, _First2, _Pred, _InIt_cats, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		return _Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
	template<class _FwdIt, class _Ty>
	inline void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2724);
		for(;
		_First!=_Last;
		++_First)*_First=_Val;
	}
	inline void _Fill(char*_First, char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2732);
		::memset(_First, _Val, _Last-_First);
	}
	inline void _Fill(signed char*_First, signed char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2739);
		::memset(_First, _Val, _Last-_First);
	}
	inline void _Fill(unsigned char*_First, unsigned char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2747);
		::memset(_First, _Val, _Last-_First);
	}
	template<class _FwdIt, class _Ty>
	inline void fill(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		_Fill(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val);
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void _Fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val, _Range_checked_iterator_tag)
	{
		for(;
		0<_Count;
		--_Count, ++_First)*_First=_Val;
	}
	inline void _Fill_n(char*_First, size_t _Count, int _Val, _Range_checked_iterator_tag)
	{
		if(0<_Count)_Debug_pointer(_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2774);
		::memset(_First, _Val, _Count);
	}
	inline void _Fill_n(signed char*_First, size_t _Count, int _Val, _Range_checked_iterator_tag)
	{
		if(0<_Count)_Debug_pointer(_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2786);
		::memset(_First, _Val, _Count);
	}
	inline void _Fill_n(unsigned char*_First, size_t _Count, int _Val, _Range_checked_iterator_tag)
	{
		if(0<_Count)_Debug_pointer(_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2798);
		::memset(_First, _Val, _Count);
	}
	template<class _OutIt, class _Diff, class _Ty, class _OutCat>
	inline void _Fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val, _OutCat, _Range_checked_iterator_tag)
	{
		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void _Fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Last=_First+_Count;
		(_Last);
		_Fill_n(::std::_Checked_base(_First), _Count, _Val, _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Ty, class _OutCat>
	inline void _Fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val, _OutCat _First_cat, _Unchecked_iterator_tag)
	{
		_Fill_n(_First, _Count, _Val, _First_cat, _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val)
	{
		_Fill_n(_First, _Count, _Val, _Iter_cat(_First), ::std::_Checked_cat(_First));
	}
	template<class _InIt1, class _InIt2>
	inline bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2849);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2850);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_First1, ++_First2)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2852))return (true);
		else if(*_First2<*_First1)return (false);
		return (_First1==_Last1&&_First2!=_Last2);
	}
	template<class _InIt1, class _InIt2>
	inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{
		return _Lexicographical_compare(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2));
	}
	inline bool lexicographical_compare(const unsigned char*_First1, const unsigned char*_Last1, const unsigned char*_First2, const unsigned char*_Last2)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2871);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2872);
		ptrdiff_t _Num1=_Last1-_First1;
		ptrdiff_t _Num2=_Last2-_First2;
		int _Ans=::memcmp(_First1, _First2, _Num1<_Num2?_Num1: _Num2);
		return (_Ans<0||_Ans==0&&_Num1<_Num2);
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2900);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2901);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2902);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_First1, ++_First2)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2904))return (true);
		else if(_Pred(*_First2, *_First1))return (false);
		return (_First1==_Last1&&_First2!=_Last2);
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
		return _Lexicographical_compare(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred);
	}
	template<class _Ty>
	inline const _Ty&(max)(const _Ty&_Left, const _Ty&_Right)
	{
		return (_Debug_lt(_Left, _Right, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2938)?_Right: _Left);
	}
	template<class _Ty, class _Pr>
	inline const _Ty&(max)(const _Ty&_Left, const _Ty&_Right, _Pr _Pred)
	{
		return (_Debug_lt_pred(_Pred, _Left, _Right, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2946)?_Right: _Left);
	}
	template<class _Ty>
	inline const _Ty&(min)(const _Ty&_Left, const _Ty&_Right)
	{
		return (_Debug_lt(_Right, _Left, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2953)?_Right: _Left);
	}
	template<class _Ty, class _Pr>
	inline const _Ty&(min)(const _Ty&_Left, const _Ty&_Right, _Pr _Pred)
	{
		return (_Debug_lt_pred(_Pred, _Right, _Left, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xutility", 2961)?_Right: _Left);
	}
}
namespace stdext
{
	template<class _InIt, class _OutIt>
	inline _OutIt unchecked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (::std::_Copy_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Ptr_cat(_First, _Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt checked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (::std::_Copy_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 unchecked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return (::std::_Copy_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Ptr_cat(_First, _Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 checked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return (::std::_Copy_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Unchecked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (::std::_Move_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Move_cat(_Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Checked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (::std::_Move_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Move_cat(_Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 _Unchecked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return (::std::_Move_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Move_cat(_Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _BidIt1, class _BidIt2>
	inline _BidIt2 _Checked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{
		return (::std::_Move_backward_opt(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Move_cat(_Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void unchecked_fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val)
	{
		::std::_Fill_n(_First, _Count, _Val, ::std::_Iter_cat(_First), ::std::_Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Ty>
	inline void checked_fill_n(_OutIt _First, _Diff _Count, const _Ty&_Val)
	{
		::std::_Fill_n(_First, _Count, _Val, ::std::_Iter_cat(_First), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2>
	inline::std::pair<_InIt1, _InIt2>unchecked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		::std::pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=::std::_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (::std::pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2>
	inline::std::pair<_InIt1, _InIt2>checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		::std::pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=::std::_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (::std::pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline::std::pair<_InIt1, _InIt2>unchecked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		::std::pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=::std::_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (::std::pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline::std::pair<_InIt1, _InIt2>checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		::std::pair<typename::std::_Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2>_Result=::std::_Mismatch(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
		::std::_Checked_assign_from_base(_First1, _Result.first);
		return (::std::pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
	template<class _InIt1, class _InIt2>
	inline bool unchecked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		return ::std::_Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2>
	inline bool checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{
		return ::std::_Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool unchecked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		return ::std::_Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{
		return ::std::_Equal(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Pred, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
}
extern "C" void _invalid_parameter(const wchar_t*, const wchar_t*, const wchar_t*, unsigned int, uintptr_t);
namespace std
{
	template<class _Ty>
	inline _Ty*_Allocate(size_t _Count, _Ty*)
	{
		if(_Count<=0)_Count=0;
		else if(((size_t)(-1)/_Count)<sizeof(_Ty))throw std::bad_alloc(0);
		return ((_Ty*)::operator new(_Count*sizeof(_Ty)));
	}
	template<class _T1, class _T2>
	inline void _Construct(_T1*_Ptr, const _T2&_Val)
	{
		void*_Vptr=_Ptr;
		::new(_Vptr)_T1(_Val);
	}
	template<class _Ty>
	inline void _Destroy(_Ty*_Ptr)
	{
		(_Ptr)->~_Ty();
	}
	template<>
	inline void _Destroy(char*)
	{
	}
	template<>
	inline void _Destroy(wchar_t*)
	{
	}
	template<class _Ty>
	struct _Allocator_base
	{
		typedef _Ty value_type;
	};
	template<class _Ty>
	struct _Allocator_base<const _Ty>
	{
		typedef _Ty value_type;
	};
	template<class _Ty>
	class allocator: public _Allocator_base<_Ty>
	{
	public:
		typedef _Allocator_base<_Ty>_Mybase;
		typedef typename _Mybase::value_type value_type;
		typedef value_type*pointer;
		typedef value_type&reference;
		typedef const value_type*const_pointer;
		typedef const value_type&const_reference;
		typedef size_t size_type;
		typedef ptrdiff_t difference_type;
		template<class _Other>
		struct rebind
		{
			typedef allocator<_Other>other;
		};
		pointer address(reference _Val)const
		{
			return (&_Val);
		}
		const_pointer address(const_reference _Val)const
		{
			return (&_Val);
		}
		allocator()throw()
		{
		}
		allocator(const allocator<_Ty>&)throw()
		{
		}
		template<class _Other>
		allocator(const allocator<_Other>&)throw()
		{
		}
		template<class _Other>
		allocator<_Ty>&operator=(const allocator<_Other>&)
		{
			return (*this);
		}
		void deallocate(pointer _Ptr, size_type)
		{
			::operator delete(_Ptr);
		}
		pointer allocate(size_type _Count)
		{
			return (_Allocate(_Count, (pointer)0));
		}
		pointer allocate(size_type _Count, const void*)
		{
			return (allocate(_Count));
		}
		void construct(pointer _Ptr, const _Ty&_Val)
		{
			_Construct(_Ptr, _Val);
		}
		void destroy(pointer _Ptr)
		{
			_Destroy(_Ptr);
		}
		size_t max_size()const throw()
		{
			size_t _Count=(size_t)(-1)/sizeof(_Ty);
			return (0<_Count?_Count: 1);
		}
	};
	template<class _Ty, class _Other>
	inline bool operator==(const allocator<_Ty>&, const allocator<_Other>&)throw()
	{
		return (true);
	}
	template<class _Ty, class _Other>
	inline bool operator!=(const allocator<_Ty>&, const allocator<_Other>&)throw()
	{
		return (false);
	}
	template<>
	class allocator<void>
	{
	public:
		typedef void _Ty;
		typedef _Ty*pointer;
		typedef const _Ty*const_pointer;
		typedef _Ty value_type;
		template<class _Other>
		struct rebind
		{
			typedef allocator<_Other>other;
		};
		allocator()throw()
		{
		}
		allocator(const allocator<_Ty>&)throw()
		{
		}
		template<class _Other>
		allocator(const allocator<_Other>&)throw()
		{
		}
		template<class _Other>
		allocator<_Ty>&operator=(const allocator<_Other>&)
		{
			return (*this);
		}
	};
	template<class _Ty, class _Alloc>
	inline void _Destroy_range(_Ty*_First, _Ty*_Last, _Alloc&_Al)
	{
		_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}
	template<class _Ty, class _Alloc>
	inline void _Destroy_range(_Ty*_First, _Ty*_Last, _Alloc&_Al, _Nonscalar_ptr_iterator_tag)
	{
		for(;
		_First!=_Last;
		++_First)_Al.destroy(_First);
	}
	template<class _Ty, class _Alloc>
	inline void _Destroy_range(_Ty*_First, _Ty*_Last, _Alloc&_Al, _Scalar_ptr_iterator_tag)
	{
	}
}
namespace std
{
	template<class _Elem, class _Traits=char_traits<_Elem>, class _Ax=allocator<_Elem> >
	class basic_string;
	template<class _Elem, class _Traits, class _Alloc>
	class _String_const_iterator: public _Ranit_base<_Elem, typename _Alloc::difference_type, typename _Alloc::const_pointer, typename _Alloc::const_reference, _Iterator_base_secure>
	{
	public:
		typedef _String_const_iterator<_Elem, _Traits, _Alloc>_Myt;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystring;
		typedef random_access_iterator_tag iterator_category;
		typedef _Elem value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::const_pointer pointer;
		typedef typename _Alloc::const_reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		_String_const_iterator()
		{
			_Myptr=0;
		}
		_String_const_iterator(pointer _Ptr, const _Container_base*_Pstring)
		{

			{
				if(!(_Pstring==0||_Ptr!=0&&((_Mystring*)_Pstring)->_Myptr()<=_Ptr&&_Ptr<=(((_Mystring*)_Pstring)->_Myptr()+((_Mystring*)_Pstring)->_Mysize)))
				{
					(void)((!!((("_Pstring == NULL || _Ptr != NULL && ((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 72, 0, L"(\"_Pstring == NULL || _Ptr != NULL && ((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 72, 0);
				};
			};
			this->_Adopt(_Pstring);
			_Myptr=_Ptr;
		}
		reference operator*()const
		{
			if(this->_Mycont==0||_Myptr==0||_Myptr<((_Mystring*)this->_Mycont)->_Myptr()||((_Mystring*)this->_Mycont)->_Myptr()+((_Mystring*)this->_Mycont)->_Mysize<=_Myptr)
			{
				_Debug_message(L"string iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 111);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 112, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 112, 0);
				};
			}
			return (*_Myptr);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			if(this->_Mycont!=((const _Container_base*)-2))
			{

				{
					if(!(this->_Mycont!=0))
					{
						(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 134, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 134, 0);
					};
				};

				{
					if(!(_Myptr<(((_Mystring*)this->_Mycont)->_Myptr()+((_Mystring*)this->_Mycont)->_Mysize)))
					{
						(void)((!!((("_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 135, 0, L"(\"_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize)\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 135, 0);
					};
				};
			}
			++_Myptr;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			if(this->_Mycont!=((const _Container_base*)-2))
			{

				{
					if(!(this->_Mycont!=0))
					{
						(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 152, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 152, 0);
					};
				};

				{
					if(!(_Myptr>((_Mystring*)this->_Mycont)->_Myptr()))
					{
						(void)((!!((("_Myptr > ((_Mystring *)this->_Mycont)->_Myptr()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 153, 0, L"(\"_Myptr > ((_Mystring *)this->_Mycont)->_Myptr()\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 153, 0);
					};
				};
			}
			--_Myptr;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{
			if(this->_Mycont!=((const _Container_base*)-2))
			{

				{
					if(!(this->_Mycont!=0))
					{
						(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 170, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 170, 0);
					};
				};

				{
					if(!(_Myptr+_Off<=(((_Mystring*)this->_Mycont)->_Myptr()+((_Mystring*)this->_Mycont)->_Mysize)&&_Myptr+_Off>=((_Mystring*)this->_Mycont)->_Myptr()))
					{
						(void)((!!((("_Myptr + _Off <= (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize) && _Myptr + _Off >= ((_Mystring *)this->_Mycont)->_Myptr()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 171, 0, L"(\"_Myptr + _Off <= (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize) && _Myptr + _Off >= ((_Mystring *)this->_Mycont)->_Myptr()\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 171, 0);
					};
				};
			}
			_Myptr+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr-_Right._Myptr);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		bool operator==(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr==_Right._Myptr);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		bool operator<(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr<_Right._Myptr);
		}
		bool operator>(const _Myt&_Right)const
		{
			return (_Right<*this);
		}
		bool operator<=(const _Myt&_Right)const
		{
			return (!(_Right<*this));
		}
		bool operator>=(const _Myt&_Right)const
		{
			return (!(*this<_Right));
		}
		void _Compat(const _Myt&_Right)const
		{
			if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
			{
				_Debug_message(L"string iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 271);

				{
					(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 272, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 272, 0);
				};
			}
		}
		static void _Xlen()
		{
			_Mystring::_Xlen();
		}
		static void _Xran()
		{
			_Mystring::_Xran();
		}
		static void _Xinvarg()
		{
			_Mystring::_Xinvarg();
		}
		pointer _Myptr;
	};
	template<class _Elem, class _Traits, class _Alloc>
	inline _String_const_iterator<_Elem, _Traits, _Alloc>operator+(typename _String_const_iterator<_Elem, _Traits, _Alloc>::difference_type _Off, _String_const_iterator<_Elem, _Traits, _Alloc>_Next)
	{
		return (_Next+=_Off);
	}
	template<class _Elem, class _Traits, class _Alloc>
	class _String_iterator: public _String_const_iterator<_Elem, _Traits, _Alloc>
	{
	public:
		typedef _String_iterator<_Elem, _Traits, _Alloc>_Myt;
		typedef _String_const_iterator<_Elem, _Traits, _Alloc>_Mybase;
		typedef random_access_iterator_tag iterator_category;
		typedef _Elem value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::pointer pointer;
		typedef typename _Alloc::reference reference;
		_String_iterator()
		{
		}
		_String_iterator(pointer _Ptr, const _Container_base*_Pstring): _Mybase(_Ptr, _Pstring)
		{
		}
		reference operator*()const
		{
			return ((reference)**(_Mybase*)this);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			++(*(_Mybase*)this);
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			--(*(_Mybase*)this);
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{
			(*(_Mybase*)this)+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Mybase&_Right)const
		{
			return ((_Mybase)*this-_Right);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
	};
	template<class _Elem, class _Traits, class _Alloc>
	inline _String_iterator<_Elem, _Traits, _Alloc>operator+(typename _String_iterator<_Elem, _Traits, _Alloc>::difference_type _Off, _String_iterator<_Elem, _Traits, _Alloc>_Next)
	{
		return (_Next+=_Off);
	}
	class _String_base: public _Container_base
	{
	public:
		static void _Xlen();
		static void _Xran();
		static void _Xinvarg();
	};
	template<class _Ty, class _Alloc>
	class _String_val: public _String_base
	{
		protected: typedef typename _Alloc::template rebind<_Ty>::other _Alty;
		_String_val(_Alty _Al=_Alty()): _Alval(_Al)
		{
		}
		_Alty _Alval;
	};
	template<class _Elem, class _Traits, class _Ax>
	class basic_string: public _String_val<_Elem, _Ax>
	{
	public:
		typedef basic_string<_Elem, _Traits, _Ax>_Myt;
		typedef _String_val<_Elem, _Ax>_Mybase;
		typedef typename _Mybase::_Alty _Alloc;
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename _Alloc::pointer _Tptr;
		typedef typename _Alloc::const_pointer _Ctptr;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef typename _Alloc::reference _Reft;
		typedef _Reft reference;
		typedef typename _Alloc::const_reference const_reference;
		typedef typename _Alloc::value_type value_type;
		typedef _String_iterator<_Elem, _Traits, _Alloc>iterator;
		typedef _String_const_iterator<_Elem, _Traits, _Alloc>const_iterator;
		friend class _String_const_iterator<_Elem, _Traits, _Alloc>;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		basic_string(): _Mybase()
		{
			_Tidy();
		}
		explicit basic_string(const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
		}
		basic_string(const _Myt&_Right): _Mybase(_Right._Alval)
		{
			_Tidy();
			assign(_Right, 0, npos);
		}
		basic_string(const _Myt&_Right, size_type _Roff, size_type _Count=npos): _Mybase()
		{
			_Tidy();
			assign(_Right, _Roff, _Count);
		}
		basic_string(const _Myt&_Right, size_type _Roff, size_type _Count, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			assign(_Right, _Roff, _Count);
		}
		basic_string(const _Elem*_Ptr, size_type _Count): _Mybase()
		{
			_Tidy();
			assign(_Ptr, _Count);
		}
		basic_string(const _Elem*_Ptr, size_type _Count, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			assign(_Ptr, _Count);
		}
		basic_string(const _Elem*_Ptr): _Mybase()
		{
			_Tidy();
			assign(_Ptr);
		}
		basic_string(const _Elem*_Ptr, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			assign(_Ptr);
		}
		basic_string(size_type _Count, _Elem _Ch): _Mybase()
		{
			_Tidy();
			assign(_Count, _Ch);
		}
		basic_string(size_type _Count, _Elem _Ch, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			assign(_Count, _Ch);
		}
		template<class _It>
		basic_string(_It _First, _It _Last): _Mybase()
		{
			_Tidy();
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		basic_string(_It _First, _It _Last, const _Alloc&_Al): _Mybase(_Al)
		{
			_Tidy();
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		void _Construct(_It _Count, _It _Ch, _Int_iterator_tag)
		{
			assign((size_type)_Count, (_Elem)_Ch);
		}
		template<class _It>
		void _Construct(_It _First, _It _Last, input_iterator_tag)
		{
			try
			{
				for(;
				_First!=_Last;
				++_First)append((size_type)1, (_Elem)*_First);
			}
			catch(...)
			{
				_Tidy(true);
				throw;
			}
		}
		template<class _It>
		void _Construct(_It _First, _It _Last, forward_iterator_tag)
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 819);
			}
			size_type _Count=0;
			_Distance(_First, _Last, _Count);
			reserve(_Count);
			try
			{
				for(;
				_First!=_Last;
				++_First)append((size_type)1, (_Elem)*_First);
			}
			catch(...)
			{
				_Tidy(true);
				throw;
			}
		}
		basic_string(const_pointer _First, const_pointer _Last): _Mybase()
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 842);
			}
			_Tidy();
			if(_First!=_Last)assign(&*_First, _Last-_First);
		}
		basic_string(const_iterator _First, const_iterator _Last): _Mybase()
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 857);
			}
			_Tidy();
			if(_First!=_Last)assign(&*_First, _Last-_First);
		}
		~basic_string()
		{
			_Tidy(true);
		}
		typedef _Traits traits_type;
		typedef _Alloc allocator_type;
		static const size_type npos;
		_Myt&operator=(const _Myt&_Right)
		{
			return (assign(_Right));
		}
		_Myt&operator=(const _Elem*_Ptr)
		{
			return (assign(_Ptr));
		}
		_Myt&operator=(_Elem _Ch)
		{
			return (assign(1, _Ch));
		}
		_Myt&operator+=(const _Myt&_Right)
		{
			return (append(_Right));
		}
		_Myt&operator+=(const _Elem*_Ptr)
		{
			return (append(_Ptr));
		}
		_Myt&operator+=(_Elem _Ch)
		{
			return (append((size_type)1, _Ch));
		}
		_Myt&append(const _Myt&_Right)
		{
			return (append(_Right, 0, npos));
		}
		_Myt&append(const _Myt&_Right, size_type _Roff, size_type _Count)
		{
			if(_Right.size()<_Roff)_String_base::_Xran();
			size_type _Num=_Right.size()-_Roff;
			if(_Num<_Count)_Count=_Num;
			if(npos-_Mysize<=_Count||_Mysize+_Count<_Mysize)_String_base::_Xlen();
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Mysize, _Myres-_Mysize, _Right._Myptr()+_Roff, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&append(const _Elem*_Ptr, size_type _Count)
		{
			if(_Inside(_Ptr))return (append(*this, _Ptr-_Myptr(), _Count));
			if(npos-_Mysize<=_Count||_Mysize+_Count<_Mysize)_String_base::_Xlen();
			size_type _Num;
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Mysize, _Myres-_Mysize, _Ptr, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&append(const _Elem*_Ptr)
		{
			return (append(_Ptr, _Traits::length(_Ptr)));
		}
		_Myt&append(size_type _Count, _Elem _Ch)
		{
			if(npos-_Mysize<=_Count)_String_base::_Xlen();
			size_type _Num;
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Chassign(_Mysize, _Count, _Ch);
				_Eos(_Num);
			}
			return (*this);
		}
		template<class _It>
		_Myt&append(_It _First, _It _Last)
		{
			return (_Append(_First, _Last, _Iter_cat(_First)));
		}
		template<class _It>
		_Myt&_Append(_It _Count, _It _Ch, _Int_iterator_tag)
		{
			return (append((size_type)_Count, (_Elem)_Ch));
		}
		template<class _It>
		_Myt&_Append(_It _First, _It _Last, input_iterator_tag)
		{
			return (replace(end(), end(), _First, _Last));
		}
		_Myt&append(const_pointer _First, const_pointer _Last)
		{
			return (replace(end(), end(), _First, _Last));
		}
		_Myt&append(const_iterator _First, const_iterator _Last)
		{
			return (replace(end(), end(), _First, _Last));
		}
		_Myt&assign(const _Myt&_Right)
		{
			return (assign(_Right, 0, npos));
		}
		_Myt&assign(const _Myt&_Right, size_type _Roff, size_type _Count)
		{
			if(_Right.size()<_Roff)_String_base::_Xran();
			size_type _Num=_Right.size()-_Roff;
			if(_Count<_Num)_Num=_Count;
			if(this==&_Right)erase((size_type)(_Roff+_Num)), erase(0, _Roff);
			else if(_Grow(_Num))
			{
				_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr()+_Roff, _Num);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&assign(const _Elem*_Ptr, size_type _Num)
		{
			if(_Inside(_Ptr))return (assign(*this, _Ptr-_Myptr(), _Num));
			if(_Grow(_Num))
			{
				_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&assign(const _Elem*_Ptr)
		{
			return (assign(_Ptr, _Traits::length(_Ptr)));
		}
		_Myt&assign(size_type _Count, _Elem _Ch)
		{
			if(_Count==npos)_String_base::_Xlen();
			if(_Grow(_Count))
			{
				_Chassign(0, _Count, _Ch);
				_Eos(_Count);
			}
			return (*this);
		}
		template<class _It>
		_Myt&assign(_It _First, _It _Last)
		{
			return (_Assign(_First, _Last, _Iter_cat(_First)));
		}
		template<class _It>
		_Myt&_Assign(_It _Count, _It _Ch, _Int_iterator_tag)
		{
			return (assign((size_type)_Count, (_Elem)_Ch));
		}
		template<class _It>
		_Myt&_Assign(_It _First, _It _Last, input_iterator_tag)
		{
			return (replace(begin(), end(), _First, _Last));
		}
		_Myt&assign(const_pointer _First, const_pointer _Last)
		{
			return (replace(begin(), end(), _First, _Last));
		}
		_Myt&assign(const_iterator _First, const_iterator _Last)
		{
			return (replace(begin(), end(), _First, _Last));
		}
		_Myt&insert(size_type _Off, const _Myt&_Right)
		{
			return (insert(_Off, _Right, 0, npos));
		}
		_Myt&insert(size_type _Off, const _Myt&_Right, size_type _Roff, size_type _Count)
		{
			if(_Mysize<_Off||_Right.size()<_Roff)_String_base::_Xran();
			size_type _Num=_Right.size()-_Roff;
			if(_Num<_Count)_Count=_Num;
			if(npos-_Mysize<=_Count)_String_base::_Xlen();
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off, _Mysize-_Off);
				if(this==&_Right)_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+(_Off<_Roff?_Roff+_Count: _Roff), _Count);
				else _Traits_helper::copy_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Right._Myptr()+_Roff, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&insert(size_type _Off, const _Elem*_Ptr, size_type _Count)
		{
			if(_Inside(_Ptr))return (insert(_Off, *this, _Ptr-_Myptr(), _Count));
			if(_Mysize<_Off)_String_base::_Xran();
			if(npos-_Mysize<=_Count)_String_base::_Xlen();
			size_type _Num;
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off, _Mysize-_Off);
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Ptr, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&insert(size_type _Off, const _Elem*_Ptr)
		{
			return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}
		_Myt&insert(size_type _Off, size_type _Count, _Elem _Ch)
		{
			if(_Mysize<_Off)_String_base::_Xran();
			if(npos-_Mysize<=_Count)_String_base::_Xlen();
			size_type _Num;
			if(0<_Count&&_Grow(_Num=_Mysize+_Count))
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off, _Mysize-_Off);
				_Chassign(_Off, _Count, _Ch);
				_Eos(_Num);
			}
			return (*this);
		}
		iterator insert(iterator _Where)
		{
			return (insert(_Where, _Elem()));
		}
		iterator insert(iterator _Where, _Elem _Ch)
		{
			size_type _Off=_Pdif(_Where, begin());
			insert(_Off, 1, _Ch);
			return (begin()+_Off);
		}
		void insert(iterator _Where, size_type _Count, _Elem _Ch)
		{
			size_type _Off=_Pdif(_Where, begin());
			insert(_Off, _Count, _Ch);
		}
		template<class _It>
		void insert(iterator _Where, _It _First, _It _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		void _Insert(iterator _Where, _It _Count, _It _Ch, _Int_iterator_tag)
		{
			insert(_Where, (size_type)_Count, (_Elem)_Ch);
		}
		template<class _It>
		void _Insert(iterator _Where, _It _First, _It _Last, input_iterator_tag)
		{
			replace(_Where, _Where, _First, _Last);
		}
		void insert(iterator _Where, const_pointer _First, const_pointer _Last)
		{
			replace(_Where, _Where, _First, _Last);
		}
		void insert(iterator _Where, const_iterator _First, const_iterator _Last)
		{
			replace(_Where, _Where, _First, _Last);
		}
		_Myt&erase(size_type _Off=0, size_type _Count=npos)
		{
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_Count)_Count=_Mysize-_Off;
			if(0<_Count)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+_Off+_Count, _Mysize-_Off-_Count);
				size_type _Newsize=_Mysize-_Count;
				_Eos(_Newsize);
			}
			return (*this);
		}
		iterator erase(iterator _Where)
		{
			size_type _Count=_Pdif(_Where, begin());
			erase(_Count, 1);
			return (iterator(_Myptr()+_Count, this));
		}
		iterator erase(iterator _First, iterator _Last)
		{
			size_type _Count=_Pdif(_First, begin());
			erase(_Count, _Pdif(_Last, _First));
			return (iterator(_Myptr()+_Count, this));
		}
		void clear()
		{
			erase(begin(), end());
		}
		_Myt&replace(size_type _Off, size_type _N0, const _Myt&_Right)
		{
			return (replace(_Off, _N0, _Right, 0, npos));
		}
		_Myt&replace(size_type _Off, size_type _N0, const _Myt&_Right, size_type _Roff, size_type _Count)
		{
			if(_Mysize<_Off||_Right.size()<_Roff)_String_base::_Xran();
			if(_Mysize-_Off<_N0)_N0=_Mysize-_Off;
			size_type _Num=_Right.size()-_Roff;
			if(_Num<_Count)_Count=_Num;
			if(npos-_Count<=_Mysize-_N0)_String_base::_Xlen();
			size_type _Nm=_Mysize-_N0-_Off;
			size_type _Newsize=_Mysize+_Count-_N0;
			if(_Mysize<_Newsize)_Grow(_Newsize);
			if(this!=&_Right)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Right._Myptr()+_Roff, _Count);
			}
			else if(_Count<=_N0)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+_Roff, _Count);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
			}
			else if(_Roff<=_Off)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+_Roff, _Count);
			}
			else if(_Off+_N0<=_Roff)
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+(_Roff+_Count-_N0), _Count);
			}
			else
			{
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Myptr()+_Roff, _N0);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_N0, _Myres-_Off-_N0, _Myptr()+_Roff+_Count, _Count-_N0);
			}
			_Eos(_Newsize);
			return (*this);
		}
		_Myt&replace(size_type _Off, size_type _N0, const _Elem*_Ptr, size_type _Count)
		{
			if(_Inside(_Ptr))return (replace(_Off, _N0, *this, _Ptr-_Myptr(), _Count));
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_N0)_N0=_Mysize-_Off;
			if(npos-_Count<=_Mysize-_N0)_String_base::_Xlen();
			size_type _Nm=_Mysize-_N0-_Off;
			if(_Count<_N0)_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
			size_type _Num;
			if((0<_Count||0<_N0)&&_Grow(_Num=_Mysize+_Count-_N0))
			{
				if(_N0<_Count)_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Traits_helper::copy_s<_Traits>(_Myptr()+_Off, _Myres-_Off, _Ptr, _Count);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&replace(size_type _Off, size_type _N0, const _Elem*_Ptr)
		{
			return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}
		_Myt&replace(size_type _Off, size_type _N0, size_type _Count, _Elem _Ch)
		{
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_N0)_N0=_Mysize-_Off;
			if(npos-_Count<=_Mysize-_N0)_String_base::_Xlen();
			size_type _Nm=_Mysize-_N0-_Off;
			if(_Count<_N0)_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
			size_type _Num;
			if((0<_Count||0<_N0)&&_Grow(_Num=_Mysize+_Count-_N0))
			{
				if(_N0<_Count)_Traits_helper::move_s<_Traits>(_Myptr()+_Off+_Count, _Myres-_Off-_Count, _Myptr()+_Off+_N0, _Nm);
				_Chassign(_Off, _Count, _Ch);
				_Eos(_Num);
			}
			return (*this);
		}
		_Myt&replace(iterator _First, iterator _Last, const _Myt&_Right)
		{
			return (replace(_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
		}
		_Myt&replace(iterator _First, iterator _Last, const _Elem*_Ptr, size_type _Count)
		{
			return (replace(_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
		}
		_Myt&replace(iterator _First, iterator _Last, const _Elem*_Ptr)
		{
			return (replace(_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
		}
		_Myt&replace(iterator _First, iterator _Last, size_type _Count, _Elem _Ch)
		{
			return (replace(_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
		}
		template<class _It>
		_Myt&replace(iterator _First, iterator _Last, _It _First2, _It _Last2)
		{
			return (_Replace(_First, _Last, _First2, _Last2, _Iter_cat(_First2)));
		}
		template<class _It>
		_Myt&_Replace(iterator _First, iterator _Last, _It _Count, _It _Ch, _Int_iterator_tag)
		{
			return (replace(_First, _Last, (size_type)_Count, (_Elem)_Ch));
		}
		template<class _It>
		_Myt&_Replace(iterator _First, iterator _Last, _It _First2, _It _Last2, input_iterator_tag)
		{
			_Myt _Right(_First2, _Last2);
			replace(_First, _Last, _Right);
			return (*this);
		}
		_Myt&replace(iterator _First, iterator _Last, const_pointer _First2, const_pointer _Last2)
		{
			if(_First2==_Last2)erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
			else replace(_Pdif(_First, begin()), _Pdif(_Last, _First), &*_First2, _Last2-_First2);
			return (*this);
		}
		_Myt&replace(iterator _First, iterator _Last, const_iterator _First2, const_iterator _Last2)
		{
			if(_First2==_Last2)erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
			else replace(_Pdif(_First, begin()), _Pdif(_Last, _First), &*_First2, _Last2-_First2);
			return (*this);
		}
		iterator begin()
		{
			return (iterator(_Myptr(), this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Myptr(), this));
		}
		iterator end()
		{
			return (iterator(_Myptr()+_Mysize, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Myptr()+_Mysize, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		reference at(size_type _Off)
		{
			if(_Mysize<=_Off)_String_base::_Xran();
			return (_Myptr()[_Off]);
		}
		const_reference at(size_type _Off)const
		{
			if(_Mysize<=_Off)_String_base::_Xran();
			return (_Myptr()[_Off]);
		}
		reference operator[](size_type _Off)
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				if(_Mysize<_Off)
				{
					_Debug_message(L"string subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1498);

					{
						(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1499, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1499, 0);
					};
				}
			}
			return (_Myptr()[_Off]);
		}
		const_reference operator[](size_type _Off)const
		{
			if(this->_Myfirstiter!=((_Iterator_base*)-3))
			{
				if(_Mysize<_Off)
				{
					_Debug_message(L"string subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1518);

					{
						(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1519, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1519, 0);
					};
				}
			}
			return (_Myptr()[_Off]);
		}
		void push_back(_Elem _Ch)
		{
			insert(end(), _Ch);
		}
		const _Elem*c_str()const
		{
			return (_Myptr());
		}
		const _Elem*data()const
		{
			return (c_str());
		}
		size_type length()const
		{
			return (_Mysize);
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			size_type _Num=_Mybase::_Alval.max_size();
			return (_Num<=1?1: _Num-1);
		}
		void resize(size_type _Newsize)
		{
			resize(_Newsize, _Elem());
		}
		void resize(size_type _Newsize, _Elem _Ch)
		{
			if(_Newsize<=_Mysize)erase(_Newsize);
			else append(_Newsize-_Mysize, _Ch);
		}
		size_type capacity()const
		{
			return (_Myres);
		}
		void reserve(size_type _Newcap=0)
		{
			if(_Mysize<=_Newcap&&_Myres!=_Newcap)
			{
				size_type _Size=_Mysize;
				if(_Grow(_Newcap, true))_Eos(_Size);
			}
		}
		bool empty()const
		{
			return (_Mysize==0);
		}
		size_type copy(_Elem*_Dest, size_type _Count, size_type _Off=0)const
		{
			return _Copy_s(_Dest, _Count, _Count, _Off);
		}
		size_type _Copy_s(_Elem*_Dest, size_type _Dest_size, size_type _Count, size_type _Off=0)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1652);
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_Count)_Count=_Mysize-_Off;
			_Traits_helper::copy_s<_Traits>(_Dest, _Dest_size, _Myptr()+_Off, _Count);
			return (_Count);
		}
		void swap(_Myt&_Right)
		{
			if(_Mybase::_Alval==_Right._Alval)
			{
				this->_Swap_all(_Right);
				_Bxty _Tbx=_Bx;
				_Bx=_Right._Bx, _Right._Bx=_Tbx;
				size_type _Tlen=_Mysize;
				_Mysize=_Right._Mysize, _Right._Mysize=_Tlen;
				size_type _Tres=_Myres;
				_Myres=_Right._Myres, _Right._Myres=_Tres;
			}
			else
			{
				_Myt _Tmp=*this;
				*this=_Right, _Right=_Tmp;
			}
		}
		size_type find(const _Myt&_Right, size_type _Off=0)const
		{
			return (find(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1693);
			if(_Count==0&&_Off<=_Mysize)return (_Off);
			size_type _Nm;
			if(_Off<_Mysize&&_Count<=(_Nm=_Mysize-_Off))
			{
				const _Elem*_Uptr, *_Vptr;
				for(_Nm-=_Count-1, _Vptr=_Myptr()+_Off;
				(_Uptr=_Traits::find(_Vptr, _Nm, *_Ptr))!=0;
				_Nm-=_Uptr-_Vptr+1, _Vptr=_Uptr+1)if(_Traits::compare(_Uptr, _Ptr, _Count)==0)return (_Uptr-_Myptr());
			}
			return (npos);
		}
		size_type find(const _Elem*_Ptr, size_type _Off=0)const
		{
			return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find(_Elem _Ch, size_type _Off=0)const
		{
			return (find((const _Elem*)&_Ch, _Off, 1));
		}
		size_type rfind(const _Myt&_Right, size_type _Off=npos)const
		{
			return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type rfind(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1729);
			if(_Count==0)return (_Off<_Mysize?_Off: _Mysize);
			if(_Count<=_Mysize)
			{
				const _Elem*_Uptr=_Myptr()+(_Off<_Mysize-_Count?_Off: _Mysize-_Count);
				for(;
				;
				--_Uptr)if(_Traits::eq(*_Uptr, *_Ptr)&&_Traits::compare(_Uptr, _Ptr, _Count)==0)return (_Uptr-_Myptr());
				else if(_Uptr==_Myptr())break;
			}
			return (npos);
		}
		size_type rfind(const _Elem*_Ptr, size_type _Off=npos)const
		{
			return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type rfind(_Elem _Ch, size_type _Off=npos)const
		{
			return (rfind((const _Elem*)&_Ch, _Off, 1));
		}
		size_type find_first_of(const _Myt&_Right, size_type _Off=0)const
		{
			return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find_first_of(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1766);
			if(0<_Count&&_Off<_Mysize)
			{
				const _Elem*const _Vptr=_Myptr()+_Mysize;
				for(const _Elem*_Uptr=_Myptr()+_Off;
				_Uptr<_Vptr;
				++_Uptr)if(_Traits::find(_Ptr, _Count, *_Uptr)!=0)return (_Uptr-_Myptr());
			}
			return (npos);
		}
		size_type find_first_of(const _Elem*_Ptr, size_type _Off=0)const
		{
			return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find_first_of(_Elem _Ch, size_type _Off=0)const
		{
			return (find((const _Elem*)&_Ch, _Off, 1));
		}
		size_type find_last_of(const _Myt&_Right, size_type _Off=npos)const
		{
			return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find_last_of(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1797);
			if(0<_Count&&0<_Mysize)for(const _Elem*_Uptr=_Myptr()+(_Off<_Mysize?_Off: _Mysize-1);
			;
			--_Uptr)if(_Traits::find(_Ptr, _Count, *_Uptr)!=0)return (_Uptr-_Myptr());
			else if(_Uptr==_Myptr())break;
			return (npos);
		}
		size_type find_last_of(const _Elem*_Ptr, size_type _Off=npos)const
		{
			return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find_last_of(_Elem _Ch, size_type _Off=npos)const
		{
			return (rfind((const _Elem*)&_Ch, _Off, 1));
		}
		size_type find_first_not_of(const _Myt&_Right, size_type _Off=0)const
		{
			return (find_first_not_of(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find_first_not_of(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1830);
			if(_Off<_Mysize)
			{
				const _Elem*const _Vptr=_Myptr()+_Mysize;
				for(const _Elem*_Uptr=_Myptr()+_Off;
				_Uptr<_Vptr;
				++_Uptr)if(_Traits::find(_Ptr, _Count, *_Uptr)==0)return (_Uptr-_Myptr());
			}
			return (npos);
		}
		size_type find_first_not_of(const _Elem*_Ptr, size_type _Off=0)const
		{
			return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find_first_not_of(_Elem _Ch, size_type _Off=0)const
		{
			return (find_first_not_of((const _Elem*)&_Ch, _Off, 1));
		}
		size_type find_last_not_of(const _Myt&_Right, size_type _Off=npos)const
		{
			return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}
		size_type find_last_not_of(const _Elem*_Ptr, size_type _Off, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1861);
			if(0<_Mysize)for(const _Elem*_Uptr=_Myptr()+(_Off<_Mysize?_Off: _Mysize-1);
			;
			--_Uptr)if(_Traits::find(_Ptr, _Count, *_Uptr)==0)return (_Uptr-_Myptr());
			else if(_Uptr==_Myptr())break;
			return (npos);
		}
		size_type find_last_not_of(const _Elem*_Ptr, size_type _Off=npos)const
		{
			return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}
		size_type find_last_not_of(_Elem _Ch, size_type _Off=npos)const
		{
			return (find_last_not_of((const _Elem*)&_Ch, _Off, 1));
		}
		_Myt substr(size_type _Off=0, size_type _Count=npos)const
		{
			return (_Myt(*this, _Off, _Count));
		}
		int compare(const _Myt&_Right)const
		{
			return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));
		}
		int compare(size_type _Off, size_type _N0, const _Myt&_Right)const
		{
			return (compare(_Off, _N0, _Right, 0, npos));
		}
		int compare(size_type _Off, size_type _N0, const _Myt&_Right, size_type _Roff, size_type _Count)const
		{
			if(_Right.size()<_Roff)_String_base::_Xran();
			if(_Right._Mysize-_Roff<_Count)_Count=_Right._Mysize-_Roff;
			return (compare(_Off, _N0, _Right._Myptr()+_Roff, _Count));
		}
		int compare(const _Elem*_Ptr)const
		{
			return (compare(0, _Mysize, _Ptr, _Traits::length(_Ptr)));
		}
		int compare(size_type _Off, size_type _N0, const _Elem*_Ptr)const
		{
			return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}
		int compare(size_type _Off, size_type _N0, const _Elem*_Ptr, size_type _Count)const
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 1923);
			if(_Mysize<_Off)_String_base::_Xran();
			if(_Mysize-_Off<_N0)_N0=_Mysize-_Off;
			size_type _Ans=_Traits::compare(_Myptr()+_Off, _Ptr, _N0<_Count?_N0: _Count);
			return (_Ans!=0?(int)_Ans: _N0<_Count?-1: _N0==_Count?0: +1);
		}
		allocator_type get_allocator()const
		{
			return (_Mybase::_Alval);
		}
		enum
		{
			_BUF_SIZE=16/sizeof(_Elem)<1?1: 16/sizeof(_Elem)
		};
		protected: enum
		{
			_ALLOC_MASK=sizeof(_Elem)<=1?15: sizeof(_Elem)<=2?7: sizeof(_Elem)<=4?3: sizeof(_Elem)<=8?1: 0
		};
		void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{
			if(_Count==1)_Traits::assign(*(_Myptr()+_Off), _Ch);
			else _Traits::assign(_Myptr()+_Off, _Count, _Ch);
		}
		void _Copy(size_type _Newsize, size_type _Oldlen)
		{
			size_type _Newres=_Newsize|_ALLOC_MASK;
			if(max_size()<_Newres)_Newres=_Newsize;
			else if(_Newres/3<_Myres/2&&_Myres<=max_size()-_Myres/2)_Newres=_Myres+_Myres/2;
			_Elem*_Ptr=0;
			try
			{
				_Ptr=_Mybase::_Alval.allocate(_Newres+1);
			}
			catch(...)
			{
				_Newres=_Newsize;
				try
				{
					_Ptr=_Mybase::_Alval.allocate(_Newres+1);
				}
				catch(...)
				{
					_Tidy(true);
					throw;
				}
			}
			if(0<_Oldlen)_Traits_helper::copy_s<_Traits>(_Ptr, _Newres+1, _Myptr(), _Oldlen);
			_Tidy(true);
			_Bx._Ptr=_Ptr;
			_Myres=_Newres;
			_Eos(_Oldlen);
		}
		void _Eos(size_type _Newsize)
		{
			_Traits::assign(_Myptr()[_Mysize=_Newsize], _Elem());
		}
		bool _Grow(size_type _Newsize, bool _Trim=false)
		{
			if(max_size()<_Newsize)_String_base::_Xlen();
			if(_Myres<_Newsize)_Copy(_Newsize, _Mysize);
			else if(_Trim&&_Newsize<_BUF_SIZE)_Tidy(true, _Newsize<_Mysize?_Newsize: _Mysize);
			else if(_Newsize==0)_Eos(0);
			return (0<_Newsize);
		}
		bool _Inside(const _Elem*_Ptr)
		{
			_Debug_pointer(_Ptr, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xstring", 2013);
			if(_Ptr<_Myptr()||_Myptr()+_Mysize<=_Ptr)return (false);
			else return (true);
		}
		static size_type _Pdif(const_iterator _P2, const_iterator _P1)
		{
			return ((_P2)._Myptr==0?0: _P2-_P1);
		}
		void _Tidy(bool _Built=false, size_type _Newsize=0)
		{
			if(!_Built);
			else if(_BUF_SIZE<=_Myres)
			{
				_Elem*_Ptr=_Bx._Ptr;
				if(0<_Newsize)_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);
				_Mybase::_Alval.deallocate(_Ptr, _Myres+1);
			}
			_Myres=_BUF_SIZE-1;
			_Eos(_Newsize);
		}
		union _Bxty
		{
			_Elem _Buf[_BUF_SIZE];
			_Elem*_Ptr;
		}
		_Bx;
		_Elem*_Myptr()
		{
			return (_BUF_SIZE<=_Myres?_Bx._Ptr: _Bx._Buf);
		}
		const _Elem*_Myptr()const
		{
			return (_BUF_SIZE<=_Myres?_Bx._Ptr: _Bx._Buf);
		}
		size_type _Mysize;
		size_type _Myres;
	};
	template<class _Elem, class _Traits, class _Ax>
	class _Move_operation_category<basic_string<_Elem, _Traits, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Elem, class _Traits, class _Alloc>
	const typename basic_string<_Elem, _Traits, _Alloc>::size_type basic_string<_Elem, _Traits, _Alloc>::npos=(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
	template<class _Elem, class _Traits, class _Alloc>
	inline void swap(basic_string<_Elem, _Traits, _Alloc>&_Left, basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	typedef basic_string<char, char_traits<char>, allocator<char> >string;
	typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >wstring;
}
namespace std
{
	class logic_error: public std::exception
	{
	public:
		explicit logic_error(const string&_Message): _Str(_Message)
		{
		}
		virtual~logic_error()throw()
		{
		}
		virtual const char*what()const throw()
		{
			return (_Str.c_str());
		}
	private:
		string _Str;
	};
	class domain_error: public logic_error
	{
	public:
		explicit domain_error(const string&_Message): logic_error(_Message)
		{
		}
		virtual~domain_error()throw()
		{
		}
	};
	class invalid_argument: public logic_error
	{
	public:
		explicit invalid_argument(const string&_Message): logic_error(_Message)
		{
		}
		virtual~invalid_argument()throw()
		{
		}
	};
	class length_error: public logic_error
	{
	public:
		explicit length_error(const string&_Message): logic_error(_Message)
		{
		}
		virtual~length_error()throw()
		{
		}
	};
	class out_of_range: public logic_error
	{
	public:
		explicit out_of_range(const string&_Message): logic_error(_Message)
		{
		}
		virtual~out_of_range()throw()
		{
		}
	};
	class runtime_error: public std::exception
	{
	public:
		explicit runtime_error(const string&_Message): _Str(_Message)
		{
		}
		virtual~runtime_error()throw()
		{
		}
		virtual const char*what()const throw()
		{
			return (_Str.c_str());
		}
	private:
		string _Str;
	};
	class overflow_error: public runtime_error
	{
	public:
		explicit overflow_error(const string&_Message): runtime_error(_Message)
		{
		}
		virtual~overflow_error()throw()
		{
		}
	};
	class underflow_error: public runtime_error
	{
	public:
		explicit underflow_error(const string&_Message): runtime_error(_Message)
		{
		}
		virtual~underflow_error()throw()
		{
		}
	};
	class range_error: public runtime_error
	{
	public:
		explicit range_error(const string&_Message): runtime_error(_Message)
		{
		}
		virtual~range_error()throw()
		{
		}
	};
}
struct __type_info_node
{
	void*memPtr;
	__type_info_node*next;
};
extern __type_info_node __type_info_root_node;
class type_info
{
public:
	virtual~type_info();
	bool operator==(const type_info&rhs)const;
	bool operator!=(const type_info&rhs)const;
	int before(const type_info&rhs)const;
	const char*name(__type_info_node*__ptype_info_node=&__type_info_root_node)const;
	const char*raw_name()const;
private:
	void*_m_data;
	char _m_d_name[1];
	type_info(const type_info&rhs);
	type_info&operator=(const type_info&rhs);
	static const char*_Name_base(const type_info*, __type_info_node*__ptype_info_node);
	static void _Type_info_dtor(type_info*);
};
namespace std
{
	using::type_info;
}
namespace std
{
	class bad_cast: public exception
	{
	public:
		bad_cast(const char*_Message="bad cast");
		bad_cast(const bad_cast&);
		virtual~bad_cast();
	};
	class bad_typeid: public exception
	{
	public:
		bad_typeid(const char*_Message="bad typeid");
		bad_typeid(const bad_typeid&);
		virtual~bad_typeid();
	};
	class __non_rtti_object: public bad_typeid
	{
	public:
		__non_rtti_object(const char*_Message);
		__non_rtti_object(const __non_rtti_object&);
		virtual~__non_rtti_object();
	};
}
namespace std
{
	struct _DebugHeapTag_t
	{
		int _Type;
	};
}
void*operator new(size_t _Size, const std::_DebugHeapTag_t&, char*, int)throw(...);
void*operator new[](size_t _Size, const std::_DebugHeapTag_t&, char*, int)throw(...);
void operator delete(void*, const std::_DebugHeapTag_t&, char*, int)throw();
void operator delete[](void*, const std::_DebugHeapTag_t&, char*, int)throw();
namespace std
{
	const _DebugHeapTag_t&_DebugHeapTag_func();
	template<class _Ty>
	void _DebugHeapDelete(_Ty*_Ptr)
	{
		if(_Ptr!=0)
		{
			_Ptr->~_Ty();
			free(_Ptr);
		}
	}
	template<class _Ty>
	class _DebugHeapAllocator: public allocator<_Ty>
	{
	public:
		template<class _Other>
		struct rebind
		{
			typedef typename _DebugHeapAllocator<_Other>other;
		};
		typename allocator<_Ty>::pointer allocate(typename allocator<_Ty>::size_type _Count, const void*)
		{
			if(_Count<=0)_Count=0;
			else if(((size_t)(-1)/_Count)<sizeof(_Ty))throw std::bad_alloc(0);
			return ((_Ty*)new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xdebug", 86)char[_Count*sizeof(_Ty)]);
		}
		typename allocator<_Ty>::pointer allocate(typename allocator<_Ty>::size_type _Count)
		{
			if(_Count<=0)_Count=0;
			else if(((size_t)(-1)/_Count)<sizeof(_Ty))throw std::bad_alloc(0);
			return ((_Ty*)new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xdebug", 97)char[_Count*sizeof(_Ty)]);
		}
		void deallocate(typename allocator<_Ty>::pointer _Ptr, typename allocator<_Ty>::size_type)
		{
			std::_DebugHeapDelete((void*)_Ptr);
		}
	};
	template class _DebugHeapAllocator<char>
	;
	class _DebugHeapString: public basic_string<char, char_traits<char>, _DebugHeapAllocator<char> >
	{
	public:
		typedef _DebugHeapString _Myt;
		typedef basic_string<char, char_traits<char>, _DebugHeapAllocator<char> >_Mybase;
		typedef char _Elem;
		_DebugHeapString(): _Mybase()
		{
		}
		_DebugHeapString(const _Myt&_Right): _Mybase(_Right)
		{
		}
		_DebugHeapString(const _Elem*_Ptr): _Mybase(_Ptr)
		{
		}
		_DebugHeapString(const string&_Str): _Mybase(_Str.c_str())
		{
		}
		operator string()const
		{
			return (string(c_str()));
		}
	};
}
extern "C"
{
	int _isctype(int _C, int _Type);
	int _isctype_l(int _C, int _Type, _locale_t _Locale);
	int isalpha(int _C);
	int _isalpha_l(int _C, _locale_t _Locale);
	int isupper(int _C);
	int _isupper_l(int _C, _locale_t _Locale);
	int islower(int _C);
	int _islower_l(int _C, _locale_t _Locale);
	int isdigit(int _C);
	int _isdigit_l(int _C, _locale_t _Locale);
	int isxdigit(int _C);
	int _isxdigit_l(int _C, _locale_t _Locale);
	int isspace(int _C);
	int _isspace_l(int _C, _locale_t _Locale);
	int ispunct(int _C);
	int _ispunct_l(int _C, _locale_t _Locale);
	int isalnum(int _C);
	int _isalnum_l(int _C, _locale_t _Locale);
	int isprint(int _C);
	int _isprint_l(int _C, _locale_t _Locale);
	int isgraph(int _C);
	int _isgraph_l(int _C, _locale_t _Locale);
	int iscntrl(int _C);
	int _iscntrl_l(int _C, _locale_t _Locale);
	int toupper(int _C);
	int tolower(int _C);
	int _tolower(int _C);
	int _tolower_l(int _C, _locale_t _Locale);
	int _toupper(int _C);
	int _toupper_l(int _C, _locale_t _Locale);
	int __isascii(int _C);
	int __toascii(int _C);
	int __iscsymf(int _C);
	int __iscsym(int _C);
	int _chvalidator(int _Ch, int _Mask);
	int _chvalidator_l(_locale_t, int _Ch, int _Mask);
}
extern "C"
{
	struct lconv
	{
		char*decimal_point;
		char*thousands_sep;
		char*grouping;
		char*int_curr_symbol;
		char*currency_symbol;
		char*mon_decimal_point;
		char*mon_thousands_sep;
		char*mon_grouping;
		char*positive_sign;
		char*negative_sign;
		char int_frac_digits;
		char frac_digits;
		char p_cs_precedes;
		char p_sep_by_space;
		char n_cs_precedes;
		char n_sep_by_space;
		char p_sign_posn;
		char n_sign_posn;
	};
	int _configthreadlocale(int _Flag);
	char*setlocale(int _Category, const char*_Locale);
	struct lconv*localeconv(void);
	_locale_t _get_current_locale(void);
	_locale_t _create_locale(int _Category, const char*_Locale);
	void _free_locale(_locale_t _Locale);
	_locale_t __get_current_locale(void);
	_locale_t __create_locale(int _Category, const char*_Locale);
	void __free_locale(_locale_t _Locale);
}
extern "C"
{
	typedef struct _Collvec
	{
		unsigned long _Hand;
		unsigned int _Page;
	}
	_Collvec;
	typedef struct _Ctypevec
	{
		unsigned long _Hand;
		unsigned int _Page;
		const short*_Table;
		int _Delfl;
	}
	_Ctypevec;
	typedef struct _Cvtvec
	{
		unsigned long _Hand;
		unsigned int _Page;
	}
	_Cvtvec;
	_Collvec _Getcoll();
	_Ctypevec _Getctype();
	_Cvtvec _Getcvt();
	int _Getdateorder();
	int _Mbrtowc(wchar_t*, const char*, size_t, mbstate_t*, const _Cvtvec*);
	float _Stof(const char*, char**, long);
	double _Stod(const char*, char**, long);
	long double _Stold(const char*, char**, long);
	int _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*);
	size_t _Strxfrm(char*_String1, char*_End1, const char*, const char*, const _Collvec*);
	int _Tolower(int, const _Ctypevec*);
	int _Toupper(int, const _Ctypevec*);
	int _Wcrtomb(char*, wchar_t, mbstate_t*, const _Cvtvec*);
	int _Wcscoll(const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*);
	size_t _Wcsxfrm(wchar_t*_String1, wchar_t*_End1, const wchar_t*, const wchar_t*, const _Collvec*);
	short _Getwctype(wchar_t, const _Ctypevec*);
	const wchar_t*_Getwctypes(const wchar_t*, const wchar_t*, short*, const _Ctypevec*);
	wchar_t _Towlower(wchar_t, const _Ctypevec*);
	wchar_t _Towupper(wchar_t, const _Ctypevec*);
}
extern "C"
{
	void*_Gettnames();
	char*_Getdays();
	char*_Getmonths();
	size_t _Strftime(char*, size_t _Maxsize, const char*, const struct tm*, void*);
}
extern "C"
{
	_locale_t _GetLocaleForCP(unsigned int);
}
namespace std
{
	class _Timevec
	{
	public:
		_Timevec(void*_Ptr=0): _Timeptr(_Ptr)
		{
		}
		_Timevec(const _Timevec&_Right)
		{
			*this=_Right;
		}
		~_Timevec()
		{
			free(_Timeptr);
		}
		_Timevec&operator=(const _Timevec&_Right)
		{
			_Timeptr=_Right._Timeptr;
			((_Timevec*)&_Right)->_Timeptr=0;
			return (*this);
		}
		void*_Getptr()const
		{
			return (_Timeptr);
		}
	private:
		void*_Timeptr;
	};
	class _Locinfo
	{
	public:
		typedef ::_Collvec _Collvec;
		typedef ::_Ctypevec _Ctypevec;
		typedef ::_Cvtvec _Cvtvec;
		typedef std::_Timevec _Timevec;
		static void _Locinfo_ctor(_Locinfo*, const char*);
		static void _Locinfo_ctor(_Locinfo*, int, const char*);
		static void _Locinfo_dtor(_Locinfo*);
		static _Locinfo&_Locinfo_Addcats(_Locinfo*, int, const char*);
		_Locinfo(const char*_Pch="C"): _Lock(0)
		{
			if(_Pch==0)throw runtime_error("bad locale name");
			_Locinfo_ctor(this, _Pch);
		}
		_Locinfo(int _I, const char*_Pch): _Lock(0)
		{
			if(_Pch==0)throw runtime_error("bad locale name");
			_Locinfo_ctor(this, _I, _Pch);
		}
		~_Locinfo()
		{
			_Locinfo_dtor(this);
		}
		_Locinfo&_Addcats(int _I, const char*_Pch)
		{
			if(_Pch==0)throw runtime_error("bad locale name");
			return _Locinfo_Addcats(this, _I, _Pch);
		}
		string _Getname()const
		{
			return (_Newlocname);
		}
		_Collvec _Getcoll()const
		{
			return (::_Getcoll());
		}
		_Ctypevec _Getctype()const
		{
			return (::_Getctype());
		}
		_Cvtvec _Getcvt()const
		{
			return (::_Getcvt());
		}
		const lconv*_Getlconv()const
		{
			return (localeconv());
		}
		_Timevec _Gettnames()const
		{
			return (_Timevec(::_Gettnames()));
		}
		const char*_Getdays()const
		{
			const char*_Ptr=::_Getdays();
			if(_Ptr!=0)
			{
				((_Locinfo*)this)->_Days=_Ptr;
				free((void*)_Ptr);
			}
			return (_Days.size()!=0?_Days.c_str(): ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday" ":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}
		const char*_Getmonths()const
		{
			const char*_Ptr=::_Getmonths();
			if(_Ptr!=0)
			{
				((_Locinfo*)this)->_Months=_Ptr;
				free((void*)_Ptr);
			}
			return (_Months.size()!=0?_Months.c_str(): ":Jan:January:Feb:February:Mar:March" ":Apr:April:May:May:Jun:June" ":Jul:July:Aug:August:Sep:September" ":Oct:October:Nov:November:Dec:December");
		}
		const char*_Getfalse()const
		{
			return ("false");
		}
		const char*_Gettrue()const
		{
			return ("true");
		}
		int _Getdateorder()const
		{
			return ::_Getdateorder();
		}
	private:
		_Lockit _Lock;
		string _Days;
		string _Months;
		string _Oldlocname;
		string _Newlocname;
	};
	template<class _Elem>
	inline int _LStrcoll(const _Elem*_First1, const _Elem*_Last1, const _Elem*_First2, const _Elem*_Last2, const _Locinfo::_Collvec*)
	{
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_First1, ++_First2)if(*_First1<*_First2)return (-1);
		else if(*_First2<*_First1)return (+1);
		return (_First2!=_Last2?-1: _First1!=_Last1?+1: 0);
	}
	template<>
	inline int _LStrcoll(const char*_First1, const char*_Last1, const char*_First2, const char*_Last2, const _Locinfo::_Collvec*_Vector)
	{
		return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}
	template<>
	inline int _LStrcoll(const wchar_t*_First1, const wchar_t*_Last1, const wchar_t*_First2, const wchar_t*_Last2, const _Locinfo::_Collvec*_Vector)
	{
		return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}
	template<class _Elem>
	inline size_t _LStrxfrm(_Elem*_First1, _Elem*_Last1, const _Elem*_First2, const _Elem*_Last2, const _Locinfo::_Collvec*)
	{
		size_t _Count=_Last2-_First2;
		if(_Count<=(size_t)(_Last1-_First1))::memcpy_s((_First1), ((_Last1-_First1)*sizeof(_Elem)), (_First2), (_Count*sizeof(_Elem)));
		return (_Count);
	}
	template<>
	inline size_t _LStrxfrm(char*_First1, char*_Last1, const char*_First2, const char*_Last2, const _Locinfo::_Collvec*_Vector)
	{
		return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
	template<>
	inline size_t _LStrxfrm(wchar_t*_First1, wchar_t*_Last1, const wchar_t*_First2, const wchar_t*_Last2, const _Locinfo::_Collvec*_Vector)
	{
		return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
namespace std
{
	template<class _Elem>
	class collate;
	template<class _Dummy>
	class _Locbase
	{
	public:
		static const int collate=((1<<(1))>>1);
		static const int ctype=((1<<(2))>>1);
		static const int monetary=((1<<(3))>>1);
		static const int numeric=((1<<(4))>>1);
		static const int time=((1<<(5))>>1);
		static const int messages=((1<<(6))>>1);
		static const int all=(((1<<(7))>>1)-1);
		static const int none=0;
	};
	template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
	template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
	template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
	template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
	template<class _Dummy>
	const int _Locbase<_Dummy>::time;
	template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
	template<class _Dummy>
	const int _Locbase<_Dummy>::all;
	template<class _Dummy>
	const int _Locbase<_Dummy>::none;
	class locale;
	template<class _Facet>
	const _Facet&use_facet(const locale&);
	class locale: public _Locbase<int>
	{
	public:
		typedef int category;
		class id
		{
		public:
			id(size_t _Val=0): _Id(_Val)
			{
			}
			operator size_t()
			{
				if(_Id==0)
				{

					{
						::std::_Lockit _Lock(0);
						if(_Id==0)_Id=++_Id_cnt;
					}
				}
				return (_Id);
			}
		private:
			id(const id&);
			id&operator=(const id&);
			size_t _Id;
			static int&_Id_cnt_func();
			static int _Id_cnt;
		};
		class _Locimp;
		class facet
		{
			friend class locale;
			friend class _Locimp;
		public:
			static size_t _Getcat(const facet** =0)
			{
				return ((size_t)(-1));
			}
			void _Incref()
			{

				{
					::std::_Lockit _Lock(0);
					if(_Refs<(size_t)(-1))++_Refs;
				}
			}
			facet*_Decref()
			{

				{
					::std::_Lockit _Lock(0);
					if(0<_Refs&&_Refs<(size_t)(-1))--_Refs;
					return (_Refs==0?this: 0);
				}
			}
			void _Register()
			{
				facet_Register(this);
			}
			void*operator new(size_t _Size)
			{
				return (operator new(_Size, std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 144));
			}
			void*operator new(size_t _Size, const std::_DebugHeapTag_t&_Tag, char*_File, int _Line)
			{
				return (::operator new(_Size, _Tag, _File, _Line));
			}
			void operator delete(void*_Ptr, const std::_DebugHeapTag_t&, char*, int)
			{
				operator delete(_Ptr);
			}
			void operator delete(void*_Ptr)
			{
				std::_DebugHeapDelete((facet*)_Ptr);
			}
			virtual~facet()
			{
			}
			protected: explicit facet(size_t _Initrefs=0): _Refs(_Initrefs)
			{
			}
		private:
			static void facet_Register(facet*);
			facet(const facet&);
			facet&operator=(const facet&);
			size_t _Refs;
		};
		class _Locimp: public facet
		{
			protected: ~_Locimp()
			{
				_Locimp_dtor(this);
			}
		private:
			static void _Locimp_dtor(_Locimp*);
			static void _Locimp_ctor(_Locimp*, const _Locimp&);
			static void _Locimp_Addfac(_Locimp*, facet*, size_t);
			friend class locale;
			_Locimp(bool _Transparent=false): locale::facet(1), _Facetvec(0), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*")
			{
			}
			_Locimp(const _Locimp&_Right): locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name(_Right._Name)
			{
				_Locimp_ctor(this, _Right);
			}
			void _Addfac(facet*_Pfacet, size_t _Id)
			{
				_Locimp_Addfac(this, _Pfacet, _Id);
			}
			static _Locimp*_Makeloc(const _Locinfo&, category, _Locimp*, const locale*);
			static void _Makewloc(const _Locinfo&, category, _Locimp*, const locale*);
			static void _Makeushloc(const _Locinfo&, category, _Locimp*, const locale*);
			static void _Makexloc(const _Locinfo&, category, _Locimp*, const locale*);
			facet**_Facetvec;
			size_t _Facetcount;
			category _Catmask;
			bool _Xparent;
			_DebugHeapString _Name;
			static _Locimp*&_Clocptr_func();
			static _Locimp*_Clocptr;
		private:
			_Locimp&operator=(const _Locimp&);
		};
		locale&_Addfac(facet*_Fac, size_t _Id, size_t _Catmask)
		{
			if(1<this->_Ptr->_Refs)
			{
				this->_Ptr->_Decref();
				this->_Ptr=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 256)_Locimp(*this->_Ptr);
			}
			this->_Ptr->_Addfac(_Fac, _Id);
			if(_Catmask!=0)this->_Ptr->_Name="*";
			return (*this);
		}
		template<class _Elem, class _Traits, class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)const
		{
			const std::collate<_Elem>&_Coll_fac=std::use_facet<std::collate<_Elem> >(*this);
			return (_Coll_fac.compare(_Left.c_str(), _Left.c_str()+_Left.size(), _Right.c_str(), _Right.c_str()+_Right.size())<0);
		}
		template<class _Facet>
		locale combine(const locale&_Loc)const
		{
			_Facet*_Facptr;
			try
			{
				_Facptr=(_Facet*)&std::use_facet<_Facet>(_Loc);
			}
			catch(...)
			{
				throw runtime_error("locale::combine facet missing");
			}
			_Locimp*_Newimp=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 289)_Locimp(*_Ptr);
			_Newimp->_Addfac(_Facptr, _Facet::id);
			_Newimp->_Catmask=0;
			_Newimp->_Name="*";
			return (locale(_Newimp));
		}
		template<class _Facet>
		locale(const locale&_Loc, const _Facet*_Facptr): _Ptr(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 298)_Locimp(*_Loc._Ptr))
		{
			if(_Facptr!=0)
			{
				_Ptr->_Addfac((_Facet*)_Facptr, _Facet::id);
				if(_Facet::_Getcat()!=(size_t)(-1))_Ptr->_Catmask=0, _Ptr->_Name="*";
			}
		}
		locale()throw(): _Ptr(_Init())
		{
			_Getgloballocale()->_Incref();
		}
		locale(_Uninitialized)
		{
		}
		locale(const locale&_Right)throw(): _Ptr(_Right._Ptr)
		{
			_Ptr->_Incref();
		}
		locale(const locale&_Loc, const locale&_Other, category _Cat): _Ptr(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 327)_Locimp(*_Loc._Ptr))
		{
			try
			{

				{
					_Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
					_Locimp::_Makeloc(_Lobj._Addcats(_Cat&_Other._Ptr->_Catmask, _Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
				}
			}
			catch(...)
			{
				std::_DebugHeapDelete(_Ptr->_Decref());
				throw;
			}
		}
		explicit locale(const char*_Locname, category _Cat=all): _Ptr(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 342)_Locimp)
		{
			try
			{
				_Init();

				{
					_Locinfo _Lobj(_Cat, _Locname);
					if(_Lobj._Getname().compare("*")==0)throw runtime_error("bad locale name");
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
				}
			}
			catch(...)
			{
				std::_DebugHeapDelete(_Ptr->_Decref());
				throw;
			}
		}
		locale(const locale&_Loc, const char*_Locname, category _Cat): _Ptr(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 359)_Locimp(*_Loc._Ptr))
		{
			try
			{

				{
					_Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
					bool _Hadname=_Lobj._Getname().compare("*")!=0;
					_Lobj._Addcats(_Cat, _Locname);
					if(_Hadname&&_Lobj._Getname().compare("*")==0)throw runtime_error("bad locale name");
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
				}
			}
			catch(...)
			{
				std::_DebugHeapDelete(_Ptr->_Decref());
				throw;
			}
		}
		~locale()throw()
		{
			if(_Ptr!=0)std::_DebugHeapDelete(_Ptr->_Decref());
		}
		locale&operator=(const locale&_Right)throw()
		{
			if(_Ptr!=_Right._Ptr)
			{
				std::_DebugHeapDelete(_Ptr->_Decref());
				_Ptr=_Right._Ptr;
				_Ptr->_Incref();
			}
			return (*this);
		}
		string name()const
		{
			return (_Ptr->_Name);
		}
		const facet*_Getfacet(size_t _Id)const
		{
			const facet*_Facptr=_Id<_Ptr->_Facetcount?_Ptr->_Facetvec[_Id]: 0;
			if(_Facptr!=0||!_Ptr->_Xparent)return (_Facptr);
			else
			{
				locale::_Locimp*_Ptr=_Getgloballocale();
				return (_Id<_Ptr->_Facetcount?_Ptr->_Facetvec[_Id]: 0);
			}
		}
		bool operator==(const locale&_Loc)const
		{
			return (_Ptr==_Loc._Ptr||name().compare("*")!=0&&name().compare(_Loc.name())==0);
		}
		bool operator!=(const locale&_Right)const
		{
			return (!(*this==_Right));
		}
		static const locale&classic();
		static locale global(const locale&);
		static locale empty();
	private:
		locale(_Locimp*_Ptrimp): _Ptr(_Ptrimp)
		{
		}
		static _Locimp*_Getgloballocale();
		static _Locimp*_Init();
		static void _Setgloballocale(void*);
		_Locimp*_Ptr;
	};
	template<class _Facet>
	struct _Facetptr
	{
		static const locale::facet*_Psave;
	};
	template<class _Facet>
	const locale::facet*_Facetptr<_Facet>::_Psave=0;
	template<class _Facet>
	inline locale _Addfac(locale _Loc, const _Facet*_Facptr)
	{
		return (_Loc._Addfac((_Facet*)_Facptr, _Facet::id, _Facet::_Getcat()));
	}
	template<class _Facet>
	inline const _Facet&use_facet(const locale&_Loc)
	{

		{
			::std::_Lockit _Lock(0);
			const locale::facet*_Psave=_Facetptr<_Facet>::_Psave;
			size_t _Id=_Facet::id;
			const locale::facet*_Pf=_Loc._Getfacet(_Id);
			if(_Pf!=0);
			else if(_Psave!=0)_Pf=_Psave;
			else if(_Facet::_Getcat(&_Psave)==(size_t)(-1))throw bad_cast();
			else
			{
				_Pf=_Psave;
				_Facetptr<_Facet>::_Psave=_Psave;
				locale::facet*_Pfmod=(_Facet*)_Psave;
				_Pfmod->_Incref();
				_Pfmod->_Register();
			}
			return ((const _Facet&)(*_Pf));
		}
	}
	template<class _Facet>
	inline const _Facet&use_facet(const locale&_Loc, const _Facet*, bool=false)
	{
		return use_facet<_Facet>(_Loc);
	}
	template<class _Elem, class _InIt>
	inline int _Getloctxt(_InIt&_First, _InIt&_Last, size_t _Numfields, const _Elem*_Ptr)
	{
		for(size_t _Off=0;
		_Ptr[_Off]!=(_Elem)0;
		++_Off)if(_Ptr[_Off]==_Ptr[0])++_Numfields;
		string _Str(_Numfields, '\0');
		int _Ans=-2;
		for(size_t _Column=1;
		;
		++_Column, ++_First, _Ans=-1)
		{
			bool _Prefix=false;
			size_t _Off=0;
			size_t _Field=0;
			for(;
			_Field<_Numfields;
			++_Field)
			{
				for(;
				_Ptr[_Off]!=(_Elem)0&&_Ptr[_Off]!=_Ptr[0];
				++_Off);
				if(_Str[_Field]!='\0')_Off+=_Str[_Field];
				else if(_Ptr[_Off+=_Column]==_Ptr[0]||_Ptr[_Off]==(_Elem)0)
				{
					_Str[_Field]=(char)(_Column<127?_Column: 127);
					_Ans=(int)_Field;
				}
				else if(_First==_Last||_Ptr[_Off]!=*_First)_Str[_Field]=(char)(_Column<127?_Column: 127);
				else _Prefix=true;
			}
			if(!_Prefix||_First==_Last)break;
		}
		return (_Ans);
	}
	template<class _Elem>
	inline char _Maklocbyte(_Elem _Char, const _Locinfo::_Cvtvec&)
	{
		return ((char)(unsigned char)_Char);
	}
	template<>
	inline char _Maklocbyte(wchar_t _Char, const _Locinfo::_Cvtvec&_Cvt)
	{
		char _Byte='\0';
		mbstate_t _Mbst1=
		{
			0
		};
		_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
		return (_Byte);
	}
	template<class _Elem>
	inline _Elem _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&)
	{
		return ((_Elem)(unsigned char)_Byte);
	}
	template<>
	inline wchar_t _Maklocchr(char _Byte, wchar_t*, const _Locinfo::_Cvtvec&_Cvt)
	{
		wchar_t _Wc=L'\0';
		mbstate_t _Mbst1=
		{
			0
		};
		_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
		return (_Wc);
	}
	template<class _Elem>
	inline _Elem*_Maklocstr(const char*_Ptr, _Elem*, const _Locinfo::_Cvtvec&)
	{
		size_t _Count=::strlen(_Ptr)+1;
		_Elem*_Ptrdest=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 609)_Elem[_Count];
		for(_Elem*_Ptrnext=_Ptrdest;
		0<_Count;
		--_Count, ++_Ptrnext, ++_Ptr)*_Ptrnext=(_Elem)(unsigned char)*_Ptr;
		return (_Ptrdest);
	}
	template<>
	inline wchar_t*_Maklocstr(const char*_Ptr, wchar_t*, const _Locinfo::_Cvtvec&_Cvt)
	{
		size_t _Count, _Count1;
		size_t _Wchars;
		const char*_Ptr1;
		int _Bytes;
		wchar_t _Wc;
		mbstate_t _Mbst1=
		{
			0
		};
		_Count1=::strlen(_Ptr)+1;
		for(_Count=_Count1, _Wchars=0, _Ptr1=_Ptr;
		0<_Count;
		_Count-=_Bytes, _Ptr1+=_Bytes, ++_Wchars)if((_Bytes=_Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt))<=0)break;
		++_Wchars;
		wchar_t*_Ptrdest=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 638)wchar_t[_Wchars];
		wchar_t*_Ptrnext=_Ptrdest;
		mbstate_t _Mbst2=
		{
			0
		};
		for(;
		0<_Wchars;
		_Count-=_Bytes, _Ptr+=_Bytes, --_Wchars, ++_Ptrnext)if((_Bytes=_Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt))<=0)break;
		*_Ptrnext=L'\0';
		return (_Ptrdest);
	}
	class codecvt_base: public locale::facet
	{
	public:
		enum
		{
			ok, partial, error, noconv
		};
		typedef int result;
		codecvt_base(size_t _Refs=0): locale::facet(_Refs)
		{
		}
		bool always_noconv()const throw()
		{
			return (do_always_noconv());
		}
		int max_length()const throw()
		{
			return (do_max_length());
		}
		int encoding()const throw()
		{
			return (do_encoding());
		}
		~codecvt_base()
		{
		}
		protected: virtual bool do_always_noconv()const throw()
		{
			return (true);
		}
		virtual int do_max_length()const throw()
		{
			return (1);
		}
		virtual int do_encoding()const throw()
		{
			return (1);
		}
	};
	template<class _Elem, class _Byte, class _Statype>
	class codecvt: public codecvt_base
	{
	public:
		typedef _Elem intern_type;
		typedef _Byte extern_type;
		typedef _Statype state_type;
		result in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			return (do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_unshift(_State, _First2, _Last2, _Mid2));
		}
		int length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			return (do_length(_State, _First1, _Last1, _Count));
		}
		static locale::id id;
		explicit codecvt(size_t _Refs=0): codecvt_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		codecvt(const _Locinfo&_Lobj, size_t _Refs=0): codecvt_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 764)codecvt<_Elem, _Byte, _Statype>;
			return (2);
		}
		protected: virtual~codecvt()
		{
		}
		protected: void _Init(const _Locinfo&)
		{
		}
		virtual result do_in(_Statype&, const _Byte*_First1, const _Byte*, const _Byte*&_Mid1, _Elem*_First2, _Elem*, _Elem*&_Mid2)const
		{
			_Mid1=_First1, _Mid2=_First2;
			return (noconv);
		}
		virtual result do_out(_Statype&, const _Elem*_First1, const _Elem*, const _Elem*&_Mid1, _Byte*_First2, _Byte*, _Byte*&_Mid2)const
		{
			_Mid1=_First1, _Mid2=_First2;
			return (noconv);
		}
		virtual result do_unshift(_Statype&, _Byte*_First2, _Byte*, _Byte*&_Mid2)const
		{
			_Mid2=_First2;
			return (noconv);
		}
		virtual int do_length(const _Statype&, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			return ((int)(_Count<(size_t)(_Last1-_First1)?_Count: _Last1-_First1));
		}
	};
	template<class _Elem, class _Byte, class _Statype>
	locale::id codecvt<_Elem, _Byte, _Statype>::id;
	template<>
	class codecvt<wchar_t, char, _Mbstatet>: public codecvt_base
	{
	public:
		typedef wchar_t _Elem;
		typedef char _Byte;
		typedef _Mbstatet _Statype;
		typedef _Elem intern_type;
		typedef _Byte extern_type;
		typedef _Statype state_type;
		result in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			return (do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_unshift(_State, _First2, _Last2, _Mid2));
		}
		int length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			return (do_length(_State, _First1, _Last1, _Count));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit codecvt(size_t _Refs=0): codecvt_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		codecvt(const _Locinfo&_Lobj, size_t _Refs=0): codecvt_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 880)codecvt<_Elem, _Byte, _Statype>;
			return (2);
		}
		protected: virtual~codecvt()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		virtual result do_in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 899);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 900);
			_Mid1=_First1, _Mid2=_First2;
			result _Ans=_Mid1==_Last1?ok: partial;
			int _Bytes;
			while(_Mid1!=_Last1&&_Mid2!=_Last2)switch(_Bytes=_Mbrtowc(_Mid2, _Mid1, _Last1-_Mid1, &_State, &_Cvt))
			{
				case-2: _Mid1=_Last1;
				return (_Ans);
				case-1: return (error);
				case 0: if(*_Mid2==(_Elem)0)_Bytes=(int)::strlen(_Mid1)+1;
				default: if(_Bytes==-3)_Bytes=0;
				_Mid1+=_Bytes;
				++_Mid2;
				_Ans=ok;
			}
			return (_Ans);
		}
		virtual result do_out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 935);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 936);
			_Mid1=_First1, _Mid2=_First2;
			result _Ans=_Mid1==_Last1?ok: partial;
			int _Bytes;
			while(_Mid1!=_Last1&&_Mid2!=_Last2)if(5<=_Last2-_Mid2)if((_Bytes=_Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt))<0)return (error);
			else++_Mid1, _Mid2+=_Bytes, _Ans=ok;
			else
			{
				_Byte _Buf[5];
				_Statype _Stsave=_State;
				if((_Bytes=_Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt))<0)return (error);
				else if(_Last2-_Mid2<_Bytes)
				{
					_State=_Stsave;
					return (_Ans);
				}
				else
				{
					::memcpy_s((_Mid2), (_Last2-_Mid2), (_Buf), (_Bytes));
					++_Mid1, _Mid2+=_Bytes, _Ans=ok;
				}
			}
			return (_Ans);
		}
		virtual result do_unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 973);
			_Mid2=_First2;
			result _Ans=ok;
			int _Bytes;
			_Byte _Buf[5];
			_Statype _Stsave=_State;
			if((_Bytes=_Wcrtomb(_Buf, L'\0', &_State, &_Cvt))<=0)_Ans=error;
			else if(_Last2-_Mid2<--_Bytes)
			{
				_State=_Stsave;
				_Ans=partial;
			}
			else if(0<_Bytes)
			{
				::memcpy_s((_Mid2), (_Last2-_Mid2), (_Buf), (_Bytes));
				_Mid2+=_Bytes;
			}
			return (_Ans);
		}
		virtual int do_length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 998);
			int _Wchars;
			const _Byte*_Mid1;
			_Statype _Mystate=_State;
			for(_Wchars=0, _Mid1=_First1;
			(size_t)_Wchars<_Count&&_Mid1!=_Last1;
			)
			{
				int _Bytes;
				_Elem _Ch;
				switch(_Bytes=_Mbrtowc(&_Ch, _Mid1, _Last1-_Mid1, &_Mystate, &_Cvt))
				{
					case-2: return (_Wchars);
					case-1: return (_Wchars);
					case 0: if(_Ch==(_Elem)0)_Bytes=(int)::strlen(_Mid1)+1;
					default: if(_Bytes==-3)_Bytes=0;
					_Mid1+=_Bytes;
					++_Wchars;
				}
			}
			return (_Wchars);
		}
		virtual bool do_always_noconv()const throw()
		{
			return (false);
		}
		virtual int do_max_length()const throw()
		{
			return (5);
		}
		virtual int do_encoding()const throw()
		{
			return (0);
		}
	private:
		_Locinfo::_Cvtvec _Cvt;
	};
	template<>
	class codecvt<unsigned short, char, _Mbstatet>: public codecvt_base
	{
	public:
		typedef unsigned short _Elem;
		typedef char _Byte;
		typedef _Mbstatet _Statype;
		typedef _Elem intern_type;
		typedef _Byte extern_type;
		typedef _Statype state_type;
		result in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			return (do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}
		result unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			return (do_unshift(_State, _First2, _Last2, _Mid2));
		}
		int length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			return (do_length(_State, _First1, _Last1, _Count));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit codecvt(size_t _Refs=0): codecvt_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		codecvt(const _Locinfo&_Lobj, size_t _Refs=0): codecvt_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1118)codecvt<_Elem, _Byte, _Statype>;
			return (2);
		}
		protected: virtual~codecvt()
		{
		}
		protected: codecvt(const char*_Locname, size_t _Refs=0): codecvt_base(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		virtual result do_in(_Statype&_State, const _Byte*_First1, const _Byte*_Last1, const _Byte*&_Mid1, _Elem*_First2, _Elem*_Last2, _Elem*&_Mid2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1145);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1146);
			_Mid1=_First1, _Mid2=_First2;
			result _Ans=_Mid1==_Last1?ok: partial;
			int _Bytes;
			while(_Mid1!=_Last1&&_Mid2!=_Last2)switch(_Bytes=_Mbrtowc((wchar_t*)_Mid2, _Mid1, _Last1-_Mid1, &_State, &_Cvt))
			{
				case-2: _Mid1=_Last1;
				return (_Ans);
				case-1: return (error);
				case 0: if(*_Mid2==(_Elem)0)_Bytes=(int)::strlen(_Mid1)+1;
				default: if(_Bytes==-3)_Bytes=0;
				_Mid1+=_Bytes;
				++_Mid2;
				_Ans=ok;
			}
			return (_Ans);
		}
		virtual result do_out(_Statype&_State, const _Elem*_First1, const _Elem*_Last1, const _Elem*&_Mid1, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1181);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1182);
			_Mid1=_First1, _Mid2=_First2;
			result _Ans=_Mid1==_Last1?ok: partial;
			int _Bytes;
			while(_Mid1!=_Last1&&_Mid2!=_Last2)if(5<=_Last2-_Mid2)if((_Bytes=_Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt))<0)return (error);
			else++_Mid1, _Mid2+=_Bytes, _Ans=ok;
			else
			{
				_Byte _Buf[5];
				_Statype _Stsave=_State;
				if((_Bytes=_Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt))<0)return (error);
				else if(_Last2-_Mid2<_Bytes)
				{
					_State=_Stsave;
					return (_Ans);
				}
				else
				{
					::memcpy_s((_Mid2), (_Last2-_Mid2), (_Buf), (_Bytes));
					++_Mid1, _Mid2+=_Bytes, _Ans=ok;
				}
			}
			return (_Ans);
		}
		virtual result do_unshift(_Statype&_State, _Byte*_First2, _Byte*_Last2, _Byte*&_Mid2)const
		{
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1219);
			_Mid2=_First2;
			result _Ans=ok;
			int _Bytes;
			_Byte _Buf[5];
			_Statype _Stsave=_State;
			if((_Bytes=_Wcrtomb(_Buf, L'\0', &_State, &_Cvt))<=0)_Ans=error;
			else if(_Last2-_Mid2<--_Bytes)
			{
				_State=_Stsave;
				_Ans=partial;
			}
			else if(0<_Bytes)
			{
				::memcpy_s((_Mid2), (_Last2-_Mid2), (_Buf), (_Bytes));
				_Mid2+=_Bytes;
			}
			return (_Ans);
		}
		virtual int do_length(const _Statype&_State, const _Byte*_First1, const _Byte*_Last1, size_t _Count)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1244);
			int _Wchars;
			const _Byte*_Mid1;
			_Statype _Mystate=_State;
			for(_Wchars=0, _Mid1=_First1;
			(size_t)_Wchars<_Count&&_Mid1!=_Last1;
			)
			{
				int _Bytes;
				_Elem _Ch;
				switch(_Bytes=_Mbrtowc((wchar_t*)&_Ch, _Mid1, _Last1-_Mid1, &_Mystate, &_Cvt))
				{
					case-2: return (_Wchars);
					case-1: return (_Wchars);
					case 0: if(_Ch==(_Elem)0)_Bytes=(int)::strlen(_Mid1)+1;
					default: if(_Bytes==-3)_Bytes=0;
					_Mid1+=_Bytes;
					++_Wchars;
				}
			}
			return (_Wchars);
		}
		virtual bool do_always_noconv()const throw()
		{
			return (false);
		}
		virtual int do_max_length()const throw()
		{
			return (5);
		}
		virtual int do_encoding()const throw()
		{
			return (0);
		}
	private:
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem, class _Byte, class _Statype>
	class codecvt_byname: public codecvt<_Elem, _Byte, _Statype>
	{
	public:
		explicit codecvt_byname(const char*_Locname, size_t _Refs=0): codecvt<_Elem, _Byte, _Statype>(_Locname, _Refs)
		{
		}
		protected: virtual~codecvt_byname()
		{
		}
	};
	struct ctype_base: public locale::facet
	{
		enum
		{
			alnum=0x4|0x2|0x1|0x100, alpha=0x2|0x1|0x100, cntrl=0x20, digit=0x4, graph=0x4|0x2|0x10|0x1|0x100, lower=0x2, print=0x4|0x2|0x10|0x40|0x1|0x100|0x80, punct=0x10, space=0x8|0x40|0x000, upper=0x1, xdigit=0x80
		};
		typedef short mask;
		ctype_base(size_t _Refs=0): locale::facet(_Refs)
		{
		}
		~ctype_base()
		{
		}
		protected: static void _Xran()
		{
			throw out_of_range("out_of_range in ctype<T>");
		}
	};
	template<class _Elem>
	class ctype: public ctype_base
	{
	public:
		typedef _Elem char_type;
		bool is(mask _Maskval, _Elem _Ch)const
		{
			return (do_is(_Maskval, _Ch));
		}
		const _Elem*is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			return (do_is(_First, _Last, _Dest));
		}
		const _Elem*scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_is(_Maskval, _First, _Last));
		}
		const _Elem*scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_not(_Maskval, _First, _Last));
		}
		_Elem tolower(_Elem _Ch)const
		{
			return (do_tolower(_Ch));
		}
		const _Elem*tolower(_Elem*_First, const _Elem*_Last)const
		{
			return (do_tolower(_First, _Last));
		}
		_Elem toupper(_Elem _Ch)const
		{
			return (do_toupper(_Ch));
		}
		const _Elem*toupper(_Elem*_First, const _Elem*_Last)const
		{
			return (do_toupper(_First, _Last));
		}
		_Elem widen(char _Byte)const
		{
			return (do_widen(_Byte));
		}
		const char*widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return (do_widen(_First, _Last, _Dest));
		}
		const char*_Widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}
		char narrow(_Elem _Ch, char _Dflt='\0')const
		{
			return (do_narrow(_Ch, _Dflt));
		}
		const _Elem*narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return (do_narrow(_First, _Last, _Dflt, _Dest));
		}
		const _Elem*_Narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}
		static locale::id id;
		explicit ctype(size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		ctype(const _Locinfo&_Lobj, size_t _Refs=0): ctype_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1460)ctype<_Elem>;
			return (2);
		}
		protected: virtual~ctype()
		{
			if(_Ctype._Delfl)free((void*)_Ctype._Table);
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Ctype=_Lobj._Getctype();
		}
		virtual bool do_is(mask _Maskval, _Elem _Ch)const
		{
			return ((_Ctype._Table[(unsigned char)narrow(_Ch)]&_Maskval)!=0);
		}
		virtual const _Elem*do_is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1486);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1487);
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Ctype._Table[(unsigned char)narrow(*_First)];
			return (_First);
		}
		virtual const _Elem*do_scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1496);
			for(;
			_First!=_Last&&!is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual const _Elem*do_scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1505);
			for(;
			_First!=_Last&&is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual _Elem do_tolower(_Elem _Ch)const
		{
			unsigned char _Byte=(unsigned char)narrow(_Ch, '\0');
			if(_Byte=='\0')return (_Ch);
			else return (widen((char)_Tolower(_Byte, &_Ctype)));
		}
		virtual const _Elem*do_tolower(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1522);
			for(;
			_First!=_Last;
			++_First)
			{
				unsigned char _Byte=(unsigned char)narrow(*_First, '\0');
				if(_Byte!='\0')*_First=(widen((char)_Tolower(_Byte, &_Ctype)));
			}
			return ((const _Elem*)_First);
		}
		virtual _Elem do_toupper(_Elem _Ch)const
		{
			unsigned char _Byte=(unsigned char)narrow(_Ch, '\0');
			if(_Byte=='\0')return (_Ch);
			else return (widen((char)_Toupper(_Byte, &_Ctype)));
		}
		virtual const _Elem*do_toupper(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1543);
			for(;
			_First!=_Last;
			++_First)
			{
				unsigned char _Byte=(unsigned char)narrow(*_First, '\0');
				if(_Byte!='\0')*_First=(widen((char)_Toupper(_Byte, &_Ctype)));
			}
			return ((const _Elem*)_First);
		}
		virtual _Elem do_widen(char _Byte)const
		{
			return (_Maklocchr(_Byte, (_Elem*)0, _Cvt));
		}
		virtual const char*do_widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return _Do_widen_s(_First, _Last, _Dest, _Last-_First);
		}
		virtual const char*_Do_widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1569);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1570);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1571, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1571, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Maklocchr(*_First, (_Elem*)0, _Cvt);
			return (_First);
		}
		char _Donarrow(_Elem _Ch, char _Dflt)const
		{
			char _Byte;
			if(_Ch==(_Elem)0)return ('\0');
			else if((_Byte=_Maklocbyte((_Elem)_Ch, _Cvt))=='\0')return (_Dflt);
			else return (_Byte);
		}
		virtual char do_narrow(_Elem _Ch, char _Dflt)const
		{
			return (_Donarrow(_Ch, _Dflt));
		}
		virtual const _Elem*do_narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1606);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1607);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1608, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1608, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Donarrow(*_First, _Dflt);
			return (_First);
		}
	private:
		_Locinfo::_Ctypevec _Ctype;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem>
	locale::id ctype<_Elem>::id;
	template<>
	class ctype<char>: public ctype_base
	{
		typedef ctype<char>_Myt;
	public:
		typedef char _Elem;
		typedef _Elem char_type;
		bool is(mask _Maskval, _Elem _Ch)const
		{
			return ((_Ctype._Table[(unsigned char)_Ch]&_Maskval)!=0);
		}
		const _Elem*is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1641);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1642);
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Ctype._Table[(unsigned char)*_First];
			return (_First);
		}
		const _Elem*scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1651);
			for(;
			_First!=_Last&&!is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		const _Elem*scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1660);
			for(;
			_First!=_Last&&is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		_Elem tolower(_Elem _Ch)const
		{
			return (do_tolower(_Ch));
		}
		const _Elem*tolower(_Elem*_First, const _Elem*_Last)const
		{
			return (do_tolower(_First, _Last));
		}
		_Elem toupper(_Elem _Ch)const
		{
			return (do_toupper(_Ch));
		}
		const _Elem*toupper(_Elem*_First, const _Elem*_Last)const
		{
			return (do_toupper(_First, _Last));
		}
		_Elem widen(char _Byte)const
		{
			return (do_widen(_Byte));
		}
		const _Elem*widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return (do_widen(_First, _Last, _Dest));
		}
		const _Elem*_Widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}
		_Elem narrow(_Elem _Ch, char _Dflt='\0')const
		{
			return (do_narrow(_Ch, _Dflt));
		}
		const _Elem*narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return (do_narrow(_First, _Last, _Dflt, _Dest));
		}
		const _Elem*_Narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit ctype(const mask*_Table=0, bool _Deletetable=false, size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
			if(_Table!=0)
			{
				_Tidy();
				_Ctype._Table=_Table;
				_Ctype._Delfl=_Deletetable?-1: 0;
			}
		}
		ctype(const _Locinfo&_Lobj, size_t _Refs=0): ctype_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1763)ctype<_Elem>;
			return (2);
		}
		static const size_t table_size=1<<8;
		protected: virtual~ctype()
		{
			_Tidy();
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Ctype=_Lobj._Getctype();
		}
		void _Tidy()
		{
			if(0<_Ctype._Delfl)free((void*)_Ctype._Table);
			else if(_Ctype._Delfl<0)delete[](void*)_Ctype._Table;
		}
		virtual _Elem do_tolower(_Elem _Ch)const
		{
			return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}
		virtual const _Elem*do_tolower(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1797);
			for(;
			_First!=_Last;
			++_First)*_First=(_Elem)_Tolower((unsigned char)*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		virtual _Elem do_toupper(_Elem _Ch)const
		{
			return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}
		virtual const _Elem*do_toupper(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1811);
			for(;
			_First!=_Last;
			++_First)*_First=(_Elem)_Toupper((unsigned char)*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		virtual _Elem do_widen(char _Byte)const
		{
			return (_Byte);
		}
		virtual const _Elem*do_widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return _Do_widen_s(_First, _Last, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1833);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1834);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1835, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1835, 0);
				}
			};
			::memcpy_s((_Dest), (_Dest_size), (_First), (_Last-_First));
			return (_Last);
		}
		virtual _Elem do_narrow(_Elem _Ch, char)const
		{
			return (_Ch);
		}
		virtual const _Elem*do_narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_narrow_s(const _Elem*_First, const _Elem*_Last, char, char*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1858);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1859);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1860, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 1860, 0);
				}
			};
			::memcpy_s((_Dest), (_Dest_size), (_First), (_Last-_First));
			return (_Last);
		}
		const mask*table()const throw()
		{
			return (_Ctype._Table);
		}
		static const mask*classic_table()throw()
		{
			const _Myt&_Ctype_fac=use_facet<_Myt>(locale::classic());
			return (_Ctype_fac.table());
		}
	private:
		_Locinfo::_Ctypevec _Ctype;
	};
	template<>
	class ctype<wchar_t>: public ctype_base
	{
		typedef ctype<wchar_t>_Myt;
	public:
		typedef wchar_t _Elem;
		typedef _Elem char_type;
		bool is(mask _Maskval, _Elem _Ch)const
		{
			return (do_is(_Maskval, _Ch));
		}
		const _Elem*is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			return (do_is(_First, _Last, _Dest));
		}
		const _Elem*scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_is(_Maskval, _First, _Last));
		}
		const _Elem*scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_not(_Maskval, _First, _Last));
		}
		_Elem tolower(_Elem _Ch)const
		{
			return (do_tolower(_Ch));
		}
		const _Elem*tolower(_Elem*_First, const _Elem*_Last)const
		{
			return (do_tolower(_First, _Last));
		}
		_Elem toupper(_Elem _Ch)const
		{
			return (do_toupper(_Ch));
		}
		const _Elem*toupper(_Elem*_First, const _Elem*_Last)const
		{
			return (do_toupper(_First, _Last));
		}
		_Elem widen(char _Byte)const
		{
			return (do_widen(_Byte));
		}
		const char*widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return (do_widen(_First, _Last, _Dest));
		}
		const char*_Widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}
		char narrow(_Elem _Ch, char _Dflt='\0')const
		{
			return (do_narrow(_Ch, _Dflt));
		}
		const _Elem*narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return (do_narrow(_First, _Last, _Dflt, _Dest));
		}
		const _Elem*_Narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit ctype(size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		ctype(const _Locinfo&_Lobj, size_t _Refs=0): ctype_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2002)ctype<_Elem>;
			return (2);
		}
		protected: virtual~ctype()
		{
			if(_Ctype._Delfl)free((void*)_Ctype._Table);
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Ctype=_Lobj._Getctype();
			_Cvt=_Lobj._Getcvt();
		}
		virtual bool do_is(mask _Maskval, _Elem _Ch)const
		{
			return ((::_Getwctype(_Ch, &_Ctype)&_Maskval)!=0);
		}
		virtual const wchar_t*do_is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2028);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2029);
			return (::_Getwctypes(_First, _Last, _Dest, &_Ctype));
		}
		virtual const _Elem*do_scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2036);
			for(;
			_First!=_Last&&!is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual const _Elem*do_scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2045);
			for(;
			_First!=_Last&&is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual _Elem do_tolower(_Elem _Ch)const
		{
			return (_Towlower(_Ch, &_Ctype));
		}
		virtual const _Elem*do_tolower(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2059);
			for(;
			_First!=_Last;
			++_First)*_First=_Towlower(*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		virtual _Elem do_toupper(_Elem _Ch)const
		{
			return (_Towupper(_Ch, &_Ctype));
		}
		virtual const _Elem*do_toupper(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2073);
			for(;
			_First!=_Last;
			++_First)*_First=_Towupper(*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		_Elem _Dowiden(char _Byte)const
		{
			mbstate_t _Mbst=
			{
				0
			};
			wchar_t _Wc;
			return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt)<0?(wchar_t)(wint_t)(0xFFFF): _Wc);
		}
		virtual _Elem do_widen(char _Byte)const
		{
			return (_Dowiden(_Byte));
		}
		virtual const char*do_widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return _Do_widen_s(_First, _Last, _Dest, _Last-_First);
		}
		virtual const char*_Do_widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2103);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2104);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2105, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2105, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Dowiden(*_First);
			return (_First);
		}
		char _Donarrow(_Elem _Ch, char _Dflt)const
		{
			char _Buf[5];
			mbstate_t _Mbst=
			{
				0
			};
			return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt)!=1?_Dflt: _Buf[0]);
		}
		virtual char do_narrow(_Elem _Ch, char _Dflt)const
		{
			return (_Donarrow(_Ch, _Dflt));
		}
		virtual const _Elem*do_narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2138);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2139);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2140, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2140, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Donarrow(*_First, _Dflt);
			return (_First);
		}
	private:
		_Locinfo::_Ctypevec _Ctype;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<>
	class ctype<unsigned short>: public ctype_base
	{
		typedef ctype<unsigned short>_Myt;
	public:
		typedef unsigned short _Elem;
		typedef _Elem char_type;
		bool is(mask _Maskval, _Elem _Ch)const
		{
			return (do_is(_Maskval, _Ch));
		}
		const _Elem*is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			return (do_is(_First, _Last, _Dest));
		}
		const _Elem*scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_is(_Maskval, _First, _Last));
		}
		const _Elem*scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			return (do_scan_not(_Maskval, _First, _Last));
		}
		_Elem tolower(_Elem _Ch)const
		{
			return (do_tolower(_Ch));
		}
		const _Elem*tolower(_Elem*_First, const _Elem*_Last)const
		{
			return (do_tolower(_First, _Last));
		}
		_Elem toupper(_Elem _Ch)const
		{
			return (do_toupper(_Ch));
		}
		const _Elem*toupper(_Elem*_First, const _Elem*_Last)const
		{
			return (do_toupper(_First, _Last));
		}
		_Elem widen(char _Byte)const
		{
			return (do_widen(_Byte));
		}
		const char*widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return (do_widen(_First, _Last, _Dest));
		}
		const char*_Widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}
		char narrow(_Elem _Ch, char _Dflt='\0')const
		{
			return (do_narrow(_Ch, _Dflt));
		}
		const _Elem*narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return (do_narrow(_First, _Last, _Dflt, _Dest));
		}
		const _Elem*_Narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}
		static locale::id&_Id_func();
		static locale::id id;
		explicit ctype(size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		ctype(const _Locinfo&_Lobj, size_t _Refs=0): ctype_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2274)ctype<_Elem>;
			return (2);
		}
		protected: virtual~ctype()
		{
			if(_Ctype._Delfl)free((void*)_Ctype._Table);
		}
		protected: ctype(const char*_Locname, size_t _Refs=0): ctype_base(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			_Ctype=_Lobj._Getctype();
			_Cvt=_Lobj._Getcvt();
		}
		virtual bool do_is(mask _Maskval, _Elem _Ch)const
		{
			return ((::_Getwctype(_Ch, &_Ctype)&_Maskval)!=0);
		}
		virtual const _Elem*do_is(const _Elem*_First, const _Elem*_Last, mask*_Dest)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2308);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2309);
			return ((const _Elem*)::_Getwctypes((const wchar_t*)_First, (const wchar_t*)_Last, _Dest, &_Ctype));
		}
		virtual const _Elem*do_scan_is(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2317);
			for(;
			_First!=_Last&&!is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual const _Elem*do_scan_not(mask _Maskval, const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2326);
			for(;
			_First!=_Last&&is(_Maskval, *_First);
			++_First);
			return (_First);
		}
		virtual _Elem do_tolower(_Elem _Ch)const
		{
			return (_Towlower(_Ch, &_Ctype));
		}
		virtual const _Elem*do_tolower(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2340);
			for(;
			_First!=_Last;
			++_First)*_First=_Towlower(*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		virtual _Elem do_toupper(_Elem _Ch)const
		{
			return (_Towupper(_Ch, &_Ctype));
		}
		virtual const _Elem*do_toupper(_Elem*_First, const _Elem*_Last)const
		{
			_Debug_range((const _Elem*)_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2354);
			for(;
			_First!=_Last;
			++_First)*_First=_Towupper(*_First, &_Ctype);
			return ((const _Elem*)_First);
		}
		_Elem _Dowiden(char _Byte)const
		{
			mbstate_t _Mbst=
			{
				0
			};
			unsigned short _Wc;
			return (_Mbrtowc((wchar_t*)&_Wc, &_Byte, 1, &_Mbst, &_Cvt)<0?(unsigned short)(wint_t)(0xFFFF): _Wc);
		}
		virtual _Elem do_widen(char _Byte)const
		{
			return (_Dowiden(_Byte));
		}
		virtual const char*do_widen(const char*_First, const char*_Last, _Elem*_Dest)const
		{
			return _Do_widen_s(_First, _Last, _Dest, _Last-_First);
		}
		virtual const char*_Do_widen_s(const char*_First, const char*_Last, _Elem*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2384);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2385);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2386, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2386, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Dowiden(*_First);
			return (_First);
		}
		char _Donarrow(_Elem _Ch, char _Dflt)const
		{
			char _Buf[5];
			mbstate_t _Mbst=
			{
				0
			};
			return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt)!=1?_Dflt: _Buf[0]);
		}
		virtual char do_narrow(_Elem _Ch, char _Dflt)const
		{
			return (_Donarrow(_Ch, _Dflt));
		}
		virtual const _Elem*do_narrow(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest)const
		{
			return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last-_First);
		}
		virtual const _Elem*_Do_narrow_s(const _Elem*_First, const _Elem*_Last, char _Dflt, char*_Dest, size_t _Dest_size)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2418);
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2419);

			{
				if(!(_Dest_size>=(size_t)(_Last-_First)))
				{
					(void)((!!((("_Dest_size >= (size_t)(_Last - _First)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2420, 0, L"(\"_Dest_size >= (size_t)(_Last - _First)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocale", 2420, 0);
				}
			};
			for(;
			_First!=_Last;
			++_First, ++_Dest)*_Dest=_Donarrow(*_First, _Dflt);
			return (_First);
		}
	private:
		_Locinfo::_Ctypevec _Ctype;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem>
	class ctype_byname: public ctype<_Elem>
	{
	public:
		explicit ctype_byname(const char*_Locname, size_t _Refs=0): ctype<_Elem>(_Locname, _Refs)
		{
		}
		protected: virtual~ctype_byname()
		{
		}
	};
	template<>
	class ctype_byname<char>: public ctype<char>
	{
	public:
		explicit ctype_byname(const char*_Locname, size_t _Refs=0): ctype<char>(_Locname, _Refs)
		{
		}
		protected: virtual~ctype_byname()
		{
		}
	};
}
namespace std
{
	template<class _Dummy>
	class _Iosb
	{
	public:
		enum _Dummy_enum
		{
			_Dummy_enum_val=1
		};
		enum _Fmtflags
		{
			_Fmtmask=0xffff, _Fmtzero=0
		};
		static const _Fmtflags skipws=(_Fmtflags)0x0001;
		static const _Fmtflags unitbuf=(_Fmtflags)0x0002;
		static const _Fmtflags uppercase=(_Fmtflags)0x0004;
		static const _Fmtflags showbase=(_Fmtflags)0x0008;
		static const _Fmtflags showpoint=(_Fmtflags)0x0010;
		static const _Fmtflags showpos=(_Fmtflags)0x0020;
		static const _Fmtflags left=(_Fmtflags)0x0040;
		static const _Fmtflags right=(_Fmtflags)0x0080;
		static const _Fmtflags internal=(_Fmtflags)0x0100;
		static const _Fmtflags dec=(_Fmtflags)0x0200;
		static const _Fmtflags oct=(_Fmtflags)0x0400;
		static const _Fmtflags hex=(_Fmtflags)0x0800;
		static const _Fmtflags scientific=(_Fmtflags)0x1000;
		static const _Fmtflags fixed=(_Fmtflags)0x2000;
		static const _Fmtflags boolalpha=(_Fmtflags)0x4000;
		static const _Fmtflags _Stdio=(_Fmtflags)0x8000;
		static const _Fmtflags adjustfield=(_Fmtflags)(0x0040|0x0080|0x0100);
		static const _Fmtflags basefield=(_Fmtflags)(0x0200|0x0400|0x0800);
		static const _Fmtflags floatfield=(_Fmtflags)(0x1000|0x2000);
		enum _Iostate
		{
			_Statmask=0x17
		};
		static const _Iostate goodbit=(_Iostate)0x0;
		static const _Iostate eofbit=(_Iostate)0x1;
		static const _Iostate failbit=(_Iostate)0x2;
		static const _Iostate badbit=(_Iostate)0x4;
		static const _Iostate _Hardfail=(_Iostate)0x10;
		enum _Openmode
		{
			_Openmask=0xff
		};
		static const _Openmode in=(_Openmode)0x01;
		static const _Openmode out=(_Openmode)0x02;
		static const _Openmode ate=(_Openmode)0x04;
		static const _Openmode app=(_Openmode)0x08;
		static const _Openmode trunc=(_Openmode)0x10;
		static const _Openmode _Nocreate=(_Openmode)0x40;
		static const _Openmode _Noreplace=(_Openmode)0x80;
		static const _Openmode binary=(_Openmode)0x20;
		enum _Seekdir
		{
			_Seekmask=0x3
		};
		static const _Seekdir beg=(_Seekdir)0;
		static const _Seekdir cur=(_Seekdir)1;
		static const _Seekdir end=(_Seekdir)2;
		enum
		{
			_Openprot=0x40
		};
	};
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::_Hardfail;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
	template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;
	class ios_base: public _Iosb<int>
	{
	public:
		typedef int fmtflags;
		typedef int iostate;
		typedef int openmode;
		typedef int seekdir;
		typedef std::streamoff streamoff;
		typedef std::streampos streampos;
		enum event
		{
			erase_event, imbue_event, copyfmt_event
		};
		typedef void(*event_callback)(event, ios_base&, int);
		typedef unsigned int io_state, open_mode, seek_dir;
		class failure: public runtime_error
		{
		public:
			explicit failure(const string&_Message): runtime_error(_Message)
			{
			}
			virtual~failure()throw()
			{
			}
		};
		class Init
		{
		public:
			Init()
			{
				_Init_ctor(this);
			}
			~Init()
			{
				_Init_dtor(this);
			}
		private:
			static void _Init_ctor(Init*);
			static void _Init_dtor(Init*);
			static int&_Init_cnt_func();
			static int _Init_cnt;
		};
		ios_base&operator=(const ios_base&_Right)
		{
			if(this!=&_Right)
			{
				_Mystate=_Right._Mystate;
				copyfmt(_Right);
			}
			return (*this);
		}
		operator void*()const
		{
			return (fail()?0: (void*)this);
		}
		bool operator!()const
		{
			return (fail());
		}
		void clear(iostate _State, bool _Reraise)
		{
			_Mystate=(iostate)(_State&_Statmask);
			if((_Mystate&_Except)==0);
			else if(_Reraise)throw;
			else if(_Mystate&_Except&badbit)throw failure("ios_base::badbit set");
			else if(_Mystate&_Except&failbit)throw failure("ios_base::failbit set");
			else throw failure("ios_base::eofbit set");
		}
		void clear(iostate _State=goodbit)
		{
			clear(_State, false);
		}
		void clear(io_state _State)
		{
			clear((iostate)_State);
		}
		iostate rdstate()const
		{
			return (_Mystate);
		}
		void setstate(iostate _State, bool _Exreraise)
		{
			if(_State!=goodbit)clear((iostate)((int)rdstate()|(int)_State), _Exreraise);
		}
		void setstate(iostate _State)
		{
			if(_State!=goodbit)clear((iostate)((int)rdstate()|(int)_State), false);
		}
		void setstate(io_state _State)
		{
			setstate((iostate)_State);
		}
		bool good()const
		{
			return (rdstate()==goodbit);
		}
		bool eof()const
		{
			return ((int)rdstate()&(int)eofbit);
		}
		bool fail()const
		{
			return (((int)rdstate()&((int)badbit|(int)failbit))!=0);
		}
		bool bad()const
		{
			return (((int)rdstate()&(int)badbit)!=0);
		}
		iostate exceptions()const
		{
			return (_Except);
		}
		void exceptions(iostate _Newexcept)
		{
			_Except=(iostate)((int)_Newexcept&(int)_Statmask);
			clear(_Mystate);
		}
		void exceptions(io_state _State)
		{
			exceptions((iostate)_State);
		}
		fmtflags flags()const
		{
			return (_Fmtfl);
		}
		fmtflags flags(fmtflags _Newfmtflags)
		{
			fmtflags _Oldfmtflags=_Fmtfl;
			_Fmtfl=(fmtflags)((int)_Newfmtflags&(int)_Fmtmask);
			return (_Oldfmtflags);
		}
		fmtflags setf(fmtflags _Newfmtflags)
		{
			ios_base::fmtflags _Oldfmtflags=_Fmtfl;
			_Fmtfl=(fmtflags)((int)_Fmtfl|(int)_Newfmtflags&(int)_Fmtmask);
			return (_Oldfmtflags);
		}
		fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{
			ios_base::fmtflags _Oldfmtflags=_Fmtfl;
			_Fmtfl=(fmtflags)(((int)_Fmtfl&(int)~_Mask)|((int)_Newfmtflags&(int)_Mask&(int)_Fmtmask));
			return (_Oldfmtflags);
		}
		void unsetf(fmtflags _Mask)
		{
			_Fmtfl=(fmtflags)((int)_Fmtfl&(int)~_Mask);
		}
		streamsize precision()const
		{
			return (_Prec);
		}
		streamsize precision(streamsize _Newprecision)
		{
			streamsize _Oldprecision=_Prec;
			_Prec=_Newprecision;
			return (_Oldprecision);
		}
		streamsize width()const
		{
			return (_Wide);
		}
		streamsize width(streamsize _Newwidth)
		{
			streamsize _Oldwidth=_Wide;
			_Wide=_Newwidth;
			return (_Oldwidth);
		}
		locale getloc()const
		{
			return (*_Ploc);
		}
		locale imbue(const locale&_Loc)
		{
			locale _Oldlocale=*_Ploc;
			*_Ploc=_Loc;
			_Callfns(imbue_event);
			return (_Oldlocale);
		}
		static int xalloc()
		{

			{
				::std::_Lockit _Lock(2);
				return (_Index++);
			}
		}
		long&iword(int _Idx)
		{
			return (_Findarr(_Idx)._Lo);
		}
		void*&pword(int _Idx)
		{
			return (_Findarr(_Idx)._Vp);
		}
		void register_callback(event_callback _Pfn, int _Idx)
		{
			_Calls=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xiosbase", 449)_Fnarray(_Idx, _Pfn, _Calls);
		}
		ios_base&copyfmt(const ios_base&_Other)
		{
			if(this!=&_Other)
			{
				_Tidy();
				*_Ploc=*_Other._Ploc;
				_Fmtfl=_Other._Fmtfl;
				_Prec=_Other._Prec;
				_Wide=_Other._Wide;
				_Iosarray*_Ptr=_Other._Arr;
				for(_Arr=0;
				_Ptr!=0;
				_Ptr=_Ptr->_Next)if(_Ptr->_Lo!=0||_Ptr->_Vp!=0)
				{
					iword(_Ptr->_Index)=_Ptr->_Lo;
					pword(_Ptr->_Index)=_Ptr->_Vp;
				}
				for(_Fnarray*_Q=_Other._Calls;
				_Q!=0;
				_Q=_Q->_Next)register_callback(_Q->_Pfn, _Q->_Index);
				_Callfns(copyfmt_event);
				exceptions(_Other._Except);
			}
			return (*this);
		}
		virtual~ios_base()
		{
			_Ios_base_dtor(this);
		}
		static bool sync_with_stdio(bool _Newsync=true)
		{

			{
				::std::_Lockit _Lock(2);
				const bool _Oldsync=_Sync;
				_Sync=_Newsync;
				return (_Oldsync);
			}
		}
		static void _Addstd(ios_base*);
		size_t _Stdstr;
		protected: ios_base()
		{
		}
		void _Init()
		{
			_Ploc=0;
			_Except=goodbit;
			_Fmtfl=skipws|dec;
			_Prec=6;
			_Wide=0;
			_Arr=0;
			_Calls=0;
			clear(goodbit);
			_Ploc=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xiosbase", 512)locale;
		}
	private:
		struct _Iosarray
		{
		public:
			_Iosarray(int _Idx, _Iosarray*_Link): _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{
			}
			_Iosarray*_Next;
			int _Index;
			long _Lo;
			void*_Vp;
		};
		struct _Fnarray
		{
			_Fnarray(int _Idx, event_callback _Pnew, _Fnarray*_Link): _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{
			}
			_Fnarray*_Next;
			int _Index;
			event_callback _Pfn;
		};
		void _Callfns(event _Ev)
		{
			for(_Fnarray*_Ptr=_Calls;
			_Ptr!=0;
			_Ptr=_Ptr->_Next)(*_Ptr->_Pfn)(_Ev, *this, _Ptr->_Index);
		}
		_Iosarray&_Findarr(int _Idx)
		{
			_Iosarray*_Ptr, *_Q;
			for(_Ptr=_Arr, _Q=0;
			_Ptr!=0;
			_Ptr=_Ptr->_Next)if(_Ptr->_Index==_Idx)return (*_Ptr);
			else if(_Q==0&&_Ptr->_Lo==0&&_Ptr->_Vp==0)_Q=_Ptr;
			if(_Q!=0)
			{
				_Q->_Index=_Idx;
				return (*_Q);
			}
			_Arr=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xiosbase", 566)_Iosarray(_Idx, _Arr);
			return (*_Arr);
		}
		void _Tidy()
		{
			_Callfns(erase_event);
			_Iosarray*_Q1, *_Q2;
			for(_Q1=_Arr;
			_Q1!=0;
			_Q1=_Q2)_Q2=_Q1->_Next, std::_DebugHeapDelete(_Q1);
			_Arr=0;
			_Fnarray*_Q3, *_Q4;
			for(_Q3=_Calls;
			_Q3!=0;
			_Q3=_Q4)_Q4=_Q3->_Next, std::_DebugHeapDelete(_Q3);
			_Calls=0;
		}
		static void _Ios_base_dtor(ios_base*);
		iostate _Mystate;
		iostate _Except;
		fmtflags _Fmtfl;
		streamsize _Prec;
		streamsize _Wide;
		_Iosarray*_Arr;
		_Fnarray*_Calls;
		locale*_Ploc;
		static int _Index;
		static bool _Sync;
		static int&_Index_func();
		static bool&_Sync_func();
	};
}
namespace std
{
	template<class _Elem, class _Traits>
	class basic_streambuf
	{
		basic_streambuf(const basic_streambuf<_Elem, _Traits>&);
		basic_streambuf<_Elem, _Traits>&operator=(const basic_streambuf<_Elem, _Traits>&);
		protected: basic_streambuf(): _Plocale(new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\streambuf", 28)(locale))
		{
			_Init();
		}
		basic_streambuf(_Uninitialized)
		{
		}
	public:
		typedef basic_streambuf<_Elem, _Traits>_Myt;
		typedef _Elem char_type;
		typedef _Traits traits_type;
		virtual~basic_streambuf()
		{
			std::_DebugHeapDelete(_Plocale);
		}
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		pos_type pubseekoff(off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode=ios_base::in|ios_base::out)
		{
			return (seekoff(_Off, _Way, _Mode));
		}
		pos_type pubseekoff(off_type _Off, ios_base::seek_dir _Way, ios_base::open_mode _Mode)
		{
			return (pubseekoff(_Off, (ios_base::seekdir)_Way, (ios_base::openmode)_Mode));
		}
		pos_type pubseekpos(pos_type _Pos, ios_base::openmode _Mode=ios_base::in|ios_base::out)
		{
			return (seekpos(_Pos, _Mode));
		}
		pos_type pubseekpos(pos_type _Pos, ios_base::open_mode _Mode)
		{
			return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}
		_Myt*pubsetbuf(_Elem*_Buffer, streamsize _Count)
		{
			return (setbuf(_Buffer, _Count));
		}
		locale pubimbue(const locale&_Newlocale)
		{
			locale _Oldlocale=*_Plocale;
			imbue(_Newlocale);
			*_Plocale=_Newlocale;
			return (_Oldlocale);
		}
		locale getloc()const
		{
			return (*_Plocale);
		}
		streamsize in_avail()
		{
			streamsize _Res=_Gnavail();
			return (0<_Res?_Res: showmanyc());
		}
		int pubsync()
		{
			return (sync());
		}
		int_type sbumpc()
		{
			return (0<_Gnavail()?_Traits::to_int_type(*_Gninc()): uflow());
		}
		int_type sgetc()
		{
			return (0<_Gnavail()?_Traits::to_int_type(*gptr()): underflow());
		}
		streamsize _Sgetn_s(_Elem*_Ptr, size_t _Ptr_size, streamsize _Count)
		{
			return _Xsgetn_s(_Ptr, _Ptr_size, _Count);
		}
		streamsize sgetn(_Elem*_Ptr, streamsize _Count)
		{
			return xsgetn(_Ptr, _Count);
		}
		int_type snextc()
		{
			return (1<_Gnavail()?_Traits::to_int_type(*_Gnpreinc()): _Traits::eq_int_type(_Traits::eof(), sbumpc())?_Traits::eof(): sgetc());
		}
		int_type sputbackc(_Elem _Ch)
		{
			return (gptr()!=0&&eback()<gptr()&&_Traits::eq(_Ch, gptr()[-1])?_Traits::to_int_type(*_Gndec()): pbackfail(_Traits::to_int_type(_Ch)));
		}
		void stossc()
		{
			if(0<_Gnavail())_Gninc();
			else uflow();
		}
		int_type sungetc()
		{
			return (gptr()!=0&&eback()<gptr()?_Traits::to_int_type(*_Gndec()): pbackfail());
		}
		int_type sputc(_Elem _Ch)
		{
			return (0<_Pnavail()?_Traits::to_int_type(*_Pninc()=_Ch): overflow(_Traits::to_int_type(_Ch)));
		}
		streamsize sputn(const _Elem*_Ptr, streamsize _Count)
		{
			return (xsputn(_Ptr, _Count));
		}
		void _Lock()
		{
			_Mylock._Lock();
		}
		void _Unlock()
		{
			_Mylock._Unlock();
		}
		protected: _Elem*eback()const
		{
			return (*_IGfirst);
		}
		_Elem*gptr()const
		{
			return (*_IGnext);
		}
		_Elem*pbase()const
		{
			return (*_IPfirst);
		}
		_Elem*pptr()const
		{
			return (*_IPnext);
		}
		_Elem*egptr()const
		{
			return (*_IGnext+*_IGcount);
		}
		void gbump(int _Off)
		{
			*_IGcount-=_Off;
			*_IGnext+=_Off;
		}
		void setg(_Elem*_First, _Elem*_Next, _Elem*_Last)
		{
			*_IGfirst=_First;
			*_IGnext=_Next;
			*_IGcount=(int)(_Last-_Next);
		}
		_Elem*epptr()const
		{
			return (*_IPnext+*_IPcount);
		}
		_Elem*_Gndec()
		{
			++*_IGcount;
			return (--*_IGnext);
		}
		_Elem*_Gninc()
		{
			--*_IGcount;
			return ((*_IGnext)++);
		}
		_Elem*_Gnpreinc()
		{
			--*_IGcount;
			return (++(*_IGnext));
		}
		streamsize _Gnavail()const
		{
			return (*_IGnext!=0?*_IGcount: 0);
		}
		void pbump(int _Off)
		{
			*_IPcount-=_Off;
			*_IPnext+=_Off;
		}
		void setp(_Elem*_First, _Elem*_Last)
		{
			*_IPfirst=_First;
			*_IPnext=_First;
			*_IPcount=(int)(_Last-_First);
		}
		void setp(_Elem*_First, _Elem*_Next, _Elem*_Last)
		{
			*_IPfirst=_First;
			*_IPnext=_Next;
			*_IPcount=(int)(_Last-_Next);
		}
		_Elem*_Pninc()
		{
			--*_IPcount;
			return ((*_IPnext)++);
		}
		streamsize _Pnavail()const
		{
			return (*_IPnext!=0?*_IPcount: 0);
		}
		void _Init()
		{
			_IGfirst=&_Gfirst, _IPfirst=&_Pfirst;
			_IGnext=&_Gnext, _IPnext=&_Pnext;
			_IGcount=&_Gcount, _IPcount=&_Pcount;
			setp(0, 0), setg(0, 0, 0);
		}
		void _Init(_Elem**_Gf, _Elem**_Gn, int*_Gc, _Elem**_Pf, _Elem**_Pn, int*_Pc)
		{
			_IGfirst=_Gf, _IPfirst=_Pf;
			_IGnext=_Gn, _IPnext=_Pn;
			_IGcount=_Gc, _IPcount=_Pc;
		}
		virtual int_type overflow(int_type=_Traits::eof())
		{
			return (_Traits::eof());
		}
		virtual int_type pbackfail(int_type=_Traits::eof())
		{
			return (_Traits::eof());
		}
		virtual streamsize showmanyc()
		{
			return (0);
		}
		virtual int_type underflow()
		{
			return (_Traits::eof());
		}
		virtual int_type uflow()
		{
			return (_Traits::eq_int_type(_Traits::eof(), underflow())?_Traits::eof(): _Traits::to_int_type(*_Gninc()));
		}
		virtual streamsize xsgetn(_Elem*_Ptr, streamsize _Count)
		{
			return _Xsgetn_s(_Ptr, (size_t)-1, _Count);
		}
		virtual streamsize _Xsgetn_s(_Elem*_Ptr, size_t _Ptr_size, streamsize _Count)
		{
			int_type _Meta;
			streamsize _Stream_size, _Size, _Copied;
			for(_Copied=0;
			0<_Count;
			)if(0<(_Stream_size=_Gnavail()))
			{
				_Size=_Stream_size;
				if(_Count<_Size)_Size=_Count;
				_Traits_helper::copy_s<_Traits>(_Ptr, _Ptr_size, gptr(), _Size);
				_Ptr+=_Size;
				_Copied+=_Size;
				_Count-=_Size;
				gbump((int)_Size);
			}
			else if(_Traits::eq_int_type(_Traits::eof(), _Meta=uflow()))break;
			else
			{
				*_Ptr++=_Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
			}
			return (_Copied);
		}
		virtual streamsize xsputn(const _Elem*_Ptr, streamsize _Count)
		{
			streamsize _Stream_size, _Size, _Copied;
			for(_Copied=0;
			0<_Count;
			)if(0<(_Stream_size=_Pnavail()))
			{
				_Size=_Stream_size;
				if(_Count<_Size)_Size=_Count;
				_Traits_helper::copy_s<_Traits>(pptr(), _Stream_size, _Ptr, _Size);
				_Ptr+=_Size;
				_Copied+=_Size;
				_Count-=_Size;
				pbump((int)_Size);
			}
			else if(_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr))))break;
			else
			{
				++_Ptr;
				++_Copied;
				--_Count;
			}
			return (_Copied);
		}
		virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode=ios_base::in|ios_base::out)
		{
			return (streampos(_BADOFF));
		}
		virtual pos_type seekpos(pos_type, ios_base::openmode=ios_base::in|ios_base::out)
		{
			return (streampos(_BADOFF));
		}
		virtual _Myt*setbuf(_Elem*, streamsize)
		{
			return (this);
		}
		virtual int sync()
		{
			return (0);
		}
		virtual void imbue(const locale&)
		{
		}
	private:
		_Mutex _Mylock;
		_Elem*_Gfirst;
		_Elem*_Pfirst;
		_Elem**_IGfirst;
		_Elem**_IPfirst;
		_Elem*_Gnext;
		_Elem*_Pnext;
		_Elem**_IGnext;
		_Elem**_IPnext;
		int _Gcount;
		int _Pcount;
		int*_IGcount;
		int*_IPcount;
		locale*_Plocale;
	};
}
extern "C"
{
	extern long _Stolx(const char*, char**, int, int*);
	extern unsigned long _Stoulx(const char*, char**, int, int*);
	extern float _Stofx(const char*, char**, long, int*);
	extern double _Stodx(const char*, char**, long, int*);
	extern long double _Stoldx(const char*, char**, long, int*);
}
namespace std
{
	template<class _Elem>
	class numpunct: public locale::facet
	{
	public:
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >string_type;
		typedef _Elem char_type;
		static locale::id id;
		_Elem decimal_point()const
		{
			return (do_decimal_point());
		}
		_Elem thousands_sep()const
		{
			return (do_thousands_sep());
		}
		string grouping()const
		{
			return (do_grouping());
		}
		string_type falsename()const
		{
			return (do_falsename());
		}
		string_type truename()const
		{
			return (do_truename());
		}
		explicit numpunct(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
				if(_Kseparator==0)_Kseparator=_Maklocchr(',', (_Elem*)0, _Lobj._Getcvt());
			}
		}
		numpunct(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 103)numpunct<_Elem>;
			return (4);
		}
		protected: virtual~numpunct()
		{
			_Tidy();
		}
		protected: numpunct(const char*_Locname, size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			const lconv*_Ptr=_Lobj._Getlconv();
			_Grouping=0;
			_Falsename=0;
			_Truename=0;
			try
			{
				_Grouping=_Maklocstr(_Ptr->grouping, (char*)0, _Lobj._Getcvt());
				_Falsename=_Maklocstr(_Lobj._Getfalse(), (_Elem*)0, _Lobj._Getcvt());
				_Truename=_Maklocstr(_Lobj._Gettrue(), (_Elem*)0, _Lobj._Getcvt());
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
			_Dp=_Maklocchr(_Ptr->decimal_point[0], (_Elem*)0, _Lobj._Getcvt());
			_Kseparator=_Maklocchr(_Ptr->thousands_sep[0], (_Elem*)0, _Lobj._Getcvt());
		}
		virtual _Elem do_decimal_point()const
		{
			return (_Dp);
		}
		virtual _Elem do_thousands_sep()const
		{
			return (_Kseparator);
		}
		virtual string do_grouping()const
		{
			return (string(_Grouping));
		}
		virtual string_type do_falsename()const
		{
			return (string_type(_Falsename));
		}
		virtual string_type do_truename()const
		{
			return (string_type(_Truename));
		}
	private:
		void _Tidy()
		{
			std::_DebugHeapDelete((void*)(void*)_Grouping);
			std::_DebugHeapDelete((void*)(void*)_Falsename);
			std::_DebugHeapDelete((void*)(void*)_Truename);
		}
		const char*_Grouping;
		_Elem _Dp;
		_Elem _Kseparator;
		const _Elem*_Falsename;
		const _Elem*_Truename;
	};
	typedef numpunct<char>_Npc;
	typedef numpunct<wchar_t>_Npwc;
	template<class _Elem>
	class numpunct_byname: public numpunct<_Elem>
	{
	public:
		explicit numpunct_byname(const char*_Locname, size_t _Refs=0): numpunct<_Elem>(_Locname, _Refs)
		{
		}
		protected: virtual~numpunct_byname()
		{
		}
	};
	template<class _Elem>
	locale::id numpunct<_Elem>::id;
	template<class _Elem, class _InIt=istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get: public locale::facet
	{
	public:
		typedef numpunct<_Elem>_Mypunct;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >_Mystr;
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 222)num_get<_Elem, _InIt>;
			return (4);
		}
		static locale::id id;
		protected: virtual~num_get()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		_Locinfo::_Cvtvec _Cvt;
	public:
		explicit num_get(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		num_get(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		typedef _Elem char_type;
		typedef _InIt iter_type;
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, _Bool&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned short&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned int&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, long&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned long&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, __int64&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned __int64&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, float&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, double&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, long double&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, void*&_Val)const
		{
			return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
		protected: virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, _Bool&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 343);
			int _Ans=-1;
			if(_Iosbase.flags()&ios_base::boolalpha)
			{
				typedef typename _Mystr::size_type _Mystrsize;
				const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Iosbase.getloc());
				_Mystr _Str((_Mystrsize)1, (char_type)0);
				_Str+=_Punct_fac.falsename();
				_Str+=(char_type)0;
				_Str+=_Punct_fac.truename();
				_Ans=_Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
			else
			{
				char _Ac[32], *_Ep;
				int _Errno=0;
				const unsigned long _Ulo=::_Stoulx(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno);
				if(_Ep!=_Ac&&_Errno==0&&_Ulo<=1)_Ans=_Ulo;
			}
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ans<0)_State|=ios_base::failbit;
			else _Val=_Ans!=0;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned short&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 380);
			char _Ac[32], *_Ep;
			int _Errno=0;
			int _Base=_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
			char*_Ptr=_Ac[0]=='-'?_Ac+1: _Ac;
			const unsigned long _Ans=::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ptr||_Errno!=0||0xffff<_Ans)_State|=ios_base::failbit;
			else _Val=(unsigned short)(_Ac[0]=='-'?0-_Ans: _Ans);
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned int&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 403);
			char _Ac[32], *_Ep;
			int _Errno=0;
			int _Base=_Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
			char*_Ptr=_Ac[0]=='-'?_Ac+1: _Ac;
			const unsigned long _Ans=::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ptr||_Errno!=0||0xffffffff<_Ans)_State|=ios_base::failbit;
			else _Val=_Ac[0]=='-'?0-_Ans: _Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, long&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 425);
			char _Ac[32], *_Ep;
			int _Errno=0;
			const long _Ans=::_Stolx(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned long&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 445);
			char _Ac[32], *_Ep;
			int _Errno=0;
			const unsigned long _Ans=::_Stoulx(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, __int64&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 466);
			char _Ac[32], *_Ep;
			int _Errno=0;
			const __int64 _Ans=::_strtoi64(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()));
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, unsigned __int64&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 486);
			char _Ac[32], *_Ep;
			int _Errno=0;
			const unsigned __int64 _Ans=::_strtoui64(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()));
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, float&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 507);
			char _Ac[8+36+16], *_Ep;
			int _Errno=0;
			const float _Ans=::_Stofx(_Ac, &_Ep, _Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, double&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 527);
			char _Ac[8+36+16], *_Ep;
			int _Errno=0;
			const double _Ans=::_Stodx(_Ac, &_Ep, _Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, long double&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 547);
			char _Ac[8+36+16], *_Ep;
			int _Errno=0;
			const long double _Ans=::_Stoldx(_Ac, &_Ep, _Getffld(_Ac, _First, _Last, _Iosbase.getloc()), &_Errno);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, void*&_Val)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 567);
			char _Ac[32], *_Ep;
			int _Errno=0;
			int _Base=_Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc());
			const unsigned __int64 _Ans=(sizeof(void*)==sizeof(unsigned long))?(unsigned __int64)::_Stoulx(_Ac, &_Ep, _Base, &_Errno): ::_strtoui64(_Ac, &_Ep, _Base);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0)_State|=ios_base::failbit;
			else _Val=(void*)(uintptr_t)_Ans;
			return (_First);
		}
	private:
		int _Getifld(char*_Ac, _InIt&_First, _InIt&_Last, ios_base::fmtflags _Basefield, const locale&_Loc)const
		{
			const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Loc);
			const string _Grouping=_Punct_fac.grouping();
			const _Elem _Kseparator=_Punct_fac.thousands_sep();
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			char*_Ptr=_Ac;
			if(_First==_Last);
			else if(*_First==_Maklocchr('+', (_Elem*)0, _Cvt))*_Ptr++='+', ++_First;
			else if(*_First==_Maklocchr('-', (_Elem*)0, _Cvt))*_Ptr++='-', ++_First;
			_Basefield&=ios_base::basefield;
			int _Base=_Basefield==ios_base::oct?8: _Basefield==ios_base::hex?16: _Basefield==ios_base::_Fmtzero?0: 10;
			bool _Seendigit=false;
			bool _Nonzero=false;
			if(_First!=_Last&&*_First==_E0)
			{
				_Seendigit=true, ++_First;
				if(_First!=_Last&&(*_First==_Maklocchr('x', (_Elem*)0, _Cvt)||*_First==_Maklocchr('X', (_Elem*)0, _Cvt))&&(_Base==0||_Base==16))_Base=16, _Seendigit=false, ++_First;
				else if(_Base==0)_Base=8;
			}
			int _Dlen=_Base==0||_Base==10?10: _Base==8?8: 16+6;
			string _Groups((size_t)1, (char)_Seendigit);
			size_t _Group=0;
			for(char*const _Pe=&_Ac[32-1];
			_First!=_Last;
			++_First)if(::memchr("0123456789abcdefABCDEF", *_Ptr=_Maklocbyte((_Elem)*_First, _Cvt), _Dlen)!=0)
			{
				if((_Nonzero||*_Ptr!='0')&&_Ptr<_Pe)++_Ptr, _Nonzero=true;
				_Seendigit=true;
				if(_Groups[_Group]!=127)++_Groups[_Group];
			}
			else if(_Groups[_Group]=='\0'||_Kseparator==(_Elem)0||*_First!=_Kseparator)break;
			else
			{
				_Groups.append((string::size_type)1, '\0');
				++_Group;
			}
			if(_Group==0);
			else if('\0'<_Groups[_Group])++_Group;
			else _Seendigit=false;
			for(const char*_Pg=_Grouping.c_str();
			_Seendigit&&0<_Group;
			)if(*_Pg==127)break;
			else if(0<--_Group&&*_Pg!=_Groups[_Group]||0==_Group&&*_Pg<_Groups[_Group])_Seendigit=false;
			else if('\0'<_Pg[1])++_Pg;
			if(_Seendigit&&!_Nonzero)*_Ptr++='0';
			else if(!_Seendigit)_Ptr=_Ac;
			*_Ptr='\0';
			return (_Base);
		}
		int _Getffld(char*_Ac, _InIt&_First, _InIt&_Last, const locale&_Loc)const
		{
			const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Loc);
			const string _Grouping=_Punct_fac.grouping();
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			char*_Ptr=_Ac;
			bool _Bad=false;
			if(_First==_Last);
			else if(*_First==_Maklocchr('+', (_Elem*)0, _Cvt))*_Ptr++='+', ++_First;
			else if(*_First==_Maklocchr('-', (_Elem*)0, _Cvt))*_Ptr++='-', ++_First;
			bool _Seendigit=false;
			int _Significant=0;
			int _Pten=0;
			if(*_Grouping.c_str()==127||*_Grouping.c_str()<='\0')for(;
			_First!=_Last&&_E0<=*_First&&*_First<=_E0+9;
			_Seendigit=true, ++_First)if(36<=_Significant)++_Pten;
			else if(*_First==_E0&&_Significant==0);
			else
			{
				*_Ptr++=(char)((*_First-_E0)+'0');
				++_Significant;
			}
			else
			{
				const _Elem _Kseparator=_Punct_fac.thousands_sep();
				string _Groups((size_t)1, '\0');
				size_t _Group=0;
				for(;
				_First!=_Last;
				++_First)if(_E0<=*_First&&*_First<=_E0+9)
				{
					_Seendigit=true;
					if(36<=_Significant)++_Pten;
					else if(*_First==_E0&&_Significant==0);
					else
					{
						*_Ptr++=(char)((*_First-_E0)+'0');
						++_Significant;
					}
					if(_Groups[_Group]!=127)++_Groups[_Group];
				}
				else if(_Groups[_Group]=='\0'||_Kseparator==(_Elem)0||*_First!=_Kseparator)break;
				else
				{
					_Groups.append((size_t)1, '\0');
					++_Group;
				}
				if(_Group==0);
				else if('\0'<_Groups[_Group])++_Group;
				else _Bad=true;
				for(const char*_Pg=_Grouping.c_str();
				!_Bad&&0<_Group;
				)if(*_Pg==127)break;
				else if(0<--_Group&&*_Pg!=_Groups[_Group]||0==_Group&&*_Pg<_Groups[_Group])_Bad=true;
				else if('\0'<_Pg[1])++_Pg;
			}
			if(_Seendigit&&_Significant==0)*_Ptr++='0';
			if(_First!=_Last&&*_First==_Punct_fac.decimal_point())*_Ptr++=localeconv()->decimal_point[0], ++_First;
			if(_Significant==0)
			{
				for(;
				_First!=_Last&&*_First==_E0;
				_Seendigit=true, ++_First)--_Pten;
				if(_Pten<0)*_Ptr++='0', ++_Pten;
			}
			for(;
			_First!=_Last&&_E0<=*_First&&*_First<=_E0+9;
			_Seendigit=true, ++_First)if(_Significant<36)
			{
				*_Ptr++=(char)((*_First-_E0)+'0');
				++_Significant;
			}
			if(_Seendigit&&_First!=_Last&&(*_First==_Maklocchr('e', (_Elem*)0, _Cvt)||*_First==_Maklocchr('E', (_Elem*)0, _Cvt)))
			{
				*_Ptr++='e', ++_First;
				_Seendigit=false, _Significant=0;
				if(_First==_Last);
				else if(*_First==_Maklocchr('+', (_Elem*)0, _Cvt))*_Ptr++='+', ++_First;
				else if(*_First==_Maklocchr('-', (_Elem*)0, _Cvt))*_Ptr++='-', ++_First;
				for(;
				_First!=_Last&&*_First==_E0;
				)_Seendigit=true, ++_First;
				if(_Seendigit)*_Ptr++='0';
				for(;
				_First!=_Last&&_E0<=*_First&&*_First<=_E0+9;
				_Seendigit=true, ++_First)if(_Significant<8)
				{
					*_Ptr++=(char)((*_First-_E0)+'0');
					++_Significant;
				}
			}
			if(_Bad||!_Seendigit)_Ptr=_Ac;
			*_Ptr='\0';
			return (_Pten);
		}
	};
	template<class _Elem, class _InIt>
	locale::id num_get<_Elem, _InIt>::id;
	template<class _Elem, class _OutIt=ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put: public locale::facet
	{
	public:
		typedef numpunct<_Elem>_Mypunct;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >_Mystr;
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 840)num_put<_Elem, _OutIt>;
			return (4);
		}
		static locale::id id;
		protected: virtual~num_put()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		_Locinfo::_Cvtvec _Cvt;
	public:
		explicit num_put(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		num_put(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		typedef _Elem char_type;
		typedef _OutIt iter_type;
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, _Bool _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, long _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, unsigned long _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, __int64 _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, unsigned __int64 _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, double _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, long double _Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const void*_Val)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
		protected: virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, _Bool _Val)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 931);
			if(!(_Iosbase.flags()&ios_base::boolalpha))return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
			else
			{
				const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Iosbase.getloc());
				_Mystr _Str;
				if(_Val)_Str.assign(_Punct_fac.truename());
				else _Str.assign(_Punct_fac.falsename());
				size_t _Fillcount=_Iosbase.width()<=0||(size_t)_Iosbase.width()<=_Str.size()?0: (size_t)_Iosbase.width()-_Str.size();
				if((_Iosbase.flags()&ios_base::adjustfield)!=ios_base::left)
				{
					_Dest=_Rep(_Dest, _Fill, _Fillcount);
					_Fillcount=0;
				}
				_Dest=_Put(_Dest, _Str.c_str(), _Str.size());
				_Iosbase.width(0);
				return (_Rep(_Dest, _Fill, _Fillcount));
			}
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, long _Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size], _Fmt[6];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, unsigned long _Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size], _Fmt[6];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, __int64 _Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size], _Fmt[8];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, unsigned __int64 _Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size], _Fmt[8];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, double _Val)const
		{
			const size_t _Buf_size=8+36+64;
			char _Buf[_Buf_size], _Fmt[8];
			streamsize _Precision=_Iosbase.precision()<=0&&!(_Iosbase.flags()&ios_base::fixed)?6: _Iosbase.precision();
			int _Significance=36<_Precision?36: (int)_Precision;
			_Precision-=_Significance;
			size_t _Beforepoint=0;
			size_t _Afterpoint=0;
			if((_Iosbase.flags()&ios_base::floatfield)==ios_base::fixed)
			{
				bool _Signed=_Val<0;
				if(_Signed)_Val=-_Val;
				for(;
				1e35<=_Val&&_Beforepoint<5000;
				_Beforepoint+=10)_Val/=1e10;
				if(0<_Val)for(;
				10<=_Precision&&_Val<=1e-35&&_Afterpoint<5000;
				_Afterpoint+=10)
				{
					_Val*=1e10;
					_Precision-=10;
				}
				if(_Signed)_Val=-_Val;
			}
			return (_Fput(_Dest, _Iosbase, _Fill, _Buf, _Beforepoint, _Afterpoint, _Precision, ::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()), _Significance, _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, long double _Val)const
		{
			const size_t _Buf_size=8+36+64;
			char _Buf[_Buf_size], _Fmt[8];
			streamsize _Precision=_Iosbase.precision()<=0&&!(_Iosbase.flags()&ios_base::fixed)?6: _Iosbase.precision();
			int _Significance=36<_Precision?36: (int)_Precision;
			_Precision-=_Significance;
			size_t _Beforepoint=0;
			size_t _Afterpoint=0;
			if((_Iosbase.flags()&ios_base::floatfield)==ios_base::fixed)
			{
				bool _Signed=_Val<0;
				if(_Signed)_Val=-_Val;
				for(;
				1e35<=_Val&&_Beforepoint<5000;
				_Beforepoint+=10)_Val/=1e10;
				if(0<_Val)for(;
				10<=_Precision&&_Val<=1e-35&&_Afterpoint<5000;
				_Afterpoint+=10)
				{
					_Val*=1e10;
					_Precision-=10;
				}
				if(_Signed)_Val=-_Val;
			}
			return (_Fput(_Dest, _Iosbase, _Fill, _Buf, _Beforepoint, _Afterpoint, _Precision, ::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()), _Significance, _Val)));
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const void*_Val)const
		{
			const size_t _Buf_size=2*32;
			char _Buf[_Buf_size];
			return (_Iput(_Dest, _Iosbase, _Fill, _Buf, ::sprintf_s(_Buf, _Buf_size, "%p", _Val)));
		}
	private:
		char*_Ffmt(char*_Fmt, char _Spec, ios_base::fmtflags _Flags)const
		{
			char*_Ptr=_Fmt;
			*_Ptr++='%';
			if(_Flags&ios_base::showpos)*_Ptr++='+';
			if(_Flags&ios_base::showpoint)*_Ptr++='#';
			*_Ptr++='.';
			*_Ptr++='*';
			if(_Spec!='\0')*_Ptr++=_Spec;
			ios_base::fmtflags _Ffl=_Flags&ios_base::floatfield;
			*_Ptr++=_Ffl==ios_base::fixed?'f': _Ffl==ios_base::scientific?'e': 'g';
			*_Ptr='\0';
			return (_Fmt);
		}
		_OutIt _Fput(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const char*_Buf, size_t _Beforepoint, size_t _Afterpoint, size_t _Trailing, size_t _Count)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 1119);
			const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Iosbase.getloc());
			const string _Grouping=_Punct_fac.grouping();
			const _Elem _Kseparator=_Punct_fac.thousands_sep();
			string _Groupstring;
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			size_t _Prefix=_Buf[0]=='+'||_Buf[0]=='-'?1: 0;
			char _Enders[3];
			_Enders[0]=::localeconv()->decimal_point[0];
			_Enders[1]='e';
			_Enders[2]='\0';
			const char*_Eptr=(const char*)::memchr(_Buf, 'e', _Count);
			const char*_Pointptr=(const char*)::memchr(_Buf, _Enders[0], _Count);
			if(_Pointptr==0)_Trailing=0;
			if(*_Grouping.c_str()!=127&&'\0'<*_Grouping.c_str())
			{
				_Groupstring.append(_Buf, _Count);
				if(_Eptr==0)_Groupstring.append(_Trailing, '0');
				else
				{
					if(_Pointptr==0)
					{
						_Groupstring.append(_Beforepoint, '0');
						_Beforepoint=0;
					}
					_Groupstring.insert(_Eptr-_Buf, _Trailing, '0');
				}
				_Trailing=0;
				if(_Pointptr==0)_Groupstring.append(_Beforepoint, '0');
				else
				{
					_Groupstring.insert(_Pointptr-_Buf+1, _Afterpoint, '0');
					_Groupstring.insert(_Pointptr-_Buf, _Beforepoint, '0');
					_Afterpoint=0;
				}
				_Beforepoint=0;
				const char*_Pg=_Grouping.c_str();
				size_t _Off=::strcspn(&_Groupstring[0], &_Enders[0]);
				while(*_Pg!=127&&'\0'<*_Pg&&(size_t)*_Pg<_Off-_Prefix)
				{
					_Groupstring.insert(_Off-=*_Pg, (size_t)1, '\0');
					if('\0'<_Pg[1])++_Pg;
				}
				_Buf=&_Groupstring[0];
				_Trailing=0;
				_Count=_Groupstring.size();
			}
			size_t _Fillcount=_Beforepoint+_Afterpoint+_Trailing+_Count;
			_Fillcount=_Iosbase.width()<=0||(size_t)_Iosbase.width()<=_Fillcount?0: (size_t)_Iosbase.width()-_Fillcount;
			ios_base::fmtflags _Adjustfield=_Iosbase.flags()&ios_base::adjustfield;
			if(_Adjustfield!=ios_base::left&&_Adjustfield!=ios_base::internal)
			{
				_Dest=_Rep(_Dest, _Fill, _Fillcount);
				_Fillcount=0;
			}
			else if(_Adjustfield==ios_base::internal)
			{
				if(0<_Prefix)
				{
					_Dest=_Putc(_Dest, _Buf, 1);
					++_Buf, --_Count;
				}
				_Dest=_Rep(_Dest, _Fill, _Fillcount);
				_Fillcount=0;
			}
			_Pointptr=(const char*)::memchr(_Buf, _Enders[0], _Count);
			if(_Pointptr!=0)
			{
				size_t _Fracoffset=_Pointptr-_Buf+1;
				_Dest=_Putgrouped(_Dest, _Buf, _Fracoffset-1, _Kseparator);
				_Dest=_Rep(_Dest, _E0, _Beforepoint);
				_Dest=_Rep(_Dest, _Punct_fac.decimal_point(), 1);
				_Dest=_Rep(_Dest, _E0, _Afterpoint);
				_Buf+=_Fracoffset, _Count-=_Fracoffset;
			}
			_Eptr=(const char*)::memchr(_Buf, 'e', _Count);
			if(_Eptr!=0)
			{
				size_t _Expoffset=_Eptr-_Buf+1;
				_Dest=_Putgrouped(_Dest, _Buf, _Expoffset-1, _Kseparator);
				_Dest=_Rep(_Dest, _E0, _Trailing), _Trailing=0;
				_Dest=_Putc(_Dest, _Iosbase.flags()&ios_base::uppercase?"E": "e", 1);
				_Buf+=_Expoffset, _Count-=_Expoffset;
			}
			_Dest=_Putgrouped(_Dest, _Buf, _Count, _Kseparator);
			_Dest=_Rep(_Dest, _E0, _Trailing);
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));
		}
		char*_Ifmt(char*_Fmt, const char*_Spec, ios_base::fmtflags _Flags)const
		{
			char*_Ptr=_Fmt;
			*_Ptr++='%';
			if(_Flags&ios_base::showpos)*_Ptr++='+';
			if(_Flags&ios_base::showbase)*_Ptr++='#';
			if(_Spec[0]!='L')*_Ptr++=_Spec[0];
			else
			{
				*_Ptr++='I';
				*_Ptr++='6';
				*_Ptr++='4';
			}
			ios_base::fmtflags _Basefield=_Flags&ios_base::basefield;
			*_Ptr++=_Basefield==ios_base::oct?'o': _Basefield!=ios_base::hex?_Spec[1]: _Flags&ios_base::uppercase?'X': 'x';
			*_Ptr='\0';
			return (_Fmt);
		}
		_OutIt _Iput(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, char*_Buf, size_t _Count)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocnum", 1264);
			const _Mypunct&_Punct_fac=use_facet<_Mypunct>(_Iosbase.getloc());
			const string _Grouping=_Punct_fac.grouping();
			const size_t _Prefix=*_Buf=='+'||*_Buf=='-'?1: *_Buf=='0'&&(_Buf[1]=='x'||_Buf[1]=='X')?2: 0;
			if(*_Grouping.c_str()!=127&&'\0'<*_Grouping.c_str())
			{
				const char*_Pg=_Grouping.c_str();
				size_t _Off=_Count;
				while(*_Pg!=127&&'\0'<*_Pg&&(size_t)*_Pg<_Off-_Prefix)
				{
					_Off-=*_Pg;
					::memmove_s((&_Buf[_Off+1]), (_Count+1-_Off), (&_Buf[_Off]), (_Count+1-_Off));
					_Buf[_Off]='\0', ++_Count;
					if('\0'<_Pg[1])++_Pg;
				}
			}
			size_t _Fillcount=_Iosbase.width()<=0||(size_t)_Iosbase.width()<=_Count?0: (size_t)_Iosbase.width()-_Count;
			ios_base::fmtflags _Adjustfield=_Iosbase.flags()&ios_base::adjustfield;
			if(_Adjustfield!=ios_base::left&&_Adjustfield!=ios_base::internal)
			{
				_Dest=_Rep(_Dest, _Fill, _Fillcount);
				_Fillcount=0;
			}
			else if(_Adjustfield==ios_base::internal)
			{
				_Dest=_Putc(_Dest, _Buf, _Prefix);
				_Buf+=_Prefix, _Count-=_Prefix;
				_Dest=_Rep(_Dest, _Fill, _Fillcount), _Fillcount=0;
			}
			_Dest=_Putgrouped(_Dest, _Buf, _Count, _Punct_fac.thousands_sep());
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));
		}
		_OutIt _Put(_OutIt _Dest, const _Elem*_Ptr, size_t _Count)const
		{
			for(;
			0<_Count;
			--_Count, ++_Dest, ++_Ptr)*_Dest=*_Ptr;
			return (_Dest);
		}
		_OutIt _Putc(_OutIt _Dest, const char*_Ptr, size_t _Count)const
		{
			for(;
			0<_Count;
			--_Count, ++_Dest, ++_Ptr)*_Dest=_Maklocchr(*_Ptr, (_Elem*)0, _Cvt);
			return (_Dest);
		}
		_OutIt _Putgrouped(_OutIt _Dest, const char*_Ptr, size_t _Count, _Elem _Kseparator)const
		{
			for(;
			;
			++_Ptr, --_Count)
			{
				const char*_Pend=(const char*)::memchr(_Ptr, '\0', _Count);
				size_t _Groupsize=_Pend!=0?_Pend-_Ptr: _Count;
				_Dest=_Putc(_Dest, _Ptr, _Groupsize);
				_Ptr+=_Groupsize, _Count-=_Groupsize;
				if(_Count==0)break;
				if(_Kseparator!=(_Elem)0)_Dest=_Rep(_Dest, _Kseparator, 1);
			}
			return (_Dest);
		}
		_OutIt _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count)const
		{
			for(;
			0<_Count;
			--_Count, ++_Dest)*_Dest=_Ch;
			return (_Dest);
		}
	};
	template<class _Elem, class _OutIt>
	locale::id num_put<_Elem, _OutIt>::id;
}
namespace std
{
	template<class _Elem, class _Traits>
	class basic_ios: public ios_base
	{
	public:
		typedef basic_ios<_Elem, _Traits>_Myt;
		typedef basic_ostream<_Elem, _Traits>_Myos;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef ctype<_Elem>_Ctype;
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		explicit basic_ios(_Mysb*_Strbuf)
		{
			init(_Strbuf);
		}
		virtual~basic_ios()
		{
		}
		void clear(iostate _State=goodbit, bool _Reraise=false)
		{
			ios_base::clear((iostate)(_Mystrbuf==0?(int)_State|(int)badbit: (int)_State), _Reraise);
		}
		void clear(io_state _State)
		{
			clear((iostate)_State);
		}
		void setstate(iostate _State, bool _Reraise=false)
		{
			if(_State!=goodbit)clear((iostate)((int)rdstate()|(int)_State), _Reraise);
		}
		void setstate(io_state _State)
		{
			setstate((iostate)_State);
		}
		_Myt&copyfmt(const _Myt&_Right)
		{
			_Tiestr=_Right.tie();
			_Fillch=_Right.fill();
			ios_base::copyfmt(_Right);
			return (*this);
		}
		_Myos*tie()const
		{
			return (_Tiestr);
		}
		_Myos*tie(_Myos*_Newtie)
		{
			_Myos*_Oldtie=_Tiestr;
			_Tiestr=_Newtie;
			return (_Oldtie);
		}
		_Mysb*rdbuf()const
		{
			return (_Mystrbuf);
		}
		_Mysb*rdbuf(_Mysb*_Strbuf)
		{
			_Mysb*_Oldstrbuf=_Mystrbuf;
			_Mystrbuf=_Strbuf;
			clear();
			return (_Oldstrbuf);
		}
		locale imbue(const locale&_Loc)
		{
			locale _Oldlocale=ios_base::imbue(_Loc);
			if(rdbuf()!=0)rdbuf()->pubimbue(_Loc);
			return (_Oldlocale);
		}
		_Elem fill()const
		{
			return (_Fillch);
		}
		_Elem fill(_Elem _Newfill)
		{
			_Elem _Oldfill=_Fillch;
			_Fillch=_Newfill;
			return (_Oldfill);
		}
		char narrow(_Elem _Ch, char _Dflt='\0')const
		{
			const _Ctype&_Ctype_fac=use_facet<_Ctype>(getloc());
			return (_Ctype_fac.narrow(_Ch, _Dflt));
		}
		_Elem widen(char _Byte)const
		{
			const _Ctype&_Ctype_fac=use_facet<_Ctype>(getloc());
			return (_Ctype_fac.widen(_Byte));
		}
		protected: void init(_Mysb*_Strbuf=0, bool _Isstd=false)
		{
			_Init();
			_Mystrbuf=_Strbuf;
			_Tiestr=0;
			_Fillch=widen(' ');
			if(_Mystrbuf==0)setstate(badbit);
			if(_Isstd)_Addstd(this);
			else _Stdstr=0;
		}
		basic_ios()
		{
		}
	private:
		basic_ios(const _Myt&);
		_Myt&operator=(const _Myt&);
		_Mysb*_Mystrbuf;
		_Myos*_Tiestr;
		_Elem _Fillch;
	};
	inline ios_base&boolalpha(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::boolalpha);
		return (_Iosbase);
	}
	inline ios_base&dec(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::dec, ios_base::basefield);
		return (_Iosbase);
	}
	inline ios_base&fixed(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
		return (_Iosbase);
	}
	inline ios_base&hex(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::hex, ios_base::basefield);
		return (_Iosbase);
	}
	inline ios_base&internal(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
		return (_Iosbase);
	}
	inline ios_base&left(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::left, ios_base::adjustfield);
		return (_Iosbase);
	}
	inline ios_base&noboolalpha(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::boolalpha);
		return (_Iosbase);
	}
	inline ios_base&noshowbase(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::showbase);
		return (_Iosbase);
	}
	inline ios_base&noshowpoint(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::showpoint);
		return (_Iosbase);
	}
	inline ios_base&noshowpos(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::showpos);
		return (_Iosbase);
	}
	inline ios_base&noskipws(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::skipws);
		return (_Iosbase);
	}
	inline ios_base&nounitbuf(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::unitbuf);
		return (_Iosbase);
	}
	inline ios_base&nouppercase(ios_base&_Iosbase)
	{
		_Iosbase.unsetf(ios_base::uppercase);
		return (_Iosbase);
	}
	inline ios_base&oct(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::oct, ios_base::basefield);
		return (_Iosbase);
	}
	inline ios_base&right(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::right, ios_base::adjustfield);
		return (_Iosbase);
	}
	inline ios_base&scientific(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
		return (_Iosbase);
	}
	inline ios_base&showbase(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::showbase);
		return (_Iosbase);
	}
	inline ios_base&showpoint(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::showpoint);
		return (_Iosbase);
	}
	inline ios_base&showpos(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::showpos);
		return (_Iosbase);
	}
	inline ios_base&skipws(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::skipws);
		return (_Iosbase);
	}
	inline ios_base&unitbuf(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::unitbuf);
		return (_Iosbase);
	}
	inline ios_base&uppercase(ios_base&_Iosbase)
	{
		_Iosbase.setf(ios_base::uppercase);
		return (_Iosbase);
	}
}
namespace std
{
	template<class _Elem, class _Traits>
	class basic_ostream: virtual public basic_ios<_Elem, _Traits>
	{
	public:
		typedef basic_ostream<_Elem, _Traits>_Myt;
		typedef basic_ios<_Elem, _Traits>_Myios;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef ostreambuf_iterator<_Elem, _Traits>_Iter;
		typedef num_put<_Elem, _Iter>_Nput;
		explicit basic_ostream(basic_streambuf<_Elem, _Traits>*_Strbuf, bool _Isstd=false)
		{
			_Myios::init(_Strbuf, _Isstd);
		}
		basic_ostream(_Uninitialized)
		{
			ios_base::_Addstd(this);
		}
		virtual~basic_ostream()
		{
		}
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		class _Sentry_base
		{
		public:
			_Sentry_base(_Myt&_Ostr): _Myostr(_Ostr)
			{
				if(_Myostr.rdbuf()!=0)_Myostr.rdbuf()->_Lock();
			}
			~_Sentry_base()
			{
				if(_Myostr.rdbuf()!=0)_Myostr.rdbuf()->_Unlock();
			}
			_Myt&_Myostr;
		};
		class sentry: public _Sentry_base
		{
		public:
			explicit sentry(_Myt&_Ostr): _Sentry_base(_Ostr)
			{
				if(_Ostr.good()&&_Ostr.tie()!=0)_Ostr.tie()->flush();
				_Ok=_Ostr.good();
			}
			~sentry()
			{
				if(!std::uncaught_exception())this->_Myostr._Osfx();
			}
			operator bool()const
			{
				return (_Ok);
			}
		private:
			sentry(const sentry&);
			sentry&operator=(const sentry&);
			bool _Ok;
		};
		bool opfx()
		{
			if(ios_base::good()&&_Myios::tie()!=0)_Myios::tie()->flush();
			return (ios_base::good());
		}
		void osfx()
		{
			_Osfx();
		}
		void _Osfx()
		{
			try
			{
				if(ios_base::flags()&ios_base::unitbuf)flush();
			}
			catch(...)
			{
			}
		}
		_Myt&operator<<(_Myt&(*_Pfn)(_Myt&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\ostream", 170);
			return ((*_Pfn)(*this));
		}
		_Myt&operator<<(_Myios&(*_Pfn)(_Myios&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\ostream", 176);
			(*_Pfn)(*(_Myios*)this);
			return (*this);
		}
		_Myt&operator<<(ios_base&(*_Pfn)(ios_base&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\ostream", 183);
			(*_Pfn)(*(ios_base*)this);
			return (*this);
		}
		_Myt&operator<<(_Bool _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(short _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				ios_base::fmtflags _Bfl=ios_base::flags()&ios_base::basefield;
				long _Tmp=(_Bfl==ios_base::oct||_Bfl==ios_base::hex)?(long)(unsigned short)_Val: (long)_Val;
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(unsigned short _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long)_Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(int _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				ios_base::fmtflags _Bfl=ios_base::flags()&ios_base::basefield;
				long _Tmp=(_Bfl==ios_base::oct||_Bfl==ios_base::hex)?(long)(unsigned int)_Val: (long)_Val;
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(unsigned int _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long)_Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(long _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(unsigned long _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long)_Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(__int64 _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(unsigned __int64 _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(float _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (double)_Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(double _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(long double _Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(const void*_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nput&_Nput_fac=use_facet<_Nput>(ios_base::getloc());
				try
				{
					if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator<<(_Mysb*_Strbuf)
		{
			ios_base::iostate _State=ios_base::goodbit;
			bool _Copied=false;
			const sentry _Ok(*this);
			if(_Ok&&_Strbuf!=0)for(int_type _Meta=_Traits::eof();
			;
			_Copied=true)
			{
				try
				{
					_Meta=_Traits::eq_int_type(_Traits::eof(), _Meta)?_Strbuf->sgetc(): _Strbuf->snextc();
				}
				catch(...)
				{
					_Myios::setstate(ios_base::failbit);
					throw;
				}
				if(_Traits::eq_int_type(_Traits::eof(), _Meta))break;
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta))))
					{
						_State|=ios_base::badbit;
						break;
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			ios_base::width(0);
			_Myios::setstate(_Strbuf==0?ios_base::badbit: !_Copied?_State|ios_base::failbit: _State);
			return (*this);
		}
		_Myt&put(_Elem _Ch)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(!_Ok)_State|=ios_base::badbit;
			else
			{
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch)))_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&write(const _Elem*_Str, streamsize _Count)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\ostream", 528);
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(!_Ok)_State|=ios_base::badbit;
			else
			{
				try
				{
					if(_Myios::rdbuf()->sputn(_Str, _Count)!=_Count)_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&flush()
		{
			ios_base::iostate _State=ios_base::goodbit;
			if(!ios_base::fail()&&_Myios::rdbuf()->pubsync()==-1)_State|=ios_base::badbit;
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&seekp(pos_type _Pos)
		{
			if(!ios_base::fail()&&(off_type)_Myios::rdbuf()->pubseekpos(_Pos, ios_base::out)==_BADOFF)_Myios::setstate(ios_base::failbit);
			return (*this);
		}
		_Myt&seekp(off_type _Off, ios_base::seekdir _Way)
		{
			if(!ios_base::fail()&&(off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out)==_BADOFF)_Myios::setstate(ios_base::failbit);
			return (*this);
		}
		pos_type tellp()
		{
			if(!ios_base::fail())return (_Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out));
			else return (pos_type(_BADOFF));
		}
	};
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const char*_Val)
	{
		ios_base::iostate _State=ios_base::goodbit;
		streamsize _Count=(streamsize)::strlen(_Val);
		streamsize _Pad=_Ostr.width()<=0||_Ostr.width()<=_Count?0: _Ostr.width()-_Count;
		const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
		if(!_Ok)_State|=ios_base::badbit;
		else
		{
			try
			{
				const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Ostr.getloc());
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				for(;
				_State==ios_base::goodbit&&0<_Count;
				--_Count, ++_Val)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))_State|=ios_base::badbit;
				if(_State==ios_base::goodbit)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				_Ostr.width(0);
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, char _Ch)
	{
		ios_base::iostate _State=ios_base::goodbit;
		const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
		if(_Ok)
		{
			const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Ostr.getloc());
			streamsize _Pad=_Ostr.width()<=1?0: _Ostr.width()-1;
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
				if(_State==ios_base::goodbit&&_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))_State|=ios_base::badbit;
				for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.width(0);
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, const char*_Val)
	{
		typedef char _Elem;
		typedef basic_ostream<_Elem, _Traits>_Myos;
		ios_base::iostate _State=ios_base::goodbit;
		streamsize _Count=(streamsize)_Traits::length(_Val);
		streamsize _Pad=_Ostr.width()<=0||_Ostr.width()<=_Count?0: _Ostr.width()-_Count;
		const typename _Myos::sentry _Ok(_Ostr);
		if(!_Ok)_State|=ios_base::badbit;
		else
		{
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				if(_State==ios_base::goodbit&&_Ostr.rdbuf()->sputn(_Val, _Count)!=_Count)_State|=ios_base::badbit;
				if(_State==ios_base::goodbit)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				_Ostr.width(0);
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, char _Ch)
	{
		typedef char _Elem;
		typedef basic_ostream<_Elem, _Traits>_Myos;
		ios_base::iostate _State=ios_base::goodbit;
		const typename _Myos::sentry _Ok(_Ostr);
		if(_Ok)
		{
			streamsize _Pad=_Ostr.width()<=1?0: _Ostr.width()-1;
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
				if(_State==ios_base::goodbit&&_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch)))_State|=ios_base::badbit;
				for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.width(0);
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const _Elem*_Val)
	{
		typedef basic_ostream<_Elem, _Traits>_Myos;
		ios_base::iostate _State=ios_base::goodbit;
		streamsize _Count=(streamsize)_Traits::length(_Val);
		streamsize _Pad=_Ostr.width()<=0||_Ostr.width()<=_Count?0: _Ostr.width()-_Count;
		const typename _Myos::sentry _Ok(_Ostr);
		if(!_Ok)_State|=ios_base::badbit;
		else
		{
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				if(_State==ios_base::goodbit&&_Ostr.rdbuf()->sputn(_Val, _Count)!=_Count)_State|=ios_base::badbit;
				if(_State==ios_base::goodbit)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				_Ostr.width(0);
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, _Elem _Ch)
	{
		typedef basic_ostream<_Elem, _Traits>_Myos;
		ios_base::iostate _State=ios_base::goodbit;
		const typename _Myos::sentry _Ok(_Ostr);
		if(_Ok)
		{
			streamsize _Pad=_Ostr.width()<=1?0: _Ostr.width()-1;
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
				if(_State==ios_base::goodbit&&_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch)))_State|=ios_base::badbit;
				for(;
				_State==ios_base::goodbit&&0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))_State|=ios_base::badbit;
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.width(0);
		_Ostr.setstate(_State);
		return (_Ostr);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, const signed char*_Val)
	{
		return (_Ostr<<(const char*)_Val);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, signed char _Ch)
	{
		return (_Ostr<<(char)_Ch);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, const unsigned char*_Val)
	{
		return (_Ostr<<(const char*)_Val);
	}
	template<class _Traits>
	inline basic_ostream<char, _Traits>&operator<<(basic_ostream<char, _Traits>&_Ostr, unsigned char _Ch)
	{
		return (_Ostr<<(char)_Ch);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&endl(basic_ostream<_Elem, _Traits>&_Ostr)
	{
		_Ostr.put(_Ostr.widen('\n'));
		_Ostr.flush();
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&ends(basic_ostream<_Elem, _Traits>&_Ostr)
	{
		_Ostr.put(_Elem());
		return (_Ostr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&flush(basic_ostream<_Elem, _Traits>&_Ostr)
	{
		_Ostr.flush();
		return (_Ostr);
	}
	inline basic_ostream<char, char_traits<char> >&endl(basic_ostream<char, char_traits<char> >&_Ostr)
	{
		_Ostr.put('\n');
		_Ostr.flush();
		return (_Ostr);
	}
	inline basic_ostream<wchar_t, char_traits<wchar_t> >&endl(basic_ostream<wchar_t, char_traits<wchar_t> >&_Ostr)
	{
		_Ostr.put('\n');
		_Ostr.flush();
		return (_Ostr);
	}
	inline basic_ostream<char, char_traits<char> >&ends(basic_ostream<char, char_traits<char> >&_Ostr)
	{
		_Ostr.put('\0');
		return (_Ostr);
	}
	inline basic_ostream<wchar_t, char_traits<wchar_t> >&ends(basic_ostream<wchar_t, char_traits<wchar_t> >&_Ostr)
	{
		_Ostr.put('\0');
		return (_Ostr);
	}
	inline basic_ostream<char, char_traits<char> >&flush(basic_ostream<char, char_traits<char> >&_Ostr)
	{
		_Ostr.flush();
		return (_Ostr);
	}
	inline basic_ostream<wchar_t, char_traits<wchar_t> >&flush(basic_ostream<wchar_t, char_traits<wchar_t> >&_Ostr)
	{
		_Ostr.flush();
		return (_Ostr);
	}
}
namespace std
{
	template<class _Elem, class _Traits>
	class basic_istream: virtual public basic_ios<_Elem, _Traits>
	{
	public:
		typedef basic_istream<_Elem, _Traits>_Myt;
		typedef basic_ios<_Elem, _Traits>_Myios;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef istreambuf_iterator<_Elem, _Traits>_Iter;
		typedef ctype<_Elem>_Ctype;
		typedef num_get<_Elem, _Iter>_Nget;
		explicit basic_istream(_Mysb*_Strbuf, bool _Isstd=false): _Chcount(0)
		{
			_Myios::init(_Strbuf, _Isstd);
		}
		basic_istream(_Uninitialized)
		{
			ios_base::_Addstd(this);
		}
		virtual~basic_istream()
		{
		}
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		class _Sentry_base
		{
		public:
			_Sentry_base(_Myt&_Istr): _Myistr(_Istr)
			{
				if(_Myistr.rdbuf()!=0)_Myistr.rdbuf()->_Lock();
			}
			~_Sentry_base()
			{
				if(_Myistr.rdbuf()!=0)_Myistr.rdbuf()->_Unlock();
			}
			_Myt&_Myistr;
		};
		class sentry: public _Sentry_base
		{
		public:
			explicit sentry(_Myt&_Istr, bool _Noskip=false): _Sentry_base(_Istr)
			{
				_Ok=this->_Myistr._Ipfx(_Noskip);
			}
			operator bool()const
			{
				return (_Ok);
			}
		private:
			sentry(const sentry&);
			sentry&operator=(const sentry&);
			bool _Ok;
		};
		bool _Ipfx(bool _Noskip=false)
		{
			if(ios_base::good())
			{
				if(_Myios::tie()!=0)_Myios::tie()->flush();
				if(!_Noskip&&ios_base::flags()&ios_base::skipws)
				{
					const _Ctype&_Ctype_fac=use_facet<_Ctype>(ios_base::getloc());
					try
					{
						int_type _Meta=_Myios::rdbuf()->sgetc();
						for(;
						;
						_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
						{
							_Myios::setstate(ios_base::eofbit);
							break;
						}
						else if(!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))break;
					}
					catch(...)
					{
						_Myios::setstate(ios_base::badbit, true);
					}
				}
				if(ios_base::good())return (true);
			}
			_Myios::setstate(ios_base::failbit);
			return (false);
		}
		bool ipfx(bool _Noskip=false)
		{
			return _Ipfx(_Noskip);
		}
		void isfx()
		{
		}
		_Myt&operator>>(_Myt&(*_Pfn)(_Myt&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 157);
			return ((*_Pfn)(*this));
		}
		_Myt&operator>>(_Myios&(*_Pfn)(_Myios&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 163);
			(*_Pfn)(*(_Myios*)this);
			return (*this);
		}
		_Myt&operator>>(ios_base&(*_Pfn)(ios_base&))
		{
			_Debug_pointer(_Pfn, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 170);
			(*_Pfn)(*(ios_base*)this);
			return (*this);
		}
		_Myt&operator>>(_Bool&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(short&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				long _Tmp=0;
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Tmp);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
				if(_State&ios_base::failbit||_Tmp<(-32768)||32767<_Tmp)_State|=ios_base::failbit;
				else _Val=(short)_Tmp;
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(unsigned short&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(int&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				long _Tmp=0;
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Tmp);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
				if(_State&ios_base::failbit||_Tmp<(-2147483647-1)||2147483647<_Tmp)_State|=ios_base::failbit;
				else _Val=_Tmp;
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(unsigned int&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(long&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(unsigned long&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, (unsigned long)_Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(__int64&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(unsigned __int64&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(float&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(double&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(long double&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(void*&_Val)
		{
			ios_base::iostate _State=ios_base::goodbit;
			const sentry _Ok(*this);
			if(_Ok)
			{
				const _Nget&_Nget_fac=use_facet<_Nget>(ios_base::getloc());
				try
				{
					_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0), *this, _State, _Val);
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&operator>>(_Mysb*_Strbuf)
		{
			ios_base::iostate _State=ios_base::goodbit;
			bool _Copied=false;
			const sentry _Ok(*this);
			if(_Ok&&_Strbuf!=0)
			{
				try
				{
					int_type _Meta=_Myios::rdbuf()->sgetc();
					for(;
					;
					_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else
					{
						try
						{
							if(_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta))))break;
						}
						catch(...)
						{
							break;
						}
						_Copied=true;
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(!_Copied?_State|ios_base::failbit: _State);
			return (*this);
		}
		int_type get()
		{
			int_type _Meta=0;
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(!_Ok)_Meta=_Traits::eof();
			else
			{
				try
				{
					_Meta=_Myios::rdbuf()->sbumpc();
					if(_Traits::eq_int_type(_Traits::eof(), _Meta))_State|=ios_base::eofbit|ios_base::failbit;
					else++_Chcount;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (_Meta);
		}
		_Myt&get(_Elem*_Str, streamsize _Count)
		{
			return (get(_Str, _Count, _Myios::widen('\n')));
		}
		_Myt&get(_Elem*_Str, streamsize _Count, _Elem _Delim)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 509);
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok&&0<_Count)
			{
				try
				{
					int_type _Meta=_Myios::rdbuf()->sgetc();
					for(;
					0<--_Count;
					_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(_Traits::to_char_type(_Meta)==_Delim)break;
					else
					{
						*_Str++=_Traits::to_char_type(_Meta);
						++_Chcount;
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_Chcount==0?_State|ios_base::failbit: _State);
			*_Str=_Elem();
			return (*this);
		}
		_Myt&get(_Elem&_Ch)
		{
			int_type _Meta=get();
			if(!_Traits::eq_int_type(_Traits::eof(), _Meta))_Ch=_Traits::to_char_type(_Meta);
			return (*this);
		}
		_Myt&get(_Mysb&_Strbuf)
		{
			return (get(_Strbuf, _Myios::widen('\n')));
		}
		_Myt&get(_Mysb&_Strbuf, _Elem _Delim)
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok)
			{
				try
				{
					int_type _Meta=_Myios::rdbuf()->sgetc();
					for(;
					;
					_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else
					{
						try
						{
							_Elem _Ch=_Traits::to_char_type(_Meta);
							if(_Ch==_Delim||_Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch)))break;
						}
						catch(...)
						{
							break;
						}
						++_Chcount;
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			if(_Chcount==0)_State|=ios_base::failbit;
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&getline(_Elem*_Str, streamsize _Count)
		{
			return (getline(_Str, _Count, _Myios::widen('\n')));
		}
		_Myt&getline(_Elem*_Str, streamsize _Count, _Elem _Delim)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 601);
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok&&0<_Count)
			{
				int_type _Metadelim=_Traits::to_int_type(_Delim);
				try
				{
					int_type _Meta=_Myios::rdbuf()->sgetc();
					for(;
					;
					_Meta=_Myios::rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(_Meta==_Metadelim)
					{
						++_Chcount;
						_Myios::rdbuf()->sbumpc();
						break;
					}
					else if(--_Count<=0)
					{
						_State|=ios_base::failbit;
						break;
					}
					else
					{
						++_Chcount;
						*_Str++=_Traits::to_char_type(_Meta);
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			*_Str=_Elem();
			_Myios::setstate(_Chcount==0?_State|ios_base::failbit: _State);
			return (*this);
		}
		_Myt&ignore(streamsize _Count=1, int_type _Metadelim=_Traits::eof())
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok&&0<_Count)
			{
				try
				{
					for(;
					;
					)
					{
						int_type _Meta;
						if(_Count!=2147483647&&--_Count<0)break;
						else if(_Traits::eq_int_type(_Traits::eof(), _Meta=_Myios::rdbuf()->sbumpc()))
						{
							_State|=ios_base::eofbit;
							break;
						}
						else
						{
							++_Chcount;
							if(_Meta==_Metadelim)break;
						}
					}
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&_Read_s(_Elem*_Str, size_t _Str_size, streamsize _Count)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 680);
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok)
			{
				try
				{
					const streamsize _Num=_Myios::rdbuf()->_Sgetn_s(_Str, _Str_size, _Count);
					_Chcount+=_Num;
					if(_Num!=_Count)_State|=ios_base::eofbit|ios_base::failbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&read(_Elem*_Str, streamsize _Count)
		{
			return _Read_s(_Str, (size_t)-1, _Count);
		}
		streamsize _Readsome_s(_Elem*_Str, size_t _Str_size, streamsize _Count)
		{
			_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 706);
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			streamsize _Num;
			if(!_Ok)_State|=ios_base::failbit;
			else if((_Num=_Myios::rdbuf()->in_avail())<0)_State|=ios_base::eofbit;
			else if(0<_Num)_Read_s(_Str, _Str_size, _Num<_Count?_Num: _Count);
			_Myios::setstate(_State);
			return (gcount());
		}
		streamsize readsome(_Elem*_Str, streamsize _Count)
		{
			return _Readsome_s(_Str, (size_t)-1, _Count);
		}
		int_type peek()
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			int_type _Meta=0;
			const sentry _Ok(*this, true);
			if(!_Ok)_Meta=_Traits::eof();
			else
			{
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Meta=_Myios::rdbuf()->sgetc()))_State|=ios_base::eofbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (_Meta);
		}
		_Myt&putback(_Elem _Ch)
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok)
			{
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch)))_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		_Myt&unget()
		{
			ios_base::iostate _State=ios_base::goodbit;
			_Chcount=0;
			const sentry _Ok(*this, true);
			if(_Ok)
			{
				try
				{
					if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc()))_State|=ios_base::badbit;
				}
				catch(...)
				{
					_Myios::setstate(ios_base::badbit, true);
				}
			}
			_Myios::setstate(_State);
			return (*this);
		}
		streamsize gcount()const
		{
			return (_Chcount);
		}
		int sync()
		{
			ios_base::iostate _State=ios_base::goodbit;
			int _Ans;
			if(_Myios::rdbuf()==0)_Ans=-1;
			else if(_Myios::rdbuf()->pubsync()==-1)
			{
				_State|=ios_base::badbit;
				_Ans=-1;
			}
			else _Ans=0;
			_Myios::setstate(_State);
			return (_Ans);
		}
		_Myt&seekg(pos_type _Pos)
		{
			if(!ios_base::fail()&&(off_type)_Myios::rdbuf()->pubseekpos(_Pos, ios_base::in)==_BADOFF)_Myios::setstate(ios_base::failbit);
			return (*this);
		}
		_Myt&seekg(off_type _Off, ios_base::seekdir _Way)
		{
			if(!ios_base::fail()&&(off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)==_BADOFF)_Myios::setstate(ios_base::failbit);
			return (*this);
		}
		pos_type tellg()
		{
			if(!ios_base::fail())return (_Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in));
			else return (pos_type(_BADOFF));
		}
	private:
		streamsize _Chcount;
	};
	template<class _Elem, class _Traits>
	class basic_iostream: public basic_istream<_Elem, _Traits>, public basic_ostream<_Elem, _Traits>
	{
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		explicit basic_iostream(basic_streambuf<_Elem, _Traits>*_Strbuf): basic_istream<_Elem, _Traits>(_Strbuf, false), basic_ostream<_Elem, _Traits>(_Strbuf)
		{
		}
		virtual~basic_iostream()
		{
		}
	};
	template<class _Elem, class _Traits>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, _Elem*_Str)
	{
		_Debug_pointer(_Str, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\istream", 933);
		typedef basic_istream<_Elem, _Traits>_Myis;
		typedef ctype<_Elem>_Ctype;
		ios_base::iostate _State=ios_base::goodbit;
		_Elem*_Str0=_Str;
		const typename _Myis::sentry _Ok(_Istr);
		if(_Ok)
		{
			const _Ctype&_Ctype_fac=use_facet<_Ctype>(_Istr.getloc());
			try
			{
				streamsize _Count=0<_Istr.width()?_Istr.width(): 2147483647;
				typename _Myis::int_type _Meta=_Istr.rdbuf()->sgetc();
				_Elem _Ch;
				for(;
				0<--_Count;
				_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
					_State|=ios_base::eofbit;
					break;
				}
				else if(_Ctype_fac.is(_Ctype::space, _Ch=_Traits::to_char_type(_Meta))||_Ch==_Elem())break;
				else*_Str++=_Traits::to_char_type(_Meta);
			}
			catch(...)
			{
				(_Istr).setstate(ios_base::badbit, true);
			}
		}
		*_Str=_Elem();
		_Istr.width(0);
		_Istr.setstate(_Str==_Str0?_State|ios_base::failbit: _State);
		return (_Istr);
	}
	template<class _Elem, class _Traits>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, _Elem&_Ch)
	{
		typedef basic_istream<_Elem, _Traits>_Myis;
		typename _Myis::int_type _Meta;
		ios_base::iostate _State=ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr);
		if(_Ok)
		{
			try
			{
				_Meta=_Istr.rdbuf()->sbumpc();
				if(_Traits::eq_int_type(_Traits::eof(), _Meta))_State|=ios_base::eofbit|ios_base::failbit;
				else _Ch=_Traits::to_char_type(_Meta);
			}
			catch(...)
			{
				(_Istr).setstate(ios_base::badbit, true);
			}
		}
		_Istr.setstate(_State);
		return (_Istr);
	}
	template<class _Traits>
	inline basic_istream<char, _Traits>&operator>>(basic_istream<char, _Traits>&_Istr, signed char*_Str)
	{
		return (_Istr>>(char*)_Str);
	}
	template<class _Traits>
	inline basic_istream<char, _Traits>&operator>>(basic_istream<char, _Traits>&_Istr, signed char&_Ch)
	{
		return (_Istr>>(char&)_Ch);
	}
	template<class _Traits>
	inline basic_istream<char, _Traits>&operator>>(basic_istream<char, _Traits>&_Istr, unsigned char*_Str)
	{
		return (_Istr>>(char*)_Str);
	}
	template<class _Traits>
	inline basic_istream<char, _Traits>&operator>>(basic_istream<char, _Traits>&_Istr, unsigned char&_Ch)
	{
		return (_Istr>>(char&)_Ch);
	}
	template<class _Elem, class _Traits>
	inline basic_istream<_Elem, _Traits>&ws(basic_istream<_Elem, _Traits>&_Istr)
	{
		typedef basic_istream<_Elem, _Traits>_Myis;
		typedef ctype<_Elem>_Ctype;
		if(!_Istr.eof())
		{
			ios_base::iostate _State=ios_base::goodbit;
			const typename _Myis::sentry _Ok(_Istr, true);
			if(_Ok)
			{
				const _Ctype&_Ctype_fac=use_facet<_Ctype>(_Istr.getloc());
				try
				{
					for(typename _Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
					;
					_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))break;
				}
				catch(...)
				{
					(_Istr).setstate(ios_base::badbit, true);
				}
			}
			_Istr.setstate(_State);
		}
		return (_Istr);
	}
	inline basic_istream<char, char_traits<char> >&ws(basic_istream<char, char_traits<char> >&_Istr)
	{
		typedef char _Elem;
		typedef char_traits<_Elem>_Traits;
		if(!_Istr.eof())
		{
			ios_base::iostate _State=ios_base::goodbit;
			const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);
			if(_Ok)
			{
				const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Istr.getloc());
				try
				{
					for(_Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
					;
					_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta)))break;
				}
				catch(...)
				{
					(_Istr).setstate(ios_base::badbit, true);
				}
			}
			_Istr.setstate(_State);
		}
		return (_Istr);
	}
	inline basic_istream<wchar_t, char_traits<wchar_t> >&ws(basic_istream<wchar_t, char_traits<wchar_t> >&_Istr)
	{
		typedef wchar_t _Elem;
		typedef char_traits<_Elem>_Traits;
		if(!_Istr.eof())
		{
			ios_base::iostate _State=ios_base::goodbit;
			const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);
			if(_Ok)
			{
				const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Istr.getloc());
				try
				{
					for(_Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
					;
					_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
						_State|=ios_base::eofbit;
						break;
					}
					else if(!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta)))break;
				}
				catch(...)
				{
					(_Istr).setstate(ios_base::badbit, true);
				}
			}
			_Istr.setstate(_State);
		}
		return (_Istr);
	}
}
namespace std
{
	extern _iobuf*_Fiopen(const char*, ios_base::openmode, int);
	extern _iobuf*_Fiopen(const wchar_t*, ios_base::openmode, int);
	extern _iobuf*_Fiopen(const unsigned short*, ios_base::openmode, int);
	template<class _Elem>
	inline bool _Fgetc(_Elem&_Ch, _iobuf*_File)
	{
		return (fread(&_Ch, sizeof(_Elem), 1, _File)==1);
	}
	template<>
	inline bool _Fgetc(char&_Byte, _iobuf*_File)
	{
		int _Meta;
		if((_Meta=fgetc(_File))==(-1))return (false);
		else
		{
			_Byte=(char)_Meta;
			return (true);
		}
	}
	template<>
	inline bool _Fgetc(wchar_t&_Wchar, _iobuf*_File)
	{
		wint_t _Meta;
		if((_Meta=::fgetwc(_File))==(wint_t)(0xFFFF))return (false);
		else
		{
			_Wchar=(wchar_t)_Meta;
			return (true);
		}
	}
	template<class _Elem>
	inline bool _Fputc(_Elem _Ch, _iobuf*_File)
	{
		return (fwrite(&_Ch, 1, sizeof(_Elem), _File)==sizeof(_Elem));
	}
	template<>
	inline bool _Fputc(char _Byte, _iobuf*_File)
	{
		return (fputc(_Byte, _File)!=(-1));
	}
	template<>
	inline bool _Fputc(wchar_t _Wchar, _iobuf*_File)
	{
		return (::fputwc(_Wchar, _File)!=(wint_t)(0xFFFF));
	}
	template<class _Elem>
	inline bool _Ungetc(const _Elem&_Ch, _iobuf*_File)
	{
		return (false);
	}
	template<>
	inline bool _Ungetc(const char&_Byte, _iobuf*_File)
	{
		return (ungetc((unsigned char)_Byte, _File)!=(-1));
	}
	template<>
	inline bool _Ungetc(const signed char&_Byte, _iobuf*_File)
	{
		return (ungetc((unsigned char)_Byte, _File)!=(-1));
	}
	template<>
	inline bool _Ungetc(const unsigned char&_Byte, _iobuf*_File)
	{
		return (ungetc(_Byte, _File)!=(-1));
	}
	template<>
	inline bool _Ungetc(const wchar_t&_Wchar, _iobuf*_File)
	{
		return (::ungetwc(_Wchar, _File)!=(wint_t)(0xFFFF));
	}
	template<class _Elem, class _Traits>
	class basic_filebuf: public basic_streambuf<_Elem, _Traits>
	{
	public:
		typedef basic_filebuf<_Elem, _Traits>_Myt;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef typename _Traits::state_type _Myst;
		typedef codecvt<_Elem, char, typename _Traits::state_type>_Cvt;
		virtual~basic_filebuf()
		{
			if(_Closef)close();
		}
		basic_filebuf(_iobuf*_File=0): _Mysb()
		{
			_Init(_File, _Newfl);
		}
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		basic_filebuf(_Uninitialized): _Mysb(_Noinit)
		{
		}
		enum _Initfl
		{
			_Newfl, _Openfl, _Closefl
		};
		bool is_open()const
		{
			return (_Myfile!=0);
		}
		_Myt*open(const char*_Filename, ios_base::openmode _Mode, int _Prot=(int)ios_base::_Openprot)
		{
			_iobuf*_File;
			if(_Myfile!=0||(_File=_Fiopen(_Filename, _Mode, _Prot))==0)return (0);
			_Init(_File, _Openfl);
			_Initcvt((_Cvt*)&use_facet<_Cvt>(_Mysb::getloc()));
			return (this);
		}
		_Myt*open(const char*_Filename, ios_base::open_mode _Mode)
		{
			return (open(_Filename, (ios_base::openmode)_Mode));
		}
		_Myt*open(const wchar_t*_Filename, ios_base::openmode _Mode, int _Prot=(int)ios_base::_Openprot)
		{
			_iobuf*_File;
			if(_Myfile!=0||(_File=_Fiopen(_Filename, _Mode, _Prot))==0)return (0);
			_Init(_File, _Openfl);
			_Initcvt((_Cvt*)&use_facet<_Cvt>(_Mysb::getloc()));
			return (this);
		}
		_Myt*open(const wchar_t*_Filename, ios_base::open_mode _Mode)
		{
			return (open(_Filename, (ios_base::openmode)_Mode));
		}
		_Myt*open(const unsigned short*_Filename, ios_base::openmode _Mode, int _Prot=(int)ios_base::_Openprot)
		{
			_iobuf*_File;
			if(_Myfile!=0||(_File=_Fiopen(_Filename, _Mode, _Prot))==0)return (0);
			_Init(_File, _Openfl);
			_Initcvt((_Cvt*)&use_facet<_Cvt>(_Mysb::getloc()));
			return (this);
		}
		_Myt*open(const unsigned short*_Filename, ios_base::open_mode _Mode)
		{
			return (open(_Filename, (ios_base::openmode)_Mode));
		}
		_Myt*close()
		{
			_Myt*_Ans=this;
			if(_Myfile==0)_Ans=0;
			else
			{
				if(!_Endwrite())_Ans=0;
				if(fclose(_Myfile)!=0)_Ans=0;
			}
			_Init(0, _Closefl);
			return (_Ans);
		}
		protected: virtual int_type overflow(int_type _Meta=_Traits::eof())
		{
			if(_Traits::eq_int_type(_Traits::eof(), _Meta))return (_Traits::not_eof(_Meta));
			else if(_Mysb::pptr()!=0&&_Mysb::pptr()<_Mysb::epptr())
			{
				*_Mysb::_Pninc()=_Traits::to_char_type(_Meta);
				return (_Meta);
			}
			else if(_Myfile==0)return (_Traits::eof());
			else if(_Pcvt==0)return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)?_Meta: _Traits::eof());
			else
			{
				const int _STRING_INC=8;
				const _Elem _Ch=_Traits::to_char_type(_Meta);
				const _Elem*_Src;
				char*_Dest;
				string _Str(_STRING_INC, '\0');
				for(;
				;
				)switch(_Pcvt->out(_State, &_Ch, &_Ch+1, _Src, &*_Str.begin(), &*_Str.begin()+_Str.size(), _Dest))
				{
					case codecvt_base::partial: case codecvt_base::ok:
					{
						size_t _Count=_Dest-&*_Str.begin();
						if(0<_Count&&_Count!=fwrite(&*_Str.begin(), 1, _Count, _Myfile))return (_Traits::eof());
						_Wrotesome=true;
						if(_Src!=&_Ch)return (_Meta);
						if(0<_Count);
						else if(_Str.size()<4*_STRING_INC)_Str.append(_STRING_INC, '\0');
						else return (_Traits::eof());
						break;
					}
					case codecvt_base::noconv: return (_Fputc(_Ch, _Myfile)?_Meta: _Traits::eof());
					default: return (_Traits::eof());
				}
			}
		}
		virtual int_type pbackfail(int_type _Meta=_Traits::eof())
		{
			if(_Mysb::gptr()!=0&&_Mysb::eback()<_Mysb::gptr()&&(_Traits::eq_int_type(_Traits::eof(), _Meta)||_Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]), _Meta)))
			{
				_Mysb::_Gndec();
				return (_Traits::not_eof(_Meta));
			}
			else if(_Myfile==0||_Traits::eq_int_type(_Traits::eof(), _Meta))return (_Traits::eof());
			else if(_Pcvt==0&&_Ungetc(_Traits::to_char_type(_Meta), _Myfile))return (_Meta);
			else if(1<sizeof(_Elem)&&_Mysb::gptr()!=&_Mychar)
			{
				_Mychar=_Traits::to_char_type(_Meta);
				_Mysb::setg(&_Mychar, &_Mychar, &_Mychar+1);
				return (_Meta);
			}
			else return (_Traits::eof());
		}
		virtual int_type underflow()
		{
			int_type _Meta;
			if(_Mysb::gptr()!=0&&_Mysb::gptr()<_Mysb::egptr())return (_Traits::to_int_type(*_Mysb::gptr()));
			else if(_Traits::eq_int_type(_Traits::eof(), _Meta=uflow()))return (_Meta);
			else
			{
				pbackfail(_Meta);
				return (_Meta);
			}
		}
		virtual int_type uflow()
		{
			if(_Mysb::gptr()!=0&&_Mysb::gptr()<_Mysb::egptr())return (_Traits::to_int_type(*_Mysb::_Gninc()));
			else if(_Myfile==0)return (_Traits::eof());
			else if(_Pcvt==0)
			{
				_Elem _Ch;
				return (_Fgetc(_Ch, _Myfile)?_Traits::to_int_type(_Ch): _Traits::eof());
			}
			else
			{
				string _Str;
				for(;
				;
				)
				{
					_Elem _Ch, *_Dest;
					const char*_Src;
					ptrdiff_t _Nleft;
					int _Meta=fgetc(_Myfile);
					if(_Meta==(-1))return (_Traits::eof());
					_Str.append(1, (char)_Meta);
					switch(_Pcvt->in(_State, &*_Str.begin(), &*_Str.begin()+_Str.size(), _Src, &_Ch, &_Ch+1, _Dest))
					{
						case codecvt_base::partial: case codecvt_base::ok: if(_Dest!=&_Ch)
						{
							for(_Nleft=&*_Str.begin()+_Str.size()-_Src;
							0<_Nleft;
							)ungetc(_Src[--_Nleft], _Myfile);
							return (_Traits::to_int_type(_Ch));
						}
						else _Str.erase((size_t)0, (size_t)(_Src-&*_Str.begin()));
						break;
						case codecvt_base::noconv: if(_Str.size()<sizeof(_Elem))break;
						::memcpy_s((&_Ch), (sizeof(_Elem)), (&*_Str.begin()), (sizeof(_Elem)));
						return (_Traits::to_int_type(_Ch));
						default: return (_Traits::eof());
					}
				}
			}
		}
		virtual pos_type seekoff(off_type _Off, ios_base::seekdir _Way, ios_base::openmode=(ios_base::openmode)(ios_base::in|ios_base::out))
		{
			fpos_t _Fileposition;
			if(_Mysb::gptr()==&_Mychar&&_Way==ios_base::cur&&_Pcvt==0)_Off-=(off_type)sizeof(_Elem);
			if(_Myfile==0||!_Endwrite()||(_Off!=0||_Way!=ios_base::cur)&&fseek(_Myfile, (long)_Off, _Way)!=0||fgetpos(_Myfile, &_Fileposition)!=0)return (pos_type(_BADOFF));
			if(_Mysb::gptr()==&_Mychar)_Mysb::setg(&_Mychar, &_Mychar+1, &_Mychar+1);
			return (pos_type(_State, _Fileposition));
		}
		virtual pos_type seekpos(pos_type _Pos, ios_base::openmode=(ios_base::openmode)(ios_base::in|ios_base::out))
		{
			fpos_t _Fileposition=_Pos.seekpos();
			off_type _Off=(off_type)_Pos-((long)(_Fileposition));
			if(_Myfile==0||!_Endwrite()||fsetpos(_Myfile, &_Fileposition)!=0||_Off!=0&&fseek(_Myfile, (long)_Off, 1)!=0||fgetpos(_Myfile, &_Fileposition)!=0)return (pos_type(_BADOFF));
			_State=_Pos.state();
			if(_Mysb::gptr()==&_Mychar)_Mysb::setg(&_Mychar, &_Mychar+1, &_Mychar+1);
			return (pos_type(_State, _Fileposition));
		}
		virtual _Mysb*setbuf(_Elem*_Buffer, streamsize _Count)
		{
			if(_Myfile==0||setvbuf(_Myfile, (char*)_Buffer, _Buffer==0&&_Count==0?0x0004: 0x0000, _Count*sizeof(_Elem))!=0)return (0);
			else
			{
				_Init(_Myfile, _Openfl);
				return (this);
			}
		}
		virtual int sync()
		{
			return (_Myfile==0||_Traits::eq_int_type(_Traits::eof(), overflow())||0<=fflush(_Myfile)?0: -1);
		}
		virtual void imbue(const locale&_Loc)
		{
			_Initcvt((_Cvt*)&use_facet<_Cvt>(_Loc));
		}
		void _Init(_iobuf*_File, _Initfl _Which)
		{
			static _Myst _Stinit;
			_Closef=_Which==_Openfl;
			_Wrotesome=false;
			_Mysb::_Init();
			if(_File!=0&&sizeof(_Elem)==1)
			{
				_Elem**_Pb=(_Elem**)&_File->_base;
				_Elem**_Pn=(_Elem**)&_File->_ptr;
				int*_Nr=(int*)&_File->_cnt;
				int*_Nw=(int*)&_File->_cnt;
				_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
			}
			_Myfile=_File;
			_State=_Stinit;
			_Pcvt=0;
		}
		bool _Endwrite()
		{
			if(_Pcvt==0||!_Wrotesome)return (true);
			else
			{
				const int _STRING_INC=8;
				char*_Dest;
				if(_Traits::eq_int_type(_Traits::eof(), overflow()))return (false);
				string _Str(_STRING_INC, '\0');
				for(;
				;
				)switch(_Pcvt->unshift(_State, &*_Str.begin(), &*_Str.begin()+_Str.size(), _Dest))
				{
					case codecvt_base::ok: _Wrotesome=false;
					case codecvt_base::partial:
					{
						size_t _Count=_Dest-&*_Str.begin();
						if(0<_Count&&_Count!=fwrite(&*_Str.begin(), 1, _Count, _Myfile))return (false);
						if(!_Wrotesome)return (true);
						if(_Count==0)_Str.append(_STRING_INC, '\0');
						break;
					}
					case codecvt_base::noconv: return (true);
					default: return (false);
				}
			}
		}
		void _Initcvt(_Cvt*_Newpcvt)
		{
			if(_Newpcvt->always_noconv())_Pcvt=0;
			else
			{
				_Pcvt=_Newpcvt;
				_Mysb::_Init();
			}
		}
	private:
		_Cvt*_Pcvt;
		_Elem _Mychar;
		bool _Wrotesome;
		typename _Traits::state_type _State;
		bool _Closef;
		_iobuf*_Myfile;
	};
	template<class _Elem, class _Traits>
	class basic_ifstream: public basic_istream<_Elem, _Traits>
	{
	public:
		typedef basic_ifstream<_Elem, _Traits>_Myt;
		typedef basic_filebuf<_Elem, _Traits>_Myfb;
		typedef basic_ios<_Elem, _Traits>_Myios;
		basic_ifstream(): basic_istream<_Elem, _Traits>(&_Filebuffer)
		{
		}
		explicit basic_ifstream(const char*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot): basic_istream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ifstream(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot): basic_istream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ifstream(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot): basic_istream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ifstream(_iobuf*_File): basic_istream<_Elem, _Traits>(&_Filebuffer), _Filebuffer(_File)
		{
		}
		void open(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const wchar_t*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void open(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const unsigned short*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		virtual~basic_ifstream()
		{
		}
		_Myfb*rdbuf()const
		{
			return ((_Myfb*)&_Filebuffer);
		}
		bool is_open()const
		{
			return (_Filebuffer.is_open());
		}
		void open(const char*_Filename, ios_base::openmode _Mode=ios_base::in, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::in, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const char*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void close()
		{
			if(_Filebuffer.close()==0)_Myios::setstate(ios_base::failbit);
		}
	private:
		_Myfb _Filebuffer;
	};
	template<class _Elem, class _Traits>
	class basic_ofstream: public basic_ostream<_Elem, _Traits>
	{
	public:
		typedef basic_ofstream<_Elem, _Traits>_Myt;
		typedef basic_filebuf<_Elem, _Traits>_Myfb;
		typedef basic_ios<_Elem, _Traits>_Myios;
		basic_ofstream(): basic_ostream<_Elem, _Traits>(&_Filebuffer)
		{
		}
		explicit basic_ofstream(const char*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_ostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ofstream(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_ostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ofstream(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_ostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_ofstream(_iobuf*_File): basic_ostream<_Elem, _Traits>(&_Filebuffer), _Filebuffer(_File)
		{
		}
		virtual~basic_ofstream()
		{
		}
		_Myfb*rdbuf()const
		{
			return ((_Myfb*)&_Filebuffer);
		}
		bool is_open()const
		{
			return (_Filebuffer.is_open());
		}
		void open(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const wchar_t*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void open(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const unsigned short*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void open(const char*_Filename, ios_base::openmode _Mode=ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode|ios_base::out, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const char*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void close()
		{
			if(_Filebuffer.close()==0)_Myios::setstate(ios_base::failbit);
		}
	private:
		_Myfb _Filebuffer;
	};
	template<class _Elem, class _Traits>
	class basic_fstream: public basic_iostream<_Elem, _Traits>
	{
	public:
		typedef basic_fstream<_Elem, _Traits>_Myt;
		typedef basic_ios<_Elem, _Traits>_Myios;
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		basic_fstream(): basic_iostream<_Elem, _Traits>(&_Filebuffer)
		{
		}
		explicit basic_fstream(const char*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_iostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_fstream(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_iostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_fstream(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot): basic_iostream<_Elem, _Traits>(&_Filebuffer)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		explicit basic_fstream(_iobuf*_File): basic_iostream<_Elem, _Traits>(&_Filebuffer), _Filebuffer(_File)
		{
		}
		void open(const wchar_t*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const wchar_t*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void open(const unsigned short*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const unsigned short*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		virtual~basic_fstream()
		{
		}
		basic_filebuf<_Elem, _Traits>*rdbuf()const
		{
			return ((basic_filebuf<_Elem, _Traits>*)&_Filebuffer);
		}
		bool is_open()const
		{
			return (_Filebuffer.is_open());
		}
		void open(const char*_Filename, ios_base::openmode _Mode=ios_base::in|ios_base::out, int _Prot=(int)ios_base::_Openprot)
		{
			if(_Filebuffer.open(_Filename, _Mode, _Prot)==0)_Myios::setstate(ios_base::failbit);
		}
		void open(const char*_Filename, ios_base::open_mode _Mode)
		{
			open(_Filename, (ios_base::openmode)_Mode);
		}
		void close()
		{
			if(_Filebuffer.close()==0)_Myios::setstate(ios_base::failbit);
		}
	private:
		basic_filebuf<_Elem, _Traits>_Filebuffer;
	};
}
template<typename T>
struct ArrayRange
{
	const T*first;
	const T*last;
	ArrayRange(const T*first, const T*last): first(first), last(last)
	{
	}
};
template<typename T>
ArrayRange<T>makeRange(const T*first, const T*last)
{
	return ArrayRange<T>(first, last);
}
struct TypeListEnd
{
};
template<typename ItemType, typename NextType>
struct TypeList
{
	typedef ItemType Item;
	typedef NextType Next;
};
template<typename Types, size_t N>
struct TypeListNth
{
	typedef typename TypeListNth<typename Types::Next, N-1>::Result Result;
};
template<typename Types>
struct TypeListNth<Types, 0>
{
	typedef typename Types::Item Result;
};
template<typename Types>
struct TypeListCount
{
	enum
	{
		RESULT=TypeListCount<typename Types::Next>::RESULT+1
	};
};
template<>
struct TypeListCount<TypeListEnd>
{
	enum
	{
		RESULT=0
	};
};
struct Callback0
{
	typedef void(*Function)(void*data);
	Function function;
	void*data;
	Callback0(): function(defaultThunk)
	{
	}
	Callback0(Function function, void*data): function(function), data(data)
	{
	}
	void operator()()const
	{
		function(data);
	}
	static void defaultThunk(void*)
	{
	}
};
template<typename A>
struct Callback1
{
	typedef void(*Function)(void*data, A);
	Function function;
	void*data;
	Callback1(): function(defaultThunk)
	{
	}
	Callback1(Function function, void*data): function(function), data(data)
	{
	}
	void operator()(A a)const
	{
		function(data, a);
	}
	static void defaultThunk(void*, A)
	{
	}
};
template<typename Object, void(Object::*member)()>
struct Member0
{
	void*object;
	Member0(Object&object): object(&object)
	{
	}
	typedef Callback0 Result;
	static void thunk(void*object)
	{
		((*static_cast<Object*>(object)).*member)();
	}
};
template<typename Object, typename A, void(Object::*member)(A)>
struct Member1
{
	void*object;
	Member1(Object&object): object(&object)
	{
	}
	typedef Callback1<A>Result;
	static void thunk(void*object, A a)
	{
		((*static_cast<Object*>(object)).*member)(a);
	}
};
template<typename Caller>
typename Caller::Result makeCallback(Caller caller)
{
	return typename Caller::Result(Caller::thunk, caller.object);
}
namespace std
{
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(_Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(_Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(1, _Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(_Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_string<_Elem, _Traits, _Alloc>operator+(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem _Right)
	{
		return (basic_string<_Elem, _Traits, _Alloc>(_Left)+=_Right);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator==(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Left.compare(_Right)==0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator==(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Right.compare(_Left)==0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator==(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (_Left.compare(_Right)==0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator!=(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Left.compare(_Right)<0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Right.compare(_Left)>0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (_Left.compare(_Right)<0);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (_Right<_Left);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<=(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>=(const _Elem*_Left, const basic_string<_Elem, _Traits, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc>&_Left, const _Elem*_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, basic_string<_Elem, _Traits, _Alloc>&_Str)
	{
		typedef ctype<_Elem>_Ctype;
		typedef basic_istream<_Elem, _Traits>_Myis;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystr;
		typedef typename _Mystr::size_type _Mysizt;
		ios_base::iostate _State=ios_base::goodbit;
		bool _Changed=false;
		const typename _Myis::sentry _Ok(_Istr);
		if(_Ok)
		{
			const _Ctype&_Ctype_fac=use_facet<_Ctype>(_Istr.getloc());
			_Str.erase();
			try
			{
				_Mysizt _Size=0<_Istr.width()&&(_Mysizt)_Istr.width()<_Str.max_size()?(_Mysizt)_Istr.width(): _Str.max_size();
				typename _Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
				for(;
				0<_Size;
				--_Size, _Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
					_State|=ios_base::eofbit;
					break;
				}
				else if(_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))break;
				else
				{
					_Str.append(1, _Traits::to_char_type(_Meta));
					_Changed=true;
				}
			}
			catch(...)
			{
				(_Istr).setstate(ios_base::badbit, true);
			}
		}
		_Istr.width(0);
		if(!_Changed)_State|=ios_base::failbit;
		_Istr.setstate(_State);
		return (_Istr);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_istream<_Elem, _Traits>&getline(basic_istream<_Elem, _Traits>&_Istr, basic_string<_Elem, _Traits, _Alloc>&_Str, const _Elem _Delim)
	{
		typedef basic_istream<_Elem, _Traits>_Myis;
		ios_base::iostate _State=ios_base::goodbit;
		bool _Changed=false;
		const typename _Myis::sentry _Ok(_Istr, true);
		if(_Ok)
		{
			try
			{
				_Str.erase();
				const typename _Traits::int_type _Metadelim=_Traits::to_int_type(_Delim);
				typename _Traits::int_type _Meta=_Istr.rdbuf()->sgetc();
				for(;
				;
				_Meta=_Istr.rdbuf()->snextc())if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{
					_State|=ios_base::eofbit;
					break;
				}
				else if(_Traits::eq_int_type(_Meta, _Metadelim))
				{
					_Changed=true;
					_Istr.rdbuf()->sbumpc();
					break;
				}
				else if(_Str.max_size()<=_Str.size())
				{
					_State|=ios_base::failbit;
					break;
				}
				else
				{
					_Str+=_Traits::to_char_type(_Meta);
					_Changed=true;
				}
			}
			catch(...)
			{
				(_Istr).setstate(ios_base::badbit, true);
			}
		}
		if(!_Changed)_State|=ios_base::failbit;
		_Istr.setstate(_State);
		return (_Istr);
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_istream<_Elem, _Traits>&getline(basic_istream<_Elem, _Traits>&_Istr, basic_string<_Elem, _Traits, _Alloc>&_Str)
	{
		return (getline(_Istr, _Str, _Istr.widen('\n')));
	}
	template<class _Elem, class _Traits, class _Alloc>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const basic_string<_Elem, _Traits, _Alloc>&_Str)
	{
		typedef basic_ostream<_Elem, _Traits>_Myos;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystr;
		typedef typename _Mystr::size_type _Mysizt;
		ios_base::iostate _State=ios_base::goodbit;
		_Mysizt _Size=_Str.size();
		_Mysizt _Pad=_Ostr.width()<=0||(_Mysizt)_Ostr.width()<=_Size?0: (_Mysizt)_Ostr.width()-_Size;
		const typename _Myos::sentry _Ok(_Ostr);
		if(!_Ok)_State|=ios_base::badbit;
		else
		{
			try
			{
				if((_Ostr.flags()&ios_base::adjustfield)!=ios_base::left)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				if(_State==ios_base::goodbit)for(_Mysizt _Count=0;
				_Count<_Size;
				++_Count)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Str[_Count])))
				{
					_State|=ios_base::badbit;
					break;
				}
				if(_State==ios_base::goodbit)for(;
				0<_Pad;
				--_Pad)if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
				{
					_State|=ios_base::badbit;
					break;
				}
				_Ostr.width(0);
			}
			catch(...)
			{
				(_Ostr).setstate(ios_base::badbit, true);
			}
		}
		_Ostr.setstate(_State);
		return (_Ostr);
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace exception_detail
	{
		template<class T>
		class refcount_ptr
		{
		public:
			refcount_ptr(): px_(0)
			{
			}
			~refcount_ptr()
			{
				release();
			}
			refcount_ptr(refcount_ptr const&x): px_(x.px_)
			{
				add_ref();
			}
			refcount_ptr&operator=(refcount_ptr const&x)
			{
				adopt(x.px_);
				return *this;
			}
			void adopt(T*px)
			{
				release();
				px_=px;
				add_ref();
			}
			T*get()const
			{
				return px_;
			}
		private:
			T*px_;
			void add_ref()
			{
				if(px_)px_->add_ref();
			}
			void release()
			{
				if(px_)px_->release();
			}
		};
	}
	template<class Tag, class T>
	class error_info;
	typedef error_info<struct throw_function_, char const*>throw_function;
	typedef error_info<struct throw_file_, char const*>throw_file;
	typedef error_info<struct throw_line_, int>throw_line;
	template<>
	class error_info<throw_function_, char const*>
	{
	public:
		typedef char const*value_type;
		value_type v_;
		explicit error_info(value_type v): v_(v)
		{
		}
	};
	template<>
	class error_info<throw_file_, char const*>
	{
	public:
		typedef char const*value_type;
		value_type v_;
		explicit error_info(value_type v): v_(v)
		{
		}
	};
	template<>
	class error_info<throw_line_, int>
	{
	public:
		typedef int value_type;
		value_type v_;
		explicit error_info(value_type v): v_(v)
		{
		}
	};
	template<class E, class Tag, class T>
	E const&operator<<(E const&, error_info<Tag, T>const&);
	class exception;
	template<class>
	class shared_ptr;
	namespace exception_detail
	{
		class error_info_base;
		struct type_info_;
		struct error_info_container
		{
			virtual char const*diagnostic_information(char const*)const=0;
			virtual shared_ptr<error_info_base>get(type_info_ const&)const=0;
			virtual void set(shared_ptr<error_info_base>const&, type_info_ const&)=0;
			virtual void add_ref()const=0;
			virtual void release()const=0;
			protected: virtual~error_info_container()throw()
			{
			}
		};
		template<class>
		struct get_info;
		template<>
		struct get_info<throw_function>;
		template<>
		struct get_info<throw_file>;
		template<>
		struct get_info<throw_line>;
		char const*get_diagnostic_information(exception const&, char const*);
	}
	class exception
	{
		protected: exception(): throw_function_(0), throw_file_(0), throw_line_(-1)
		{
		}
		virtual~exception()throw()=0;
	private:
		template<class E>
		friend E const&operator<<(E const&x, throw_function const&y)
		{
			x.throw_function_=y.v_;
			return x;
		}
		template<class E>
		friend E const&operator<<(E const&x, throw_file const&y)
		{
			x.throw_file_=y.v_;
			return x;
		}
		template<class E>
		friend E const&operator<<(E const&x, throw_line const&y)
		{
			x.throw_line_=y.v_;
			return x;
		}
		friend char const*exception_detail::get_diagnostic_information(exception const&, char const*);
		template<class E, class Tag, class T>
		friend E const&operator<<(E const&, error_info<Tag, T>const&);
		template<class>
		friend struct exception_detail::get_info;
		friend struct exception_detail::get_info<throw_function>;
		friend struct exception_detail::get_info<throw_file>;
		friend struct exception_detail::get_info<throw_line>;
		mutable exception_detail::refcount_ptr<exception_detail::error_info_container>data_;
		mutable char const*throw_function_;
		mutable char const*throw_file_;
		mutable int throw_line_;
	};
	inline exception::~exception()throw()
	{
	}
	namespace exception_detail
	{
		template<class T>
		struct error_info_injector: public T, public exception
		{
			explicit error_info_injector(T const&x): T(x)
			{
			}
			~error_info_injector()throw()
			{
			}
		};
		struct large_size
		{
			char c[256];
		};
		large_size dispatch(exception*);
		struct small_size
		{
		};
		small_size dispatch(void*);
		template<class, int>
		struct enable_error_info_helper;
		template<class T>
		struct enable_error_info_helper<T, sizeof(large_size)>
		{
			typedef T type;
		};
		template<class T>
		struct enable_error_info_helper<T, sizeof(small_size)>
		{
			typedef error_info_injector<T>type;
		};
		template<class T>
		struct enable_error_info_return_type
		{
			typedef typename enable_error_info_helper<T, sizeof(dispatch((T*)0))>::type type;
		};
	}
	template<class T>
	inline typename exception_detail::enable_error_info_return_type<T>::type enable_error_info(T const&x)
	{
		typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
		return rt(x);
	}
	namespace exception_detail
	{
		class clone_base
		{
		public:
			virtual clone_base const*clone()const=0;
			virtual void rethrow()const=0;
			virtual~clone_base()throw()
			{
			}
		};
		inline void copy_boost_exception(exception*a, exception const*b)
		{
			*a=*b;
		}
		inline void copy_boost_exception(void*, void const*)
		{
		}
		template<class T>
		class clone_impl: public T, public clone_base
		{
		public:
			explicit clone_impl(T const&x): T(x)
			{
				copy_boost_exception(this, &x);
			}
			~clone_impl()throw()
			{
			}
		private:
			clone_base const*clone()const
			{
				return new clone_impl(*this);
			}
			void rethrow()const
			{
				throw*this;
			}
		};
	}
	template<class T>
	inline exception_detail::clone_impl<T>enable_current_exception(T const&x)
	{
		return exception_detail::clone_impl<T>(x);
	}
}
namespace boost
{
	namespace detail
	{
		inline void current_function_helper()
		{
		}
	}
}
namespace boost
{
	void throw_exception(std::exception const&e);
}
namespace std
{
	template<class _Container>
	class back_insert_iterator: public _Outit
	{
	public:
		typedef _Container container_type;
		typedef typename _Container::reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		explicit back_insert_iterator(_Container&_Cont): container(&_Cont)
		{
		}
		back_insert_iterator<_Container>&operator=(typename _Container::const_reference _Val)
		{
			container->push_back(_Val);
			return (*this);
		}
		back_insert_iterator<_Container>&operator*()
		{
			return (*this);
		}
		back_insert_iterator<_Container>&operator++()
		{
			return (*this);
		}
		back_insert_iterator<_Container>operator++(int)
		{
			return (*this);
		}
		protected: _Container*container;
	};
	template<class _Container>
	inline back_insert_iterator<_Container>back_inserter(_Container&_Cont)
	{
		return (std::back_insert_iterator<_Container>(_Cont));
	}
	template<class _Container>
	class front_insert_iterator: public _Outit
	{
	public:
		typedef _Container container_type;
		typedef typename _Container::reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		explicit front_insert_iterator(_Container&_Cont): container(&_Cont)
		{
		}
		front_insert_iterator<_Container>&operator=(typename _Container::const_reference _Val)
		{
			container->push_front(_Val);
			return (*this);
		}
		front_insert_iterator<_Container>&operator*()
		{
			return (*this);
		}
		front_insert_iterator<_Container>&operator++()
		{
			return (*this);
		}
		front_insert_iterator<_Container>operator++(int)
		{
			return (*this);
		}
		protected: _Container*container;
	};
	template<class _Container>
	inline front_insert_iterator<_Container>front_inserter(_Container&_Cont)
	{
		return (std::front_insert_iterator<_Container>(_Cont));
	}
	template<class _Container>
	class insert_iterator: public _Outit
	{
	public:
		typedef _Container container_type;
		typedef typename _Container::reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		insert_iterator(_Container&_Cont, typename _Container::iterator _Where): container(&_Cont), iter(_Where)
		{
		}
		insert_iterator<_Container>&operator=(typename _Container::const_reference _Val)
		{
			iter=container->insert(iter, _Val);
			++iter;
			return (*this);
		}
		insert_iterator<_Container>&operator*()
		{
			return (*this);
		}
		insert_iterator<_Container>&operator++()
		{
			return (*this);
		}
		insert_iterator<_Container>&operator++(int)
		{
			return (*this);
		}
		protected: _Container*container;
		typename _Container::iterator iter;
	};
	template<class _Container, class _Iter>
	inline insert_iterator<_Container>inserter(_Container&_Cont, _Iter _Where)
	{
		return (std::insert_iterator<_Container>(_Cont, _Where));
	}
	template<class _Ty, class _Elem=char, class _Traits=char_traits<_Elem>, class _Diff=ptrdiff_t>
	class istream_iterator: public iterator<input_iterator_tag, _Ty, _Diff, const _Ty*, const _Ty&>
	{
		typedef istream_iterator<_Ty, _Elem, _Traits, _Diff>_Myt;
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef basic_istream<_Elem, _Traits>istream_type;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		istream_iterator(): _Myistr(0)
		{
		}
		istream_iterator(istream_type&_Istr): _Myistr(&_Istr)
		{
			_Getval();
		}
		const _Ty&operator*()const
		{
			if(_Myistr==0)
			{
				_Debug_message(L"istream_iterator is not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 202);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 203, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 203, 0);
				};
			}
			return (_Myval);
		}
		const _Ty*operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			if(_Myistr==0)
			{
				_Debug_message(L"istream_iterator is not incrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 223);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 224, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 224, 0);
				};
			}
			_Getval();
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		bool _Equal(const _Myt&_Right)const
		{
			return (_Myistr==_Right._Myistr);
		}
		protected: void _Getval()
		{
			if(_Myistr!=0&&!(*_Myistr>>_Myval))_Myistr=0;
		}
		static void _Xran()
		{
			throw out_of_range("invalid istream_iterator");
		}
		istream_type*_Myistr;
		_Ty _Myval;
	};
	template<class _Ty, class _Elem, class _Traits, class _Diff>
	inline bool operator==(const istream_iterator<_Ty, _Elem, _Traits, _Diff>&_Left, const istream_iterator<_Ty, _Elem, _Traits, _Diff>&_Right)
	{
		return (_Left._Equal(_Right));
	}
	template<class _Ty, class _Elem, class _Traits, class _Diff>
	inline bool operator!=(const istream_iterator<_Ty, _Elem, _Traits, _Diff>&_Left, const istream_iterator<_Ty, _Elem, _Traits, _Diff>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty, class _Elem=char, class _Traits=char_traits<_Elem> >
	class ostream_iterator: public _Outit
	{
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef basic_ostream<_Elem, _Traits>ostream_type;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		ostream_iterator(ostream_type&_Ostr, const _Elem*_Delim=0): _Myostr(&_Ostr), _Mydelim(_Delim)
		{
		}
		ostream_iterator<_Ty, _Elem, _Traits>&operator=(const _Ty&_Val)
		{
			*_Myostr<<_Val;
			if(_Mydelim!=0)*_Myostr<<_Mydelim;
			if(!*_Myostr)
			{
				_Debug_message(L"ostream_iterator is not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 316);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 317, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 317, 0);
				};
			}
			return (*this);
		}
		ostream_iterator<_Ty, _Elem, _Traits>&operator*()
		{
			return (*this);
		}
		ostream_iterator<_Ty, _Elem, _Traits>&operator++()
		{
			return (*this);
		}
		ostream_iterator<_Ty, _Elem, _Traits>operator++(int)
		{
			return (*this);
		}
		protected: static void _Xran()
		{
			throw out_of_range("invalid ostream_iterator");
		}
		const _Elem*_Mydelim;
		ostream_type*_Myostr;
	};
}
namespace stdext
{
	template<class _Cont, class _Iter=typename _Cont::iterator>
	class checked_iterator: public::std::iterator<typename::std::iterator_traits<_Iter>::iterator_category, typename::std::iterator_traits<_Iter>::value_type, typename::std::iterator_traits<_Iter>::difference_type, typename::std::iterator_traits<_Iter>::pointer, typename::std::iterator_traits<_Iter>::reference>
	{
		friend class checked_iterator;
	public:
		typedef checked_iterator<_Cont, _Iter>_Myt;
		typedef typename::std::iterator_traits<_Iter>::difference_type difference_type;
		typedef typename::std::iterator_traits<_Iter>::pointer pointer;
		typedef typename::std::iterator_traits<_Iter>::reference reference;
		typedef ::std::_Range_checked_iterator_tag _Checked_iterator_category;
		typedef _Iter _Inner_type;
		typedef _Iter _Checked_iterator_base_type;
		_Checked_iterator_base_type _Checked_iterator_base()const
		{
			return _Current;
		}
		void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
		{
			_Current=_Base;
		}
		checked_iterator(): _Mycont(0)
		{
		}
		checked_iterator(_Cont&_C, _Iter _Ptr): _Mycont(&_C), _Current(_Ptr)
		{
		}
		checked_iterator(const _Myt&_Right): _Mycont(_Right._Mycont), _Current(_Right._Current)
		{
		}
		template<class Iter2>
		checked_iterator(const checked_iterator<_Cont, Iter2>&_Right): _Mycont(_Right._Mycont), _Current(_Right._Current)
		{
		}
		_Iter base()const
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 412, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 412, 0);
				}
			};
			return _Current;
		}
		template<class Iter2>
		bool operator==(const checked_iterator<_Cont, Iter2>&_Right)const
		{

			{
				if(!(_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 419, 0, L"(\"_Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 419, 0);
				}
			};
			return _Current==_Right._Current;
		}
		template<class Iter2>
		bool operator!=(const checked_iterator<_Cont, Iter2>&_Right)const
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 426, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 426, 0);
				}
			};
			return !(*this==_Right);
		}
		template<class Iter2>
		bool operator<(const checked_iterator<_Cont, Iter2>&_Right)const
		{

			{
				if(!(_Mycont!=0&&_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont != NULL && _Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 433, 0, L"(\"_Mycont != NULL && _Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 433, 0);
				}
			};
			return _Current<_Right._Current;
		}
		template<class Iter2>
		bool operator>(const checked_iterator<_Cont, Iter2>&_Right)const
		{
			return _Right<*this;
		}
		template<class Iter2>
		bool operator<=(const checked_iterator<_Cont, Iter2>&_Right)const
		{
			return !(_Right<*this);
		}
		template<class Iter2>
		bool operator>=(const checked_iterator<_Cont, Iter2>&_Right)const
		{
			return !(*this<_Right);
		}
		reference operator*()const
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 457, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 457, 0);
				}
			};

			{
				if(!(_Current!=_Mycont->end()))
				{
					(void)((!!((("_Current != _Mycont->end()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 458, 0, L"(\"_Current != _Mycont->end()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 458, 0);
				}
			};
			return *_Current;
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 469, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 469, 0);
				}
			};

			{
				if(!(_Current!=_Mycont->end()))
				{
					(void)((!!((("_Current != _Mycont->end()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 470, 0, L"(\"_Current != _Mycont->end()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 470, 0);
				}
			};
			++_Current;
			return *this;
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return _Tmp;
		}
		_Myt&operator--()
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 484, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 484, 0);
				}
			};

			{
				if(!(_Current!=_Mycont->begin()))
				{
					(void)((!!((("_Current != _Mycont->begin()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 485, 0, L"(\"_Current != _Mycont->begin()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 485, 0);
				}
			};
			--_Current;
			return *this;
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return _Tmp;
		}
		_Myt&operator+=(difference_type _Off)
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 501, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 501, 0);
				}
			};

			{
				if(!((_Mycont->end()-_Current)>=_Off&&(_Mycont->begin()-_Current)<=_Off))
				{
					(void)((!!((("(_Mycont->end() - _Current) >= _Off && (_Mycont->begin() - _Current) <= _Off", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 502, 0, L"(\"(_Mycont->end() - _Current) >= _Off && (_Mycont->begin() - _Current) <= _Off\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 502, 0);
				}
			};
			_Current+=_Off;
			return *this;
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Myt&_Right)const
		{

			{
				if(!(_Mycont!=0&&_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont != NULL && _Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 526, 0, L"(\"_Mycont != NULL && _Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 526, 0);
				}
			};
			return _Current-_Right._Current;
		}
		reference operator[](difference_type _Off)const
		{

			{
				if(!(_Mycont!=0))
				{
					(void)((!!((("_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 532, 0, L"(\"_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 532, 0);
				}
			};

			{
				if(!((_Mycont->end()-_Current)>_Off&&(_Mycont->begin()-_Current)<=_Off))
				{
					(void)((!!((("(_Mycont->end() - _Current) > _Off && (_Mycont->begin() - _Current) <= _Off", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 533, 0, L"(\"(_Mycont->end() - _Current) > _Off && (_Mycont->begin() - _Current) <= _Off\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 533, 0);
				}
			};
			return _Current[_Off];
		}
		protected: void _Xran()const
		{
			throw::std::out_of_range("invalid checked_iterator<T> subscript");
		}
		void _Xinvarg()const
		{
			throw::std::invalid_argument("invalid checked_iterator<T> argument");
		}
		_Cont*_Mycont;
		_Iter _Current;
	};
	template<class _Iterator>
	class checked_array_iterator: public::std::iterator<typename::std::iterator_traits<_Iterator>::iterator_category, typename::std::iterator_traits<_Iterator>::value_type, typename::std::iterator_traits<_Iterator>::difference_type, typename::std::iterator_traits<_Iterator>::pointer, typename::std::iterator_traits<_Iterator>::reference>
	{
	public:
		typedef checked_array_iterator<_Iterator>_Myt;
		typedef typename::std::iterator_traits<_Iterator>::difference_type difference_type;
		typedef typename::std::iterator_traits<_Iterator>::pointer pointer;
		typedef typename::std::iterator_traits<_Iterator>::reference reference;
		typedef ::std::_Range_checked_iterator_tag _Checked_iterator_category;
		typedef _Iterator _Inner_type;
		typedef _Iterator _Checked_iterator_base_type;
		_Checked_iterator_base_type _Checked_iterator_base()const
		{
			return _Mycont+_Current;
		}
		void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
		{
			_Current=_Base-_Mycont;
		}
		checked_array_iterator(): _Size(0), _Current(0)
		{
		}
		checked_array_iterator(_Iterator _Cont, size_t _S, size_t _Index=0)
		{

			{
				if(!(_Index<=_S))
				{
					(void)((!!((("_Index <= _S", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 592, 0, L"(\"_Index <= _S\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 592, 0);
				}
			};
			_Mycont=_Cont;
			_Size=_S;
			_Current=_Index;
		}
		_Iterator base()const
		{
			return _Mycont+_Current;
		}
		size_t __Size()const
		{
			return _Size;
		}
		bool operator==(const _Myt&_Right)const
		{

			{
				if(!(_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 610, 0, L"(\"_Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 610, 0);
				}
			};
			return _Current==_Right._Current;
		}
		bool operator!=(const _Myt&_Right)const
		{
			return !(*this==_Right);
		}
		bool operator<(const _Myt&_Right)const
		{

			{
				if(!(_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 621, 0, L"(\"_Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 621, 0);
				}
			};
			return _Current<_Right._Current;
		}
		bool operator>(const _Myt&_Right)const
		{
			return _Right<*this;
		}
		bool operator<=(const _Myt&_Right)const
		{
			return !(_Right<*this);
		}
		bool operator>=(const _Myt&_Right)const
		{
			return !(*this<_Right);
		}
		reference operator*()const
		{

			{
				if(!(_Current<_Size))
				{
					(void)((!!((("_Current < _Size", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 642, 0, L"(\"_Current < _Size\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 642, 0);
				}
			};
			return *(_Mycont+_Current);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		checked_array_iterator&operator++()
		{

			{
				if(!(_Current<_Size))
				{
					(void)((!!((("_Current < _Size", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 653, 0, L"(\"_Current < _Size\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 653, 0);
				}
			};
			++_Current;
			return *this;
		}
		_Myt operator++(int)
		{
			checked_array_iterator _Tmp=*this;
			++*this;
			return _Tmp;
		}
		_Myt&operator--()
		{

			{
				if(!(_Current>0))
				{
					(void)((!!((("_Current > 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 667, 0, L"(\"_Current > 0\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 667, 0);
				}
			};
			--_Current;
			return *this;
		}
		_Myt operator--(int)
		{
			checked_array_iterator _Tmp=*this;
			--*this;
			return _Tmp;
		}
		_Myt&operator+=(difference_type _Off)
		{

			{
				if(!(_Current+_Off<=_Size&&_Current+_Off>=0))
				{
					(void)((!!((("_Current + _Off <= _Size && _Current + _Off >= 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 683, 0, L"(\"_Current + _Off <= _Size && _Current + _Off >= 0\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 683, 0);
				}
			};
			_Current+=_Off;
			return *this;
		}
		_Myt operator+(difference_type _Off)const
		{
			checked_array_iterator _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			checked_array_iterator _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const checked_array_iterator&_Right)const
		{

			{
				if(!(_Mycont==_Right._Mycont))
				{
					(void)((!!((("_Mycont == _Right._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 707, 0, L"(\"_Mycont == _Right._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 707, 0);
				}
			};
			return _Current-_Right._Current;
		}
		reference operator[](difference_type _Off)const
		{

			{
				if(!(_Current+_Off<_Size&&_Current+_Off>0))
				{
					(void)((!!((("_Current + _Off < _Size && _Current + _Off > 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 713, 0, L"(\"_Current + _Off < _Size && _Current + _Off > 0\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\iterator", 713, 0);
				}
			};
			return *(_Mycont+_Current+_Off);
		}
		protected: void _Xran()const
		{
			throw::std::out_of_range("invalid checked_array_iterator<T> subscript");
		}
		void _Xinvarg()const
		{
			throw::std::invalid_argument("invalid checked_array_iterator<T> argument");
		}
		_Iterator _Mycont;
		size_t _Current;
		size_t _Size;
	};
}
namespace boost
{
	namespace detail
	{
		template<class Category, class T, class Distance, class Pointer, class Reference>
		struct iterator_base: std::iterator<Category, T, Distance, Pointer, Reference>
		{
		};
	}
	template<class Category, class T, class Distance=std::ptrdiff_t, class Pointer=T*, class Reference=T&>
	struct iterator: boost::detail::iterator_base<Category, T, Distance, Pointer, Reference>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<class T>
		struct addr_impl_ref
		{
			T&v_;
			inline addr_impl_ref(T&v): v_(v)
			{
			}
			inline operator T&()const
			{
				return v_;
			}
		private:
			addr_impl_ref&operator=(const addr_impl_ref&);
		};
		template<class T>
		struct addressof_impl
		{
			static inline T*f(T&v, long)
			{
				return reinterpret_cast<T*>(&const_cast<char&>(reinterpret_cast<const volatile char&>(v)));
			}
			static inline T*f(T*v, int)
			{
				return v;
			}
		};
	}
	template<class T>
	T*addressof(T&v)
	{
		return boost::detail::addressof_impl<T>::f(boost::detail::addr_impl_ref<T>(v), 0);
	}
}
namespace boost
{
	template<typename MemberType, int UniqueID=0>
	class base_from_member
	{
		protected: MemberType member;
		base_from_member(): member()
		{
		}
		template<typename T0>
		explicit base_from_member(T0 x0): member(x0)
		{
		}
		template<typename T0, typename T1>
		explicit base_from_member(T0 x0, T1 x1): member(x0, x1)
		{
		}
		template<typename T0, typename T1, typename T2>
		explicit base_from_member(T0 x0, T1 x1, T2 x2): member(x0, x1, x2)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3): member(x0, x1, x2, x3)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4): member(x0, x1, x2, x3, x4)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5): member(x0, x1, x2, x3, x4, x5)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6): member(x0, x1, x2, x3, x4, x5, x6)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7): member(x0, x1, x2, x3, x4, x5, x6, x7)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7, T8 x8): member(x0, x1, x2, x3, x4, x5, x6, x7, x8)
		{
		}
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
		explicit base_from_member(T0 x0, T1 x1, T2 x2, T3 x3, T4 x4, T5 x5, T6 x6, T7 x7, T8 x8, T9 x9): member(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)
		{
		}
	};
}
namespace boost
{
	template<bool B, class T=void>
	struct enable_if_c
	{
		typedef T type;
	};
	template<class T>
	struct enable_if_c<false, T>
	{
	};
	template<class Cond, class T=void>
	struct enable_if: public enable_if_c<Cond::value, T>
	{
	};
	template<bool B, class T>
	struct lazy_enable_if_c
	{
		typedef typename T::type type;
	};
	template<class T>
	struct lazy_enable_if_c<false, T>
	{
	};
	template<class Cond, class T>
	struct lazy_enable_if: public lazy_enable_if_c<Cond::value, T>
	{
	};
	template<bool B, class T=void>
	struct disable_if_c
	{
		typedef T type;
	};
	template<class T>
	struct disable_if_c<true, T>
	{
	};
	template<class Cond, class T=void>
	struct disable_if: public disable_if_c<Cond::value, T>
	{
	};
	template<bool B, class T>
	struct lazy_disable_if_c
	{
		typedef typename T::type type;
	};
	template<class T>
	struct lazy_disable_if_c<true, T>
	{
	};
	template<class Cond, class T>
	struct lazy_disable_if: public lazy_disable_if_c<Cond::value, T>
	{
	};
}
namespace boost
{
	template<class T>
	inline void checked_delete(T*x)
	{
		typedef char type_must_be_complete[sizeof(T)?1: -1];
		(void)sizeof(type_must_be_complete);
		delete x;
	}
	template<class T>
	inline void checked_array_delete(T*x)
	{
		typedef char type_must_be_complete[sizeof(T)?1: -1];
		(void)sizeof(type_must_be_complete);
		delete[]x;
	}
	template<class T>
	struct checked_deleter
	{
		typedef void result_type;
		typedef T*argument_type;
		void operator()(T*x)const
		{
			boost::checked_delete(x);
		}
	};
	template<class T>
	struct checked_array_deleter
	{
		typedef void result_type;
		typedef T*argument_type;
		void operator()(T*x)const
		{
			boost::checked_array_delete(x);
		}
	};
}
namespace boost
{
	template<class T>
	inline T next(T x)
	{
		return ++x;
	}
	template<class T, class Distance>
	inline T next(T x, Distance n)
	{
		std::advance(x, n);
		return x;
	}
	template<class T>
	inline T prior(T x)
	{
		return --x;
	}
	template<class T, class Distance>
	inline T prior(T x, Distance n)
	{
		std::advance(x, -n);
		return x;
	}
}
namespace boost
{
	namespace noncopyable_
	{
		class noncopyable
		{
			protected: noncopyable()
			{
			}
			~noncopyable()
			{
			}
		private:
			noncopyable(const noncopyable&);
			const noncopyable&operator=(const noncopyable&);
		};
	}
	typedef noncopyable_::noncopyable noncopyable;
}
namespace boost
{
	template<bool x>
	struct STATIC_ASSERTION_FAILURE;
	template<>
	struct STATIC_ASSERTION_FAILURE<true>
	{
		enum
		{
			value=1
		};
	};
	template<int x>
	struct static_assert_test
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<class Iterator>
		struct iterator_traits: std::iterator_traits<Iterator>
		{
		};
		using std::distance;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct value_type_wknd
			{
				typedef typename T::value_type type;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		struct void_;
	}
}
namespace boost
{
	namespace mpl
	{
		template<bool C_>
		struct bool_;
		typedef bool_<true>true_;
		typedef bool_<false>false_;
	}
}
namespace boost
{
	namespace mpl
	{
		struct integral_c_tag
		{
			static const int value=0;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<bool C_>
		struct bool_
		{
			static const bool value=C_;
			typedef integral_c_tag tag;
			typedef bool_ type;
			typedef bool value_type;
			operator bool()const
			{
				return this->value;
			}
		};
		template<bool C_>
		bool const bool_<C_>::value;
	}
}
namespace boost
{
	namespace mpl
	{
		struct na
		{
			typedef na type;
			enum
			{
				value=0
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T>
		struct is_na: false_
		{
		};
		template<>
		struct is_na<na>: true_
		{
		};
		template<typename T>
		struct is_not_na: true_
		{
		};
		template<>
		struct is_not_na<na>: false_
		{
		};
		template<typename T, typename U>
		struct if_na
		{
			typedef T type;
		};
		template<typename U>
		struct if_na<na, U>
		{
			typedef U type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<int N>
		struct int_;
	}
}
namespace boost
{
	namespace mpl
	{
		template<int N>
		struct int_
		{
			static const int value=N;
			typedef int_ type;
			typedef int value_type;
			typedef integral_c_tag tag;
			typedef boost::mpl::int_<static_cast<int>((value+1))>next;
			typedef boost::mpl::int_<static_cast<int>((value-1))>prior;
			operator int()const
			{
				return static_cast<int>(this->value);
			}
		};
		template<int N>
		int const boost::mpl::int_<N>::value;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename F>
			struct template_arity;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na, typename Tag=void_>
		struct lambda;
	}
}
namespace boost
{
	namespace mpl
	{
		template<bool C, typename T1, typename T2>
		struct if_c
		{
			typedef T1 type;
		};
		template<typename T1, typename T2>
		struct if_c<false, T1, T2>
		{
			typedef T2 type;
		};
		template<typename T1=na, typename T2=na, typename T3=na>
		struct if_
		{
		private:
			typedef if_c<static_cast<bool>(T1::value), T2, T3>almost_type_;
		public:
			typedef typename almost_type_::type type;
		};
		template<>
		struct if_<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: if_<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<if_<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef if_<na, na, na>result_;
			typedef if_<na, na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename C=na, typename F1=na, typename F2=na>
		struct eval_if: if_<C, F1, F2>::type
		{
		};
		template<bool C, typename F1, typename F2>
		struct eval_if_c: if_c<C, F1, F2>::type
		{
		};
		template<>
		struct eval_if<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: eval_if<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<eval_if<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef eval_if<na, na, na>result_;
			typedef eval_if<na, na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na>
		struct identity
		{
			typedef T type;
		};
		template<typename T=na>
		struct make_identity
		{
			typedef identity<T>type;
		};
		template<>
		struct identity<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: identity<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<identity<na>, Tag>
		{
			typedef false_ is_le;
			typedef identity<na>result_;
			typedef identity<na>type;
		};
		template<>
		struct make_identity<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: make_identity<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<make_identity<na>, Tag>
		{
			typedef false_ is_le;
			typedef make_identity<na>result_;
			typedef make_identity<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<int N>
		struct arg;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<long C_>
			struct not_impl: bool_<!C_>
			{
			};
		}
		template<typename T=na>
		struct not_: aux::not_impl<T::type::value>
		{
		};
		template<>
		struct not_<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: not_<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<not_<na>, Tag>
		{
			typedef false_ is_le;
			typedef not_<na>result_;
			typedef not_<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			typedef char(&no_tag)[1];
			typedef char(&yes_tag)[2];
			template<bool C_>
			struct yes_no_tag
			{
				typedef no_tag type;
			};
			template<>
			struct yes_no_tag<true>
			{
				typedef yes_tag type;
			};
			template<long n>
			struct weighted_tag
			{
				typedef char(&type)[n];
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		struct failed
		{
		};
		template<bool C>
		struct assert
		{
			typedef void*type;
		};
		template<>
		struct assert<false>
		{
			typedef assert type;
		};
		template<bool C>
		int assertion_failed(typename assert<C>::type);
		template<bool C>
		struct assertion
		{
			static int failed(assert<false>);
		};
		template<>
		struct assertion<true>
		{
			static int failed(void*);
		};
		struct assert_
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na>
			struct types
			{
			};
			static assert_ const arg;
			enum relations
			{
				equal=1, not_equal, greater, greater_equal, less, less_equal
			};
		};
		bool operator==(failed, failed);
		bool operator!=(failed, failed);
		bool operator>(failed, failed);
		bool operator>=(failed, failed);
		bool operator<(failed, failed);
		bool operator<=(failed, failed);
		template<long x, long y, bool(*)(failed, failed)>
		struct assert_relation
		{
		};
		template<bool>
		struct assert_arg_pred_impl
		{
			typedef int type;
		};
		template<>
		struct assert_arg_pred_impl<true>
		{
			typedef void*type;
		};
		template<typename P>
		struct assert_arg_pred
		{
			typedef typename P::type p_type;
			typedef typename assert_arg_pred_impl<p_type::value>::type type;
		};
		template<typename P>
		struct assert_arg_pred_not
		{
			typedef typename P::type p_type;
			static const bool p=!p_type::value;
			typedef typename assert_arg_pred_impl<p>::type type;
		};
		template<typename Pred>
		failed************(Pred::************assert_arg(void(*)(Pred), typename assert_arg_pred<Pred>::type));
		template<typename Pred>
		failed************(boost::mpl::not_<Pred>::************assert_not_arg(void(*)(Pred), typename assert_arg_pred_not<Pred>::type));
		template<typename Pred>
		assert<false>assert_arg(void(*)(Pred), typename assert_arg_pred_not<Pred>::type);
		template<typename Pred>
		assert<false>assert_not_arg(void(*)(Pred), typename assert_arg_pred<Pred>::type);
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct arg<-1>
		{
			static const int value=-1;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U1 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<1>
		{
			static const int value=1;
			typedef arg<2>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U1 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<2>
		{
			static const int value=2;
			typedef arg<3>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U2 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<3>
		{
			static const int value=3;
			typedef arg<4>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U3 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<4>
		{
			static const int value=4;
			typedef arg<5>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U4 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
		template<>
		struct arg<5>
		{
			static const int value=5;
			typedef arg<6>next;
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
				typedef U5 type;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(boost::mpl::is_na<type>))0, 1)));
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<-1>_;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<1>_1;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_1;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<2>_2;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_2;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<3>_3;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_3;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<4>_4;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_4;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<5>_5;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_5;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		typedef arg<6>_6;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace placeholders
		{
			using boost::mpl::_6;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T, T N>
		struct integral_c;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T, T N>
		struct integral_c
		{
			static const T value=N;
			typedef integral_c type;
			typedef T value_type;
			typedef integral_c_tag tag;
			typedef integral_c<T, static_cast<T>((value+1))>next;
			typedef integral_c<T, static_cast<T>((value-1))>prior;
			operator T()const
			{
				return static_cast<T>(this->value);
			}
		};
		template<typename T, T N>
		T const integral_c<T, N>::value;
	}
}
namespace boost
{
	namespace mpl
	{
		template<bool C>
		struct integral_c<bool, C>
		{
			static const bool value=C;
			typedef integral_c_tag tag;
			typedef integral_c type;
			typedef bool value_type;
			operator bool()const
			{
				return this->value;
			}
		};
	}
}
namespace boost
{
	template<class T, T val>
	struct integral_constant: public mpl::integral_c<T, val>
	{
		typedef integral_constant<T, val>type;
	};
	template<>
	struct integral_constant<bool, true>: public mpl::true_
	{
		typedef integral_constant<bool, true>type;
	};
	template<>
	struct integral_constant<bool, false>: public mpl::false_
	{
		typedef integral_constant<bool, false>type;
	};
	typedef integral_constant<bool, true>true_type;
	typedef integral_constant<bool, false>false_type;
}
namespace boost
{
	template<typename T, typename U>
	struct is_same: ::boost::integral_constant<bool, false>
	{
	};
	template<typename T>
	struct is_same<T, T>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace type_traits
	{
		typedef char yes_type;
		struct no_type
		{
			char padding[8];
		};
	}
}
namespace boost
{
	template<typename T>
	struct is_array: ::boost::integral_constant<bool, false>
	{
	};
	template<typename T, std::size_t N>
	struct is_array<T[N]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, std::size_t N>
	struct is_array<T const[N]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, std::size_t N>
	struct is_array<T volatile[N]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, std::size_t N>
	struct is_array<T const volatile[N]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T>
	struct is_array<T[]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T>
	struct is_array<T const[]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T>
	struct is_array<T volatile[]>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T>
	struct is_array<T const volatile[]>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_reference: ::boost::integral_constant<bool, false>
	{
	};
	template<typename T>
	struct is_reference<T&>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct add_reference_impl
		{
			typedef T&type;
		};
		template<typename T>
		struct add_reference_impl<T&>
		{
			typedef T&type;
		};
		template<>
		struct add_reference_impl<void>
		{
			typedef void type;
		};
		template<>
		struct add_reference_impl<void const>
		{
			typedef void const type;
		};
		template<>
		struct add_reference_impl<void volatile>
		{
			typedef void volatile type;
		};
		template<>
		struct add_reference_impl<void const volatile>
		{
			typedef void const volatile type;
		};
	}
	template<typename T>
	struct add_reference
	{
		typedef typename boost::detail::add_reference_impl<T>::type type;
	};
}
namespace boost
{
	namespace type_traits
	{
		template<bool b1, bool b2, bool b3=false, bool b4=false, bool b5=false, bool b6=false, bool b7=false>
		struct ice_or;
		template<bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
		struct ice_or
		{
			static const bool value=true;
		};
		template<>
		struct ice_or<false, false, false, false, false, false, false>
		{
			static const bool value=false;
		};
	}
}
namespace boost
{
	namespace type_traits
	{
		template<bool b1, bool b2, bool b3=true, bool b4=true, bool b5=true, bool b6=true, bool b7=true>
		struct ice_and;
		template<bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
		struct ice_and
		{
			static const bool value=false;
		};
		template<>
		struct ice_and<true, true, true, true, true, true, true>
		{
			static const bool value=true;
		};
	}
}
namespace boost
{
	namespace type_traits
	{
		template<bool b>
		struct ice_not
		{
			static const bool value=true;
		};
		template<>
		struct ice_not<true>
		{
			static const bool value=false;
		};
	}
}
namespace boost
{
	namespace type_traits
	{
		template<int b1, int b2>
		struct ice_eq
		{
			static const bool value=(b1==b2);
		};
		template<int b1, int b2>
		struct ice_ne
		{
			static const bool value=(b1!=b2);
		};
		template<int b1, int b2>
		bool const ice_eq<b1, b2>::value;
		template<int b1, int b2>
		bool const ice_ne<b1, b2>::value;
	}
}
namespace boost
{
	template<typename T>
	struct is_integral: ::boost::integral_constant<bool, false>
	{
	};
	template<>
	struct is_integral<unsigned char>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned char const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned char volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned char const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned short>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned short const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned short volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned short const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned int>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned int const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned int volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned int const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned long>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned long const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned long volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned long const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed char>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed char const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed char volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed char const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed short>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed short const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed short volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed short const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed int>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed int const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed int volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed int const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed long>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed long const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed long volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<signed long const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<bool>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<bool const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<bool volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<bool const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<char>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<char const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<char volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<char const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<wchar_t>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<wchar_t const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<wchar_t volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<wchar_t const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned __int64>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned __int64 const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned __int64 volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<unsigned __int64 const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<__int64>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<__int64 const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<__int64 volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_integral<__int64 const volatile>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_float: ::boost::integral_constant<bool, false>
	{
	};
	template<>
	struct is_float<float>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<float const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<float volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<float const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<double>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<double const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<double volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<double const volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<long double>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<long double const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<long double volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_float<long double const volatile>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_arithmetic_impl
		{
			static const bool value=(::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value>::value);
		};
	}
	template<typename T>
	struct is_arithmetic: ::boost::integral_constant<bool, ::boost::detail::is_arithmetic_impl<T>::value>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_void: ::boost::integral_constant<bool, false>
	{
	};
	template<>
	struct is_void<void>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_void<void const>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_void<void volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<>
	struct is_void<void const volatile>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<class T>
		struct is_abstract_imp
		{
			static const bool value=__is_abstract(T);
		};
	}
	template<typename T>
	struct is_abstract: ::boost::integral_constant<bool, ::boost::detail::is_abstract_imp<T>::value>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename From, typename To>
		struct is_convertible_basic_impl
		{
			static::boost::type_traits::no_type _m_check(...);
			static::boost::type_traits::yes_type _m_check(To);
			static From _m_from;
			static const bool value=sizeof(_m_check(_m_from))==sizeof(::boost::type_traits::yes_type);
		};
		template<typename From, typename To>
		struct is_convertible_impl
		{
			typedef typename add_reference<From>::type ref_type;
			static const bool value=(::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::detail::is_convertible_basic_impl<ref_type, To>::value, ::boost::is_void<To>::value>::value, ::boost::type_traits::ice_not< ::boost::is_array<To>::value>::value>::value);
		};
		template<bool trivial1, bool trivial2, bool abstract_target>
		struct is_convertible_impl_select
		{
			template<class From, class To>
			struct rebind
			{
				typedef is_convertible_impl<From, To>type;
			};
		};
		template<>
		struct is_convertible_impl_select<true, true, false>
		{
			template<class From, class To>
			struct rebind
			{
				typedef true_type type;
			};
		};
		template<>
		struct is_convertible_impl_select<false, false, true>
		{
			template<class From, class To>
			struct rebind
			{
				typedef false_type type;
			};
		};
		template<>
		struct is_convertible_impl_select<true, false, true>
		{
			template<class From, class To>
			struct rebind
			{
				typedef false_type type;
			};
		};
		template<typename From, typename To>
		struct is_convertible_impl_dispatch_base
		{
			typedef is_convertible_impl_select< ::boost::is_arithmetic<From>::value, ::boost::is_arithmetic<To>::value, ::boost::is_abstract<To>::value>selector;
			typedef typename selector::template rebind<From, To>isc_binder;
			typedef typename isc_binder::type type;
		};
		template<typename From, typename To>
		struct is_convertible_impl_dispatch: public is_convertible_impl_dispatch_base<From, To>::type
		{
		};
		template<>
		struct is_convertible_impl<void, void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void, void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void, void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void, void const volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const, void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const, void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const, void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const, void const volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void volatile, void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void volatile, void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void volatile, void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void volatile, void const volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const volatile, void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const volatile, void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const volatile, void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_convertible_impl<void const volatile, void const volatile>
		{
			static const bool value=(true);
		};
		template<typename To>
		struct is_convertible_impl<void, To>
		{
			static const bool value=(false);
		};
		template<typename From>
		struct is_convertible_impl<From, void>
		{
			static const bool value=(true);
		};
		template<typename To>
		struct is_convertible_impl<void const, To>
		{
			static const bool value=(false);
		};
		template<typename To>
		struct is_convertible_impl<void volatile, To>
		{
			static const bool value=(false);
		};
		template<typename To>
		struct is_convertible_impl<void const volatile, To>
		{
			static const bool value=(false);
		};
		template<typename From>
		struct is_convertible_impl<From, void const>
		{
			static const bool value=(true);
		};
		template<typename From>
		struct is_convertible_impl<From, void volatile>
		{
			static const bool value=(true);
		};
		template<typename From>
		struct is_convertible_impl<From, void const volatile>
		{
			static const bool value=(true);
		};
	}
	template<typename From, typename To>
	struct is_convertible: ::boost::integral_constant<bool, (::boost::detail::is_convertible_impl_dispatch<From, To>::value)>
	{
	};
}
namespace boost
{
	struct no_traversal_tag
	{
	};
	struct incrementable_traversal_tag: no_traversal_tag
	{
	};
	struct single_pass_traversal_tag: incrementable_traversal_tag
	{
	};
	struct forward_traversal_tag: single_pass_traversal_tag
	{
	};
	struct bidirectional_traversal_tag: forward_traversal_tag
	{
	};
	struct random_access_traversal_tag: bidirectional_traversal_tag
	{
	};
	namespace detail
	{
		template<class Cat>
		struct old_category_to_traversal: mpl::eval_if<is_convertible<Cat, std::random_access_iterator_tag>, mpl::identity<random_access_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::bidirectional_iterator_tag>, mpl::identity<bidirectional_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::forward_iterator_tag>, mpl::identity<forward_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::input_iterator_tag>, mpl::identity<single_pass_traversal_tag>, mpl::eval_if<is_convertible<Cat, std::output_iterator_tag>, mpl::identity<incrementable_traversal_tag>, void> > > > >
		{
		};
		template<class Traversal>
		struct pure_traversal_tag: mpl::eval_if<is_convertible<Traversal, random_access_traversal_tag>, mpl::identity<random_access_traversal_tag>, mpl::eval_if<is_convertible<Traversal, bidirectional_traversal_tag>, mpl::identity<bidirectional_traversal_tag>, mpl::eval_if<is_convertible<Traversal, forward_traversal_tag>, mpl::identity<forward_traversal_tag>, mpl::eval_if<is_convertible<Traversal, single_pass_traversal_tag>, mpl::identity<single_pass_traversal_tag>, mpl::eval_if<is_convertible<Traversal, incrementable_traversal_tag>, mpl::identity<incrementable_traversal_tag>, void> > > > >
		{
		};
	}
	template<class Cat>
	struct iterator_category_to_traversal: mpl::eval_if<is_convertible<Cat, incrementable_traversal_tag>, mpl::identity<Cat>, boost::detail::old_category_to_traversal<Cat> >
	{
	};
	template<class Iterator=mpl::_1>
	struct iterator_traversal: iterator_category_to_traversal<typename boost::detail::iterator_traits<Iterator>::iterator_category>
	{
	};
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<bool C_, typename T1, typename T2, typename T3, typename T4>
			struct or_impl: true_
			{
			};
			template<typename T1, typename T2, typename T3, typename T4>
			struct or_impl<false, T1, T2, T3, T4>: or_impl<T1::type::value, T2, T3, T4, false_>
			{
			};
			template<>
			struct or_impl<false, false_, false_, false_, false_>: false_
			{
			};
		}
		template<typename T1=na, typename T2=na, typename T3=false_, typename T4=false_, typename T5=false_>
		struct or_: aux::or_impl<T1::type::value, T2, T3, T4, T5>
		{
		};
		template<>
		struct or_<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: or_<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<or_<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef or_<na, na>result_;
			typedef or_<na, na>type;
		};
	}
}
namespace boost
{
	template<typename A, typename B>
	struct is_interoperable: mpl::or_<is_convertible<A, B>, is_convertible<B, A> >
	{
	};
}
namespace boost
{
	template<class Iterator>
	struct iterator_value
	{
		typedef typename boost::detail::iterator_traits<Iterator>::value_type type;
	};
	template<class Iterator>
	struct iterator_reference
	{
		typedef typename boost::detail::iterator_traits<Iterator>::reference type;
	};
	template<class Iterator>
	struct iterator_pointer
	{
		typedef typename boost::detail::iterator_traits<Iterator>::pointer type;
	};
	template<class Iterator>
	struct iterator_difference
	{
		typedef typename boost::detail::iterator_traits<Iterator>::difference_type type;
	};
	template<class Iterator>
	struct iterator_category
	{
		typedef typename boost::detail::iterator_traits<Iterator>::iterator_category type;
	};
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<bool C_, typename T1, typename T2, typename T3, typename T4>
			struct and_impl: false_
			{
			};
			template<typename T1, typename T2, typename T3, typename T4>
			struct and_impl<true, T1, T2, T3, T4>: and_impl<T1::type::value, T2, T3, T4, true_>
			{
			};
			template<>
			struct and_impl<true, true_, true_, true_, true_>: true_
			{
			};
		}
		template<typename T1=na, typename T2=na, typename T3=true_, typename T4=true_, typename T5=true_>
		struct and_: aux::and_impl<T1::type::value, T2, T3, T4, T5>
		{
		};
		template<>
		struct and_<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: and_<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<and_<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef and_<na, na>result_;
			typedef and_<na, na>type;
		};
	}
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct cv_traits_imp
		{
		};
		template<typename T>
		struct cv_traits_imp<T*>
		{
			static const bool is_const=false;
			static const bool is_volatile=false;
			typedef T unqualified_type;
		};
		template<typename T>
		struct cv_traits_imp<const T*>
		{
			static const bool is_const=true;
			static const bool is_volatile=false;
			typedef T unqualified_type;
		};
		template<typename T>
		struct cv_traits_imp<volatile T*>
		{
			static const bool is_const=false;
			static const bool is_volatile=true;
			typedef T unqualified_type;
		};
		template<typename T>
		struct cv_traits_imp<const volatile T*>
		{
			static const bool is_const=true;
			static const bool is_volatile=true;
			typedef T unqualified_type;
		};
	}
}
namespace boost
{
	template<typename T>
	struct is_const: ::boost::integral_constant<bool, ::boost::detail::cv_traits_imp<T*>::is_const>
	{
	};
	template<typename T>
	struct is_const<T&>: ::boost::integral_constant<bool, false>
	{
	};
}
namespace boost
{
	namespace type_traits
	{
		struct false_result
		{
			template<typename T>
			struct result_
			{
				static const bool value=false;
			};
		};
	}
}
namespace boost
{
	namespace type_traits
	{
		template<class R>
		struct is_function_ptr_helper
		{
			static const bool value=false;
		};
		template<class R>
		struct is_function_ptr_helper<R(*)()>
		{
			static const bool value=true;
		};
		template<class R>
		struct is_function_ptr_helper<R(*)(...)>
		{
			static const bool value=true;
		};
		template<class R, class T0>
		struct is_function_ptr_helper<R(*)(T0)>
		{
			static const bool value=true;
		};
		template<class R, class T0>
		struct is_function_ptr_helper<R(*)(T0...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1>
		struct is_function_ptr_helper<R(*)(T0, T1)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1>
		struct is_function_ptr_helper<R(*)(T0, T1...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2>
		struct is_function_ptr_helper<R(*)(T0, T1, T2)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2>
		struct is_function_ptr_helper<R(*)(T0, T1, T2...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)>
		{
			static const bool value=true;
		};
		template<class R, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_function_ptr_helper<R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)>
		{
			static const bool value=true;
		};
	}
}
namespace boost
{
	namespace detail
	{
		template<bool is_ref=true>
		struct is_function_chooser: ::boost::type_traits::false_result
		{
		};
		template<>
		struct is_function_chooser<false>
		{
			template<typename T>
			struct result_: ::boost::type_traits::is_function_ptr_helper<T*>
			{
			};
		};
		template<typename T>
		struct is_function_impl: is_function_chooser< ::boost::is_reference<T>::value>::template result_<T>
		{
		};
	}
	template<typename T>
	struct is_function: ::boost::integral_constant<bool, ::boost::detail::is_function_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace type_traits
	{
		template<typename T>
		struct is_mem_fun_pointer_impl
		{
			static const bool value=false;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)()>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)(...)>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)()const>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)()volatile>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)()const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)(...)const>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)(...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T>
		struct is_mem_fun_pointer_impl<R(T::*)(...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0>
		struct is_mem_fun_pointer_impl<R(T::*)(T0...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23...)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)const volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)const>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)volatile>
		{
			static const bool value=true;
		};
		template<class R, class T, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24>
		struct is_mem_fun_pointer_impl<R(T::*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24...)const volatile>
		{
			static const bool value=true;
		};
	}
}
namespace boost
{
	template<typename T>
	struct remove_cv
	{
		typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type;
	};
	template<typename T>
	struct remove_cv<T&>
	{
		typedef T&type;
	};
	template<typename T, std::size_t N>
	struct remove_cv<T const[N]>
	{
		typedef T type[N];
	};
	template<typename T, std::size_t N>
	struct remove_cv<T volatile[N]>
	{
		typedef T type[N];
	};
	template<typename T, std::size_t N>
	struct remove_cv<T const volatile[N]>
	{
		typedef T type[N];
	};
}
namespace boost
{
	template<typename T>
	struct is_member_function_pointer: ::boost::integral_constant<bool, ::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_member_pointer: ::boost::integral_constant<bool, ::boost::is_member_function_pointer<T>::value>
	{
	};
	template<typename T, typename U>
	struct is_member_pointer<U T::*>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, typename U>
	struct is_member_pointer<U T::*const>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, typename U>
	struct is_member_pointer<U T::*volatile>: ::boost::integral_constant<bool, true>
	{
	};
	template<typename T, typename U>
	struct is_member_pointer<U T::*const volatile>: ::boost::integral_constant<bool, true>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_pointer_helper
		{
			static const bool value=false;
		};
		template<typename T>
		struct is_pointer_helper<T*>
		{
			static const bool value=true;
		};
		template<typename T>
		struct is_pointer_impl
		{
			static const bool value=(::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value, ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value>::value>::value);
		};
	}
	template<typename T>
	struct is_pointer: ::boost::integral_constant<bool, ::boost::detail::is_pointer_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_class_impl
		{
			static const bool value=__is_class(T);
		};
	}
	template<typename T>
	struct is_class: ::boost::integral_constant<bool, ::boost::detail::is_class_impl<T>::value>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_volatile: ::boost::integral_constant<bool, ::boost::detail::cv_traits_imp<T*>::is_volatile>
	{
	};
	template<typename T>
	struct is_volatile<T&>: ::boost::integral_constant<bool, false>
	{
	};
}
namespace boost
{
	template<typename T>
	struct remove_reference
	{
		typedef T type;
	};
	template<typename T>
	struct remove_reference<T&>
	{
		typedef T type;
	};
}
namespace boost
{
	template<typename T>
	struct remove_pointer
	{
		typedef T type;
	};
	template<typename T>
	struct remove_pointer<T*>
	{
		typedef T type;
	};
	template<typename T>
	struct remove_pointer<T*const>
	{
		typedef T type;
	};
	template<typename T>
	struct remove_pointer<T*volatile>
	{
		typedef T type;
	};
	template<typename T>
	struct remove_pointer<T*const volatile>
	{
		typedef T type;
	};
}
namespace boost
{
	namespace detail
	{
		namespace indirect_traits
		{
			template<class T>
			struct is_reference_to_const: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_const<T const&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_function: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_function<T&>: is_function<T>
			{
			};
			template<class T>
			struct is_pointer_to_function: mpl::false_
			{
			};
			template<class T>
			struct is_pointer_to_function<T*>: is_function<T>
			{
			};
			template<class T>
			struct is_reference_to_member_function_pointer_impl: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_member_function_pointer_impl<T&>: is_member_function_pointer<typename remove_cv<T>::type>
			{
			};
			template<class T>
			struct is_reference_to_member_function_pointer: is_reference_to_member_function_pointer_impl<T>
			{
			};
			template<class T>
			struct is_reference_to_function_pointer_aux: mpl::and_<is_reference<T>, is_pointer_to_function<typename remove_cv<typename remove_reference<T>::type>::type> >
			{
			};
			template<class T>
			struct is_reference_to_function_pointer: mpl::if_<is_reference_to_function<T>, mpl::false_, is_reference_to_function_pointer_aux<T> >::type
			{
			};
			template<class T>
			struct is_reference_to_non_const: mpl::and_<is_reference<T>, mpl::not_<is_reference_to_const<T> > >
			{
			};
			template<class T>
			struct is_reference_to_volatile: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_volatile<T volatile&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_pointer: mpl::false_
			{
			};
			template<class T>
			struct is_reference_to_pointer<T*&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_pointer<T*const&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_pointer<T*volatile&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_pointer<T*const volatile&>: mpl::true_
			{
			};
			template<class T>
			struct is_reference_to_class: mpl::and_<is_reference<T>, is_class<typename remove_cv<typename remove_reference<T>::type>::type> >
			{
			};
			template<class T>
			struct is_pointer_to_class: mpl::and_<is_pointer<T>, is_class<typename remove_cv<typename remove_pointer<T>::type>::type> >
			{
			};
		}
		using namespace indirect_traits;
	}
}
namespace boost
{
	struct use_default;
}
namespace boost
{
	namespace detail
	{
		struct input_output_iterator_tag: std::input_iterator_tag
		{
			operator std::output_iterator_tag()const
			{
				return std::output_iterator_tag();
			}
		};
		template<class ValueParam, class Reference>
		struct iterator_writability_disabled: mpl::or_<is_const<Reference>, boost::detail::indirect_traits::is_reference_to_const<Reference>, is_const<ValueParam> >
		{
		};
		template<class Traversal, class ValueParam, class Reference>
		struct iterator_facade_default_category: mpl::eval_if<mpl::and_<is_reference<Reference>, is_convertible<Traversal, forward_traversal_tag> >, mpl::eval_if<is_convertible<Traversal, random_access_traversal_tag>, mpl::identity<std::random_access_iterator_tag>, mpl::if_<is_convertible<Traversal, bidirectional_traversal_tag>, std::bidirectional_iterator_tag, std::forward_iterator_tag> >, typename mpl::eval_if<mpl::and_<is_convertible<Traversal, single_pass_traversal_tag>, is_convertible<Reference, ValueParam> >, mpl::identity<std::input_iterator_tag>, mpl::identity<Traversal> > >
		{
		};
		template<class T>
		struct is_iterator_category: mpl::or_<is_convertible<T, std::input_iterator_tag>, is_convertible<T, std::output_iterator_tag> >
		{
		};
		template<class T>
		struct is_iterator_traversal: is_convertible<T, incrementable_traversal_tag>
		{
		};
		template<class Category, class Traversal>
		struct iterator_category_with_traversal: Category, Traversal
		{
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(is_convertible<typename iterator_category_to_traversal<Category>::type, Traversal>))0, 1)));
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_arg((void(*)(is_iterator_category<Category>))0, 1)));
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(is_iterator_category<Traversal>))0, 1)));
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(is_iterator_traversal<Category>))0, 1)));
		};
		template<class Traversal, class ValueParam, class Reference>
		struct facade_iterator_category_impl
		{
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_not_arg((void(*)(is_iterator_category<Traversal>))0, 1)));
			typedef typename iterator_facade_default_category<Traversal, ValueParam, Reference>::type category;
			typedef typename mpl::if_<is_same<Traversal, typename iterator_category_to_traversal<category>::type>, category, iterator_category_with_traversal<category, Traversal> >::type type;
		};
		template<class CategoryOrTraversal, class ValueParam, class Reference>
		struct facade_iterator_category: mpl::eval_if<is_iterator_category<CategoryOrTraversal>, mpl::identity<CategoryOrTraversal>, facade_iterator_category_impl<CategoryOrTraversal, ValueParam, Reference> >
		{
		};
	}
}
namespace boost
{
	namespace iterators
	{
		template<bool>
		struct enabled
		{
			template<typename T>
			struct base
			{
				typedef T type;
			};
		};
		template<>
		struct enabled<false>
		{
			template<typename T>
			struct base
			{
			};
		};
		template<class Cond, class Return>
		struct enable_if: enabled<(Cond::value)>::template base<Return>
		{
		};
	}
}
namespace boost
{
	template<typename T>
	inline T implicit_cast(typename mpl::identity<T>::type x)
	{
		return x;
	}
}
namespace boost
{
	template<typename T>
	struct add_const
	{
		typedef T const type;
	};
	template<typename T>
	struct add_const<T&>
	{
		typedef T&type;
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct add_pointer_impl
		{
			typedef typename remove_reference<T>::type no_ref_type;
			typedef no_ref_type*type;
		};
	}
	template<typename T>
	struct add_pointer
	{
		typedef typename boost::detail::add_pointer_impl<T>::type type;
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T, bool is_vol>
		struct remove_const_helper
		{
			typedef T type;
		};
		template<typename T>
		struct remove_const_helper<T, true>
		{
			typedef T volatile type;
		};
		template<typename T>
		struct remove_const_impl
		{
			typedef typename remove_const_helper<typename cv_traits_imp<T*>::unqualified_type, ::boost::is_volatile<T>::value>::type type;
		};
	}
	template<typename T>
	struct remove_const
	{
		typedef typename boost::detail::remove_const_impl<T>::type type;
	};
	template<typename T>
	struct remove_const<T&>
	{
		typedef T&type;
	};
	template<typename T, std::size_t N>
	struct remove_const<T const[N]>
	{
		typedef T type[N];
	};
	template<typename T, std::size_t N>
	struct remove_const<T const volatile[N]>
	{
		typedef T volatile type[N];
	};
}
namespace boost
{
	template<typename T>
	struct is_enum: ::boost::integral_constant<bool, __is_enum(T)>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_scalar_impl
		{
			static const bool value=(::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value>::value);
		};
		template<>
		struct is_scalar_impl<void>
		{
			static const bool value=false;
		};
		template<>
		struct is_scalar_impl<void const>
		{
			static const bool value=false;
		};
		template<>
		struct is_scalar_impl<void volatile>
		{
			static const bool value=false;
		};
		template<>
		struct is_scalar_impl<void const volatile>
		{
			static const bool value=false;
		};
	}
	template<typename T>
	struct is_scalar: ::boost::integral_constant<bool, ::boost::detail::is_scalar_impl<T>::value>
	{
	};
}
namespace boost
{
	template<typename T>
	struct is_POD;
	namespace detail
	{
		template<typename T>
		struct is_pod_impl
		{
			static const bool value=(::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, (__is_pod(T)&&__has_trivial_constructor(T))>::value);
		};
		template<typename T, std::size_t sz>
		struct is_pod_impl<T[sz]>: is_pod_impl<T>
		{
		};
		template<>
		struct is_pod_impl<void>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl<void const>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl<void volatile>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl<void const volatile>
		{
			static const bool value=(true);
		};
	}
	template<typename T>
	struct is_POD: ::boost::integral_constant<bool, ::boost::detail::is_pod_impl<T>::value>
	{
	};
	template<typename T>
	struct is_pod: ::boost::integral_constant<bool, ::boost::detail::is_pod_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace mpl
	{
		template<typename Value>
		struct always
		{
			template<typename T, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply
			{
				typedef Value type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename F, typename T1=na, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
		struct apply;
		template<typename F>
		struct apply0;
		template<typename F, typename T1>
		struct apply1;
		template<typename F, typename T1, typename T2>
		struct apply2;
		template<typename F, typename T1, typename T2, typename T3>
		struct apply3;
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct apply4;
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct apply5;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct type_wrapper
			{
				typedef T type;
			};
			template<typename T>
			struct wrapped_type;
			template<typename T>
			struct wrapped_type<type_wrapper<T> >
			{
				typedef T type;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct has_apply_msvc_sfinae_helper
			{
				typedef void type;
			};
			template<typename T, typename U=void>
			struct has_apply_impl_
			{
				static const bool value=false;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T>
			struct has_apply_impl_<T, typename has_apply_msvc_sfinae_helper<typename T::apply>::type>
			{
				static const bool value=true;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T, typename fallback_=boost::mpl::bool_<false> >
			struct has_apply: has_apply_impl_<T>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename F, typename has_apply_=typename aux::has_apply<F>::type>
		struct apply_wrap0: F::template apply<>
		{
		};
		template<typename F>
		struct apply_wrap0<F, true_>: F::apply
		{
		};
		template<typename F, typename T1>
		struct apply_wrap1: F::template apply<T1>
		{
		};
		template<typename F, typename T1, typename T2>
		struct apply_wrap2: F::template apply<T1, T2>
		{
		};
		template<typename F, typename T1, typename T2, typename T3>
		struct apply_wrap3: F::template apply<T1, T2, T3>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct apply_wrap4: F::template apply<T1, T2, T3, T4>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct apply_wrap5: F::template apply<T1, T2, T3, T4, T5>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename F, typename T1=na, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
		struct bind;
		template<typename F>
		struct bind0;
		template<typename F, typename T1>
		struct bind1;
		template<typename F, typename T1, typename T2>
		struct bind2;
		template<typename F, typename T1, typename T2, typename T3>
		struct bind3;
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct bind4;
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct bind5;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na>
		struct next
		{
			typedef typename T::next type;
		};
		template<typename T=na>
		struct prior
		{
			typedef typename T::prior type;
		};
		template<>
		struct next<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: next<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<next<na>, Tag>
		{
			typedef false_ is_le;
			typedef next<na>result_;
			typedef next<na>type;
		};
		template<>
		struct prior<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: prior<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<prior<na>, Tag>
		{
			typedef false_ is_le;
			typedef prior<na>result_;
			typedef prior<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na, int not_le_=0>
		struct protect: T
		{
			typedef protect type;
		};
		template<>
		struct protect<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: protect<T1>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg
			{
				typedef T type;
			};
			template<typename T, typename Arg>
			struct replace_unnamed_arg
			{
				typedef Arg next;
				typedef T type;
			};
			template<typename Arg>
			struct replace_unnamed_arg<arg<-1>, Arg>
			{
				typedef typename Arg::next next;
				typedef Arg type;
			};
			template<int N, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<arg<N>, U1, U2, U3, U4, U5>
			{
				typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
			};
			template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>
			{
				typedef bind<F, T1, T2, T3, T4, T5>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F>
		struct bind0
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
			public:
				typedef typename apply_wrap0<f_>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind0<F>, U1, U2, U3, U4, U5>
			{
				typedef bind0<F>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F>
		struct bind<F, na, na, na, na, na>: bind0<F>
		{
		};
		template<typename F, typename T1>
		struct bind1
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
			public:
				typedef typename apply_wrap1<f_, typename t1::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind1<F, T1>, U1, U2, U3, U4, U5>
			{
				typedef bind1<F, T1>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1>
		struct bind<F, T1, na, na, na, na>: bind1<F, T1>
		{
		};
		template<typename F, typename T1, typename T2>
		struct bind2
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
			public:
				typedef typename apply_wrap2<f_, typename t1::type, typename t2::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename T2, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind2<F, T1, T2>, U1, U2, U3, U4, U5>
			{
				typedef bind2<F, T1, T2>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1, typename T2>
		struct bind<F, T1, T2, na, na, na>: bind2<F, T1, T2>
		{
		};
		template<typename F, typename T1, typename T2, typename T3>
		struct bind3
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
			public:
				typedef typename apply_wrap3<f_, typename t1::type, typename t2::type, typename t3::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename T2, typename T3, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind3<F, T1, T2, T3>, U1, U2, U3, U4, U5>
			{
				typedef bind3<F, T1, T2, T3>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1, typename T2, typename T3>
		struct bind<F, T1, T2, T3, na, na>: bind3<F, T1, T2, T3>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct bind4
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
				typedef aux::replace_unnamed_arg<T4, n4>r4;
				typedef typename r4::type a4;
				typedef typename r4::next n5;
				typedef aux::resolve_bind_arg<a4, U1, U2, U3, U4, U5>t4;
			public:
				typedef typename apply_wrap4<f_, typename t1::type, typename t2::type, typename t3::type, typename t4::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename T2, typename T3, typename T4, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind4<F, T1, T2, T3, T4>, U1, U2, U3, U4, U5>
			{
				typedef bind4<F, T1, T2, T3, T4>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct bind<F, T1, T2, T3, T4, na>: bind4<F, T1, T2, T3, T4>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct bind5
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef aux::replace_unnamed_arg<F, mpl::arg<1> >r0;
				typedef typename r0::type a0;
				typedef typename r0::next n1;
				typedef typename aux::resolve_bind_arg<a0, U1, U2, U3, U4, U5>::type f_;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
				typedef aux::replace_unnamed_arg<T4, n4>r4;
				typedef typename r4::type a4;
				typedef typename r4::next n5;
				typedef aux::resolve_bind_arg<a4, U1, U2, U3, U4, U5>t4;
				typedef aux::replace_unnamed_arg<T5, n5>r5;
				typedef typename r5::type a5;
				typedef typename r5::next n6;
				typedef aux::resolve_bind_arg<a5, U1, U2, U3, U4, U5>t5;
			public:
				typedef typename apply_wrap5<f_, typename t1::type, typename t2::type, typename t3::type, typename t4::type, typename t5::type>::type type;
			};
		};
		namespace aux
		{
			template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename U1, typename U2, typename U3, typename U4, typename U5>
			struct resolve_bind_arg<bind5<F, T1, T2, T3, T4, T5>, U1, U2, U3, U4, U5>
			{
				typedef bind5<F, T1, T2, T3, T4, T5>f_;
				typedef typename apply_wrap5<f_, U1, U2, U3, U4, U5>::type type;
			};
		}
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct bind: bind5<F, T1, T2, T3, T4, T5>
		{
		};
		template<template<typename T1, typename T2, typename T3>class F, typename Tag>
		struct quote3;
		template<typename T1, typename T2, typename T3>
		struct if_;
		template<typename Tag, typename T1, typename T2, typename T3>
		struct bind3<quote3<if_, Tag>, T1, T2, T3>
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef mpl::arg<1>n1;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
				typedef typename if_<typename t1::type, t2, t3>::type f_;
			public:
				typedef typename f_::type type;
			};
		};
		template<template<typename T1, typename T2, typename T3>class F, typename Tag>
		struct quote3;
		template<typename T1, typename T2, typename T3>
		struct eval_if;
		template<typename Tag, typename T1, typename T2, typename T3>
		struct bind3<quote3<eval_if, Tag>, T1, T2, T3>
		{
			template<typename U1=na, typename U2=na, typename U3=na, typename U4=na, typename U5=na>
			struct apply
			{
			private:
				typedef mpl::arg<1>n1;
				typedef aux::replace_unnamed_arg<T1, n1>r1;
				typedef typename r1::type a1;
				typedef typename r1::next n2;
				typedef aux::resolve_bind_arg<a1, U1, U2, U3, U4, U5>t1;
				typedef aux::replace_unnamed_arg<T2, n2>r2;
				typedef typename r2::type a2;
				typedef typename r2::next n3;
				typedef aux::resolve_bind_arg<a2, U1, U2, U3, U4, U5>t2;
				typedef aux::replace_unnamed_arg<T3, n3>r3;
				typedef typename r3::type a3;
				typedef typename r3::next n4;
				typedef aux::resolve_bind_arg<a3, U1, U2, U3, U4, U5>t3;
				typedef typename eval_if<typename t1::type, t2, t3>::type f_;
			public:
				typedef typename f_::type type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		struct void_
		{
			typedef void_ type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T>
		struct is_void_: false_
		{
		};
		template<>
		struct is_void_<void_>: true_
		{
		};
		template<typename T>
		struct is_not_void_: true_
		{
		};
		template<>
		struct is_not_void_<void_>: false_
		{
		};
		template<>
		struct is_void_<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: is_void_<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<is_void_<na>, Tag>
		{
			typedef false_ is_le;
			typedef is_void_<na>result_;
			typedef is_void_<na>type;
		};
		template<>
		struct is_not_void_<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: is_not_void_<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<is_not_void_<na>, Tag>
		{
			typedef false_ is_le;
			typedef is_not_void_<na>result_;
			typedef is_not_void_<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct has_type_msvc_sfinae_helper
			{
				typedef void type;
			};
			template<typename T, typename U=void>
			struct has_type_impl_
			{
				static const bool value=false;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T>
			struct has_type_impl_<T, typename has_type_msvc_sfinae_helper<typename T::type>::type>
			{
				static const bool value=true;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T, typename fallback_=boost::mpl::bool_<true> >
			struct has_type: has_type_impl_<T>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T, bool has_type_>
		struct quote_impl: T
		{
		};
		template<typename T>
		struct quote_impl<T, false>
		{
			typedef T type;
		};
		template<template<typename P1>class F, typename Tag=void_>
		struct quote1
		{
			template<typename U1>
			struct apply: quote_impl<F<U1>, aux::has_type<F<U1> >::value>
			{
			};
		};
		template<template<typename P1, typename P2>class F, typename Tag=void_>
		struct quote2
		{
			template<typename U1, typename U2>
			struct apply: quote_impl<F<U1, U2>, aux::has_type<F<U1, U2> >::value>
			{
			};
		};
		template<template<typename P1, typename P2, typename P3>class F, typename Tag=void_>
		struct quote3
		{
			template<typename U1, typename U2, typename U3>
			struct apply: quote_impl<F<U1, U2, U3>, aux::has_type<F<U1, U2, U3> >::value>
			{
			};
		};
		template<template<typename P1, typename P2, typename P3, typename P4>class F, typename Tag=void_>
		struct quote4
		{
			template<typename U1, typename U2, typename U3, typename U4>
			struct apply: quote_impl<F<U1, U2, U3, U4>, aux::has_type<F<U1, U2, U3, U4> >::value>
			{
			};
		};
		template<template<typename P1, typename P2, typename P3, typename P4, typename P5>class F, typename Tag=void_>
		struct quote5
		{
			template<typename U1, typename U2, typename U3, typename U4, typename U5>
			struct apply: quote_impl<F<U1, U2, U3, U4, U5>, aux::has_type<F<U1, U2, U3, U4, U5> >::value>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<bool C1=false, bool C2=false, bool C3=false, bool C4=false, bool C5=false>
			struct lambda_or: true_
			{
			};
			template<>
			struct lambda_or<false, false, false, false, false>: false_
			{
			};
		}
		template<typename T, typename Tag>
		struct lambda
		{
			typedef false_ is_le;
			typedef T result_;
			typedef T type;
		};
		template<typename T>
		struct is_lambda_expression: lambda<T>::is_le
		{
		};
		template<int N, typename Tag>
		struct lambda<arg<N>, Tag>
		{
			typedef true_ is_le;
			typedef mpl::arg<N>result_;
			typedef mpl::protect<result_>type;
		};
		template<typename F, typename Tag>
		struct lambda<bind0<F>, Tag>
		{
			typedef false_ is_le;
			typedef bind0<F>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1>class F, typename L1>
			struct le_result1
			{
				typedef F<typename L1::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1>class F, typename L1>
			struct le_result1<true_, Tag, F, L1>
			{
				typedef bind1<quote1<F, Tag>, typename L1::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1>class F, typename T1, typename Tag>
		struct lambda<F<T1>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef typename l1::is_le is_le1;
			typedef typename aux::lambda_or<is_le1::value>::type is_le;
			typedef aux::le_result1<is_le, Tag, F, l1>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename Tag>
		struct lambda<bind1<F, T1>, Tag>
		{
			typedef false_ is_le;
			typedef bind1<F, T1>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1, typename P2>class F, typename L1, typename L2>
			struct le_result2
			{
				typedef F<typename L1::type, typename L2::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1, typename P2>class F, typename L1, typename L2>
			struct le_result2<true_, Tag, F, L1, L2>
			{
				typedef bind2<quote2<F, Tag>, typename L1::result_, typename L2::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1, typename P2>class F, typename T1, typename T2, typename Tag>
		struct lambda<F<T1, T2>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef lambda<T2, Tag>l2;
			typedef typename l1::is_le is_le1;
			typedef typename l2::is_le is_le2;
			typedef typename aux::lambda_or<is_le1::value, is_le2::value>::type is_le;
			typedef aux::le_result2<is_le, Tag, F, l1, l2>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename T2, typename Tag>
		struct lambda<bind2<F, T1, T2>, Tag>
		{
			typedef false_ is_le;
			typedef bind2<F, T1, T2>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1, typename P2, typename P3>class F, typename L1, typename L2, typename L3>
			struct le_result3
			{
				typedef F<typename L1::type, typename L2::type, typename L3::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1, typename P2, typename P3>class F, typename L1, typename L2, typename L3>
			struct le_result3<true_, Tag, F, L1, L2, L3>
			{
				typedef bind3<quote3<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1, typename P2, typename P3>class F, typename T1, typename T2, typename T3, typename Tag>
		struct lambda<F<T1, T2, T3>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef lambda<T2, Tag>l2;
			typedef lambda<T3, Tag>l3;
			typedef typename l1::is_le is_le1;
			typedef typename l2::is_le is_le2;
			typedef typename l3::is_le is_le3;
			typedef typename aux::lambda_or<is_le1::value, is_le2::value, is_le3::value>::type is_le;
			typedef aux::le_result3<is_le, Tag, F, l1, l2, l3>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename T2, typename T3, typename Tag>
		struct lambda<bind3<F, T1, T2, T3>, Tag>
		{
			typedef false_ is_le;
			typedef bind3<F, T1, T2, T3>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1, typename P2, typename P3, typename P4>class F, typename L1, typename L2, typename L3, typename L4>
			struct le_result4
			{
				typedef F<typename L1::type, typename L2::type, typename L3::type, typename L4::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1, typename P2, typename P3, typename P4>class F, typename L1, typename L2, typename L3, typename L4>
			struct le_result4<true_, Tag, F, L1, L2, L3, L4>
			{
				typedef bind4<quote4<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_, typename L4::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1, typename P2, typename P3, typename P4>class F, typename T1, typename T2, typename T3, typename T4, typename Tag>
		struct lambda<F<T1, T2, T3, T4>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef lambda<T2, Tag>l2;
			typedef lambda<T3, Tag>l3;
			typedef lambda<T4, Tag>l4;
			typedef typename l1::is_le is_le1;
			typedef typename l2::is_le is_le2;
			typedef typename l3::is_le is_le3;
			typedef typename l4::is_le is_le4;
			typedef typename aux::lambda_or<is_le1::value, is_le2::value, is_le3::value, is_le4::value>::type is_le;
			typedef aux::le_result4<is_le, Tag, F, l1, l2, l3, l4>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename Tag>
		struct lambda<bind4<F, T1, T2, T3, T4>, Tag>
		{
			typedef false_ is_le;
			typedef bind4<F, T1, T2, T3, T4>result_;
			typedef result_ type;
		};
		namespace aux
		{
			template<typename IsLE, typename Tag, template<typename P1, typename P2, typename P3, typename P4, typename P5>class F, typename L1, typename L2, typename L3, typename L4, typename L5>
			struct le_result5
			{
				typedef F<typename L1::type, typename L2::type, typename L3::type, typename L4::type, typename L5::type>result_;
				typedef result_ type;
			};
			template<typename Tag, template<typename P1, typename P2, typename P3, typename P4, typename P5>class F, typename L1, typename L2, typename L3, typename L4, typename L5>
			struct le_result5<true_, Tag, F, L1, L2, L3, L4, L5>
			{
				typedef bind5<quote5<F, Tag>, typename L1::result_, typename L2::result_, typename L3::result_, typename L4::result_, typename L5::result_>result_;
				typedef mpl::protect<result_>type;
			};
		}
		template<template<typename P1, typename P2, typename P3, typename P4, typename P5>class F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
		struct lambda<F<T1, T2, T3, T4, T5>, Tag>
		{
			typedef lambda<T1, Tag>l1;
			typedef lambda<T2, Tag>l2;
			typedef lambda<T3, Tag>l3;
			typedef lambda<T4, Tag>l4;
			typedef lambda<T5, Tag>l5;
			typedef typename l1::is_le is_le1;
			typedef typename l2::is_le is_le2;
			typedef typename l3::is_le is_le3;
			typedef typename l4::is_le is_le4;
			typedef typename l5::is_le is_le5;
			typedef typename aux::lambda_or<is_le1::value, is_le2::value, is_le3::value, is_le4::value, is_le5::value>::type is_le;
			typedef aux::le_result5<is_le, Tag, F, l1, l2, l3, l4, l5>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
		struct lambda<bind5<F, T1, T2, T3, T4, T5>, Tag>
		{
			typedef false_ is_le;
			typedef bind5<F, T1, T2, T3, T4, T5>result_;
			typedef result_ type;
		};
		template<typename T, typename Tag>
		struct lambda<mpl::protect<T>, Tag>
		{
			typedef false_ is_le;
			typedef mpl::protect<T>result_;
			typedef result_ type;
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5, typename Tag>
		struct lambda<bind<F, T1, T2, T3, T4, T5>, Tag>
		{
			typedef false_ is_le;
			typedef bind<F, T1, T2, T3, T4, T5>result_;
			typedef result_ type;
		};
		template<typename F, typename Tag1, typename Tag2>
		struct lambda<lambda<F, Tag1>, Tag2>
		{
			typedef lambda<F, Tag2>l1;
			typedef lambda<Tag1, Tag2>l2;
			typedef typename l1::is_le is_le;
			typedef aux::le_result2<is_le, Tag2, mpl::lambda, l1, l2>le_result_;
			typedef typename le_result_::result_ result_;
			typedef typename le_result_::type type;
		};
		template<>
		struct lambda<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: lambda<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<lambda<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef lambda<na, na>result_;
			typedef lambda<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename F>
		struct apply0: apply_wrap0<typename lambda<F>::type>
		{
		};
		template<typename F>
		struct apply<F, na, na, na, na, na>: apply0<F>
		{
		};
		template<typename F, typename T1>
		struct apply1: apply_wrap1<typename lambda<F>::type, T1>
		{
		};
		template<typename F, typename T1>
		struct apply<F, T1, na, na, na, na>: apply1<F, T1>
		{
		};
		template<typename F, typename T1, typename T2>
		struct apply2: apply_wrap2<typename lambda<F>::type, T1, T2>
		{
		};
		template<typename F, typename T1, typename T2>
		struct apply<F, T1, T2, na, na, na>: apply2<F, T1, T2>
		{
		};
		template<typename F, typename T1, typename T2, typename T3>
		struct apply3: apply_wrap3<typename lambda<F>::type, T1, T2, T3>
		{
		};
		template<typename F, typename T1, typename T2, typename T3>
		struct apply<F, T1, T2, T3, na, na>: apply3<F, T1, T2, T3>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct apply4: apply_wrap4<typename lambda<F>::type, T1, T2, T3, T4>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4>
		struct apply<F, T1, T2, T3, T4, na>: apply4<F, T1, T2, T3, T4>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct apply5: apply_wrap5<typename lambda<F>::type, T1, T2, T3, T4, T5>
		{
		};
		template<typename F, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct apply: apply5<F, T1, T2, T3, T4, T5>
		{
		};
	}
}
namespace boost
{
	template<class I, class V, class TC, class R, class D>
	class iterator_facade;
	namespace detail
	{
		struct always_bool2
		{
			template<class T, class U>
			struct apply
			{
				typedef bool type;
			};
		};
		template<class Facade1, class Facade2, class Return>
		struct enable_if_interoperable: ::boost::iterators::enable_if<mpl::or_<is_convertible<Facade1, Facade2>, is_convertible<Facade2, Facade1> >, Return>
		{
		};
		template<class ValueParam, class CategoryOrTraversal, class Reference, class Difference>
		struct iterator_facade_types
		{
			typedef typename facade_iterator_category<CategoryOrTraversal, ValueParam, Reference>::type iterator_category;
			typedef typename remove_const<ValueParam>::type value_type;
			typedef typename mpl::eval_if<boost::detail::iterator_writability_disabled<ValueParam, Reference>, add_pointer<const value_type>, add_pointer<value_type> >::type pointer;
		};
		template<class Iterator>
		class postfix_increment_proxy
		{
			typedef typename iterator_value<Iterator>::type value_type;
		public:
			explicit postfix_increment_proxy(Iterator const&x): stored_value(*x)
			{
			}
			value_type&operator*()const
			{
				return this->stored_value;
			}
		private:
			mutable value_type stored_value;
		};
		template<class Iterator>
		class writable_postfix_increment_proxy
		{
			typedef typename iterator_value<Iterator>::type value_type;
		public:
			explicit writable_postfix_increment_proxy(Iterator const&x): stored_value(*x), stored_iterator(x)
			{
			}
			writable_postfix_increment_proxy const&operator*()const
			{
				return *this;
			}
			operator value_type&()const
			{
				return stored_value;
			}
			template<class T>
			T const&operator=(T const&x)const
			{
				*this->stored_iterator=x;
				return x;
			}
			template<class T>
			T&operator=(T&x)const
			{
				*this->stored_iterator=x;
				return x;
			}
			operator Iterator const&()const
			{
				return stored_iterator;
			}
		private:
			mutable value_type stored_value;
			Iterator stored_iterator;
		};
		template<class Reference, class Value>
		struct is_non_proxy_reference: is_convertible<typename remove_reference<Reference>::type const volatile*, Value const volatile*>
		{
		};
		template<class Iterator, class Value, class Reference, class CategoryOrTraversal>
		struct postfix_increment_result: mpl::eval_if<mpl::and_<is_convertible<Reference, Value const&>, mpl::not_<is_convertible<typename iterator_category_to_traversal<CategoryOrTraversal>::type, forward_traversal_tag> > >, mpl::if_<is_non_proxy_reference<Reference, Value>, postfix_increment_proxy<Iterator>, writable_postfix_increment_proxy<Iterator> >, mpl::identity<Iterator> >
		{
		};
		template<class T>
		struct operator_arrow_proxy
		{
			operator_arrow_proxy(T const*px): m_value(*px)
			{
			}
			T*operator->()const
			{
				return &m_value;
			}
			operator T*()const
			{
				return &m_value;
			}
			mutable T m_value;
		};
		template<class ValueType, class Reference, class Pointer>
		struct operator_arrow_result
		{
			typedef typename mpl::if_<is_reference<Reference>, Pointer, operator_arrow_proxy<ValueType> >::type type;
			static type make(Reference x)
			{
				return implicit_cast<type>(&x);
			}
		};
		template<class Iterator>
		class operator_brackets_proxy
		{
			typedef typename Iterator::reference reference;
			typedef typename Iterator::value_type value_type;
		public:
			operator_brackets_proxy(Iterator const&iter): m_iter(iter)
			{
			}
			operator reference()const
			{
				return *m_iter;
			}
			operator_brackets_proxy&operator=(value_type const&val)
			{
				*m_iter=val;
				return *this;
			}
		private:
			Iterator m_iter;
		};
		template<class ValueType, class Reference>
		struct use_operator_brackets_proxy: mpl::not_<mpl::and_<boost::is_POD<ValueType>, iterator_writability_disabled<ValueType, Reference> > >
		{
		};
		template<class Iterator, class Value, class Reference>
		struct operator_brackets_result
		{
			typedef typename mpl::if_<use_operator_brackets_proxy<Value, Reference>, operator_brackets_proxy<Iterator>, Value>::type type;
		};
		template<class Iterator>
		operator_brackets_proxy<Iterator>make_operator_brackets_result(Iterator const&iter, mpl::true_)
		{
			return operator_brackets_proxy<Iterator>(iter);
		}
		template<class Iterator>
		typename Iterator::value_type make_operator_brackets_result(Iterator const&iter, mpl::false_)
		{
			return *iter;
		}
		struct choose_difference_type
		{
			template<class I1, class I2>
			struct apply: mpl::eval_if<is_convertible<I2, I1>, iterator_difference<I1>, iterator_difference<I2> >
			{
			};
		};
	}
	class iterator_core_access
	{
	public:
		template<class Facade>
		static typename Facade::reference dereference(Facade const&f)
		{
			return f.dereference();
		}
		template<class Facade>
		static void increment(Facade&f)
		{
			f.increment();
		}
		template<class Facade>
		static void decrement(Facade&f)
		{
			f.decrement();
		}
		template<class Facade1, class Facade2>
		static bool equal(Facade1 const&f1, Facade2 const&f2, mpl::true_)
		{
			return f1.equal(f2);
		}
		template<class Facade1, class Facade2>
		static bool equal(Facade1 const&f1, Facade2 const&f2, mpl::false_)
		{
			return f2.equal(f1);
		}
		template<class Facade>
		static void advance(Facade&f, typename Facade::difference_type n)
		{
			f.advance(n);
		}
		template<class Facade1, class Facade2>
		static typename Facade1::difference_type distance_from(Facade1 const&f1, Facade2 const&f2, mpl::true_)
		{
			return -f1.distance_to(f2);
		}
		template<class Facade1, class Facade2>
		static typename Facade2::difference_type distance_from(Facade1 const&f1, Facade2 const&f2, mpl::false_)
		{
			return f2.distance_to(f1);
		}
		template<class I, class V, class TC, class R, class D>
		static I&derived(iterator_facade<I, V, TC, R, D>&facade)
		{
			return *static_cast<I*>(&facade);
		}
		template<class I, class V, class TC, class R, class D>
		static I const&derived(iterator_facade<I, V, TC, R, D>const&facade)
		{
			return *static_cast<I const*>(&facade);
		}
	private:
		iterator_core_access();
	};
	template<class Derived, class Value, class CategoryOrTraversal, class Reference=Value&, class Difference=std::ptrdiff_t>
	class iterator_facade
	{
	private:
		Derived&derived()
		{
			return *static_cast<Derived*>(this);
		}
		Derived const&derived()const
		{
			return *static_cast<Derived const*>(this);
		}
		typedef boost::detail::iterator_facade_types<Value, CategoryOrTraversal, Reference, Difference>associated_types;
		protected: typedef iterator_facade<Derived, Value, CategoryOrTraversal, Reference, Difference>iterator_facade_;
	public:
		typedef typename associated_types::value_type value_type;
		typedef Reference reference;
		typedef Difference difference_type;
		typedef typename associated_types::pointer pointer;
		typedef typename associated_types::iterator_category iterator_category;
		reference operator*()const
		{
			return iterator_core_access::dereference(this->derived());
		}
		typename boost::detail::operator_arrow_result<value_type, reference, pointer>::type operator->()const
		{
			return boost::detail::operator_arrow_result<value_type, reference, pointer>::make(*this->derived());
		}
		typename boost::detail::operator_brackets_result<Derived, Value, reference>::type operator[](difference_type n)const
		{
			typedef boost::detail::use_operator_brackets_proxy<Value, Reference>use_proxy;
			return boost::detail::make_operator_brackets_result<Derived>(this->derived()+n, use_proxy());
		}
		Derived&operator++()
		{
			iterator_core_access::increment(this->derived());
			return this->derived();
		}
		Derived&operator--()
		{
			iterator_core_access::decrement(this->derived());
			return this->derived();
		}
		Derived operator--(int)
		{
			Derived tmp(this->derived());
			--*this;
			return tmp;
		}
		Derived&operator+=(difference_type n)
		{
			iterator_core_access::advance(this->derived(), n);
			return this->derived();
		}
		Derived&operator-=(difference_type n)
		{
			iterator_core_access::advance(this->derived(), -n);
			return this->derived();
		}
		Derived operator-(difference_type x)const
		{
			Derived result(this->derived());
			return result-=x;
		}
	};
	template<class I, class V, class TC, class R, class D>
	inline typename boost::detail::postfix_increment_result<I, V, R, TC>::type operator++(iterator_facade<I, V, TC, R, D>&i, int)
	{
		typename boost::detail::postfix_increment_result<I, V, R, TC>::type tmp(*static_cast<I*>(&i));
		++i;
		return tmp;
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator==(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return iterator_core_access::equal(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator!=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return !iterator_core_access::equal(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator<(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return 0>iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator>(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return 0<iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator<=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return 0>=iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::always_bool2, Derived1, Derived2>::type>::type operator>=(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return 0<=iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived1, class V1, class TC1, class Reference1, class Difference1, class Derived2, class V2, class TC2, class Reference2, class Difference2>
	inline typename boost::detail::enable_if_interoperable<Derived1, Derived2, typename mpl::apply2<boost::detail::choose_difference_type, Derived1, Derived2>::type>::type operator-(iterator_facade<Derived1, V1, TC1, Reference1, Difference1>const&lhs, iterator_facade<Derived2, V2, TC2, Reference2, Difference2>const&rhs)
	{
		typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_interoperable<Derived1, Derived2>::value))>)>boost_static_assert_typedef___COUNTER__;
		return iterator_core_access::distance_from(*static_cast<Derived1 const*>(&lhs), *static_cast<Derived2 const*>(&rhs), is_convertible<Derived2, Derived1>());
	}
	template<class Derived, class V, class TC, class R, class D>
	inline Derived operator+(iterator_facade<Derived, V, TC, R, D>const&i, typename Derived::difference_type n)
	{
		Derived tmp(static_cast<Derived const&>(i));
		return tmp+=n;
	}
	template<class Derived, class V, class TC, class R, class D>
	inline Derived operator+(typename Derived::difference_type n, iterator_facade<Derived, V, TC, R, D>const&i)
	{
		Derived tmp(static_cast<Derived const&>(i));
		return tmp+=n;
	}
}
namespace boost
{
	struct use_default;
	template<class To>
	struct is_convertible<use_default, To>: mpl::false_
	{
	};
	namespace detail
	{
		struct enable_type;
	}
	template<typename From, typename To>
	struct enable_if_convertible: iterators::enable_if<mpl::or_<is_same<From, To>, is_convertible<From, To> >, boost::detail::enable_type>
	{
	};
	namespace detail
	{
		template<class T, class DefaultNullaryFn>
		struct ia_dflt_help: mpl::eval_if<is_same<T, use_default>, DefaultNullaryFn, mpl::identity<T> >
		{
		};
		template<class Derived, class Base, class Value, class Traversal, class Reference, class Difference>
		struct iterator_adaptor_base
		{
			typedef iterator_facade<Derived, typename boost::detail::ia_dflt_help<Value, mpl::eval_if<is_same<Reference, use_default>, iterator_value<Base>, remove_reference<Reference> > >::type, typename boost::detail::ia_dflt_help<Traversal, iterator_traversal<Base> >::type, typename boost::detail::ia_dflt_help<Reference, mpl::eval_if<is_same<Value, use_default>, iterator_reference<Base>, add_reference<Value> > >::type, typename boost::detail::ia_dflt_help<Difference, iterator_difference<Base> >::type>type;
		};
		template<class Tr1, class Tr2>
		inline void iterator_adaptor_assert_traversal()
		{
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_convertible<Tr1, Tr2>::value))>)>boost_static_assert_typedef___COUNTER__;
		}
	}
	template<class Derived, class Base, class Value=use_default, class Traversal=use_default, class Reference=use_default, class Difference=use_default>
	class iterator_adaptor: public boost::detail::iterator_adaptor_base<Derived, Base, Value, Traversal, Reference, Difference>::type
	{
		friend class iterator_core_access;
		protected: typedef typename boost::detail::iterator_adaptor_base<Derived, Base, Value, Traversal, Reference, Difference>::type super_t;
	public:
		iterator_adaptor()
		{
		}
		explicit iterator_adaptor(Base const&iter): m_iterator(iter)
		{
		}
		typedef Base base_type;
		Base const&base()const
		{
			return m_iterator;
		}
		protected: typedef iterator_adaptor<Derived, Base, Value, Traversal, Reference, Difference>iterator_adaptor_;
		Base const&base_reference()const
		{
			return m_iterator;
		}
		Base&base_reference()
		{
			return m_iterator;
		}
	private:
		typename super_t::reference dereference()const
		{
			return *m_iterator;
		}
		template<class OtherDerived, class OtherIterator, class V, class C, class R, class D>
		bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D>const&x)const
		{
			return m_iterator==x.base();
		}
		typedef typename iterator_category_to_traversal<typename super_t::iterator_category>::type my_traversal;
		void advance(typename super_t::difference_type n)
		{
			boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
			m_iterator+=n;
		}
		void increment()
		{
			++m_iterator;
		}
		void decrement()
		{
			boost::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
			--m_iterator;
		}
		template<class OtherDerived, class OtherIterator, class V, class C, class R, class D>
		typename super_t::difference_type distance_to(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D>const&y)const
		{
			boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
			return y.base()-m_iterator;
		}
	private:
		Base m_iterator;
	};
}
namespace boost
{
	template<class Iterator>
	class reverse_iterator: public iterator_adaptor<reverse_iterator<Iterator>, Iterator>
	{
		typedef iterator_adaptor<reverse_iterator<Iterator>, Iterator>super_t;
		friend class iterator_core_access;
	public:
		reverse_iterator()
		{
		}
		explicit reverse_iterator(Iterator x): super_t(x)
		{
		}
		template<class OtherIterator>
		reverse_iterator(reverse_iterator<OtherIterator>const&r, typename enable_if_convertible<OtherIterator, Iterator>::type* =0): super_t(r.base())
		{
		}
	private:
		typename super_t::reference dereference()const
		{
			return *boost::prior(this->base());
		}
		void increment()
		{
			--this->base_reference();
		}
		void decrement()
		{
			++this->base_reference();
		}
		void advance(typename super_t::difference_type n)
		{
			this->base_reference()+=-n;
		}
		template<class OtherIterator>
		typename super_t::difference_type distance_to(reverse_iterator<OtherIterator>const&y)const
		{
			return this->base_reference()-y.base();
		}
	};
	template<class BidirectionalIterator>
	reverse_iterator<BidirectionalIterator>make_reverse_iterator(BidirectionalIterator x)
	{
		return reverse_iterator<BidirectionalIterator>(x);
	}
}
namespace std
{
	template<class _Ty>
	inline pair<_Ty*, ptrdiff_t>get_temporary_buffer(ptrdiff_t _Count)
	{
		_Ty*_Pbuf;
		if(_Count<=0)_Count=0;
		else if(((size_t)(-1)/_Count)<sizeof(_Ty))throw std::bad_alloc(0);
		for(_Pbuf=0;
		0<_Count;
		_Count/=2)if((_Pbuf=(_Ty*)operator new((size_t)_Count*sizeof(_Ty), nothrow))!=0)break;
		return (pair<_Ty*, ptrdiff_t>(_Pbuf, _Count));
	}
	template<class _Ty>
	inline void return_temporary_buffer(_Ty*_Pbuf)
	{
		operator delete(_Pbuf);
	}
	template<class _InIt, class _FwdIt>
	inline _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 49);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 50);
		_FwdIt _Next=_Dest;
		try
		{
			for(;
			_First!=_Last;
			++_Dest, ++_First)_Construct(&*_Dest, *_First);
		}
		catch(...)
		{
			for(;
			_Next!=_Dest;
			++_Next)_Destroy(&*_Next);
			throw;
		}
		return (_Dest);
	}
	template<class _Ty1, class _Ty2>
	inline _Ty2 _Uninit_copy(_Ty1 _First, _Ty1 _Last, _Ty2 _Dest, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 69);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 70);
		size_t _Count=(size_t)(_Last-_First);
		_Ty2 _Result=_Dest+_Count;
		if(_Count>0)::memmove_s((&*_Dest), (_Count*sizeof(*_First)), (&*_First), (_Count*sizeof(*_First)));
		return _Result;
	}
	template<class _Ty1, class _Ty2, class _Ty3>
	inline _Ty2 _Uninit_copy(_Ty1 _First, _Ty1 _Last, _Ty2 _Dest, _Ty3 _Ptr_cat, _Unchecked_iterator_tag)
	{
		return _Uninit_copy(_First, _Last, _Dest, _Ptr_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _FwdIt>
	inline _FwdIt uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{
		return (_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 103);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 104);
		_FwdIt _Next=_Dest;
		try
		{
			for(;
			_First!=_Last;
			++_Dest, ++_First)_Al.construct(_Dest, *_First);
		}
		catch(...)
		{
			for(;
			_Next!=_Dest;
			++_Next)_Al.destroy(_Next);
			throw;
		}
		return (_Dest);
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 124);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 125);
		size_t _Count=(size_t)(_Last-_First);
		_FwdIt _Result=_Dest+_Count;
		if(_Count>0)::memmove_s((&*_Dest), (_Count*sizeof(*_First)), (&*_First), (_Count*sizeof(*_First)));
		return _Result;
	}
	template<class _InIt, class _FwdIt, class _Alloc, class _Ty>
	inline _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc _Al, _Ty _Ptr_cat, _Unchecked_iterator_tag)
	{
		return _Uninit_copy(_First, _Last, _Dest, _Al, _Ptr_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc, class _MoveCatTy>
	inline _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al, _MoveCatTy, _Range_checked_iterator_tag)
	{
		return (_Uninit_copy(_First, _Last, _Dest, _Al, _Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al, _Swap_move_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 169);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 170);
		_FwdIt _Next=_Dest;
		typename _Alloc::value_type _Val;
		try
		{
			for(;
			_First!=_Last;
			++_Dest, ++_First)
			{
				_Al.construct(_Dest, _Val);
				::std::swap(*_Dest, *_First);
			}
		}
		catch(...)
		{
			for(;
			_Next!=_Dest;
			++_Next)_Al.destroy(_Next);
			throw;
		}
		return (_Dest);
	}
	template<class _InIt, class _FwdIt, class _Alloc, class _MoveCatTy>
	inline _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc _Al, _MoveCatTy _Move_cat, _Unchecked_iterator_tag)
	{
		return _Uninit_move(_First, _Last, _Dest, _Al, _Move_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (_Uninit_move(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, _Move_cat(_Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _FwdIt, class _Tval>
	inline void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval&_Val, _Nonscalar_ptr_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 215);
		_FwdIt _Next=_First;
		try
		{
			for(;
			_First!=_Last;
			++_First)_Construct(&*_First, _Val);
		}
		catch(...)
		{
			for(;
			_Next!=_First;
			++_Next)_Destroy(&*_Next);
			throw;
		}
	}
	template<class _Ty, class _Tval>
	inline void _Uninit_fill(_Ty*_First, _Ty*_Last, const _Tval&_Val, _Scalar_ptr_iterator_tag)
	{
		std::fill(_First, _Last, _Val);
	}
	template<class _FwdIt, class _Tval>
	inline void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval&_Val)
	{
		_Uninit_fill(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Ptr_cat(_First, _First));
	}
	template<class _FwdIt, class _Diff, class _Tval>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_FwdIt _Next=_First;
		try
		{
			for(;
			0<_Count;
			--_Count, ++_First)_Construct(&*_First, _Val);
		}
		catch(...)
		{
			for(;
			_Next!=_First;
			++_Next)_Destroy(&*_Next);
			throw;
		}
	}
	template<class _Ty, class _Diff, class _Tval>
	inline void _Uninit_fill_n(_Ty*_First, _Diff _Count, const _Tval&_Val, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		::stdext::unchecked_fill_n(_First, _Count, _Val);
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Ty2>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Ty2 _Ptr_cat, _Unchecked_iterator_tag)
	{
		_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat, _Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _Diff, class _Tval>
	inline void uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val)
	{
		_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First), ::std::_Checked_cat(_First));
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		_FwdIt _Next=_First;
		try
		{
			for(;
			0<_Count;
			--_Count, ++_First)_Al.construct(_First, _Val);
		}
		catch(...)
		{
			for(;
			_Next!=_First;
			++_Next)_Al.destroy(_Next);
			throw;
		}
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
	{
		::stdext::unchecked_fill_n(_First, _Count, _Val);
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc, class _Ty>
	inline void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al, _Ty _Ptr_cat, _Unchecked_iterator_tag)
	{
		_Uninit_fill_n(_First, _Count, _Val, _Al, _Ptr_cat, _Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al)
	{
		_Uninit_fill_n(_First, _Count, _Val, _Al, _Ptr_cat(_First, _First), ::std::_Checked_cat(_First));
	}
	template<class _FwdIt, class _Ty>
	class raw_storage_iterator: public _Outit
	{
	public:
		typedef _FwdIt iterator_type;
		typedef _FwdIt iter_type;
		typedef _Ty element_type;
		explicit raw_storage_iterator(_FwdIt _First): _Next(_First)
		{
		}
		raw_storage_iterator<_FwdIt, _Ty>&operator*()
		{
			return (*this);
		}
		raw_storage_iterator<_FwdIt, _Ty>&operator=(const _Ty&_Val)
		{
			_Construct(&*_Next, _Val);
			return (*this);
		}
		raw_storage_iterator<_FwdIt, _Ty>&operator++()
		{
			++_Next;
			return (*this);
		}
		raw_storage_iterator<_FwdIt, _Ty>operator++(int)
		{
			raw_storage_iterator<_FwdIt, _Ty>_Ans=*this;
			++_Next;
			return (_Ans);
		}
	private:
		_FwdIt _Next;
	};
	template<class _Ty>
	class _Temp_iterator: public _Outit
	{
	public:
		typedef _Ty*_Pty;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		_Temp_iterator(ptrdiff_t _Count=0)
		{
			_Buf._Begin=0;
			_Buf._Current=0;
			_Buf._Hiwater=0;
			_Buf._Size=_Count;
			_Pbuf=&_Buf;
		}
		_Temp_iterator(const _Temp_iterator<_Ty>&_Right)
		{
			_Buf._Begin=0;
			_Buf._Current=0;
			_Buf._Hiwater=0;
			_Buf._Size=0;
			*this=_Right;
		}
		~_Temp_iterator()
		{
			if(_Buf._Begin!=0)
			{
				for(_Pty _Next=_Buf._Begin;
				_Next!=_Buf._Hiwater;
				++_Next)_Destroy(&*_Next);
				std::return_temporary_buffer(_Buf._Begin);
			}
		}
		_Temp_iterator<_Ty>&operator=(const _Temp_iterator<_Ty>&_Right)
		{
			_Pbuf=_Right._Pbuf;
			return (*this);
		}
		_Temp_iterator<_Ty>&operator=(const _Ty&_Val)
		{
			if(_Pbuf->_Current<_Pbuf->_Hiwater)*_Pbuf->_Current++=_Val;
			else
			{

				{
					if(!((_Pbuf->_Current-_Pbuf->_Begin)<_Pbuf->_Size))
					{
						(void)((!!((("(_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 451, 0, L"(\"(_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 451, 0);
					};
				};
				_Pty _Ptr=&*_Pbuf->_Current;
				_Construct(_Ptr, _Val);
				_Pbuf->_Hiwater=++_Pbuf->_Current;
			}
			return (*this);
		}
		_Temp_iterator<_Ty>&operator*()
		{
			return (*this);
		}
		_Temp_iterator<_Ty>&operator++()
		{
			return (*this);
		}
		_Temp_iterator<_Ty>&operator++(int)
		{
			return (*this);
		}
		_Temp_iterator<_Ty>&_Init()
		{
			_Pbuf->_Current=_Pbuf->_Begin;
			return (*this);
		}
		_Pty _First()const
		{
			return (_Pbuf->_Begin);
		}
		_Pty _Last()const
		{
			return (_Pbuf->_Current);
		}
		ptrdiff_t _Maxlen()
		{
			if(_Pbuf->_Begin==0&&0<_Pbuf->_Size)
			{
				pair<_Pty, ptrdiff_t>_Pair=std::get_temporary_buffer<_Ty>(_Pbuf->_Size);
				_Pbuf->_Begin=_Pair.first;
				_Pbuf->_Current=_Pair.first;
				_Pbuf->_Hiwater=_Pair.first;
				_Pbuf->_Size=_Pair.second;
			}
			return (_Pbuf->_Size);
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid _Temp_iterator<T> argument");
		}
	private:
		struct _Bufpar
		{
			_Pty _Begin;
			_Pty _Current;
			_Pty _Hiwater;
			ptrdiff_t _Size;
		};
		_Bufpar _Buf;
		_Bufpar*_Pbuf;
	};
	template<class _Ty>
	class auto_ptr;
	template<class _Ty>
	struct auto_ptr_ref
	{
		auto_ptr_ref(void*_Right): _Ref(_Right)
		{
		}
		void*_Ref;
	};
	template<class _Ty>
	class auto_ptr
	{
	public:
		typedef _Ty element_type;
		explicit auto_ptr(_Ty*_Ptr=0)throw(): _Myptr(_Ptr)
		{
		}
		auto_ptr(auto_ptr<_Ty>&_Right)throw(): _Myptr(_Right.release())
		{
		}
		auto_ptr(auto_ptr_ref<_Ty>_Right)throw()
		{
			_Ty**_Pptr=(_Ty**)_Right._Ref;
			_Ty*_Ptr=*_Pptr;
			*_Pptr=0;
			_Myptr=_Ptr;
		}
		template<class _Other>
		operator auto_ptr<_Other>()throw()
		{
			return (auto_ptr<_Other>(*this));
		}
		template<class _Other>
		operator auto_ptr_ref<_Other>()throw()
		{
			_Other*_Testptr=(_Ty*)_Myptr;
			auto_ptr_ref<_Other>_Ans(&_Myptr);
			return (_Testptr!=0?_Ans: _Ans);
		}
		template<class _Other>
		auto_ptr<_Ty>&operator=(auto_ptr<_Other>&_Right)throw()
		{
			reset(_Right.release());
			return (*this);
		}
		template<class _Other>
		auto_ptr(auto_ptr<_Other>&_Right)throw(): _Myptr(_Right.release())
		{
		}
		auto_ptr<_Ty>&operator=(auto_ptr<_Ty>&_Right)throw()
		{
			reset(_Right.release());
			return (*this);
		}
		auto_ptr<_Ty>&operator=(auto_ptr_ref<_Ty>_Right)throw()
		{
			_Ty**_Pptr=(_Ty**)_Right._Ref;
			_Ty*_Ptr=*_Pptr;
			*_Pptr=0;
			reset(_Ptr);
			return (*this);
		}
		~auto_ptr()
		{
			delete(_Ty*)_Myptr;
		}
		_Ty&operator*()const throw()
		{
			if(_Myptr==0)_Debug_message(L"auto_ptr not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\memory", 613);
			;
			return (*(_Ty*)_Myptr);
		}
		_Ty*operator->()const throw()
		{
			return (&**this);
		}
		_Ty*get()const throw()
		{
			return ((_Ty*)_Myptr);
		}
		_Ty*release()throw()
		{
			_Ty*_Tmp=(_Ty*)_Myptr;
			_Myptr=0;
			return (_Tmp);
		}
		void reset(_Ty*_Ptr=0)
		{
			if(_Ptr!=_Myptr)delete(_Ty*)_Myptr;
			_Myptr=_Ptr;
		}
	private:
		const _Ty*_Myptr;
	};
}
namespace stdext
{
	template<class _InIt, class _FwdIt>
	inline _FwdIt unchecked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{
		return (::std::_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Ptr_cat(_First, _Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _FwdIt>
	inline _FwdIt checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{
		return (::std::_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt unchecked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (::std::_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, ::std::_Ptr_cat(_First, _Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (::std::_Uninit_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, ::std::_Ptr_cat(_First, _Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Unchecked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (::std::_Uninit_move(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, ::std::_Move_cat(_Dest), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _FwdIt, class _Alloc>
	inline _FwdIt _Checked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest, _Alloc&_Al)
	{
		return (::std::_Uninit_move(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Al, ::std::_Move_cat(_Dest), ::std::_Checked_cat(_Dest)));
	}
	template<class _FwdIt, class _Diff, class _Tval>
	inline void unchecked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val)
	{
		::std::_Uninit_fill_n(_First, _Count, _Val, ::std::_Ptr_cat(_First, _First), ::std::_Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _Diff, class _Tval>
	inline void checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val)
	{
		::std::_Uninit_fill_n(_First, _Count, _Val, ::std::_Ptr_cat(_First, _First), ::std::_Checked_cat(_First));
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void unchecked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al)
	{
		::std::_Uninit_fill_n(_First, _Count, _Val, _Al, ::std::_Ptr_cat(_First, _First), ::std::_Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _Diff, class _Tval, class _Alloc>
	inline void checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval&_Val, _Alloc&_Al)
	{
		::std::_Uninit_fill_n(_First, _Count, _Val, _Al, ::std::_Ptr_cat(_First, _First), ::std::_Checked_cat(_First));
	}
}
namespace std
{
	template<class _Ty, class _Ax=allocator<_Ty> >
	class vector;
	template<class _Ty, class _Alloc>
	class _Vector_const_iterator: public _Ranit<_Ty, typename _Alloc::difference_type, typename _Alloc::const_pointer, typename _Alloc::const_reference>
	{
	public:
		typedef _Vector_const_iterator<_Ty, _Alloc>_Myt;
		typedef vector<_Ty, _Alloc>_Myvec;
		typedef typename _Alloc::pointer _Tptr;
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::const_pointer pointer;
		typedef typename _Alloc::const_reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		typedef _Tptr _Inner_type;
		_Vector_const_iterator()
		{
			_Myptr=0;
		}
		_Vector_const_iterator(_Tptr _Ptr, const _Container_base*_Pvector)
		{

			{
				if(!(_Pvector==0||(((_Myvec*)_Pvector)->_Myfirst<=_Ptr&&_Ptr<=((_Myvec*)_Pvector)->_Mylast)))
				{
					(void)((!!((("_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 71, 0, L"(\"_Pvector == NULL || (((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast)\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 71, 0);
				};
			};
			this->_Adopt(_Pvector);
			_Myptr=_Ptr;
		}
		reference operator*()const
		{
			if(this->_Mycont==0||_Myptr<((_Myvec*)this->_Mycont)->_Myfirst||((_Myvec*)this->_Mycont)->_Mylast<=_Myptr)
			{
				_Debug_message(L"vector iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 99);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 100, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 100, 0);
				};
			}
			return (*_Myptr);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{

			{
				if(!(this->_Mycont!=0))
				{
					(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 117, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 117, 0);
				};
			};

			{
				if(!(_Myptr<((_Myvec*)(this->_Mycont))->_Mylast))
				{
					(void)((!!((("_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 118, 0, L"(\"_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 118, 0);
				};
			};
			++_Myptr;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{

			{
				if(!(this->_Mycont!=0))
				{
					(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 132, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 132, 0);
				};
			};

			{
				if(!(_Myptr>((_Myvec*)(this->_Mycont))->_Myfirst))
				{
					(void)((!!((("_Myptr > ((_Myvec *)(this->_Mycont))->_Myfirst", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 133, 0, L"(\"_Myptr > ((_Myvec *)(this->_Mycont))->_Myfirst\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 133, 0);
				};
			};
			--_Myptr;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{

			{
				if(!(this->_Mycont!=0))
				{
					(void)((!!((("this->_Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 147, 0, L"(\"this->_Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 147, 0);
				};
			};

			{
				if(!(_Myptr+_Off<=((_Myvec*)(this->_Mycont))->_Mylast&&_Myptr+_Off>=((_Myvec*)(this->_Mycont))->_Myfirst))
				{
					(void)((!!((("_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast && _Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 148, 0, L"(\"_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast && _Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 148, 0);
				};
			};
			_Myptr+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr-_Right._Myptr);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		bool operator==(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr==_Right._Myptr);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		bool operator<(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myptr<_Right._Myptr);
		}
		bool operator>(const _Myt&_Right)const
		{
			return (_Right<*this);
		}
		bool operator<=(const _Myt&_Right)const
		{
			return (!(_Right<*this));
		}
		bool operator>=(const _Myt&_Right)const
		{
			return (!(*this<_Right));
		}
		void _Compat(const _Myt&_Right)const
		{
			if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
			{
				_Debug_message(L"vector iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 238);

				{
					(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 239, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 239, 0);
				};
			}
		}
		static void _Xlen()
		{
			throw length_error("vector<T> too long");
		}
		static void _Xran()
		{
			throw out_of_range("invalid vector<T> subscript");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid vector<T> argument");
		}
		_Tptr _Myptr;
	};
	template<class _Ty, class _Alloc>
	inline _Vector_const_iterator<_Ty, _Alloc>operator+(typename _Vector_const_iterator<_Ty, _Alloc>::difference_type _Off, _Vector_const_iterator<_Ty, _Alloc>_Next)
	{
		return (_Next+=_Off);
	}
	template<class _Ty, class _Alloc>
	class _Vector_iterator: public _Vector_const_iterator<_Ty, _Alloc>
	{
	public:
		typedef _Vector_iterator<_Ty, _Alloc>_Myt;
		typedef _Vector_const_iterator<_Ty, _Alloc>_Mybase;
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::pointer pointer;
		typedef typename _Alloc::reference reference;
		_Vector_iterator()
		{
		}
		_Vector_iterator(pointer _Ptr, const _Container_base*_Pvector): _Mybase(_Ptr, _Pvector)
		{
		}
		reference operator*()const
		{
			return ((reference)**(_Mybase*)this);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			++(*(_Mybase*)this);
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			--(*(_Mybase*)this);
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{
			(*(_Mybase*)this)+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Mybase&_Right)const
		{
			return (*(_Mybase*)this-_Right);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
	};
	template<class _Ty, class _Alloc>
	inline _Vector_iterator<_Ty, _Alloc>operator+(typename _Vector_iterator<_Ty, _Alloc>::difference_type _Off, _Vector_iterator<_Ty, _Alloc>_Next)
	{
		return (_Next+=_Off);
	}
	template<class _Ty, class _Alloc>
	class _Vector_val: public _Container_base
	{
		protected: _Vector_val()
		{
		}
		explicit _Vector_val(_Alloc _Al): _Alval(_Al)
		{
		}
		typedef typename _Alloc::template rebind<_Ty>::other _Alty;
		_Alty _Alval;
	};
	template<class _Ty, class _Ax>
	class vector: public _Vector_val<_Ty, _Ax>
	{
	public:
		typedef vector<_Ty, _Ax>_Myt;
		typedef _Vector_val<_Ty, _Ax>_Mybase;
		typedef typename _Mybase::_Alty _Alloc;
		typedef _Alloc allocator_type;
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename _Alloc::pointer _Tptr;
		typedef typename _Alloc::const_pointer _Ctptr;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef typename _Alloc::reference _Reft;
		typedef _Reft reference;
		typedef typename _Alloc::const_reference const_reference;
		typedef typename _Alloc::value_type value_type;
		typedef _Vector_iterator<_Ty, _Alloc>iterator;
		typedef _Vector_const_iterator<_Ty, _Alloc>const_iterator;
		friend class _Vector_const_iterator<_Ty, _Alloc>;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		vector(): _Mybase()
		{
			_Buy(0);
		}
		explicit vector(const _Alloc&_Al): _Mybase(_Al)
		{
			_Buy(0);
		}
		explicit vector(size_type _Count): _Mybase()
		{
			_Construct_n(_Count, _Ty());
		}
		vector(size_type _Count, const _Ty&_Val): _Mybase()
		{
			_Construct_n(_Count, _Val);
		}
		vector(size_type _Count, const _Ty&_Val, const _Alloc&_Al): _Mybase(_Al)
		{
			_Construct_n(_Count, _Val);
		}
		vector(const _Myt&_Right): _Mybase(_Right._Alval)
		{
			if(_Buy(_Right.size()))try
			{
				_Mylast=_Ucopy(_Right.begin(), _Right.end(), _Myfirst);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		template<class _Iter>
		vector(_Iter _First, _Iter _Last): _Mybase()
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc&_Al): _Mybase(_Al)
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			size_type _Size=(size_type)_Count;
			_Construct_n(_Size, (_Ty)_Val);
		}
		template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			_Buy(0);
			try
			{
				insert(begin(), _First, _Last);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		void _Construct_n(size_type _Count, const _Ty&_Val)
		{
			if(_Buy(_Count))
			{
				try
				{
					_Mylast=_Ufill(_Myfirst, _Count, _Val);
				}
				catch(...)
				{
					_Tidy();
					throw;
				}
			}
		}
		~vector()
		{
			_Tidy();
		}
		_Myt&operator=(const _Myt&_Right)
		{
			if(this!=&_Right)
			{
				this->_Orphan_all();
				if(_Right.size()==0)clear();
				else if(_Right.size()<=size())
				{
					pointer _Ptr=::stdext::unchecked_copy(_Right._Myfirst, _Right._Mylast, _Myfirst);
					_Destroy(_Ptr, _Mylast);
					_Mylast=_Myfirst+_Right.size();
				}
				else if(_Right.size()<=capacity())
				{
					pointer _Ptr=_Right._Myfirst+size();
					::stdext::unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);
					_Mylast=_Ucopy(_Ptr, _Right._Mylast, _Mylast);
				}
				else
				{
					if(_Myfirst!=0)
					{
						_Destroy(_Myfirst, _Mylast);
						this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
					}
					if(_Buy(_Right.size()))_Mylast=_Ucopy(_Right._Myfirst, _Right._Mylast, _Myfirst);
				}
			}
			return (*this);
		}
		void reserve(size_type _Count)
		{
			if(max_size()<_Count)_Xlen();
			else if(capacity()<_Count)
			{
				pointer _Ptr=this->_Alval.allocate(_Count);
				try
				{
					_Umove(begin(), end(), _Ptr);
				}
				catch(...)
				{
					this->_Alval.deallocate(_Ptr, _Count);
					throw;
				}
				size_type _Size=size();
				if(_Myfirst!=0)
				{
					_Destroy(_Myfirst, _Mylast);
					this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
				}
				this->_Orphan_all();
				_Myend=_Ptr+_Count;
				_Mylast=_Ptr+_Size;
				_Myfirst=_Ptr;
			}
		}
		size_type capacity()const
		{
			return (_Myfirst==0?0: _Myend-_Myfirst);
		}
		iterator begin()
		{
			return (iterator(_Myfirst, this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Myfirst, this));
		}
		iterator end()
		{
			return (iterator(_Mylast, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Mylast, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		void resize(size_type _Newsize)
		{
			resize(_Newsize, _Ty());
		}
		void resize(size_type _Newsize, _Ty _Val)
		{
			if(size()<_Newsize)_Insert_n(end(), _Newsize-size(), _Val);
			else if(_Newsize<size())erase(begin()+_Newsize, end());
		}
		size_type size()const
		{
			return (_Myfirst==0?0: _Mylast-_Myfirst);
		}
		size_type max_size()const
		{
			return (this->_Alval.max_size());
		}
		bool empty()const
		{
			return (size()==0);
		}
		_Alloc get_allocator()const
		{
			return (this->_Alval);
		}
		const_reference at(size_type _Pos)const
		{
			if(size()<=_Pos)_Xran();
			return (*(begin()+_Pos));
		}
		reference at(size_type _Pos)
		{
			if(size()<=_Pos)_Xran();
			return (*(begin()+_Pos));
		}
		const_reference operator[](size_type _Pos)const
		{
			if(size()<=_Pos)
			{
				_Debug_message(L"vector subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 744);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 745, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 745, 0);
				};
			}

			{
				if(!(_Pos<size()))
				{
					(void)((!!((("_Pos < size()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 748, 0, L"(\"_Pos < size()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 748, 0);
				};
			};
			return (*(_Myfirst+_Pos));
		}
		reference operator[](size_type _Pos)
		{
			if(size()<=_Pos)
			{
				_Debug_message(L"vector subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 759);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 760, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 760, 0);
				};
			}

			{
				if(!(_Pos<size()))
				{
					(void)((!!((("_Pos < size()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 763, 0, L"(\"_Pos < size()\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 763, 0);
				};
			};
			return (*(_Myfirst+_Pos));
		}
		reference front()
		{
			return (*begin());
		}
		const_reference front()const
		{
			return (*begin());
		}
		reference back()
		{
			return (*(end()-1));
		}
		const_reference back()const
		{
			return (*(end()-1));
		}
		void push_back(const _Ty&_Val)
		{
			if(size()<capacity())
			{
				_Orphan_range(_Mylast, _Mylast);
				_Mylast=_Ufill(_Mylast, 1, _Val);
			}
			else insert(end(), _Val);
		}
		void pop_back()
		{
			if(empty())_Debug_message(L"vector empty before pop", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 810);
			else
			{
				_Orphan_range(_Mylast-1, _Mylast);
				_Destroy(_Mylast-1, _Mylast);
				--_Mylast;
			}
		}
		template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
			_Assign(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Assign_n((size_type)_Count, (_Ty)_Val);
		}
		template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			erase(begin(), end());
			insert(begin(), _First, _Last);
		}
		void assign(size_type _Count, const _Ty&_Val)
		{
			_Assign_n(_Count, _Val);
		}
		iterator insert(iterator _Where, const _Ty&_Val)
		{
			size_type _Off=size()==0?0: _Where-begin();
			_Insert_n(_Where, (size_type)1, _Val);
			return (begin()+_Off);
		}
		void insert(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			_Insert_n(_Where, _Count, _Val);
		}
		template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, _Int_iterator_tag)
		{
			_Insert_n(_Where, (size_type)_First, (_Ty)_Last);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
		{
			for(;
			_First!=_Last;
			++_First, ++_Where)_Where=insert(_Where, *_First);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
		{
			if(_Where._Mycont!=this||_Where._Myptr<_Myfirst||_Mylast<_Where._Myptr)_Debug_message(L"vector insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 895);
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 896);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"vector insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 898);
			size_type _Count=0;
			_Distance(_First, _Last, _Count);
			size_type _Capacity=capacity();
			if(_Count==0);
			else if(max_size()-size()<_Count)_Xlen();
			else if(_Capacity<size()+_Count)
			{
				_Capacity=max_size()-_Capacity/2<_Capacity?0: _Capacity+_Capacity/2;
				if(_Capacity<size()+_Count)_Capacity=size()+_Count;
				pointer _Newvec=this->_Alval.allocate(_Capacity);
				pointer _Ptr=_Newvec;
				try
				{
					_Ptr=_Umove(_Myfirst, (_Where)._Myptr, _Newvec);
					_Ptr=_Ucopy(_First, _Last, _Ptr);
					_Umove((_Where)._Myptr, _Mylast, _Ptr);
				}
				catch(...)
				{
					_Destroy(_Newvec, _Ptr);
					this->_Alval.deallocate(_Newvec, _Capacity);
					throw;
				}
				_Count+=size();
				if(_Myfirst!=0)
				{
					_Destroy(_Myfirst, _Mylast);
					this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
				}
				this->_Orphan_all();
				_Myend=_Newvec+_Capacity;
				_Mylast=_Newvec+_Count;
				_Myfirst=_Newvec;
			}
			else if((size_type)(end()-_Where)<_Count)
			{
				_Umove((_Where)._Myptr, _Mylast, (_Where)._Myptr+_Count);
				_Iter _Mid=_First;
				advance(_Mid, end()-_Where);
				try
				{
					_Ucopy(_Mid, _Last, _Mylast);
				}
				catch(...)
				{
					_Destroy((_Where)._Myptr+_Count, _Mylast+_Count);
					throw;
				}
				_Mylast+=_Count;
				_Orphan_range(_Where._Myptr, _Mylast);
				::stdext::unchecked_copy(_First, _Mid, (_Where)._Myptr);
			}
			else
			{
				pointer _Oldend=_Mylast;
				_Mylast=_Umove(_Oldend-_Count, _Oldend, _Mylast);
				::stdext::_Unchecked_move_backward((_Where)._Myptr, _Oldend-_Count, _Oldend);
				_Orphan_range(_Where._Myptr, _Mylast);
				::stdext::unchecked_copy(_First, _Last, (_Where)._Myptr);
			}
		}
		iterator erase(iterator _Where)
		{
			if(_Where._Mycont!=this||_Where._Myptr<_Myfirst||_Mylast<=_Where._Myptr)_Debug_message(L"vector erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 989);
			::stdext::unchecked_copy(_Where._Myptr+1, _Mylast, _Where._Myptr);
			_Destroy(_Mylast-1, _Mylast);
			_Orphan_range(_Where._Myptr, _Mylast);
			--_Mylast;
			return (iterator(_Where._Myptr, this));
		}
		iterator erase(iterator _First, iterator _Last)
		{
			if(_First!=_Last)
			{
				if(_Last<_First||_First._Mycont!=this||_First._Myptr<_Myfirst||_Mylast<_Last._Myptr)_Debug_message(L"vector erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1016);
				pointer _Ptr=::stdext::unchecked_copy((_Last)._Myptr, _Mylast, (_First)._Myptr);
				_Orphan_range(_First._Myptr, _Mylast);
				_Destroy(_Ptr, _Mylast);
				_Mylast=_Ptr;
			}
			return (iterator(_First._Myptr, this));
		}
		void clear()
		{
			erase(begin(), end());
		}
		void swap(_Myt&_Right)
		{
			if(this->_Alval==_Right._Alval)
			{
				this->_Swap_all(_Right);
				std::swap(_Myfirst, _Right._Myfirst);
				std::swap(_Mylast, _Right._Mylast);
				std::swap(_Myend, _Right._Myend);
			}
			else
			{
				_Myt _Ts=*this;
				*this=_Right, _Right=_Ts;
			}
		}
		protected: void _Assign_n(size_type _Count, const _Ty&_Val)
		{
			_Ty _Tmp=_Val;
			erase(begin(), end());
			insert(begin(), _Count, _Tmp);
		}
		bool _Buy(size_type _Capacity)
		{
			_Myfirst=0, _Mylast=0, _Myend=0;
			if(_Capacity==0)return (false);
			else if(max_size()<_Capacity)_Xlen();
			else
			{
				_Myfirst=this->_Alval.allocate(_Capacity);
				_Mylast=_Myfirst;
				_Myend=_Myfirst+_Capacity;
			}
			return (true);
		}
		void _Destroy(pointer _First, pointer _Last)
		{
			_Destroy_range(_First, _Last, this->_Alval);
		}
		void _Tidy()
		{
			if(_Myfirst!=0)
			{
				this->_Orphan_all();
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
			}
			_Myfirst=0, _Mylast=0, _Myend=0;
		}
		template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{
			return (::stdext::unchecked_uninitialized_copy(_First, _Last, _Ptr, this->_Alval));
		}
		template<class _Iter>
		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
		{
			return (::stdext::_Unchecked_uninitialized_move(_First, _Last, _Ptr, this->_Alval));
		}
		void _Insert_n(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			if(_Where._Mycont!=this||_Where._Myptr<_Myfirst||_Mylast<_Where._Myptr)_Debug_message(L"vector insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1125);
			_Ty _Tmp=_Val;
			size_type _Capacity=capacity();
			if(_Count==0);
			else if(max_size()-size()<_Count)_Xlen();
			else if(_Capacity<size()+_Count)
			{
				_Capacity=max_size()-_Capacity/2<_Capacity?0: _Capacity+_Capacity/2;
				if(_Capacity<size()+_Count)_Capacity=size()+_Count;
				pointer _Newvec=this->_Alval.allocate(_Capacity);
				pointer _Ptr=_Newvec;
				try
				{
					_Ptr=_Umove(_Myfirst, (_Where)._Myptr, _Newvec);
					_Ptr=_Ufill(_Ptr, _Count, _Tmp);
					_Umove((_Where)._Myptr, _Mylast, _Ptr);
				}
				catch(...)
				{
					_Destroy(_Newvec, _Ptr);
					this->_Alval.deallocate(_Newvec, _Capacity);
					throw;
				}
				_Count+=size();
				if(_Myfirst!=0)
				{
					_Destroy(_Myfirst, _Mylast);
					this->_Alval.deallocate(_Myfirst, _Myend-_Myfirst);
				}
				this->_Orphan_all();
				_Myend=_Newvec+_Capacity;
				_Mylast=_Newvec+_Count;
				_Myfirst=_Newvec;
			}
			else if((size_type)(_Mylast-(_Where)._Myptr)<_Count)
			{
				_Umove((_Where)._Myptr, _Mylast, (_Where)._Myptr+_Count);
				try
				{
					_Ufill(_Mylast, _Count-(_Mylast-(_Where)._Myptr), _Tmp);
				}
				catch(...)
				{
					_Destroy((_Where)._Myptr+_Count, _Mylast+_Count);
					throw;
				}
				_Mylast+=_Count;
				_Orphan_range(_Where._Myptr, _Mylast);
				fill((_Where)._Myptr, _Mylast-_Count, _Tmp);
			}
			else
			{
				pointer _Oldend=_Mylast;
				_Mylast=_Umove(_Oldend-_Count, _Oldend, _Mylast);
				_Orphan_range(_Where._Myptr, _Mylast);
				::stdext::_Unchecked_move_backward((_Where)._Myptr, _Oldend-_Count, _Oldend);
				fill((_Where)._Myptr, (_Where)._Myptr+_Count, _Tmp);
			}
		}
		pointer _Ufill(pointer _Ptr, size_type _Count, const _Ty&_Val)
		{
			::stdext::unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);
			return (_Ptr+_Count);
		}
		static void _Xlen()
		{
			throw length_error("vector<T> too long");
		}
		static void _Xran()
		{
			throw out_of_range("invalid vector<T> subscript");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid vector<T> argument");
		}
		void _Orphan_range(pointer _First, pointer _Last)const
		{
			_Lockit _Lock(3);
			const_iterator**_Pnext=(const_iterator**)&this->_Myfirstiter;
			while(*_Pnext!=0)if((*_Pnext)->_Myptr<_First||_Last<(*_Pnext)->_Myptr)_Pnext=(const_iterator**)&(*_Pnext)->_Mynextiter;
			else
			{
				(*_Pnext)->_Mycont=0;
				*_Pnext=(const_iterator*)(*_Pnext)->_Mynextiter;
			}
		}
		pointer _Myfirst;
		pointer _Mylast;
		pointer _Myend;
	};
	template<class _Ty, class _Ax>
	class _Move_operation_category<vector<_Ty, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Ty, class _Alloc>
	inline bool operator==(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (_Left.size()==_Right.size()&&equal(_Left.begin(), _Left.end(), _Right.begin()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator!=(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty, class _Alloc>
	inline bool operator<(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Ty, class _Alloc>
	inline bool operator<=(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>=(const vector<_Ty, _Alloc>&_Left, const vector<_Ty, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
	template<class _Ty, class _Alloc>
	inline void swap(vector<_Ty, _Alloc>&_Left, vector<_Ty, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	typedef unsigned _Vbase;
	const int _VBITS=8*sizeof(_Vbase);
	template<class _MycontTy>
	class _Vb_iter_base: public _Ranit<_Bool, typename _MycontTy::difference_type, bool*, bool>
	{
	public:
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		_Vb_iter_base(): _Myptr(0), _Myoff(0)
		{
		}
		_Vb_iter_base(const _Vb_iter_base<_MycontTy>&_Right): _Myptr(_Right._Myptr), _Myoff(_Right._Myoff)
		{

			{
				if(!(_Right._Mycont!=0))
				{
					(void)((!!((("_Right._Mycont != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1343, 0, L"(\"_Right._Mycont != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1343, 0);
				};
			};
			this->_Adopt(_Right._Mycont);
		}
		_Vb_iter_base(_Vbase*_Ptr, _MycontTy*_Mypvbool): _Myptr(_Ptr), _Myoff(0)
		{

			{
				if(!(_Mypvbool!=0))
				{
					(void)((!!((("_Mypvbool != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1350, 0, L"(\"_Mypvbool != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1350, 0);
				};
			};
			this->_Adopt(_Mypvbool);
		}
		_Vbase*_Myptr;
		typename _MycontTy::size_type _Myoff;
		static void _Xlen()
		{
			throw length_error("vector<bool> too long");
		}
		static void _Xran()
		{
			throw out_of_range("invalid vector<bool> subscript");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid vector<bool> argument");
		}
		_Vbase*_My_cont_begin()const
		{
			return (((_MycontTy*)this->_Mycont)->_Myvec.begin())._Myptr;
		}
		typename _MycontTy::size_type _My_actual_offset()const
		{
			typename _MycontTy::size_type _Off=this->_Myoff;
			_Off+=_VBITS*(this->_Myptr-_My_cont_begin());
			return _Off;
		}
	};
	template<class _MycontTy>
	class _Vb_reference: public _Vb_iter_base<_MycontTy>
	{
	public:
		_Vb_reference()
		{
		}
		_Vb_reference(const _Vb_iter_base<_MycontTy>&_Right): _Vb_iter_base<_MycontTy>(_Right)
		{
		}
		_Vb_reference&operator=(const _Vb_reference<_MycontTy>&_Right)
		{
			return (*this=bool(_Right));
		}
		_Vb_reference<_MycontTy>&operator=(bool _Val)
		{
			if(_Val)*_Getptr()|=_Mask();
			else*_Getptr()&=~_Mask();
			return (*this);
		}
		void flip()
		{
			*_Getptr()^=_Mask();
		}
		bool operator~()const
		{
			return (!bool(*this));
		}
		operator bool()const
		{
			return ((*_Getptr()&_Mask())!=0);
		}
		_Vbase*_Getptr()const
		{
			if(this->_Mycont==0||this->_Myptr==0||((_MycontTy*)this->_Mycont)->_Mysize<=this->_My_actual_offset())
			{
				_Debug_message(L"vector<bool> iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1466);

				{
					(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1467, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1467, 0);
				};
			}
			return (this->_Myptr);
		}
		protected: _Vbase _Mask()const
		{
			return ((_Vbase)(1<<this->_Myoff));
		}
	};
	template<class _MycontTy>
	void swap(_Vb_reference<_MycontTy>_Left, _Vb_reference<_MycontTy>_Right)
	{
		bool _Val=_Left;
		_Left=_Right;
		_Right=_Val;
	}
	template<class _MycontTy>
	class _Vb_const_iterator: public _Vb_iter_base<_MycontTy>
	{
	public:
		typedef _Vb_reference<_MycontTy>_Reft;
		typedef bool const_reference;
		typedef random_access_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef typename _MycontTy::size_type size_type;
		typedef typename _MycontTy::difference_type difference_type;
		typedef const_reference*pointer;
		typedef const_reference reference;
		_Vb_const_iterator()
		{
		}
		_Vb_const_iterator(const _Vbase*_Ptr, const _MycontTy*_Mypvbool): _Vb_iter_base<_MycontTy>((_Vbase*)_Ptr, (_MycontTy*)_Mypvbool)
		{
		}
		const_reference operator*()const
		{
			return (_Reft(*this));
		}
		_Vb_const_iterator<_MycontTy>&operator++()
		{
			_Inc();
			return (*this);
		}
		_Vb_const_iterator<_MycontTy>operator++(int)
		{
			_Vb_const_iterator<_MycontTy>_Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Vb_const_iterator<_MycontTy>&operator--()
		{
			_Dec();
			return (*this);
		}
		_Vb_const_iterator<_MycontTy>operator--(int)
		{
			_Vb_const_iterator<_MycontTy>_Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Vb_const_iterator<_MycontTy>&operator+=(difference_type _Off)
		{
			if(_Off==0)return (*this);

			{
				if(!(this->_Mycont!=0&&this->_Myptr!=0))
				{
					(void)((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1559, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1559, 0);
				};
			};
			if(_Off<0)
			{

				{
					if(!(this->_My_actual_offset()>=((size_type)-_Off)))
					{
						(void)((!!((("this->_My_actual_offset() >= ((size_type)-_Off)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1562, 0, L"(\"this->_My_actual_offset() >= ((size_type)-_Off)\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1562, 0);
					};
				};
			}
			else
			{

				{
					if(!((this->_My_actual_offset()+_Off)<=((_MycontTy*)this->_Mycont)->_Mysize))
					{
						(void)((!!((("(this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Mycont)->_Mysize", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1566, 0, L"(\"(this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Mycont)->_Mysize\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1566, 0);
					};
				};
			}
			if(_Off<0&&this->_Myoff<0-(size_type)_Off)
			{
				this->_Myoff+=_Off;
				this->_Myptr-=1+((size_type)(-1)-this->_Myoff)/_VBITS;
				this->_Myoff%=_VBITS;
			}
			else
			{
				this->_Myoff+=_Off;
				this->_Myptr+=this->_Myoff/_VBITS;
				this->_Myoff%=_VBITS;
			}
			return (*this);
		}
		_Vb_const_iterator<_MycontTy>operator+(difference_type _Off)const
		{
			_Vb_const_iterator<_MycontTy>_Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Vb_const_iterator<_MycontTy>&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Vb_const_iterator<_MycontTy>operator-(difference_type _Off)const
		{
			_Vb_const_iterator<_MycontTy>_Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			_Compat(_Right);
			return (_VBITS*(this->_Myptr-_Right._Myptr)+(difference_type)this->_Myoff-(difference_type)_Right._Myoff);
		}
		const_reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		bool operator==(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			_Compat(_Right);
			return (this->_Myptr==_Right._Myptr&&this->_Myoff==_Right._Myoff);
		}
		bool operator!=(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (!(*this==_Right));
		}
		bool operator<(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			_Compat(_Right);
			return (this->_Myptr<_Right._Myptr||this->_Myptr==_Right._Myptr&&this->_Myoff<_Right._Myoff);
		}
		bool operator>(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (_Right<*this);
		}
		bool operator<=(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (!(_Right<*this));
		}
		bool operator>=(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (!(*this<_Right));
		}
		protected: void _Compat(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)_Debug_message(L"vector<bool> iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1667);
		}
		void _Dec()
		{
			if(this->_Myoff!=0)
			{
				--this->_Myoff;
			}
			else
			{

				{
					if(!(this->_Mycont!=0&&this->_Myptr!=0))
					{
						(void)((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1679, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1679, 0);
					};
				};

				{
					if(!(this->_Myptr>this->_My_cont_begin()))
					{
						(void)((!!((("this->_Myptr > this->_My_cont_begin()", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1680, 0, L"(\"this->_Myptr > this->_My_cont_begin()\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1680, 0);
					};
				};
				--this->_Myptr;
				this->_Myoff=_VBITS-1;
			}
		}
		void _Inc()
		{

			{
				if(!(this->_Mycont!=0&&this->_Myptr!=0))
				{
					(void)((!!((("this->_Mycont != NULL && this->_Myptr != NULL", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1688, 0, L"(\"this->_Mycont != NULL && this->_Myptr != NULL\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1688, 0);
				};
			};

			{
				if(!((this->_My_actual_offset()+1)<=((_MycontTy*)this->_Mycont)->_Mysize))
				{
					(void)((!!((("(this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Mycont)->_Mysize", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1689, 0, L"(\"(this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Mycont)->_Mysize\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 1689, 0);
				};
			};
			if(this->_Myoff<_VBITS-1)++this->_Myoff;
			else this->_Myoff=0, ++this->_Myptr;
		}
	};
	template<class _MycontTy>
	_Vb_const_iterator<_MycontTy>operator+(typename _Vb_const_iterator<_MycontTy>::difference_type _Off, _Vb_const_iterator<_MycontTy>_Right)
	{
		return (_Right+=_Off);
	}
	template<class _MycontTy>
	class _Vb_iterator: public _Vb_const_iterator<_MycontTy>
	{
	public:
		typedef _Vb_reference<_MycontTy>_Reft;
		typedef bool const_reference;
		typedef random_access_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef typename _MycontTy::size_type size_type;
		typedef typename _MycontTy::difference_type difference_type;
		typedef _Reft*pointer;
		typedef _Reft reference;
		_Vb_iterator()
		{
		}
		_Vb_iterator(_Vbase*_Ptr, _MycontTy*_Mypvbool): _Vb_const_iterator<_MycontTy>(_Ptr, _Mypvbool)
		{
		}
		reference operator*()const
		{
			return (_Reft(*this));
		}
		_Vb_iterator<_MycontTy>&operator++()
		{
			++*(_Vb_const_iterator<_MycontTy>*)this;
			return (*this);
		}
		_Vb_iterator<_MycontTy>operator++(int)
		{
			_Vb_iterator<_MycontTy>_Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Vb_iterator<_MycontTy>&operator--()
		{
			--*(_Vb_const_iterator<_MycontTy>*)this;
			return (*this);
		}
		_Vb_iterator<_MycontTy>operator--(int)
		{
			_Vb_iterator<_MycontTy>_Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Vb_iterator<_MycontTy>&operator+=(difference_type _Off)
		{
			*(_Vb_const_iterator<_MycontTy>*)this+=_Off;
			return (*this);
		}
		_Vb_iterator<_MycontTy>operator+(difference_type _Off)const
		{
			_Vb_iterator<_MycontTy>_Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Vb_iterator<_MycontTy>&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Vb_iterator<_MycontTy>operator-(difference_type _Off)const
		{
			_Vb_iterator<_MycontTy>_Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Vb_const_iterator<_MycontTy>&_Right)const
		{
			return (*(_Vb_const_iterator<_MycontTy>*)this-_Right);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
	};
	template<class _MycontTy>
	_Vb_iterator<_MycontTy>operator+(typename _Vb_iterator<_MycontTy>::difference_type _Off, _Vb_iterator<_MycontTy>_Right)
	{
		return (_Right+=_Off);
	}
	template<class _Alloc>
	class vector<_Bool, _Alloc>: public _Container_base
	{
	public:
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef std::vector<_Vbase, typename _Alloc::template rebind<_Vbase>::other>_Vbtype;
		typedef std::vector<_Bool, _Alloc>_Myt;
		typedef _Dift difference_type;
		typedef _Bool _Ty;
		typedef _Alloc allocator_type;
		typedef _Vb_reference<_Myt>reference;
		typedef bool const_reference;
		typedef bool value_type;
		typedef reference _Reft;
		typedef _Vb_const_iterator<_Myt>const_iterator;
		typedef _Vb_iterator<_Myt>iterator;
		friend class _Vb_reference<_Myt>;
		friend class _Vb_iter_base<_Myt>;
		friend class _Vb_const_iterator<_Myt>;
		typedef iterator pointer;
		typedef const_iterator const_pointer;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		vector(): _Mysize(0), _Myvec()
		{
		}
		explicit vector(const _Alloc&_Al): _Mysize(0), _Myvec(_Al)
		{
		}
		explicit vector(size_type _Count, bool _Val=false): _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val?-1: 0))
		{
			_Trim(_Count);
		}
		vector(size_type _Count, bool _Val, const _Alloc&_Al): _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val?-1: 0), _Al)
		{
			_Trim(_Count);
		}
		template<class _Iter>
		vector(_Iter _First, _Iter _Last): _Mysize(0), _Myvec()
		{
			_BConstruct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc&_Al): _Mysize(0), _Myvec(_Al)
		{
			_BConstruct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _BConstruct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			size_type _Num=(size_type)_Count;
			_Myvec.assign(_Num, (_Ty)_Val?-1: 0);
			_Trim(_Num);
		}
		template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			insert(begin(), _First, _Last);
		}
		~vector()
		{
			_Mysize=0;
		}
		void reserve(size_type _Count)
		{
			_Myvec.reserve(_Nw(_Count));
		}
		size_type capacity()const
		{
			return (_Myvec.capacity()*_VBITS);
		}
		iterator begin()
		{
			return (iterator((_Myvec.begin())._Myptr, this));
		}
		const_iterator begin()const
		{
			return (const_iterator((_Myvec.begin())._Myptr, this));
		}
		iterator end()
		{
			iterator _Tmp=begin();
			if(0<_Mysize)_Tmp+=_Mysize;
			return (_Tmp);
		}
		const_iterator end()const
		{
			const_iterator _Tmp=begin();
			if(0<_Mysize)_Tmp+=_Mysize;
			return (_Tmp);
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		void resize(size_type _Newsize, bool _Val=false)
		{
			if(size()<_Newsize)_Insert_n(end(), _Newsize-size(), _Val);
			else if(_Newsize<size())erase(begin()+_Newsize, end());
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			const size_type _Maxsize=_Myvec.max_size();
			return (_Maxsize<(size_type)(-1)/_VBITS?_Maxsize*_VBITS: (size_type)(-1));
		}
		bool empty()const
		{
			return (size()==0);
		}
		_Alloc get_allocator()const
		{
			return (_Myvec.get_allocator());
		}
		const_reference at(size_type _Off)const
		{
			if(size()<=_Off)_Xran();
			return (*(begin()+_Off));
		}
		reference at(size_type _Off)
		{
			if(size()<=_Off)_Xran();
			return (*(begin()+_Off));
		}
		const_reference operator[](size_type _Off)const
		{
			return (*(begin()+_Off));
		}
		reference operator[](size_type _Off)
		{
			return (*(begin()+_Off));
		}
		reference front()
		{
			return (*begin());
		}
		const_reference front()const
		{
			return (*begin());
		}
		reference back()
		{
			return (*(end()-1));
		}
		const_reference back()const
		{
			return (*(end()-1));
		}
		void push_back(bool _Val)
		{
			insert(end(), _Val);
		}
		void pop_back()
		{
			if(!empty())erase(end()-1);
		}
		template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
			_Assign(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Assign_n((size_type)_Count, (bool)_Val);
		}
		template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			erase(begin(), end());
			insert(begin(), _First, _Last);
		}
		void assign(size_type _Count, bool _Val)
		{
			_Assign_n(_Count, _Val);
		}
		iterator insert(iterator _Where, bool _Val)
		{
			size_type _Off=_Where-begin();
			_Insert_n(_Where, (size_type)1, _Val);
			return (begin()+_Off);
		}
		void insert(iterator _Where, size_type _Count, bool _Val)
		{
			_Insert_n(_Where, _Count, _Val);
		}
		template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Insert_n(_Where, (size_type)_Count, (bool)_Val);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
		{
			size_type _Off=_Where-begin();
			for(;
			_First!=_Last;
			++_First, ++_Off)insert(begin()+_Off, *_First);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2118);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"vector<bool> insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2120);
			size_type _Count=0;
			_Distance(_First, _Last, _Count);
			size_type _Off=_Insert_x(_Where, _Count);
			std::copy(_First, _Last, begin()+_Off);
		}
		iterator erase(iterator _Where)
		{
			size_type _Off=_Where-begin();
			if(end()<=_Where)_Debug_message(L"vector<bool> erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2136);
			std::copy(_Where+1, end(), _Where);
			_Orphan_range(_Off, _Mysize);
			_Trim(_Mysize-1);
			return (begin()+_Off);
		}
		iterator erase(iterator _First, iterator _Last)
		{
			size_type _Off=_First-begin();
			if(_Last<_First||end()<_Last)_Debug_message(L"vector<bool> erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2154);
			iterator _Next=std::copy(_Last, end(), _First);
			size_type _Newsize=_Next-begin();
			_Orphan_range(_Newsize, _Mysize);
			_Trim(_Newsize);
			return (begin()+_Off);
		}
		void clear()
		{
			erase(begin(), end());
		}
		void flip()
		{
			for(typename _Vbtype::iterator _Next=_Myvec.begin();
			_Next!=_Myvec.end();
			++_Next)*_Next=(_Vbase)~*_Next;
			_Trim(_Mysize);
		}
		void swap(_Myt&_Right)
		{
			this->_Swap_all(_Right);
			std::swap(_Mysize, _Right._Mysize);
			_Myvec.swap(_Right._Myvec);
		}
		static void swap(reference _Left, reference _Right)
		{
			bool _Val=_Left;
			_Left=_Right;
			_Right=_Val;
		}
		protected: void _Assign_n(size_type _Count, bool _Val)
		{
			erase(begin(), end());
			_Insert_n(begin(), _Count, _Val);
		}
		void _Insert_n(iterator _Where, size_type _Count, bool _Val)
		{
			size_type _Off=_Insert_x(_Where, _Count);
			fill(begin()+_Off, begin()+(_Off+_Count), _Val);
		}
		size_type _Insert_x(iterator _Where, size_type _Count)
		{
			size_type _Off=_Where-begin();
			if(end()<_Where)_Debug_message(L"vector<bool> insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\vector", 2220);
			bool _Realloc=capacity()-size()<_Count;
			if(_Count==0);
			else if(max_size()-size()<_Count)_Xlen();
			else
			{
				_Myvec.resize(_Nw(size()+_Count), 0);
				if(size()==0)_Mysize+=_Count;
				else
				{
					iterator _Oldend=end();
					_Mysize+=_Count;
					copy_backward(begin()+_Off, _Oldend, end());
				}
				_Orphan_range(_Realloc?0: _Off, _Mysize);
			}
			return (_Off);
		}
		static size_type _Nw(size_type _Count)
		{
			return ((_Count+_VBITS-1)/_VBITS);
		}
		void _Orphan_range(size_type _Offlo, size_type _Offhi)const
		{
			_Lockit _Lock(3);
			_Vbase*_Base=(_Vbase*)(_Myvec.begin())._Myptr;
			_Vb_iter_base<_Myt>**_Pnext=(_Vb_iter_base<_Myt>**)&this->_Myfirstiter;
			while(*_Pnext!=0)
			{
				size_type _Off=_VBITS*((*_Pnext)->_Myptr-_Base)+(*_Pnext)->_Myoff;
				if(_Off<_Offlo||_Offhi<_Off)_Pnext=(_Vb_iter_base<_Myt>**)&(*_Pnext)->_Mynextiter;
				else
				{
					(*_Pnext)->_Mycont=0;
					*_Pnext=(_Vb_iter_base<_Myt>*)(*_Pnext)->_Mynextiter;
				}
			}
		}
		void _Trim(size_type _Size)
		{
			if(max_size()<_Size)_Xlen();
			size_type _Words=_Nw(_Size);
			if(_Words<_Myvec.size())_Myvec.erase(_Myvec.begin()+_Words, _Myvec.end());
			_Mysize=_Size;
			_Size%=_VBITS;
			if(0<_Size)_Myvec[_Words-1]&=(_Vbase)((1<<_Size)-1);
		}
		void _Xlen()const
		{
			throw length_error("vector<bool> too long");
		}
		void _Xran()const
		{
			throw out_of_range("invalid vector<bool> subscript");
		}
		size_type _Mysize;
		_Vbtype _Myvec;
	};
	typedef vector<bool, allocator<bool> >_Bvector;
}
namespace stdext
{
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt unchecked_remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val);
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt checked_remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val);
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unchecked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred);
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt checked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred);
	template<class _InIt, class _OutIt>
	inline _OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest);
	template<class _InIt, class _OutIt>
	inline _OutIt checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest);
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred);
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred);
	template<class _BidIt, class _OutIt>
	inline _OutIt unchecked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest);
	template<class _BidIt, class _OutIt>
	inline _OutIt checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest);
	template<class _FwdIt, class _OutIt>
	inline _OutIt unchecked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest);
	template<class _FwdIt, class _OutIt>
	inline _OutIt checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest);
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest);
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred);
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred);
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count);
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count);
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred);
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred);
}
namespace std
{
	const int _ISORT_MAX=32;
	template<class _InIt, class _Fn1>
	inline _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 254);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 255);
		typename::std::_Checked_iterator_base_helper<_InIt>::_Checked_iterator_base_type _ChkFirst(::std::_Checked_base(_First));
		typename::std::_Checked_iterator_base_helper<_InIt>::_Checked_iterator_base_type _ChkLast(::std::_Checked_base(_Last));
		for(;
		_ChkFirst!=_ChkLast;
		++_ChkFirst)_Func(*_ChkFirst);
		return (_Func);
	}
	template<class _InIt, class _Ty>
	inline _InIt _Find(_InIt _First, _InIt _Last, const _Ty&_Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 268);
		for(;
		_First!=_Last;
		++_First)if(*_First==_Val)break;
		return (_First);
	}
	inline const char*_Find(const char*_First, const char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 277);
		_First=(const char*)::memchr(_First, _Val, _Last-_First);
		return (_First==0?_Last: _First);
	}
	inline const signed char*_Find(const signed char*_First, const signed char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 285);
		_First=(const signed char*)::memchr(_First, _Val, _Last-_First);
		return (_First==0?_Last: _First);
	}
	inline const unsigned char*_Find(const unsigned char*_First, const unsigned char*_Last, int _Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 294);
		_First=(const unsigned char*)::memchr(_First, _Val, _Last-_First);
		return (_First==0?_Last: _First);
	}
	template<class _InIt, class _Ty>
	inline _InIt find(_InIt _First, _InIt _Last, const _Ty&_Val)
	{
		::std::_Checked_assign_from_base(_First, _Find(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val));
		return (_First);
	}
	template<class _InIt, class _Pr>
	inline _InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 314);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 315);
		for(;
		_First!=_Last;
		++_First)if(_Pred(*_First))break;
		return (_First);
	}
	template<class _InIt, class _Pr>
	inline _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Find_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _FwdIt>
	inline _FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 335);
		for(_FwdIt _Firstb;
		(_Firstb=_First)!=_Last&&++_First!=_Last;
		)if(*_Firstb==*_First)return (_Firstb);
		return (_Last);
	}
	template<class _FwdIt>
	inline _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
	{
		::std::_Checked_assign_from_base(_First, _Adjacent_find(::std::_Checked_base(_First), ::std::_Checked_base(_Last)));
		return (_First);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 355);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 356);
		for(_FwdIt _Firstb;
		(_Firstb=_First)!=_Last&&++_First!=_Last;
		)if(_Pred(*_Firstb, *_First))return (_Firstb);
		return (_Last);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Adjacent_find(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _InIt, class _Ty>
	inline typename iterator_traits<_InIt>::difference_type _Count(_InIt _First, _InIt _Last, const _Ty&_Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 378);
		typename iterator_traits<_InIt>::difference_type _Cnt=0;
		for(;
		_First!=_Last;
		++_First)if(*_First==_Val)++_Cnt;
		return (_Cnt);
	}
	template<class _InIt, class _Ty>
	inline typename iterator_traits<_InIt>::difference_type count(_InIt _First, _InIt _Last, const _Ty&_Val)
	{
		return _Count(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val);
	}
	template<class _InIt, class _Pr>
	inline typename iterator_traits<_InIt>::difference_type _Count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 401);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 402);
		typename iterator_traits<_InIt>::difference_type _Count=0;
		for(;
		_First!=_Last;
		++_First)if(_Pred(*_First))++_Count;
		return (_Count);
	}
	template<class _InIt, class _Pr>
	inline typename iterator_traits<_InIt>::difference_type count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{
		return _Count_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred);
	}
	template<class _FwdIt1, class _FwdIt2, class _Diff1, class _Diff2>
	inline _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1*, _Diff2*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 427);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 428);
		_Diff1 _Count1=0;
		_Distance(_First1, _Last1, _Count1);
		_Diff2 _Count2=0;
		_Distance(_First2, _Last2, _Count2);
		for(;
		_Count2<=_Count1;
		++_First1, --_Count1)
		{
			_FwdIt1 _Mid1=_First1;
			for(_FwdIt2 _Mid2=_First2;
			;
			++_Mid1, ++_Mid2)if(_Mid2==_Last2)return (_First1);
			else if(!(*_Mid1==*_Mid2))break;
		}
		return (_Last1);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
	{
		::std::_Checked_assign_from_base(_First1, _Search(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dist_type(_First1), _Dist_type(_First2)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2, class _Diff1, class _Diff2, class _Pr>
	inline _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1*, _Diff2*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 467);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 468);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 469);
		_Diff1 _Count1=0;
		_Distance(_First1, _Last1, _Count1);
		_Diff2 _Count2=0;
		_Distance(_First2, _Last2, _Count2);
		for(;
		_Count2<=_Count1;
		++_First1, --_Count1)
		{
			_FwdIt1 _Mid1=_First1;
			for(_FwdIt2 _Mid2=_First2;
			;
			++_Mid1, ++_Mid2)if(_Mid2==_Last2)return (_First1);
			else if(!_Pred(*_Mid1, *_Mid2))break;
		}
		return (_Last1);
	}
	template<class _FwdIt1, class _FwdIt2, class _Pr>
	inline _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First1, _Search(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred, _Dist_type(_First1), _Dist_type(_First2)));
		return _First1;
	}
	template<class _FwdIt1, class _Diff2, class _Ty>
	inline _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, forward_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 507);
		_FwdIt1 _Mid1;
		if(_Count==0)return (_First1);
		for(;
		;
		_First1=++_Mid1)
		{
			_Diff2 _Count1=_Count;
			for(;
			_First1!=_Last1;
			++_First1)if(*_First1==_Val)break;
			for(_Mid1=_First1;
			;
			)if(--_Count1==0)return (_First1);
			else if(_Mid1==_Last1||!(*++_Mid1==_Val))break;
			if(_Mid1==_Last1)return (_Last1);
		}
	}
	template<class _FwdIt1, class _Diff2, class _Ty>
	inline _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, random_access_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 537);
		_FwdIt1 _Mid1;
		if(_Count==0)return (_First1);
		for(;
		;
		_First1=++_Mid1)
		{
			_FwdIt1 _Oldfirst1=_First1;
			_Diff2 _Count1=_Count;
			for(;
			;
			_First1+=_Count)if(_First1==_Last1)return (_Last1);
			else if(*_First1==_Val)break;
			else if(_Last1-_First1<_Count)return (_Last1);
			if(_Oldfirst1!=_First1)for(++_Oldfirst1;
			_Oldfirst1!=_First1;
			--_First1, --_Count1)if(!(_First1[-1]==_Val))break;
			for(_Mid1=_First1;
			;
			)if(--_Count1==0)return (_First1);
			else if(_Mid1==_Last1||!(*++_Mid1==_Val))break;
			if(_Mid1==_Last1)return (_Last1);
		}
	}
	template<class _FwdIt1, class _Diff2, class _Ty>
	inline _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val)
	{
		::std::_Checked_assign_from_base(_First1, _Search_n(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _Count, _Val, _Iter_cat(_First1)));
		return _First1;
	}
	template<class _FwdIt1, class _Diff2, class _Ty, class _Pr>
	inline _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, _Pr _Pred, forward_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 591);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 592);
		_FwdIt1 _Mid1;
		if(_Count==0)return (_First1);
		for(;
		;
		_First1=++_Mid1)
		{
			_Diff2 _Count1=_Count;
			for(;
			_First1!=_Last1;
			++_First1)if(_Pred(*_First1, _Val))break;
			for(_Mid1=_First1;
			;
			)if(--_Count1==0)return (_First1);
			else if(_Mid1==_Last1||!_Pred(*++_Mid1, _Val))break;
			if(_Mid1==_Last1)return (_Last1);
		}
	}
	template<class _FwdIt1, class _Diff2, class _Ty, class _Pr>
	inline _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, _Pr _Pred, random_access_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 623);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 624);
		_FwdIt1 _Mid1;
		if(_Count==0)return (_First1);
		for(;
		;
		_First1=++_Mid1)
		{
			_FwdIt1 _Oldfirst1=_First1;
			_Diff2 _Count1=_Count;
			for(;
			;
			_First1+=_Count)if(_First1==_Last1)return (_Last1);
			else if(_Pred(*_First1, _Val))break;
			else if(_Last1-_First1<_Count)return (_Last1);
			if(_Oldfirst1!=_First1)for(++_Oldfirst1;
			_Oldfirst1!=_First1;
			--_First1, --_Count1)if(!_Pred(_First1[-1], _Val))break;
			for(_Mid1=_First1;
			;
			)if(--_Count1==0)return (_First1);
			else if(_Mid1==_Last1||!_Pred(*++_Mid1, _Val))break;
			if(_Mid1==_Last1)return (_Last1);
		}
	}
	template<class _FwdIt1, class _Diff2, class _Ty, class _Pr>
	inline _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff2 _Count, const _Ty&_Val, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First1, _Search_n(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _Count, _Val, _Pred, _Iter_cat(_First1)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2, class _Diff1, class _Diff2>
	inline _FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1*, _Diff2*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 679);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 680);
		_Diff1 _Count1=0;
		_Distance(_First1, _Last1, _Count1);
		_Diff2 _Count2=0;
		_Distance(_First2, _Last2, _Count2);
		_FwdIt1 _Ans=_Last1;
		if(0<_Count2)for(;
		_Count2<=_Count1;
		++_First1, --_Count1)
		{
			_FwdIt1 _Mid1=_First1;
			for(_FwdIt2 _Mid2=_First2;
			;
			++_Mid1)if(!(*_Mid1==*_Mid2))break;
			else if(++_Mid2==_Last2)
			{
				_Ans=_First1;
				break;
			}
		}
		return (_Ans);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
	{
		::std::_Checked_assign_from_base(_First1, _Find_end(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dist_type(_First1), _Dist_type(_First2)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2, class _Diff1, class _Diff2, class _Pr>
	inline _FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1*, _Diff2*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 724);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 725);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 726);
		_Diff1 _Count1=0;
		_Distance(_First1, _Last1, _Count1);
		_Diff2 _Count2=0;
		_Distance(_First2, _Last2, _Count2);
		_FwdIt1 _Ans=_Last1;
		if(0<_Count2)for(;
		_Count2<=_Count1;
		++_First1, --_Count1)
		{
			_FwdIt1 _Mid1=_First1;
			for(_FwdIt2 _Mid2=_First2;
			;
			++_Mid1)if(!_Pred(*_Mid1, *_Mid2))break;
			else if(++_Mid2==_Last2)
			{
				_Ans=_First1;
				break;
			}
		}
		return (_Ans);
	}
	template<class _FwdIt1, class _FwdIt2, class _Pr>
	inline _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First1, _Find_end(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred, _Dist_type(_First1), _Dist_type(_First2)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 768);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 769);
		for(;
		_First1!=_Last1;
		++_First1)for(_FwdIt2 _Mid2=_First2;
		_Mid2!=_Last2;
		++_Mid2)if(*_First1==*_Mid2)return (_First1);
		return (_First1);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 782);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 783);
		::std::_Checked_assign_from_base(_First1, _Find_first_of(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2)));
		return _First1;
	}
	template<class _FwdIt1, class _FwdIt2, class _Pr>
	inline _FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 797);
		for(;
		_First1!=_Last1;
		++_First1)for(_FwdIt2 _Mid2=_First2;
		_Mid2!=_Last2;
		++_Mid2)if(_Pred(*_First1, *_Mid2))return (_First1);
		return (_First1);
	}
	template<class _FwdIt1, class _FwdIt2, class _Pr>
	inline _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First1, _Find_first_of(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred));
		return (_First1);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{
		std::swap(*_Left, *_Right);
	}
	template<class _FwdIt1, class _FwdIt2, class _FwdItCats>
	inline _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdItCats, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 831);
		for(;
		_First1!=_Last1;
		++_First1, ++_First2)std::iter_swap(_First1, _First2);
		return (_First2);
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_FwdIt2 _Result=_First2+(_Last1-_First1);
		_Swap_ranges(_First1, _Last1, ::std::_Checked_base(_First2), forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _FwdIt1, class _FwdIt2, class _FwdItCats>
	inline _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdItCats _Iter_cats, _Unchecked_iterator_tag)
	{
		return _Swap_ranges(_First1, _Last1, _First2, _Iter_cats, _Range_checked_iterator_tag());
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return _Swap_ranges(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Iter_random(_First1, _First2), ::std::_Checked_cat(_First2));
	}
	template<class _InIt, class _OutIt, class _Fn1, class _InOutItCat>
	inline _OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 876);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 877);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 878);
		for(;
		_First!=_Last;
		++_First, ++_Dest)*_Dest=_Func(*_First);
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Fn1>
	inline _OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Transform(_First, _Last, ::std::_Checked_base(_Dest), _Func, forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _InIt, class _OutIt, class _Fn1, class _InOutItCat>
	inline _OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Transform(_First, _Last, _Dest, _Func, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Fn1>
	inline _OutIt transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
		return _Transform(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Func, _Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats, _InOutItCat, _Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 926);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 927);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 928);
		for(;
		_First1!=_Last1;
		++_First1, ++_First2, ++_Dest)*_Dest=_Func(*_First1, *_First2);
		return (_Dest);
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, random_access_iterator_tag, random_access_iterator_tag, _Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		_OutIt _Result=_Dest+(_Last1-_First1);
		_Transform(_First1, _Last1, ::std::_Checked_base(_First2), ::std::_Checked_base(_Dest), _Func, forward_iterator_tag(), forward_iterator_tag(), _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, random_access_iterator_tag, _InOutItCat, _Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{
		_InIt2 _Last2=_First2+(_Last1-_First1);
		(_Last2);
		return _Transform(_First1, _Last1, ::std::_Checked_base(_First2), _Dest, _Func, forward_iterator_tag(), forward_iterator_tag(), _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats, random_access_iterator_tag, _Range_checked_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last1-_First1);
		_Transform(_First1, _Last1, _First2, ::std::_Checked_base(_Dest), _Func, forward_iterator_tag(), forward_iterator_tag(), _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats _InIt_cats, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag, _Unchecked_iterator_tag)
	{
		return _Transform(_First1, _Last1, _First2, _Dest, _Func, _InIt_cats, _First_dest_cat, _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats _InIt_cats, _InOutItCat _First_dest_cat, _Range_checked_iterator_tag, _Unchecked_iterator_tag)
	{
		return _Transform(_First1, _Last1, _First2, _Dest, _Func, _InIt_cats, _First_dest_cat, _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
	inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func, _InItCats _InIt_cats, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag, _Range_checked_iterator_tag)
	{
		return _Transform(_First1, _Last1, _First2, _Dest, _Func, _InIt_cats, _First_dest_cat, _Range_checked_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
	inline _OutIt transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{
		return _Transform(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Dest, _Func, _Iter_random(_First1, _First2), _Iter_random(_First1, _Dest), ::std::_Checked_cat(_First2), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt, class _Ty>
	inline void _Replace(_FwdIt _First, _FwdIt _Last, const _Ty&_Oldval, const _Ty&_Newval)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1041);
		for(;
		_First!=_Last;
		++_First)if(*_First==_Oldval)*_First=_Newval;
	}
	template<class _FwdIt, class _Ty>
	inline void replace(_FwdIt _First, _FwdIt _Last, const _Ty&_Oldval, const _Ty&_Newval)
	{
		_Replace(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Oldval, _Newval);
	}
	template<class _FwdIt, class _Pr, class _Ty>
	inline void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty&_Val)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1061);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1062);
		for(;
		_First!=_Last;
		++_First)if(_Pred(*_First))*_First=_Val;
	}
	template<class _FwdIt, class _Pr, class _Ty>
	inline void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty&_Val)
	{
		_Replace_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred, _Val);
	}
	template<class _InIt, class _OutIt, class _Ty, class _InOutItCat>
	inline _OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1083);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1084);
		for(;
		_First!=_Last;
		++_First, ++_Dest)*_Dest=*_First==_Oldval?_Newval: *_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Replace_copy(_First, _Last, ::std::_Checked_base(_Dest), _Oldval, _Newval, forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _InIt, class _OutIt, class _Ty, class _InOutItCat>
	inline _OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Replace_copy(_First, _Last, _Dest, _Oldval, _Newval, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval)
	{
		return _Replace_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Oldval, _Newval, _Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty, class _InOutItCat>
	inline _OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1135);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1136);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1137);
		for(;
		_First!=_Last;
		++_First, ++_Dest)*_Dest=_Pred(*_First)?_Val: *_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty>
	inline _OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Replace_copy_if(_First, _Last, ::std::_Checked_base(_Dest), _Pred, _Val, forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty, class _InOutItCat>
	inline _OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Replace_copy_if(_First, _Last, _Dest, _Pred, _Val, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty>
	inline _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val)
	{
		return _Replace_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Val, _Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt, class _Fn0>
	inline void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1188);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1189);
		for(;
		_First!=_Last;
		++_First)*_First=_Func();
	}
	template<class _FwdIt, class _Fn0>
	inline void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{
		_Generate(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Func);
	}
	template<class _OutIt, class _Diff, class _Fn0, class _OutItCat>
	inline void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, _OutItCat, _Range_checked_iterator_tag)
	{
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1207);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1208);
		for(;
		0<_Count;
		--_Count, ++_Dest)*_Dest=_Func();
	}
	template<class _OutIt, class _Diff, class _Fn0>
	inline void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+_Count;
		_Generate_n(::std::_Checked_base(_Dest), _Count, _Func, forward_iterator_tag(), _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Fn0, class _OutItCat>
	inline void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, _OutItCat _Dest_cat, _Unchecked_iterator_tag)
	{
		_Generate_n(_Dest, _Count, _Func, _Dest_cat, _Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Fn0>
	inline void generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{
		_Generate_n(_Dest, _Count, _Func, _Iter_cat(_Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt _Remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1253);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1254);
		for(;
		_First!=_Last;
		++_First)if(!(*_First==_Val))*_Dest++=*_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt _Remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val, _Unchecked_iterator_tag)
	{
		return _Remove_copy(_First, _Last, _Dest, _Val, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val)
	{
		return _Remove_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Val, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt _Remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1287);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1288);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1289);
		for(;
		_First!=_Last;
		++_First)if(!_Pred(*_First))*_Dest++=*_First;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt _Remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Remove_copy_if(_First, _Last, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return _Remove_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt, class _Ty>
	inline _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		_First=find(_First, _Last, _Val);
		if(_First==_Last)return (_First);
		else
		{
			_FwdIt _First1=_First;
			return (::stdext::unchecked_remove_copy(++_First1, _Last, _First, _Val));
		}
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_First=std::find_if(_First, _Last, _Pred);
		if(_First==_Last)return (_First);
		else
		{
			_FwdIt _First1=_First;
			return (::stdext::unchecked_remove_copy_if(++_First1, _Last, _First, _Pred));
		}
	}
	template<class _FwdIt>
	inline _FwdIt _Unique(_FwdIt _First, _FwdIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1348);
		for(_FwdIt _Firstb;
		(_Firstb=_First)!=_Last&&++_First!=_Last;
		)if(*_Firstb==*_First)
		{
			for(;
			++_First!=_Last;
			)if(!(*_Firstb==*_First))*++_Firstb=*_First;
			return (++_Firstb);
		}
		return (_Last);
	}
	template<class _FwdIt>
	inline _FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{
		::std::_Checked_assign_from_base(_Last, _Unique(::std::_Checked_base(_First), ::std::_Checked_base(_Last)));
		return (_Last);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1373);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1374);
		for(_FwdIt _Firstb;
		(_Firstb=_First)!=_Last&&++_First!=_Last;
		)if(_Pred(*_Firstb, *_First))
		{
			for(;
			++_First!=_Last;
			)if(!_Pred(*_Firstb, *_First))*++_Firstb=*_First;
			return (++_Firstb);
		}
		return (_Last);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_Last, _Unique(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_Last);
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Ty*, _Range_checked_iterator_tag)
	{
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1401);
		_Ty _Val=*_First;
		for(*_Dest++=_Val;
		++_First!=_Last;
		)if(!(_Val==*_First))_Val=*_First, *_Dest++=_Val;
		return (_Dest);
	}
	template<class _InIt, class _OutIt>
	inline _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, input_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, _Val_type(_First), _Range_checked_iterator_tag()));
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest, forward_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1423);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1424);
		_FwdIt _Firstb=_First;
		for(*_Dest++=*_Firstb;
		++_First!=_Last;
		)if(!(*_Firstb==*_First))_Firstb=_First, *_Dest++=*_Firstb;
		return (_Dest);
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, bidirectional_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}
	template<class _RanIt, class _OutIt>
	inline _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}
	template<class _RanIt, class _OutIt, class _RanItCat>
	inline _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _RanItCat _First_cat, _Unchecked_iterator_tag)
	{
		return _Unique_copy(_First, _Last, _Dest, _First_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt>
	inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (_First==_Last?_Dest: _Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_cat(_First), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _OutIt, class _Ty, class _Pr>
	inline _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Ty*, _Range_checked_iterator_tag)
	{
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1475);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1476);
		_Ty _Val=*_First;
		for(*_Dest++=_Val;
		++_First!=_Last;
		)if(!_Pred(_Val, *_First))_Val=*_First, *_Dest++=_Val;
		return (_Dest);
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, input_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, _Pred, _Val_type(_First)), _Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _OutIt, class _Pr>
	inline _OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest, _Pr _Pred, forward_iterator_tag, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1500);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1501);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1502);
		_FwdIt _Firstb=_First;
		for(*_Dest++=*_Firstb;
		++_First!=_Last;
		)if(!_Pred(*_Firstb, *_First))_Firstb=_First, *_Dest++=*_Firstb;
		return (_Dest);
	}
	template<class _BidIt, class _OutIt, class _Pr>
	inline _OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Pr _Pred, bidirectional_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, _Pred, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}
	template<class _RanIt, class _OutIt, class _Pr>
	inline _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _Pr _Pred, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		return (_Unique_copy(_First, _Last, _Dest, _Pred, forward_iterator_tag(), _Range_checked_iterator_tag()));
	}
	template<class _RanIt, class _OutIt, class _Pr, class _RanItCat>
	inline _OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _Pr _Pred, _RanItCat _First_cat, _Unchecked_iterator_tag)
	{
		return _Unique_copy(_First, _Last, _Dest, _Pred, _First_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return (_First==_Last?_Dest: _Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std::_Checked_cat(_Dest)));
	}
	template<class _BidIt>
	inline void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
	{
		for(;
		_First!=_Last&&_First!=--_Last;
		++_First)std::iter_swap(_First, _Last);
	}
	template<class _RanIt>
	inline void _Reverse(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1562);
		for(;
		_First<_Last;
		++_First)std::iter_swap(_First, --_Last);
	}
	template<class _BidIt>
	inline void reverse(_BidIt _First, _BidIt _Last)
	{
		_Reverse(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Iter_cat(_First));
	}
	template<class _BidIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1579);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1580);
		for(;
		_First!=_Last;
		++_Dest)*_Dest=*--_Last;
		return (_Dest);
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last-_First);
		_Reverse_copy(_First, _Last, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Range_checked_iterator_tag());
		return (_Result);
	}
	template<class _BidIt, class _OutIt, class _InOutItCat>
	inline _OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Reverse_copy(_First, _Last, _Dest, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{
		return _Reverse_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt>
	inline void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, forward_iterator_tag)
	{
		for(_FwdIt _Next=_Mid;
		;
		)
		{
			std::iter_swap(_First, _Next);
			if(++_First==_Mid)if(++_Next==_Last)break;
			else _Mid=_Next;
			else if(++_Next==_Last)_Next=_Mid;
		}
	}
	template<class _BidIt>
	inline void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last, bidirectional_iterator_tag)
	{
		std::reverse(_First, _Mid);
		std::reverse(_Mid, _Last);
		std::reverse(_First, _Last);
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff*, _Ty*)
	{
		_Debug_range(_First, _Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1651);
		_Debug_range(_Mid, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1652);
		_Diff _Shift=_Mid-_First;
		_Diff _Count=_Last-_First;
		for(_Diff _Factor=_Shift;
		_Factor!=0;
		)
		{
			_Diff _Tmp=_Count%_Factor;
			_Count=_Factor, _Factor=_Tmp;
		}
		if(_Count<_Last-_First)for(;
		0<_Count;
		--_Count)
		{
			_RanIt _Hole=_First+_Count;
			_RanIt _Next=_Hole;
			_Ty _Holeval=*_Hole;
			_RanIt _Next1=_Next+_Shift==_Last?_First: _Next+_Shift;
			while(_Next1!=_Hole)
			{
				*_Next=*_Next1;
				_Next=_Next1;
				_Next1=_Shift<_Last-_Next1?_Next1+_Shift: _First+(_Shift-(_Last-_Next1));
			}
			*_Next=_Holeval;
		}
	}
	template<class _RanIt>
	inline void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, random_access_iterator_tag)
	{
		_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
	}
	template<class _FwdIt>
	inline void rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{
		if(_First!=_Mid&&_Mid!=_Last)_Rotate(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Iter_cat(_First));
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt _Rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Dest=::stdext::unchecked_copy(_Mid, _Last, _Dest);
		return (::stdext::unchecked_copy(_First, _Mid, _Dest));
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt _Rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Rotate_copy(_First, _Mid, _Last, _Dest, _Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return _Rotate_copy(_First, _Mid, _Last, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _RanIt, class _Diff>
	inline void _Random_shuffle(_RanIt _First, _RanIt _Last, _Diff*)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1725);
		const int _RANDOM_BITS=15;
		const int _RANDOM_MAX=(1U<<_RANDOM_BITS)-1;
		_RanIt _Next=_First;
		for(unsigned long _Index=2;
		++_Next!=_Last;
		++_Index)
		{
			unsigned long _Rm=_RANDOM_MAX;
			unsigned long _Rn=::rand()&_RANDOM_MAX;
			for(;
			_Rm<_Index&&_Rm!=~0UL;
			_Rm=_Rm<<_RANDOM_BITS|_RANDOM_MAX)_Rn=_Rn<<_RANDOM_BITS|(::rand()&_RANDOM_MAX);
			std::iter_swap(_Next, _First+_Diff(_Rn%_Index));
		}
	}
	template<class _RanIt>
	inline void random_shuffle(_RanIt _First, _RanIt _Last)
	{
		if(_First!=_Last)_Random_shuffle(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dist_type(_First));
	}
	template<class _RanIt, class _Fn1, class _Diff>
	inline void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&_Func, _Diff*)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1756);
		_Debug_pointer(_Func, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1757);
		_RanIt _Next=_First;
		for(_Diff _Index=2;
		++_Next!=_Last;
		++_Index)std::iter_swap(_Next, _First+_Diff(_Func(_Index)%_Index));
	}
	template<class _RanIt, class _Fn1>
	inline void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&_Func)
	{
		if(_First!=_Last)_Random_shuffle(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Func, _Dist_type(_First));
	}
	template<class _BidIt, class _Pr>
	inline _BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1777);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1778);
		for(;
		;
		++_First)
		{
			for(;
			_First!=_Last&&_Pred(*_First);
			++_First);
			if(_First==_Last)break;
			for(;
			_First!=--_Last&&!_Pred(*_Last);
			);
			if(_First==_Last)break;
			std::iter_swap(_First, _Last);
		}
		return (_First);
	}
	template<class _BidIt, class _Pr>
	inline _BidIt partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Partition(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _BidIt, class _Pr, class _Diff, class _Ty>
	inline _BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf)
	{
		if(_Count==0)return (_First);
		else if(_Count==1)return (_Pred(*_First)?_Last: _First);
		else if(_Count<=_Tempbuf._Maxlen())
		{
			_BidIt _Next=_First;
			for(_Tempbuf._Init();
			_First!=_Last;
			++_First)if(_Pred(*_First))*_Next++=*_First;
			else*_Tempbuf++=*_First;
			::stdext::unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _Next);
			return (_Next);
		}
		else
		{
			_BidIt _Mid=_First;
			std::advance(_Mid, _Count/2);
			_BidIt _Left=_Stable_partition(_First, _Mid, _Pred, _Count/2, _Tempbuf);
			_BidIt _Right=_Stable_partition(_Mid, _Last, _Pred, _Count-_Count/2, _Tempbuf);
			_Diff _Count1=0;
			_Distance(_Left, _Mid, _Count1);
			_Diff _Count2=0;
			_Distance(_Mid, _Right, _Count2);
			return (_Buffered_rotate(_Left, _Mid, _Right, _Count1, _Count2, _Tempbuf));
		}
	}
	template<class _BidIt, class _Pr, class _Diff, class _Ty>
	inline _BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred, _Diff*, _Ty*)
	{
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		_Temp_iterator<_Ty>_Tempbuf(_Count);
		return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
	}
	template<class _BidIt, class _Pr>
	inline _BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		if(_First!=_Last)
		{
			::std::_Checked_assign_from_base(_First, _Stable_partition(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred, _Dist_type(_First), _Val_type(_First)));
		}
		return _First;
	}
	template<class _RanIt>
	inline void _Debug_heap(_RanIt _First, _RanIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1884);
		if(_First!=_Last)for(_RanIt _Root=_First;
		++_First!=_Last;
		++_Root)if(_Debug_lt(*_Root, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1888))_Debug_message(L"invalid heap", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1889);
		else if(++_First==_Last)break;
		else if(_Debug_lt(*_Root, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1892))_Debug_message(L"invalid heap", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1893);
	}
	template<class _RanIt, class _Pr>
	inline void _Debug_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1901);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1902);
		if(_First!=_Last)for(_RanIt _Root=_First;
		++_First!=_Last;
		++_Root)if(_Debug_lt_pred(_Pred, *_Root, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1906))_Debug_message(L"invalid heap", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1907);
		else if(++_First==_Last)break;
		else if(_Debug_lt_pred(_Pred, *_Root, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1910))_Debug_message(L"invalid heap", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1911);
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Push_heap(_RanIt _First, _Diff _Hole, _Diff _Top, _Ty _Val)
	{
		for(_Diff _Idx=(_Hole-1)/2;
		_Top<_Hole&&_Debug_lt(*(_First+_Idx), _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1932);
		_Idx=(_Hole-1)/2)
		{
			*(_First+_Hole)=*(_First+_Idx);
			_Hole=_Idx;
		}
		*(_First+_Hole)=_Val;
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Push_heap_0(_RanIt _First, _RanIt _Last, _Diff*, _Ty*)
	{
		_Debug_heap(_First, _Last);
		_Diff _Count=_Last-_First;
		if(0<_Count)_Push_heap(_First, _Count, _Diff(0), _Ty(*_Last));
	}
	template<class _RanIt>
	inline void push_heap(_RanIt _First, _RanIt _Last)
	{
		if(_First==_Last)_Debug_message(L"empty push_heap sequence", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1959);
		else _Push_heap_0(::std::_Checked_base(_First), ::std::_Checked_base(--_Last), _Dist_type(_First), _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Push_heap(_RanIt _First, _Diff _Hole, _Diff _Top, _Ty _Val, _Pr _Pred)
	{
		for(_Diff _Idx=(_Hole-1)/2;
		_Top<_Hole&&_Debug_lt_pred(_Pred, *(_First+_Idx), _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 1979);
		_Idx=(_Hole-1)/2)
		{
			*(_First+_Hole)=*(_First+_Idx);
			_Hole=_Idx;
		}
		*(_First+_Hole)=_Val;
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff*, _Ty*)
	{
		_Debug_heap(_First, _Last, _Pred);
		_Diff _Count=_Last-_First;
		if(0<_Count)_Push_heap(_First, _Count, _Diff(0), _Ty(*_Last), _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		if(_First==_Last)_Debug_message(L"empty push_heap sequence", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2008);
		else _Push_heap_0(::std::_Checked_base(_First), ::std::_Checked_base(--_Last), _Pred, _Dist_type(_First), _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom, _Ty _Val)
	{
		_Diff _Top=_Hole;
		_Diff _Idx=2*_Hole+2;
		for(;
		_Idx<_Bottom;
		_Idx=2*_Idx+2)
		{
			if(_Debug_lt(*(_First+_Idx), *(_First+(_Idx-1)), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2030))--_Idx;
			*(_First+_Hole)=*(_First+_Idx), _Hole=_Idx;
		}
		if(_Idx==_Bottom)
		{
			*(_First+_Hole)=*(_First+(_Bottom-1));
			_Hole=_Bottom-1;
		}
		_Push_heap(_First, _Hole, _Top, _Val);
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty _Val, _Diff*)
	{
		*_Dest=*_First;
		_Adjust_heap(_First, _Diff(0), _Diff(_Last-_First), _Val);
	}
	template<class _RanIt, class _Ty>
	inline void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Ty*)
	{
		_Pop_heap(_First, _Last-1, _Last-1, _Ty(*(_Last-1)), _Dist_type(_First));
	}
	template<class _RanIt>
	inline void pop_heap(_RanIt _First, _RanIt _Last)
	{
		_Debug_heap(_First, _Last);
		if(1<_Last-_First)_Pop_heap_0(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom, _Ty _Val, _Pr _Pred)
	{
		_Diff _Top=_Hole;
		_Diff _Idx=2*_Hole+2;
		for(;
		_Idx<_Bottom;
		_Idx=2*_Idx+2)
		{
			if(_Debug_lt_pred(_Pred, *(_First+_Idx), *(_First+(_Idx-1)), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2082))--_Idx;
			*(_First+_Hole)=*(_First+_Idx), _Hole=_Idx;
		}
		if(_Idx==_Bottom)
		{
			*(_First+_Hole)=*(_First+(_Bottom-1));
			_Hole=_Bottom-1;
		}
		_Push_heap(_First, _Hole, _Top, _Val, _Pred);
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty _Val, _Pr _Pred, _Diff*)
	{
		*_Dest=*_First;
		_Adjust_heap(_First, _Diff(0), _Diff(_Last-_First), _Val, _Pred);
	}
	template<class _RanIt, class _Ty, class _Pr>
	inline void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty*)
	{
		_Pop_heap(_First, _Last-1, _Last-1, _Ty(*(_Last-1)), _Pred, _Dist_type(_First));
	}
	template<class _RanIt, class _Pr>
	inline void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_Debug_heap(_First, _Last, _Pred);
		if(1<_Last-_First)_Pop_heap_0(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred, _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty>
	inline void _Make_heap(_RanIt _First, _RanIt _Last, _Diff*, _Ty*)
	{
		_Diff _Bottom=_Last-_First;
		for(_Diff _Hole=_Bottom/2;
		0<_Hole;
		)
		{
			--_Hole;
			_Adjust_heap(_First, _Hole, _Bottom, _Ty(*(_First+_Hole)));
		}
	}
	template<class _RanIt>
	inline void make_heap(_RanIt _First, _RanIt _Last)
	{
		if(1<_Last-_First)_Make_heap(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dist_type(_First), _Val_type(_First));
	}
	template<class _RanIt, class _Diff, class _Ty, class _Pr>
	inline void _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff*, _Ty*)
	{
		_Diff _Bottom=_Last-_First;
		for(_Diff _Hole=_Bottom/2;
		0<_Hole;
		)
		{
			--_Hole;
			_Adjust_heap(_First, _Hole, _Bottom, _Ty(*(_First+_Hole)), _Pred);
		}
	}
	template<class _RanIt, class _Pr>
	inline void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		if(1<_Last-_First)_Make_heap(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred, _Dist_type(_First), _Val_type(_First));
	}
	template<class _RanIt>
	inline void _Sort_heap(_RanIt _First, _RanIt _Last)
	{
		_Debug_heap(_First, _Last);
		for(;
		1<_Last-_First;
		--_Last)std::pop_heap(_First, _Last);
	}
	template<class _RanIt>
	inline void sort_heap(_RanIt _First, _RanIt _Last)
	{
		_Debug_heap(_First, _Last);
		_Sort_heap(::std::_Checked_base(_First), ::std::_Checked_base(_Last));
	}
	template<class _RanIt, class _Pr>
	inline void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		for(;
		1<_Last-_First;
		--_Last)std::pop_heap(_First, _Last, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_Debug_heap(_First, _Last, _Pred);
		_Sort_heap(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred);
	}
	template<class _FwdIt, class _Ty, class _Diff>
	inline _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Diff*)
	{
		_Debug_order_single(_First, _Last, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2211);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2220);
			if(_Debug_lt(*_Mid, _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2222))_First=++_Mid, _Count-=_Count2+1;
			else _Count=_Count2;
		}
		return (_First);
	}
	template<class _FwdIt, class _Ty>
	inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		::std::_Checked_assign_from_base(_First, _Lower_bound(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Dist_type(_First)));
		return _First;
	}
	template<class _FwdIt, class _Ty, class _Diff, class _Pr>
	inline _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred, _Diff*)
	{
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2247);
		_Debug_order_single(_First, _Last, _Pred, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2248);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, _Pred, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2256);
			if(_Debug_lt_pred(_Pred, *_Mid, _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2258))_First=++_Mid, _Count-=_Count2+1;
			else _Count=_Count2;
		}
		return (_First);
	}
	template<class _FwdIt, class _Ty, class _Pr>
	inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Lower_bound(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Pred, _Dist_type(_First)));
		return _First;
	}
	template<class _FwdIt, class _Ty, class _Diff>
	inline _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Diff*)
	{
		_Debug_order_single(_First, _Last, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2283);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2291);
			if(!_Debug_lt(_Val, *_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2293))_First=++_Mid, _Count-=_Count2+1;
			else _Count=_Count2;
		}
		return (_First);
	}
	template<class _FwdIt, class _Ty>
	inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		::std::_Checked_assign_from_base(_First, _Upper_bound(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Dist_type(_First)));
		return _First;
	}
	template<class _FwdIt, class _Ty, class _Diff, class _Pr>
	inline _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred, _Diff*)
	{
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2318);
		_Debug_order_single(_First, _Last, _Pred, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2319);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, _Pred, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2327);
			if(!_Debug_lt_pred(_Pred, _Val, *_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2329))_First=++_Mid, _Count-=_Count2+1;
			else _Count=_Count2;
		}
		return (_First);
	}
	template<class _FwdIt, class _Ty, class _Pr>
	inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Upper_bound(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Val, _Pred, _Dist_type(_First)));
		return _First;
	}
	template<class _FwdIt, class _Ty, class _Diff>
	inline pair<_FwdIt, _FwdIt>_Equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Diff*)
	{
		_Debug_order_single(_First, _Last, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2355);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2364);
			if(_Debug_lt(*_Mid, _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2366))
			{
				_First=++_Mid;
				_Count-=_Count2+1;
			}
			else if(_Val<*_Mid)_Count=_Count2;
			else
			{
				_FwdIt _First2=lower_bound(_First, _Mid, _Val);
				std::advance(_First, _Count);
				_FwdIt _Last2=upper_bound(++_Mid, _First, _Val);
				return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}
		return (pair<_FwdIt, _FwdIt>(_First, _First));
	}
	template<class _FwdIt, class _Ty>
	inline pair<_FwdIt, _FwdIt>equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		return (_Equal_range(_First, _Last, _Val, _Dist_type(_First)));
	}
	template<class _FwdIt, class _Ty, class _Diff, class _Pr>
	inline pair<_FwdIt, _FwdIt>_Equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred, _Diff*)
	{
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2401);
		_Debug_order_single(_First, _Last, _Pred, true, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2402);
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		for(;
		0<_Count;
		)
		{
			_Diff _Count2=_Count/2;
			_FwdIt _Mid=_First;
			std::advance(_Mid, _Count2);
			_Debug_order_single(_Mid, _Last, _Pred, false, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2411);
			if(_Debug_lt_pred(_Pred, *_Mid, _Val, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2413))
			{
				_First=++_Mid;
				_Count-=_Count2+1;
			}
			else if(_Pred(_Val, *_Mid))_Count=_Count2;
			else
			{
				_FwdIt _First2=lower_bound(_First, _Mid, _Val, _Pred);
				std::advance(_First, _Count);
				_FwdIt _Last2=upper_bound(++_Mid, _First, _Val, _Pred);
				return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}
		return (pair<_FwdIt, _FwdIt>(_First, _First));
	}
	template<class _FwdIt, class _Ty, class _Pr>
	inline pair<_FwdIt, _FwdIt>equal_range(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred)
	{
		return (_Equal_range(_First, _Last, _Val, _Pred, _Dist_type(_First)));
	}
	template<class _FwdIt, class _Ty>
	inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty&_Val)
	{
		_First=std::lower_bound(_First, _Last, _Val);
		return (_First!=_Last&&!(_Val<*_First));
	}
	template<class _FwdIt, class _Ty, class _Pr>
	inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty&_Val, _Pr _Pred)
	{
		_First=std::lower_bound(_First, _Last, _Val, _Pred);
		return (_First!=_Last&&!_Pred(_Val, *_First));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _InOutItCat>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2468);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2469);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2470);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_Dest)if(_Debug_lt(*_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2472))*_Dest=*_First2, ++_First2;
		else*_Dest=*_First1, ++_First1;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last1-_First1)+(_Last2-_First2);
		_Merge(_First1, _Last1, _First2, _Last2, ::std::_Checked_base(_Dest), forward_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _InOutItCat>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Merge(_First1, _Last1, _First2, _Last2, _Dest, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Iter_random(_First1, _First2, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr, class _InOutItCat>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _InOutItCat, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2525);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2526);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2527);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		++_Dest)if(_Debug_lt_pred(_Pred, *_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2529))*_Dest=*_First2, ++_First2;
		else*_Dest=*_First1, ++_First1;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, random_access_iterator_tag, _Range_checked_iterator_tag)
	{
		_OutIt _Result=_Dest+(_Last1-_First1)+(_Last2-_First2);
		_Merge(_First1, _Last1, _First2, _Last2, ::std::_Checked_base(_Dest), _Pred, forward_iterator_tag(), _Range_checked_iterator_tag());
		return _Result;
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr, class _InOutItCat>
	inline _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _InOutItCat _First_dest_cat, _Unchecked_iterator_tag)
	{
		return _Merge(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _First_dest_cat, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, _Iter_random(_First1, _First2, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline _BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>&_Tempbuf)
	{
		if(_Count1<=_Count2&&_Count1<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_First, _Mid, _Tempbuf._Init());
			::stdext::unchecked_copy(_Mid, _Last, _First);
			return (::stdext::unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(), _Last));
		}
		else if(_Count2<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_Mid, _Last, _Tempbuf._Init());
			::stdext::unchecked_copy_backward(_First, _Mid, _Last);
			return (::stdext::unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));
		}
		else
		{
			std::rotate(_First, _Mid, _Last);
			std::advance(_First, _Count2);
			return (_First);
		}
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Range_checked_iterator_tag)
	{
		for(;
		;
		)if(_First1==_Last1)return (::stdext::unchecked_copy_backward(_First2, _Last2, _Dest));
		else if(_First2==_Last2)return (::stdext::unchecked_copy_backward(_First1, _Last1, _Dest));
		else if(_Debug_lt(*--_Last2, *--_Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2616))*--_Dest=*_Last1, ++_Last2;
		else*--_Dest=*_Last2, ++_Last1;
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Unchecked_iterator_tag)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>&_Tempbuf)
	{
		if(_Count1+_Count2==2)
		{
			if(_Debug_lt(*_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2650))std::iter_swap(_First, _Mid);
		}
		else if(_Count1<=_Count2&&_Count1<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_First, _Mid, _Tempbuf._Init());
			::stdext::unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);
		}
		else if(_Count2<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_Mid, _Last, _Tempbuf._Init());
			::stdext::_Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(), _Last);
		}
		else
		{
			_BidIt _Firstn, _Lastn;
			_Diff _Count1n, _Count2n;
			if(_Count2<_Count1)
			{
				_Count1n=_Count1/2, _Count2n=0;
				_Firstn=_First;
				std::advance(_Firstn, _Count1n);
				_Lastn=std::lower_bound(_Mid, _Last, *_Firstn);
				_Distance(_Mid, _Lastn, _Count2n);
			}
			else
			{
				_Count1n=0, _Count2n=_Count2/2;
				_Lastn=_Mid;
				std::advance(_Lastn, _Count2n);
				_Firstn=std::upper_bound(_First, _Mid, *_Lastn);
				_Distance(_First, _Firstn, _Count1n);
			}
			_BidIt _Midn=_Buffered_rotate(_Firstn, _Mid, _Lastn, _Count1-_Count1n, _Count2n, _Tempbuf);
			_Buffered_merge(_First, _Firstn, _Midn, _Count1n, _Count2n, _Tempbuf);
			_Buffered_merge(_Midn, _Lastn, _Last, _Count1-_Count1n, _Count2-_Count2n, _Tempbuf);
		}
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Diff*, _Ty*)
	{
		_Debug_order(_First, _Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2701);
		_Debug_order(_Mid, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2702);
		_Diff _Count1=0;
		_Distance(_First, _Mid, _Count1);
		_Diff _Count2=0;
		_Distance(_Mid, _Last, _Count2);
		_Temp_iterator<_Ty>_Tempbuf(_Count1<_Count2?_Count1: _Count2);
		_Buffered_merge(_First, _Mid, _Last, _Count1, _Count2, _Tempbuf);
	}
	template<class _BidIt>
	inline void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{
		if(_First!=_Mid&&_Mid!=_Last)_Inplace_merge(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Dist_type(_First), _Val_type(_First));
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		for(;
		;
		)if(_First1==_Last1)return (::stdext::unchecked_copy_backward(_First2, _Last2, _Dest));
		else if(_First2==_Last2)return (::stdext::unchecked_copy_backward(_First1, _Last1, _Dest));
		else if(_Debug_lt_pred(_Pred, *--_Last2, *--_Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2733))*--_Dest=*_Last1, ++_Last2;
		else*--_Dest=*_Last2, ++_Last1;
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Unchecked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>&_Tempbuf, _Pr _Pred)
	{
		if(_Count1+_Count2==2)
		{
			if(_Debug_lt_pred(_Pred, *_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2768))std::iter_swap(_First, _Mid);
		}
		else if(_Count1<=_Count2&&_Count1<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_First, _Mid, _Tempbuf._Init());
			::stdext::unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First, _Pred);
		}
		else if(_Count2<=_Tempbuf._Maxlen())
		{
			::stdext::unchecked_copy(_Mid, _Last, _Tempbuf._Init());
			::stdext::_Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
		}
		else
		{
			_BidIt _Firstn, _Lastn;
			_Diff _Count1n, _Count2n;
			if(_Count2<_Count1)
			{
				_Count1n=_Count1/2, _Count2n=0;
				_Firstn=_First;
				std::advance(_Firstn, _Count1n);
				_Lastn=lower_bound(_Mid, _Last, *_Firstn, _Pred);
				_Distance(_Mid, _Lastn, _Count2n);
			}
			else
			{
				_Count1n=0, _Count2n=_Count2/2;
				_Lastn=_Mid;
				std::advance(_Lastn, _Count2n);
				_Firstn=upper_bound(_First, _Mid, *_Lastn, _Pred);
				_Distance(_First, _Firstn, _Count1n);
			}
			_BidIt _Midn=_Buffered_rotate(_Firstn, _Mid, _Lastn, _Count1-_Count1n, _Count2n, _Tempbuf);
			_Buffered_merge(_First, _Firstn, _Midn, _Count1n, _Count2n, _Tempbuf, _Pred);
			_Buffered_merge(_Midn, _Lastn, _Last, _Count1-_Count1n, _Count2-_Count2n, _Tempbuf, _Pred);
		}
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred, _Diff*, _Ty*)
	{
		_Debug_order(_First, _Mid, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2819);
		_Debug_order(_Mid, _Last, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2820);
		_Diff _Count1=0;
		_Distance(_First, _Mid, _Count1);
		_Diff _Count2=0;
		_Distance(_Mid, _Last, _Count2);
		_Temp_iterator<_Ty>_Tempbuf(_Count1<_Count2?_Count1: _Count2);
		_Buffered_merge(_First, _Mid, _Last, _Count1, _Count2, _Tempbuf, _Pred);
	}
	template<class _BidIt, class _Pr>
	inline void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{
		if(_First!=_Mid&&_Mid!=_Last)_Inplace_merge(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Pred, _Dist_type(_First), _Val_type(_First));
	}
	template<class _BidIt, class _Ty>
	inline void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Ty*)
	{
		if(_First!=_Last)for(_BidIt _Next=_First;
		++_Next!=_Last;
		)
		{
			_BidIt _Next1=_Next;
			_Ty _Val=*_Next;
			if(_Debug_lt(_Val, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2850))
			{
				::stdext::unchecked_copy_backward(_First, _Next, ++_Next1);
				*_First=_Val;
			}
			else
			{
				for(_BidIt _First1=_Next1;
				_Debug_lt(_Val, *--_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2858);
				_Next1=_First1)*_Next1=*_First1;
				*_Next1=_Val;
			}
		}
	}
	template<class _BidIt>
	inline void _Insertion_sort(_BidIt _First, _BidIt _Last)
	{
		_Insertion_sort1(_First, _Last, _Val_type(_First));
	}
	template<class _RanIt>
	inline void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{
		if(_Debug_lt(*_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2875))std::iter_swap(_Mid, _First);
		if(_Debug_lt(*_Last, *_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2877))std::iter_swap(_Last, _Mid);
		if(_Debug_lt(*_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2879))std::iter_swap(_Mid, _First);
	}
	template<class _RanIt>
	inline void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{
		if(40<_Last-_First)
		{
			size_t _Step=(_Last-_First+1)/8;
			_Med3(_First, _First+_Step, _First+2*_Step);
			_Med3(_Mid-_Step, _Mid, _Mid+_Step);
			_Med3(_Last-2*_Step, _Last-_Step, _Last);
			_Med3(_First+_Step, _Mid, _Last-_Step);
		}
		else _Med3(_First, _Mid, _Last);
	}
	template<class _RanIt>
	inline pair<_RanIt, _RanIt>_Unguarded_partition(_RanIt _First, _RanIt _Last)
	{
		_RanIt _Mid=_First+(_Last-_First)/2;
		_Median(_First, _Mid, _Last-1);
		_RanIt _Pfirst=_Mid;
		_RanIt _Plast=_Pfirst+1;
		while(_First<_Pfirst&&!_Debug_lt(*(_Pfirst-1), *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2907)&&!(*_Pfirst<*(_Pfirst-1)))--_Pfirst;
		while(_Plast<_Last&&!_Debug_lt(*_Plast, *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2911)&&!(*_Pfirst<*_Plast))++_Plast;
		_RanIt _Gfirst=_Plast;
		_RanIt _Glast=_Pfirst;
		for(;
		;
		)
		{
			for(;
			_Gfirst<_Last;
			++_Gfirst)if(_Debug_lt(*_Pfirst, *_Gfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2921));
			else if(*_Gfirst<*_Pfirst)break;
			else std::iter_swap(_Plast++, _Gfirst);
			for(;
			_First<_Glast;
			--_Glast)if(_Debug_lt(*(_Glast-1), *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2928));
			else if(*_Pfirst<*(_Glast-1))break;
			else std::iter_swap(--_Pfirst, _Glast-1);
			if(_Glast==_First&&_Gfirst==_Last)return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
			if(_Glast==_First)
			{
				if(_Plast!=_Gfirst)std::iter_swap(_Pfirst, _Plast);
				++_Plast;
				std::iter_swap(_Pfirst++, _Gfirst++);
			}
			else if(_Gfirst==_Last)
			{
				if(--_Glast!=--_Pfirst)std::iter_swap(_Glast, _Pfirst);
				std::iter_swap(_Pfirst, --_Plast);
			}
			else std::iter_swap(_Gfirst++, --_Glast);
		}
	}
	template<class _RanIt, class _Diff>
	inline void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal)
	{
		_Diff _Count;
		for(;
		_ISORT_MAX<(_Count=_Last-_First)&&0<_Ideal;
		)
		{
			pair<_RanIt, _RanIt>_Mid=_Unguarded_partition(_First, _Last);
			_Ideal/=2, _Ideal+=_Ideal/2;
			if(_Mid.first-_First<_Last-_Mid.second)_Sort(_First, _Mid.first, _Ideal), _First=_Mid.second;
			else _Sort(_Mid.second, _Last, _Ideal), _Last=_Mid.first;
		}
		if(_ISORT_MAX<_Count)
		{
			std::make_heap(_First, _Last);
			std::sort_heap(_First, _Last);
		}
		else if(1<_Count)_Insertion_sort(_First, _Last);
	}
	template<class _RanIt>
	inline void sort(_RanIt _First, _RanIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2983);
		_Sort(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Last-_First);
	}
	template<class _BidIt, class _Pr>
	inline void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		if(_First!=_Last)for(_BidIt _Next=_First;
		++_Next!=_Last;
		)if(_Debug_lt_pred(_Pred, *_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 2994))
		{
			_BidIt _Next1=_Next;
			std::rotate(_First, _Next, ++_Next1);
		}
		else
		{
			_BidIt _Dest=_Next;
			for(_BidIt _Dest0=_Dest;
			_Debug_lt_pred(_Pred, *_Next, *--_Dest0, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3003);
			)_Dest=_Dest0;
			if(_Dest!=_Next)
			{
				_BidIt _Next1=_Next;
				std::rotate(_Dest, _Next, ++_Next1);
			}
		}
	}
	template<class _RanIt, class _Pr>
	inline void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{
		if(_Debug_lt_pred(_Pred, *_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3017))std::iter_swap(_Mid, _First);
		if(_Debug_lt_pred(_Pred, *_Last, *_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3019))std::iter_swap(_Last, _Mid);
		if(_Debug_lt_pred(_Pred, *_Mid, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3021))std::iter_swap(_Mid, _First);
	}
	template<class _RanIt, class _Pr>
	inline void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{
		if(40<_Last-_First)
		{
			size_t _Step=(_Last-_First+1)/8;
			_Med3(_First, _First+_Step, _First+2*_Step, _Pred);
			_Med3(_Mid-_Step, _Mid, _Mid+_Step, _Pred);
			_Med3(_Last-2*_Step, _Last-_Step, _Last, _Pred);
			_Med3(_First+_Step, _Mid, _Last-_Step, _Pred);
		}
		else _Med3(_First, _Mid, _Last, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline pair<_RanIt, _RanIt>_Unguarded_partition(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_RanIt _Mid=_First+(_Last-_First)/2;
		_Median(_First, _Mid, _Last-1, _Pred);
		_RanIt _Pfirst=_Mid;
		_RanIt _Plast=_Pfirst+1;
		while(_First<_Pfirst&&!_Debug_lt_pred(_Pred, *(_Pfirst-1), *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3052)&&!_Pred(*_Pfirst, *(_Pfirst-1)))--_Pfirst;
		while(_Plast<_Last&&!_Debug_lt_pred(_Pred, *_Plast, *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3056)&&!_Pred(*_Pfirst, *_Plast))++_Plast;
		_RanIt _Gfirst=_Plast;
		_RanIt _Glast=_Pfirst;
		for(;
		;
		)
		{
			for(;
			_Gfirst<_Last;
			++_Gfirst)if(_Debug_lt_pred(_Pred, *_Pfirst, *_Gfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3066));
			else if(_Pred(*_Gfirst, *_Pfirst))break;
			else std::iter_swap(_Plast++, _Gfirst);
			for(;
			_First<_Glast;
			--_Glast)if(_Debug_lt_pred(_Pred, *(_Glast-1), *_Pfirst, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3073));
			else if(_Pred(*_Pfirst, *(_Glast-1)))break;
			else std::iter_swap(--_Pfirst, _Glast-1);
			if(_Glast==_First&&_Gfirst==_Last)return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
			if(_Glast==_First)
			{
				if(_Plast!=_Gfirst)std::iter_swap(_Pfirst, _Plast);
				++_Plast;
				std::iter_swap(_Pfirst++, _Gfirst++);
			}
			else if(_Gfirst==_Last)
			{
				if(--_Glast!=--_Pfirst)std::iter_swap(_Glast, _Pfirst);
				std::iter_swap(_Pfirst, --_Plast);
			}
			else std::iter_swap(_Gfirst++, --_Glast);
		}
	}
	template<class _RanIt, class _Diff, class _Pr>
	inline void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
	{
		_Diff _Count;
		for(;
		_ISORT_MAX<(_Count=_Last-_First)&&0<_Ideal;
		)
		{
			pair<_RanIt, _RanIt>_Mid=_Unguarded_partition(_First, _Last, _Pred);
			_Ideal/=2, _Ideal+=_Ideal/2;
			if(_Mid.first-_First<_Last-_Mid.second)_Sort(_First, _Mid.first, _Ideal, _Pred), _First=_Mid.second;
			else _Sort(_Mid.second, _Last, _Ideal, _Pred), _Last=_Mid.first;
		}
		if(_ISORT_MAX<_Count)
		{
			std::make_heap(_First, _Last, _Pred);
			std::sort_heap(_First, _Last, _Pred);
		}
		else if(1<_Count)_Insertion_sort(_First, _Last, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3131);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3132);
		_Sort(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Last-_First, _Pred);
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Range_checked_iterator_tag)
	{
		for(_Diff _Chunk2=_Chunk*2;
		_Chunk2<=_Count;
		_Count-=_Chunk2)
		{
			_BidIt _Mid1=_First;
			std::advance(_Mid1, _Chunk);
			_BidIt _Mid2=_Mid1;
			std::advance(_Mid2, _Chunk);
			_Dest=::stdext::unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);
			_First=_Mid2;
		}
		if(_Count<=_Chunk)::stdext::unchecked_copy(_First, _Last, _Dest);
		else
		{
			_BidIt _Mid=_First;
			std::advance(_Mid, _Chunk);
			::stdext::unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);
		}
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Unchecked_iterator_tag)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf)
	{
		_BidIt _Mid=_First;
		for(_Diff _Nleft=_Count;
		_ISORT_MAX<=_Nleft;
		_Nleft-=_ISORT_MAX)
		{
			_BidIt _Midend=_Mid;
			std::advance(_Midend, (int)_ISORT_MAX);
			_Insertion_sort(_Mid, _Midend);
			_Mid=_Midend;
		}
		_Insertion_sort(_Mid, _Last);
		for(_Diff _Chunk=_ISORT_MAX;
		_Chunk<_Count;
		_Chunk*=2)
		{
			::stdext::_Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(), _Chunk, _Count);
			::stdext::_Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First, _Chunk*=2, _Count);
		}
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf)
	{
		if(_Count<=_ISORT_MAX)_Insertion_sort(_First, _Last);
		else
		{
			_Diff _Count2=(_Count+1)/2;
			_BidIt _Mid=_First;
			std::advance(_Mid, _Count2);
			if(_Count2<=_Tempbuf._Maxlen())
			{
				_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);
				_Buffered_merge_sort(_Mid, _Last, _Count-_Count2, _Tempbuf);
			}
			else
			{
				_Stable_sort(_First, _Mid, _Count2, _Tempbuf);
				_Stable_sort(_Mid, _Last, _Count-_Count2, _Tempbuf);
			}
			_Buffered_merge(_First, _Mid, _Last, _Count2, _Count-_Count2, _Tempbuf);
		}
	}
	template<class _BidIt, class _Diff, class _Ty>
	inline void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff*, _Ty*)
	{
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		_Temp_iterator<_Ty>_Tempbuf((_Count+1)/2);
		_Stable_sort(_First, _Last, _Count, _Tempbuf);
	}
	template<class _BidIt>
	inline void stable_sort(_BidIt _First, _BidIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3254);
		if(_First!=_Last)
		{
			_Stable_sort(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dist_type(_First), _Val_type(_First));
		}
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred, _Range_checked_iterator_tag)
	{
		for(_Diff _Chunk2=_Chunk*2;
		_Chunk2<=_Count;
		_Count-=_Chunk2)
		{
			_BidIt _Mid1=_First;
			std::advance(_Mid1, _Chunk);
			_BidIt _Mid2=_Mid1;
			std::advance(_Mid2, _Chunk);
			_Dest=::stdext::unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
			_First=_Mid2;
		}
		if(_Count<=_Chunk)::stdext::unchecked_copy(_First, _Last, _Dest);
		else
		{
			_BidIt _Mid1=_First;
			std::advance(_Mid1, _Chunk);
			::stdext::unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
		}
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred, _Unchecked_iterator_tag)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf, _Pr _Pred)
	{
		_BidIt _Mid=_First;
		for(_Diff _Nleft=_Count;
		_ISORT_MAX<=_Nleft;
		_Nleft-=_ISORT_MAX)
		{
			_BidIt _Midn=_Mid;
			std::advance(_Midn, (int)_ISORT_MAX);
			_Insertion_sort(_Mid, _Midn, _Pred);
			_Mid=_Midn;
		}
		_Insertion_sort(_Mid, _Last, _Pred);
		for(_Diff _Chunk=_ISORT_MAX;
		_Chunk<_Count;
		_Chunk*=2)
		{
			::stdext::_Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(), _Chunk, _Count, _Pred);
			::stdext::_Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First, _Chunk*=2, _Count, _Pred);
		}
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count, _Temp_iterator<_Ty>&_Tempbuf, _Pr _Pred)
	{
		if(_Count<=_ISORT_MAX)_Insertion_sort(_First, _Last, _Pred);
		else
		{
			_Diff _Count2=(_Count+1)/2;
			_BidIt _Mid=_First;
			std::advance(_Mid, _Count2);
			if(_Count2<=_Tempbuf._Maxlen())
			{
				_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
				_Buffered_merge_sort(_Mid, _Last, _Count-_Count2, _Tempbuf, _Pred);
			}
			else
			{
				_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
				_Stable_sort(_Mid, _Last, _Count-_Count2, _Tempbuf, _Pred);
			}
			_Buffered_merge(_First, _Mid, _Last, _Count2, _Count-_Count2, _Tempbuf, _Pred);
		}
	}
	template<class _BidIt, class _Diff, class _Ty, class _Pr>
	inline void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff*, _Ty*, _Pr _Pred)
	{
		_Diff _Count=0;
		_Distance(_First, _Last, _Count);
		_Temp_iterator<_Ty>_Tempbuf((_Count+1)/2);
		_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
	}
	template<class _BidIt, class _Pr>
	inline void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3385);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3386);
		if(_First!=_Last)
		{
			_Stable_sort(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dist_type(_First), _Val_type(_First), _Pred);
		}
	}
	template<class _RanIt, class _Ty>
	inline void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty*)
	{
		_Debug_range(_First, _Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3399);
		_Debug_range(_Mid, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3400);
		std::make_heap(_First, _Mid);
		for(_RanIt _Next=_Mid;
		_Next<_Last;
		++_Next)if(_Debug_lt(*_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3404))_Pop_heap(_First, _Mid, _Next, _Ty(*_Next), _Dist_type(_First));
		std::sort_heap(_First, _Mid);
	}
	template<class _RanIt>
	inline void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{
		_Partial_sort(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Val_type(_First));
	}
	template<class _RanIt, class _Ty, class _Pr>
	inline void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred, _Ty*)
	{
		_Debug_range(_First, _Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3423);
		_Debug_range(_Mid, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3424);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3425);
		std::make_heap(_First, _Mid, _Pred);
		for(_RanIt _Next=_Mid;
		_Next<_Last;
		++_Next)if(_Debug_lt_pred(_Pred, *_Next, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3429))_Pop_heap(_First, _Mid, _Next, _Ty(*_Next), _Pred, _Dist_type(_First));
		std::sort_heap(_First, _Mid, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{
		_Partial_sort(::std::_Checked_base(_First), ::std::_Checked_base(_Mid), ::std::_Checked_base(_Last), _Pred, _Val_type(_First));
	}
	template<class _InIt, class _RanIt, class _Diff, class _Ty>
	inline _RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Diff*, _Ty*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3450);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3451);
		_RanIt _Mid2=_First2;
		for(;
		_First1!=_Last1&&_Mid2!=_Last2;
		++_First1, ++_Mid2)*_Mid2=*_First1;
		std::make_heap(_First2, _Mid2);
		for(;
		_First1!=_Last1;
		++_First1)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3458))_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2-_First2), _Ty(*_First1));
		std::sort_heap(_First2, _Mid2);
		return (_Mid2);
	}
	template<class _InIt, class _RanIt>
	inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2)
	{
		if(_First1!=_Last1&&_First2!=_Last2)::std::_Checked_assign_from_base(_First2, _Partial_sort_copy(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dist_type(_First2), _Val_type(_First1)));
		return (_First2);
	}
	template<class _InIt, class _RanIt, class _Diff, class _Ty, class _Pr>
	inline _RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff*, _Ty*)
	{
		_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3487);
		_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3488);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3489);
		_RanIt _Mid2=_First2;
		for(;
		_First1!=_Last1&&_Mid2!=_Last2;
		++_First1, ++_Mid2)*_Mid2=*_First1;
		std::make_heap(_First2, _Mid2, _Pred);
		for(;
		_First1!=_Last1;
		++_First1)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3496))_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2-_First2), _Ty(*_First1), _Pred);
		std::sort_heap(_First2, _Mid2, _Pred);
		return (_Mid2);
	}
	template<class _InIt, class _RanIt, class _Pr>
	inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{
		if(_First1!=_Last1&&_First2!=_Last2)::std::_Checked_assign_from_base(_First2, _Partial_sort_copy(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred, _Dist_type(_First2), _Val_type(_First1)));
		return (_First2);
	}
	template<class _RanIt>
	inline void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3521);
		for(;
		_ISORT_MAX<_Last-_First;
		)
		{
			pair<_RanIt, _RanIt>_Mid=_Unguarded_partition(_First, _Last);
			if(_Mid.second<=_Nth)_First=_Mid.second;
			else if(_Mid.first<=_Nth)return ;
			else _Last=_Mid.first;
		}
		_Insertion_sort(_First, _Last);
	}
	template<class _RanIt>
	inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{
		_Nth_element(::std::_Checked_base(_First), ::std::_Checked_base(_Nth), ::std::_Checked_base(_Last));
	}
	template<class _RanIt, class _Pr>
	inline void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3549);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3550);
		for(;
		_ISORT_MAX<_Last-_First;
		)
		{
			pair<_RanIt, _RanIt>_Mid=_Unguarded_partition(_First, _Last, _Pred);
			if(_Mid.second<=_Nth)_First=_Mid.second;
			else if(_Mid.first<=_Nth)return ;
			else _Last=_Mid.first;
		}
		_Insertion_sort(_First, _Last, _Pred);
	}
	template<class _RanIt, class _Pr>
	inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{
		_Nth_element(::std::_Checked_base(_First), ::std::_Checked_base(_Nth), ::std::_Checked_base(_Last), _Pred);
	}
	template<class _InIt1, class _InIt2>
	inline bool _Includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3580);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3581);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3583))return (false);
		else if(*_First1<*_First2)++_First1;
		else++_First1, ++_First2;
		return (_First2==_Last2);
	}
	template<class _InIt1, class _InIt2>
	inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
	{
		return _Includes(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2));
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool _Includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3608);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3609);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3611))return (false);
		else if(_Pred(*_First1, *_First2))++_First1;
		else++_First1, ++_First2;
		return (_First2==_Last2);
	}
	template<class _InIt1, class _InIt2, class _Pr>
	inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{
		return _Includes(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Pred);
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3637);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3638);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3639);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3641))*_Dest++=*_First1, ++_First1;
		else if(*_First2<*_First1)*_Dest++=*_First2, ++_First2;
		else*_Dest++=*_First1, ++_First1, ++_First2;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Set_union(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3681);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3682);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3683);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3685))*_Dest++=*_First1, ++_First1;
		else if(_Pred(*_First2, *_First1))*_Dest++=*_First2, ++_First2;
		else*_Dest++=*_First1, ++_First1, ++_First2;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Set_union(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3725);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3726);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3727);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3729))++_First1;
		else if(*_First2<*_First1)++_First2;
		else*_Dest++=*_First1++, ++_First2;
		return (_Dest);
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Set_intersection(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3768);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3769);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3770);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3772))++_First1;
		else if(_Pred(*_First2, *_First1))++_First2;
		else*_Dest++=*_First1++, ++_First2;
		return (_Dest);
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Set_intersection(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3811);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3812);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3813);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3815))*_Dest++=*_First1, ++_First1;
		else if(*_First2<*_First1)++_First2;
		else++_First1, ++_First2;
		return (::stdext::unchecked_copy(_First1, _Last1, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Set_difference(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3854);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3855);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3856);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3858))*_Dest++=*_First1, ++_First1;
		else if(_Pred(*_First2, *_First1))++_First2;
		else++_First1, ++_First2;
		return (::stdext::unchecked_copy(_First1, _Last1, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Set_difference(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3897);
		_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3898);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3899);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt(*_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3901))*_Dest++=*_First1, ++_First1;
		else if(*_First2<*_First1)*_Dest++=*_First2, ++_First2;
		else++_First1, ++_First2;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Unchecked_iterator_tag)
	{
		return _Set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return _Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
	{
		_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3941);
		_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3942);
		_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3943);
		for(;
		_First1!=_Last1&&_First2!=_Last2;
		)if(_Debug_lt_pred(_Pred, *_First1, *_First2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3945))*_Dest++=*_First1, ++_First1;
		else if(_Pred(*_First2, *_First1))*_Dest++=*_First2, ++_First2;
		else++_First1, ++_First2;
		_Dest=::stdext::unchecked_copy(_First1, _Last1, _Dest);
		return (::stdext::unchecked_copy(_First2, _Last2, _Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Unchecked_iterator_tag)
	{
		return _Set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return _Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt>
	inline _FwdIt _Max_element(_FwdIt _First, _FwdIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3982);
		_FwdIt _Found=_First;
		if(_First!=_Last)for(;
		++_First!=_Last;
		)if(_Debug_lt(*_Found, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 3986))_Found=_First;
		return (_Found);
	}
	template<class _FwdIt>
	inline _FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{
		::std::_Checked_assign_from_base(_First, _Max_element(::std::_Checked_base(_First), ::std::_Checked_base(_Last)));
		return (_First);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4004);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4005);
		_FwdIt _Found=_First;
		if(_First!=_Last)for(;
		++_First!=_Last;
		)if(_Debug_lt_pred(_Pred, *_Found, *_First, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4009))_Found=_First;
		return (_Found);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Max_element(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _FwdIt>
	inline _FwdIt _Min_element(_FwdIt _First, _FwdIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4027);
		_FwdIt _Found=_First;
		if(_First!=_Last)for(;
		++_First!=_Last;
		)if(_Debug_lt(*_First, *_Found, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4031))_Found=_First;
		return (_Found);
	}
	template<class _FwdIt>
	inline _FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{
		::std::_Checked_assign_from_base(_First, _Min_element(::std::_Checked_base(_First), ::std::_Checked_base(_Last)));
		return (_First);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4049);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4050);
		_FwdIt _Found=_First;
		if(_First!=_Last)for(;
		++_First!=_Last;
		)if(_Debug_lt_pred(_Pred, *_First, *_Found, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4054))_Found=_First;
		return (_Found);
	}
	template<class _FwdIt, class _Pr>
	inline _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{
		::std::_Checked_assign_from_base(_First, _Min_element(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred));
		return (_First);
	}
	template<class _BidIt>
	inline bool _Next_permutation(_BidIt _First, _BidIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4072);
		_BidIt _Next=_Last;
		if(_First==_Last||_First==--_Next)return (false);
		for(;
		;
		)
		{
			_BidIt _Next1=_Next;
			if(_Debug_lt(*--_Next, *_Next1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4080))
			{
				_BidIt _Mid=_Last;
				for(;
				!_Debug_lt(*_Next, *--_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4083);
				);
				std::iter_swap(_Next, _Mid);
				std::reverse(_Next1, _Last);
				return (true);
			}
			if(_Next==_First)
			{
				std::reverse(_First, _Last);
				return (false);
			}
		}
	}
	template<class _BidIt>
	inline bool next_permutation(_BidIt _First, _BidIt _Last)
	{
		return _Next_permutation(::std::_Checked_base(_First), ::std::_Checked_base(_Last));
	}
	template<class _BidIt, class _Pr>
	inline bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4109);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4110);
		_BidIt _Next=_Last;
		if(_First==_Last||_First==--_Next)return (false);
		for(;
		;
		)
		{
			_BidIt _Next1=_Next;
			if(_Debug_lt_pred(_Pred, *--_Next, *_Next1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4118))
			{
				_BidIt _Mid=_Last;
				for(;
				!_Debug_lt_pred(_Pred, *_Next, *--_Mid, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4121);
				);
				std::iter_swap(_Next, _Mid);
				std::reverse(_Next1, _Last);
				return (true);
			}
			if(_Next==_First)
			{
				std::reverse(_First, _Last);
				return (false);
			}
		}
	}
	template<class _BidIt, class _Pr>
	inline bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		return _Next_permutation(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred);
	}
	template<class _BidIt>
	inline bool _Prev_permutation(_BidIt _First, _BidIt _Last)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4147);
		_BidIt _Next=_Last;
		if(_First==_Last||_First==--_Next)return (false);
		for(;
		;
		)
		{
			_BidIt _Next1=_Next;
			if(_Debug_lt(*_Next1, *--_Next, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4154))
			{
				_BidIt _Mid=_Last;
				for(;
				!_Debug_lt(*--_Mid, *_Next, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4157);
				);
				std::iter_swap(_Next, _Mid);
				std::reverse(_Next1, _Last);
				return (true);
			}
			if(_Next==_First)
			{
				std::reverse(_First, _Last);
				return (false);
			}
		}
	}
	template<class _BidIt>
	inline bool prev_permutation(_BidIt _First, _BidIt _Last)
	{
		return _Prev_permutation(::std::_Checked_base(_First), ::std::_Checked_base(_Last));
	}
	template<class _BidIt, class _Pr>
	inline bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4183);
		_Debug_pointer(_Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4184);
		_BidIt _Next=_Last;
		if(_First==_Last||_First==--_Next)return (false);
		for(;
		;
		)
		{
			_BidIt _Next1=_Next;
			if(_Debug_lt_pred(_Pred, *_Next1, *--_Next, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4192))
			{
				_BidIt _Mid=_Last;
				for(;
				!_Debug_lt_pred(_Pred, *--_Mid, *_Next, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\algorithm", 4195);
				);
				std::iter_swap(_Next, _Mid);
				std::reverse(_Next1, _Last);
				return (true);
			}
			if(_Next==_First)
			{
				std::reverse(_First, _Last);
				return (false);
			}
		}
	}
	template<class _BidIt, class _Pr>
	inline bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{
		return _Prev_permutation(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Pred);
	}
}
namespace stdext
{
	template<class _InIt, class _OutIt, class _Fn1>
	inline _OutIt unchecked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
		return ::std::_Transform(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Func, ::std::_Iter_random(_First, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Fn1>
	inline _OutIt checked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{
		return ::std::_Transform(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Func, ::std::_Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
	inline _OutIt unchecked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{
		return ::std::_Transform(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Dest, _Func, ::std::_Iter_random(_First1, _First2), ::std::_Iter_random(_First1, _Dest), ::std::_Range_checked_iterator_tag(), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
	inline _OutIt checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{
		return ::std::_Transform(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, _Dest, _Func, ::std::_Iter_random(_First1, _First2), ::std::_Iter_random(_First1, _Dest), ::std::_Checked_cat(_First2), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt2 unchecked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return ::std::_Swap_ranges(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Range_checked_iterator_tag());
	}
	template<class _FwdIt1, class _FwdIt2>
	inline _FwdIt2 checked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
	{
		return ::std::_Swap_ranges(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), _First2, ::std::_Iter_random(_First1, _First2), ::std::_Checked_cat(_Last1));
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt unchecked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval)
	{
		return ::std::_Replace_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Oldval, _Newval, ::std::_Iter_random(_First, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt checked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Oldval, const _Ty&_Newval)
	{
		return ::std::_Replace_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Oldval, _Newval, ::std::_Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty>
	inline _OutIt unchecked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val)
	{
		return ::std::_Replace_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Val, ::std::_Iter_random(_First, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr, class _Ty>
	inline _OutIt checked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty&_Val)
	{
		return ::std::_Replace_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Val, ::std::_Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _OutIt, class _Diff, class _Fn0>
	inline void unchecked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{
		::std::_Generate_n(_Dest, _Count, _Func, _Iter_cat(_Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _OutIt, class _Diff, class _Fn0>
	inline void checked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{
		::std::_Generate_n(_Dest, _Count, _Func, _Iter_cat(_Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt unchecked_remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val)
	{
		return ::std::_Remove_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Val, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Ty>
	inline _OutIt checked_remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty&_Val)
	{
		return ::std::_Remove_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Val, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unchecked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Remove_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt checked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Remove_copy_if(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (_First==_Last?_Dest: ::std::_Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_cat(_First), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _OutIt>
	inline _OutIt checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{
		return (_First==_Last?_Dest: ::std::_Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Iter_cat(_First), ::std::_Checked_cat(_Dest)));
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return (_First==_Last?_Dest: ::std::_Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std::_Range_checked_iterator_tag()));
	}
	template<class _InIt, class _OutIt, class _Pr>
	inline _OutIt checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{
		return (_First==_Last?_Dest: ::std::_Unique_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std::_Checked_cat(_Dest)));
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt unchecked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{
		return ::std::_Reverse_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt>
	inline _OutIt checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{
		return ::std::_Reverse_copy(::std::_Checked_base(_First), ::std::_Checked_base(_Last), _Dest, ::std::_Iter_random(_First, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt unchecked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return ::std::_Rotate_copy(_First, _Mid, _Last, _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _FwdIt, class _OutIt>
	inline _OutIt checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{
		return ::std::_Rotate_copy(_First, _Mid, _Last, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Iter_random(_First1, _First2, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Merge(_First1, _Last1, _First2, _Last2, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Iter_random(_First1, _First2, _Dest), ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Merge(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Iter_random(_First1, _First2, _Dest), ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return ::std::_Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3>
	inline _BidIt3 _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
	{
		return ::std::_Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return ::std::_Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
	inline _BidIt3 _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
	{
		return ::std::_Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count)
	{
		::std::_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt, class _Diff>
	inline void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count)
	{
		::std::_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std::_Checked_cat(_Dest));
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		::std::_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _BidIt, class _OutIt, class _Diff, class _Pr>
	inline void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Diff _Chunk, _Diff _Count, _Pr _Pred)
	{
		::std::_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_union(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_intersection(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt>
	inline _OutIt checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{
		return ::std::_Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, ::std::_Checked_cat(_Dest));
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Range_checked_iterator_tag());
	}
	template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
	inline _OutIt checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{
		return ::std::_Set_symmetric_difference(::std::_Checked_base(_First1), ::std::_Checked_base(_Last1), ::std::_Checked_base(_First2), ::std::_Checked_base(_Last2), _Dest, _Pred, ::std::_Checked_cat(_Dest));
	}
}
namespace std
{
	template<class _Arg, class _Result>
	struct unary_function
	{
		typedef _Arg argument_type;
		typedef _Result result_type;
	};
	template<class _Arg1, class _Arg2, class _Result>
	struct binary_function
	{
		typedef _Arg1 first_argument_type;
		typedef _Arg2 second_argument_type;
		typedef _Result result_type;
	};
	template<class _Ty>
	struct plus: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left+_Right);
		}
	};
	template<class _Ty>
	struct minus: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left-_Right);
		}
	};
	template<class _Ty>
	struct multiplies: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left*_Right);
		}
	};
	template<class _Ty>
	struct divides: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left/_Right);
		}
	};
	template<class _Ty>
	struct modulus: public binary_function<_Ty, _Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left%_Right);
		}
	};
	template<class _Ty>
	struct negate: public unary_function<_Ty, _Ty>
	{
		_Ty operator()(const _Ty&_Left)const
		{
			return (-_Left);
		}
	};
	template<class _Ty>
	struct equal_to: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left==_Right);
		}
	};
	template<class _Ty>
	struct not_equal_to: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left!=_Right);
		}
	};
	template<class _Ty>
	struct greater: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left>_Right);
		}
	};
	template<class _Ty>
	struct less: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left<_Right);
		}
	};
	template<class _Ty>
	struct greater_equal: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left>=_Right);
		}
	};
	template<class _Ty>
	struct less_equal: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left<=_Right);
		}
	};
	template<class _Ty>
	struct logical_and: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left&&_Right);
		}
	};
	template<class _Ty>
	struct logical_or: public binary_function<_Ty, _Ty, bool>
	{
		bool operator()(const _Ty&_Left, const _Ty&_Right)const
		{
			return (_Left||_Right);
		}
	};
	template<class _Ty>
	struct logical_not: public unary_function<_Ty, bool>
	{
		bool operator()(const _Ty&_Left)const
		{
			return (!_Left);
		}
	};
	template<class _Fn1>
	class unary_negate: public unary_function<typename _Fn1::argument_type, bool>
	{
	public:
		explicit unary_negate(const _Fn1&_Func): _Functor(_Func)
		{
		}
		bool operator()(const typename _Fn1::argument_type&_Left)const
		{
			return (!_Functor(_Left));
		}
		protected: _Fn1 _Functor;
	};
	template<class _Fn1>
	inline unary_negate<_Fn1>not1(const _Fn1&_Func)
	{
		return (std::unary_negate<_Fn1>(_Func));
	}
	template<class _Fn2>
	class binary_negate: public binary_function<typename _Fn2::first_argument_type, typename _Fn2::second_argument_type, bool>
	{
	public:
		explicit binary_negate(const _Fn2&_Func): _Functor(_Func)
		{
		}
		bool operator()(const typename _Fn2::first_argument_type&_Left, const typename _Fn2::second_argument_type&_Right)const
		{
			return (!_Functor(_Left, _Right));
		}
		protected: _Fn2 _Functor;
	};
	template<class _Fn2>
	inline binary_negate<_Fn2>not2(const _Fn2&_Func)
	{
		return (std::binary_negate<_Fn2>(_Func));
	}
	template<class _Fn2>
	class binder1st: public unary_function<typename _Fn2::second_argument_type, typename _Fn2::result_type>
	{
	public:
		typedef unary_function<typename _Fn2::second_argument_type, typename _Fn2::result_type>_Base;
		typedef typename _Base::argument_type argument_type;
		typedef typename _Base::result_type result_type;
		binder1st(const _Fn2&_Func, const typename _Fn2::first_argument_type&_Left): op(_Func), value(_Left)
		{
		}
		result_type operator()(const argument_type&_Right)const
		{
			return (op(value, _Right));
		}
		result_type operator()(argument_type&_Right)const
		{
			return (op(value, _Right));
		}
		protected: _Fn2 op;
		typename _Fn2::first_argument_type value;
	};
	template<class _Fn2, class _Ty>
	inline binder1st<_Fn2>bind1st(const _Fn2&_Func, const _Ty&_Left)
	{
		typename _Fn2::first_argument_type _Val(_Left);
		return (std::binder1st<_Fn2>(_Func, _Val));
	}
	template<class _Fn2>
	class binder2nd: public unary_function<typename _Fn2::first_argument_type, typename _Fn2::result_type>
	{
	public:
		typedef unary_function<typename _Fn2::first_argument_type, typename _Fn2::result_type>_Base;
		typedef typename _Base::argument_type argument_type;
		typedef typename _Base::result_type result_type;
		binder2nd(const _Fn2&_Func, const typename _Fn2::second_argument_type&_Right): op(_Func), value(_Right)
		{
		}
		result_type operator()(const argument_type&_Left)const
		{
			return (op(_Left, value));
		}
		result_type operator()(argument_type&_Left)const
		{
			return (op(_Left, value));
		}
		protected: _Fn2 op;
		typename _Fn2::second_argument_type value;
	};
	template<class _Fn2, class _Ty>
	inline binder2nd<_Fn2>bind2nd(const _Fn2&_Func, const _Ty&_Right)
	{
		typename _Fn2::second_argument_type _Val(_Right);
		return (std::binder2nd<_Fn2>(_Func, _Val));
	}
	template<class _Arg, class _Result, class _Fn=_Result(*)(_Arg)>
	class pointer_to_unary_function: public unary_function<_Arg, _Result>
	{
	public:
		explicit pointer_to_unary_function(_Fn _Left): _Pfun(_Left)
		{
		}
		_Result operator()(_Arg _Left)const
		{
			return (_Pfun(_Left));
		}
		protected: _Fn _Pfun;
	};
	template<class _Arg1, class _Arg2, class _Result, class _Fn=_Result(*)(_Arg1, _Arg2)>
	class pointer_to_binary_function: public binary_function<_Arg1, _Arg2, _Result>
	{
	public:
		explicit pointer_to_binary_function(_Fn _Left): _Pfun(_Left)
		{
		}
		_Result operator()(_Arg1 _Left, _Arg2 _Right)const
		{
			return (_Pfun(_Left, _Right));
		}
		protected: _Fn _Pfun;
	};
	template<class _Arg, class _Result>
	inline pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>ptr_fun(_Result(*_Left)(_Arg))
	{
		return (std::pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>(_Left));
	}
	template<class _Arg, class _Result>
	inline pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>ptr_fun(_Result(*_Left)(_Arg))
	{
		return (std::pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>(_Left));
	}
	template<class _Arg, class _Result>
	inline pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>ptr_fun(_Result(*_Left)(_Arg))
	{
		return (std::pointer_to_unary_function<_Arg, _Result, _Result(*)(_Arg)>(_Left));
	}
	template<class _Arg1, class _Arg2, class _Result>
	inline pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>ptr_fun(_Result(*_Left)(_Arg1, _Arg2))
	{
		return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>(_Left));
	}
	template<class _Arg1, class _Arg2, class _Result>
	inline pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>ptr_fun(_Result(*_Left)(_Arg1, _Arg2))
	{
		return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>(_Left));
	}
	template<class _Arg1, class _Arg2, class _Result>
	inline pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>ptr_fun(_Result(*_Left)(_Arg1, _Arg2))
	{
		return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(*)(_Arg1, _Arg2)>(_Left));
	}
	template<class _Result, class _Ty>
	class mem_fun_t: public unary_function<_Ty*, _Result>
	{
	public:
		explicit mem_fun_t(_Result(_Ty::*_Pm)()): _Pmemfun(_Pm)
		{
		}
		_Result operator()(_Ty*_Pleft)const
		{
			return ((_Pleft->*_Pmemfun)());
		}
	private:
		_Result(_Ty::*_Pmemfun)();
	};
	template<class _Result, class _Ty, class _Arg>
	class mem_fun1_t: public binary_function<_Ty*, _Arg, _Result>
	{
	public:
		explicit mem_fun1_t(_Result(_Ty::*_Pm)(_Arg)): _Pmemfun(_Pm)
		{
		}
		_Result operator()(_Ty*_Pleft, _Arg _Right)const
		{
			return ((_Pleft->*_Pmemfun)(_Right));
		}
	private:
		_Result(_Ty::*_Pmemfun)(_Arg);
	};
	template<class _Result, class _Ty>
	class const_mem_fun_t: public unary_function<const _Ty*, _Result>
	{
	public:
		explicit const_mem_fun_t(_Result(_Ty::*_Pm)()const): _Pmemfun(_Pm)
		{
		}
		_Result operator()(const _Ty*_Pleft)const
		{
			return ((_Pleft->*_Pmemfun)());
		}
	private:
		_Result(_Ty::*_Pmemfun)()const;
	};
	template<class _Result, class _Ty, class _Arg>
	class const_mem_fun1_t: public binary_function<const _Ty*, _Arg, _Result>
	{
	public:
		explicit const_mem_fun1_t(_Result(_Ty::*_Pm)(_Arg)const): _Pmemfun(_Pm)
		{
		}
		_Result operator()(const _Ty*_Pleft, _Arg _Right)const
		{
			return ((_Pleft->*_Pmemfun)(_Right));
		}
	private:
		_Result(_Ty::*_Pmemfun)(_Arg)const;
	};
	template<class _Result, class _Ty>
	inline mem_fun_t<_Result, _Ty>mem_fun(_Result(_Ty::*_Pm)())
	{
		return (std::mem_fun_t<_Result, _Ty>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline mem_fun1_t<_Result, _Ty, _Arg>mem_fun(_Result(_Ty::*_Pm)(_Arg))
	{
		return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty>
	inline const_mem_fun_t<_Result, _Ty>mem_fun(_Result(_Ty::*_Pm)()const)
	{
		return (std::const_mem_fun_t<_Result, _Ty>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline const_mem_fun1_t<_Result, _Ty, _Arg>mem_fun(_Result(_Ty::*_Pm)(_Arg)const)
	{
		return (std::const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline mem_fun1_t<_Result, _Ty, _Arg>mem_fun1(_Result(_Ty::*_Pm)(_Arg))
	{
		return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty>
	class mem_fun_ref_t: public unary_function<_Ty, _Result>
	{
	public:
		explicit mem_fun_ref_t(_Result(_Ty::*_Pm)()): _Pmemfun(_Pm)
		{
		}
		_Result operator()(_Ty&_Left)const
		{
			return ((_Left.*_Pmemfun)());
		}
	private:
		_Result(_Ty::*_Pmemfun)();
	};
	template<class _Result, class _Ty, class _Arg>
	class mem_fun1_ref_t: public binary_function<_Ty, _Arg, _Result>
	{
	public:
		explicit mem_fun1_ref_t(_Result(_Ty::*_Pm)(_Arg)): _Pmemfun(_Pm)
		{
		}
		_Result operator()(_Ty&_Left, _Arg _Right)const
		{
			return ((_Left.*_Pmemfun)(_Right));
		}
	private:
		_Result(_Ty::*_Pmemfun)(_Arg);
	};
	template<class _Result, class _Ty>
	class const_mem_fun_ref_t: public unary_function<_Ty, _Result>
	{
	public:
		explicit const_mem_fun_ref_t(_Result(_Ty::*_Pm)()const): _Pmemfun(_Pm)
		{
		}
		_Result operator()(const _Ty&_Left)const
		{
			return ((_Left.*_Pmemfun)());
		}
	private:
		_Result(_Ty::*_Pmemfun)()const;
	};
	template<class _Result, class _Ty, class _Arg>
	class const_mem_fun1_ref_t: public binary_function<_Ty, _Arg, _Result>
	{
	public:
		explicit const_mem_fun1_ref_t(_Result(_Ty::*_Pm)(_Arg)const): _Pmemfun(_Pm)
		{
		}
		_Result operator()(const _Ty&_Left, _Arg _Right)const
		{
			return ((_Left.*_Pmemfun)(_Right));
		}
	private:
		_Result(_Ty::*_Pmemfun)(_Arg)const;
	};
	template<class _Result, class _Ty>
	inline mem_fun_ref_t<_Result, _Ty>mem_fun_ref(_Result(_Ty::*_Pm)())
	{
		return (std::mem_fun_ref_t<_Result, _Ty>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline mem_fun1_ref_t<_Result, _Ty, _Arg>mem_fun_ref(_Result(_Ty::*_Pm)(_Arg))
	{
		return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty>
	inline const_mem_fun_ref_t<_Result, _Ty>mem_fun_ref(_Result(_Ty::*_Pm)()const)
	{
		return (std::const_mem_fun_ref_t<_Result, _Ty>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline const_mem_fun1_ref_t<_Result, _Ty, _Arg>mem_fun_ref(_Result(_Ty::*_Pm)(_Arg)const)
	{
		return (std::const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
	template<class _Result, class _Ty, class _Arg>
	inline mem_fun1_ref_t<_Result, _Ty, _Arg>mem_fun1_ref(_Result(_Ty::*_Pm)(_Arg))
	{
		return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
}
extern "C"
{
	typedef union
	{
		unsigned short _Word[8];
		float _Float;
		double _Double;
		long double _Long_double;
	}
	_Dconst;
	void _Feraise(int);
	double _Cosh(double, double);
	short _Dtest(double*);
	short _Exp(double*, double, short);
	double _Sinh(double, double);
	extern _Dconst _Denorm, _Hugeval, _Inf, _Nan, _Snan;
	float _FCosh(float, float);
	short _FDtest(float*);
	short _FExp(float*, float, short);
	float _FSinh(float, float);
	extern _Dconst _FDenorm, _FInf, _FNan, _FSnan;
	long double _LCosh(long double, long double);
	short _LDtest(long double*);
	short _LExp(long double*, long double, short);
	long double _LSinh(long double, long double);
	extern _Dconst _LDenorm, _LInf, _LNan, _LSnan;
}
extern "C"
{
	unsigned int _clearfp(void);
	unsigned int _controlfp(unsigned int _NewValue, unsigned int _Mask);
	void _set_controlfp(unsigned int _NewValue, unsigned int _Mask);
	errno_t _controlfp_s(unsigned int*_CurrentState, unsigned int _NewValue, unsigned int _Mask);
	unsigned int _statusfp(void);
	void _fpreset(void);
	void _statusfp2(unsigned int*_X86_status, unsigned int*_SSE2_status);
	unsigned int _control87(unsigned int _NewValue, unsigned int _Mask);
	int __control87_2(unsigned int _NewValue, unsigned int _Mask, unsigned int*_X86_cw, unsigned int*_Sse2_cw);
	extern int _fpecode;
	double _copysign(double _Number, double _Sign);
	double _chgsign(double _X);
	double _scalb(double _X, long _Y);
	double _logb(double _X);
	double _nextafter(double _X, double _Y);
	int _finite(double _X);
	int _isnan(double _X);
	int _fpclass(double _X);
}
extern "C"
{
	struct _exception
	{
		int type;
		char*name;
		double arg1;
		double arg2;
		double retval;
	};
	struct _complex
	{
		double x, y;
	};
	extern double _HUGE;
	double acos(double _X);
	double asin(double _X);
	double atan(double _X);
	double atan2(double _Y, double _X);
	double cos(double _X);
	double cosh(double _X);
	double exp(double _X);
	double fabs(double _X);
	double fmod(double _X, double _Y);
	double log(double _X);
	double log10(double _X);
	double pow(double _X, double _Y);
	double sin(double _X);
	double sinh(double _X);
	double tan(double _X);
	double tanh(double _X);
	double sqrt(double _X);
	double _cabs(struct _complex _Complex);
	double ceil(double _X);
	double floor(double _X);
	double frexp(double _X, int*_Y);
	double _hypot(double _X, double _Y);
	double _j0(double _X);
	double _j1(double _X);
	double _jn(int _X, double _Y);
	double ldexp(double _X, int _Y);
	int _matherr(struct _exception*_Except);
	double modf(double _X, double*_Y);
	double _y0(double _X);
	double _y1(double _X);
	double _yn(int _X, double _Y);
	int _set_SSE2_enable(int _Flag);
	float _hypotf(float _X, float _Y);
	inline long double acosl(long double _X)
	{
		return (acos((double)_X));
	}
	inline long double asinl(long double _X)
	{
		return (asin((double)_X));
	}
	inline long double atanl(long double _X)
	{
		return (atan((double)_X));
	}
	inline long double atan2l(long double _X, long double _Y)
	{
		return (atan2((double)_X, (double)_Y));
	}
	inline long double ceill(long double _X)
	{
		return (ceil((double)_X));
	}
	inline long double cosl(long double _X)
	{
		return (cos((double)_X));
	}
	inline long double coshl(long double _X)
	{
		return (cosh((double)_X));
	}
	inline long double expl(long double _X)
	{
		return (exp((double)_X));
	}
	inline long double fabsl(long double _X)
	{
		return (fabs((double)_X));
	}
	inline long double floorl(long double _X)
	{
		return (floor((double)_X));
	}
	inline long double fmodl(long double _X, long double _Y)
	{
		return (fmod((double)_X, (double)_Y));
	}
	inline long double frexpl(long double _X, int*_Y)
	{
		return (frexp((double)_X, _Y));
	}
	inline long double ldexpl(long double _X, int _Y)
	{
		return (ldexp((double)_X, _Y));
	}
	inline long double logl(long double _X)
	{
		return (log((double)_X));
	}
	inline long double log10l(long double _X)
	{
		return (log10((double)_X));
	}
	inline long double modfl(long double _X, long double*_Y)
	{
		double _Di, _Df=modf((double)_X, &_Di);
		*_Y=(long double)_Di;
		return (_Df);
	}
	inline long double powl(long double _X, long double _Y)
	{
		return (pow((double)_X, (double)_Y));
	}
	inline long double sinl(long double _X)
	{
		return (sin((double)_X));
	}
	inline long double sinhl(long double _X)
	{
		return (sinh((double)_X));
	}
	inline long double sqrtl(long double _X)
	{
		return (sqrt((double)_X));
	}
	inline long double tanl(long double _X)
	{
		return (tan((double)_X));
	}
	inline long double tanhl(long double _X)
	{
		return (tanh((double)_X));
	}
	inline long double _chgsignl(long double _Number)
	{
		return _chgsign(static_cast<double>(_Number));
	}
	inline long double _copysignl(long double _Number, long double _Sign)
	{
		return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign));
	}
	inline float frexpf(float _X, int*_Y)
	{
		return ((float)frexp((double)_X, _Y));
	}
	inline float fabsf(float _X)
	{
		return ((float)fabs((double)_X));
	}
	inline float ldexpf(float _X, int _Y)
	{
		return ((float)ldexp((double)_X, _Y));
	}
	inline float acosf(float _X)
	{
		return ((float)acos((double)_X));
	}
	inline float asinf(float _X)
	{
		return ((float)asin((double)_X));
	}
	inline float atanf(float _X)
	{
		return ((float)atan((double)_X));
	}
	inline float atan2f(float _X, float _Y)
	{
		return ((float)atan2((double)_X, (double)_Y));
	}
	inline float ceilf(float _X)
	{
		return ((float)ceil((double)_X));
	}
	inline float cosf(float _X)
	{
		return ((float)cos((double)_X));
	}
	inline float coshf(float _X)
	{
		return ((float)cosh((double)_X));
	}
	inline float expf(float _X)
	{
		return ((float)exp((double)_X));
	}
	inline float floorf(float _X)
	{
		return ((float)floor((double)_X));
	}
	inline float fmodf(float _X, float _Y)
	{
		return ((float)fmod((double)_X, (double)_Y));
	}
	inline float logf(float _X)
	{
		return ((float)log((double)_X));
	}
	inline float log10f(float _X)
	{
		return ((float)log10((double)_X));
	}
	inline float modff(float _X, float*_Y)
	{
		double _Di, _Df=modf((double)_X, &_Di);
		*_Y=(float)_Di;
		return ((float)_Df);
	}
	inline float powf(float _X, float _Y)
	{
		return ((float)pow((double)_X, (double)_Y));
	}
	inline float sinf(float _X)
	{
		return ((float)sin((double)_X));
	}
	inline float sinhf(float _X)
	{
		return ((float)sinh((double)_X));
	}
	inline float sqrtf(float _X)
	{
		return ((float)sqrt((double)_X));
	}
	inline float tanf(float _X)
	{
		return ((float)tan((double)_X));
	}
	inline float tanhf(float _X)
	{
		return ((float)tanh((double)_X));
	}
}
extern "C++"
{
	template<class _Ty>
	inline _Ty _Pow_int(_Ty _X, int _Y)
	{
		unsigned int _N;
		if(_Y>=0)_N=(unsigned int)_Y;
		else _N=(unsigned int)(-_Y);
		for(_Ty _Z=_Ty(1);
		;
		_X*=_X)
		{
			if((_N&1)!=0)_Z*=_X;
			if((_N>>=1)==0)return (_Y<0?_Ty(1)/_Z: _Z);
		}
	}
	inline long abs(long _X)
	{
		return (labs(_X));
	}
	inline double abs(double _X)
	{
		return (fabs(_X));
	}
	inline double pow(double _X, int _Y)
	{
		return (_Pow_int(_X, _Y));
	}
	inline float abs(float _X)
	{
		return (fabsf(_X));
	}
	inline float acos(float _X)
	{
		return (acosf(_X));
	}
	inline float asin(float _X)
	{
		return (asinf(_X));
	}
	inline float atan(float _X)
	{
		return (atanf(_X));
	}
	inline float atan2(float _Y, float _X)
	{
		return (atan2f(_Y, _X));
	}
	inline float ceil(float _X)
	{
		return (ceilf(_X));
	}
	inline float cos(float _X)
	{
		return (cosf(_X));
	}
	inline float cosh(float _X)
	{
		return (coshf(_X));
	}
	inline float exp(float _X)
	{
		return (expf(_X));
	}
	inline float fabs(float _X)
	{
		return (fabsf(_X));
	}
	inline float floor(float _X)
	{
		return (floorf(_X));
	}
	inline float fmod(float _X, float _Y)
	{
		return (fmodf(_X, _Y));
	}
	inline float frexp(float _X, int*_Y)
	{
		return (frexpf(_X, _Y));
	}
	inline float ldexp(float _X, int _Y)
	{
		return (ldexpf(_X, _Y));
	}
	inline float log(float _X)
	{
		return (logf(_X));
	}
	inline float log10(float _X)
	{
		return (log10f(_X));
	}
	inline float modf(float _X, float*_Y)
	{
		return (modff(_X, _Y));
	}
	inline float pow(float _X, float _Y)
	{
		return (powf(_X, _Y));
	}
	inline float pow(float _X, int _Y)
	{
		return (_Pow_int(_X, _Y));
	}
	inline float sin(float _X)
	{
		return (sinf(_X));
	}
	inline float sinh(float _X)
	{
		return (sinhf(_X));
	}
	inline float sqrt(float _X)
	{
		return (sqrtf(_X));
	}
	inline float tan(float _X)
	{
		return (tanf(_X));
	}
	inline float tanh(float _X)
	{
		return (tanhf(_X));
	}
	inline long double abs(long double _X)
	{
		return (fabsl(_X));
	}
	inline long double acos(long double _X)
	{
		return (acosl(_X));
	}
	inline long double asin(long double _X)
	{
		return (asinl(_X));
	}
	inline long double atan(long double _X)
	{
		return (atanl(_X));
	}
	inline long double atan2(long double _Y, long double _X)
	{
		return (atan2l(_Y, _X));
	}
	inline long double ceil(long double _X)
	{
		return (ceill(_X));
	}
	inline long double cos(long double _X)
	{
		return (cosl(_X));
	}
	inline long double cosh(long double _X)
	{
		return (coshl(_X));
	}
	inline long double exp(long double _X)
	{
		return (expl(_X));
	}
	inline long double fabs(long double _X)
	{
		return (fabsl(_X));
	}
	inline long double floor(long double _X)
	{
		return (floorl(_X));
	}
	inline long double fmod(long double _X, long double _Y)
	{
		return (fmodl(_X, _Y));
	}
	inline long double frexp(long double _X, int*_Y)
	{
		return (frexpl(_X, _Y));
	}
	inline long double ldexp(long double _X, int _Y)
	{
		return (ldexpl(_X, _Y));
	}
	inline long double log(long double _X)
	{
		return (logl(_X));
	}
	inline long double log10(long double _X)
	{
		return (log10l(_X));
	}
	inline long double modf(long double _X, long double*_Y)
	{
		return (modfl(_X, _Y));
	}
	inline long double pow(long double _X, long double _Y)
	{
		return (powl(_X, _Y));
	}
	inline long double pow(long double _X, int _Y)
	{
		return (_Pow_int(_X, _Y));
	}
	inline long double sin(long double _X)
	{
		return (sinl(_X));
	}
	inline long double sinh(long double _X)
	{
		return (sinhl(_X));
	}
	inline long double sqrt(long double _X)
	{
		return (sqrtl(_X));
	}
	inline long double tan(long double _X)
	{
		return (tanl(_X));
	}
	inline long double tanh(long double _X)
	{
		return (tanhl(_X));
	}
}
namespace std
{
	using::acosf;
	using::asinf;
	using::atanf;
	using::atan2f;
	using::ceilf;
	using::cosf;
	using::coshf;
	using::expf;
	using::fabsf;
	using::floorf;
	using::fmodf;
	using::frexpf;
	using::ldexpf;
	using::logf;
	using::log10f;
	using::modff;
	using::powf;
	using::sinf;
	using::sinhf;
	using::sqrtf;
	using::tanf;
	using::tanhf;
	using::acosl;
	using::asinl;
	using::atanl;
	using::atan2l;
	using::ceill;
	using::cosl;
	using::coshl;
	using::expl;
	using::fabsl;
	using::floorl;
	using::fmodl;
	using::frexpl;
	using::ldexpl;
	using::logl;
	using::log10l;
	using::modfl;
	using::powl;
	using::sinl;
	using::sinhl;
	using::sqrtl;
	using::tanl;
	using::tanhl;
	using::abs;
	using::acos;
	using::asin;
	using::atan;
	using::atan2;
	using::ceil;
	using::cos;
	using::cosh;
	using::exp;
	using::fabs;
	using::floor;
	using::fmod;
	using::frexp;
	using::ldexp;
	using::log;
	using::log10;
	using::modf;
	using::pow;
	using::sin;
	using::sinh;
	using::sqrt;
	using::tan;
	using::tanh;
}
namespace std
{
	typedef enum
	{
		denorm_indeterminate=-1, denorm_absent=0, denorm_present=1
	}
	float_denorm_style;
	typedef enum
	{
		round_indeterminate=-1, round_toward_zero=0, round_to_nearest=1, round_toward_infinity=2, round_toward_neg_infinity=3
	}
	float_round_style;
	struct _Num_base
	{
		static const float_denorm_style has_denorm=(float_denorm_style)(denorm_absent);
		static const bool has_denorm_loss=(bool)(false);
		static const bool has_infinity=(bool)(false);
		static const bool has_quiet_NaN=(bool)(false);
		static const bool has_signaling_NaN=(bool)(false);
		static const bool is_bounded=(bool)(false);
		static const bool is_exact=(bool)(false);
		static const bool is_iec559=(bool)(false);
		static const bool is_integer=(bool)(false);
		static const bool is_modulo=(bool)(false);
		static const bool is_signed=(bool)(false);
		static const bool is_specialized=(bool)(false);
		static const bool tinyness_before=(bool)(false);
		static const bool traps=(bool)(false);
		static const float_round_style round_style=(float_round_style)(round_toward_zero);
		static const int digits=(int)(0);
		static const int digits10=(int)(0);
		static const int max_exponent=(int)(0);
		static const int max_exponent10=(int)(0);
		static const int min_exponent=(int)(0);
		static const int min_exponent10=(int)(0);
		static const int radix=(int)(0);
	};
	const float_denorm_style _Num_base::has_denorm;
	const bool _Num_base::has_denorm_loss;
	const bool _Num_base::has_infinity;
	const bool _Num_base::has_quiet_NaN;
	const bool _Num_base::has_signaling_NaN;
	const bool _Num_base::is_bounded;
	const bool _Num_base::is_exact;
	const bool _Num_base::is_iec559;
	const bool _Num_base::is_integer;
	const bool _Num_base::is_modulo;
	const bool _Num_base::is_signed;
	const bool _Num_base::is_specialized;
	const bool _Num_base::tinyness_before;
	const bool _Num_base::traps;
	const float_round_style _Num_base::round_style;
	const int _Num_base::digits;
	const int _Num_base::digits10;
	const int _Num_base::max_exponent;
	const int _Num_base::max_exponent10;
	const int _Num_base::min_exponent;
	const int _Num_base::min_exponent10;
	const int _Num_base::radix;
	template<class _Ty>
	class numeric_limits: public _Num_base
	{
	public:
		static _Ty(min)()throw()
		{
			return (_Ty(0));
		}
		static _Ty(max)()throw()
		{
			return (_Ty(0));
		}
		static _Ty epsilon()throw()
		{
			return (_Ty(0));
		}
		static _Ty round_error()throw()
		{
			return (_Ty(0));
		}
		static _Ty denorm_min()throw()
		{
			return (_Ty(0));
		}
		static _Ty infinity()throw()
		{
			return (_Ty(0));
		}
		static _Ty quiet_NaN()throw()
		{
			return (_Ty(0));
		}
		static _Ty signaling_NaN()throw()
		{
			return (_Ty(0));
		}
	};
	struct _Num_int_base: public _Num_base
	{
		static const bool is_bounded=(bool)(true);
		static const bool is_exact=(bool)(true);
		static const bool is_integer=(bool)(true);
		static const bool is_modulo=(bool)(true);
		static const bool is_specialized=(bool)(true);
		static const int radix=(int)(2);
	};
	const bool _Num_int_base::is_bounded;
	const bool _Num_int_base::is_exact;
	const bool _Num_int_base::is_integer;
	const bool _Num_int_base::is_modulo;
	const bool _Num_int_base::is_specialized;
	const int _Num_int_base::radix;
	struct _Num_float_base: public _Num_base
	{
		static const float_denorm_style has_denorm=(float_denorm_style)(denorm_present);
		static const bool has_denorm_loss=(bool)(true);
		static const bool has_infinity=(bool)(true);
		static const bool has_quiet_NaN=(bool)(true);
		static const bool has_signaling_NaN=(bool)(true);
		static const bool is_bounded=(bool)(true);
		static const bool is_exact=(bool)(false);
		static const bool is_iec559=(bool)(true);
		static const bool is_integer=(bool)(false);
		static const bool is_modulo=(bool)(false);
		static const bool is_signed=(bool)(true);
		static const bool is_specialized=(bool)(true);
		static const bool tinyness_before=(bool)(true);
		static const bool traps=(bool)(true);
		static const float_round_style round_style=(float_round_style)(round_to_nearest);
		static const int radix=(int)(2);
	};
	const float_denorm_style _Num_float_base::has_denorm;
	const bool _Num_float_base::has_denorm_loss;
	const bool _Num_float_base::has_infinity;
	const bool _Num_float_base::has_quiet_NaN;
	const bool _Num_float_base::has_signaling_NaN;
	const bool _Num_float_base::is_bounded;
	const bool _Num_float_base::is_exact;
	const bool _Num_float_base::is_iec559;
	const bool _Num_float_base::is_integer;
	const bool _Num_float_base::is_modulo;
	const bool _Num_float_base::is_signed;
	const bool _Num_float_base::is_specialized;
	const bool _Num_float_base::tinyness_before;
	const bool _Num_float_base::traps;
	const float_round_style _Num_float_base::round_style;
	const int _Num_float_base::radix;
	template<>
	class numeric_limits<char>: public _Num_int_base
	{
	public:
		typedef char _Ty;
		static _Ty(min)()throw()
		{
			return ((-128));
		}
		static _Ty(max)()throw()
		{
			return (127);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)((-128)!=0);
		static const int digits=(int)(8-((-128)!=0?1: 0));
		static const int digits10=(int)((8-((-128)!=0?1: 0))*301L/1000);
	};
	const bool numeric_limits<char>::is_signed;
	const int numeric_limits<char>::digits;
	const int numeric_limits<char>::digits10;
	template<>
	class numeric_limits<wchar_t>: public _Num_int_base
	{
	public:
		typedef wchar_t _Ty;
		static _Ty(min)()throw()
		{
			return ((_Ty)0);
		}
		static _Ty(max)()throw()
		{
			return ((_Ty)0xffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(0!=0);
		static const int digits=(int)(8*sizeof(wchar_t)-(0!=0?1: 0));
		static const int digits10=(int)((8*sizeof(wchar_t)-(0!=0?1: 0))*301L/1000);
	};
	const bool numeric_limits<wchar_t>::is_signed;
	const int numeric_limits<wchar_t>::digits;
	const int numeric_limits<wchar_t>::digits10;
	template<>
	class numeric_limits<_Bool>: public _Num_int_base
	{
	public:
		typedef bool _Ty;
		static _Ty(min)()throw()
		{
			return (false);
		}
		static _Ty(max)()throw()
		{
			return (true);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_modulo=(bool)(false);
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(1);
		static const int digits10=(int)(0);
	};
	const bool numeric_limits<_Bool>::is_modulo;
	const bool numeric_limits<_Bool>::is_signed;
	const int numeric_limits<_Bool>::digits;
	const int numeric_limits<_Bool>::digits10;
	template<>
	class numeric_limits<signed char>: public _Num_int_base
	{
	public:
		typedef signed char _Ty;
		static _Ty(min)()throw()
		{
			return ((-128));
		}
		static _Ty(max)()throw()
		{
			return (127);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8-1);
		static const int digits10=(int)((8-1)*301L/1000);
	};
	const bool numeric_limits<signed char>::is_signed;
	const int numeric_limits<signed char>::digits;
	const int numeric_limits<signed char>::digits10;
	template<>
	class numeric_limits<unsigned char>: public _Num_int_base
	{
	public:
		typedef unsigned char _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8);
		static const int digits10=(int)((8)*301L/1000);
	};
	const bool numeric_limits<unsigned char>::is_signed;
	const int numeric_limits<unsigned char>::digits;
	const int numeric_limits<unsigned char>::digits10;
	template<>
	class numeric_limits<short>: public _Num_int_base
	{
	public:
		typedef short _Ty;
		static _Ty(min)()throw()
		{
			return ((-32768));
		}
		static _Ty(max)()throw()
		{
			return (32767);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8*sizeof(short)-1);
		static const int digits10=(int)((8*sizeof(short)-1)*301L/1000);
	};
	const bool numeric_limits<short>::is_signed;
	const int numeric_limits<short>::digits;
	const int numeric_limits<short>::digits10;
	template<>
	class numeric_limits<unsigned short>: public _Num_int_base
	{
	public:
		typedef unsigned short _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8*sizeof(unsigned short));
		static const int digits10=(int)((8*sizeof(unsigned short))*301L/1000);
	};
	const bool numeric_limits<unsigned short>::is_signed;
	const int numeric_limits<unsigned short>::digits;
	const int numeric_limits<unsigned short>::digits10;
	template<>
	class numeric_limits<int>: public _Num_int_base
	{
	public:
		typedef int _Ty;
		static _Ty(min)()throw()
		{
			return ((-2147483647-1));
		}
		static _Ty(max)()throw()
		{
			return (2147483647);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8*sizeof(int)-1);
		static const int digits10=(int)((8*sizeof(int)-1)*301L/1000);
	};
	const bool numeric_limits<int>::is_signed;
	const int numeric_limits<int>::digits;
	const int numeric_limits<int>::digits10;
	template<>
	class numeric_limits<unsigned int>: public _Num_int_base
	{
	public:
		typedef unsigned int _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xffffffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8*sizeof(unsigned int));
		static const int digits10=(int)((8*sizeof(unsigned int))*301L/1000);
	};
	const bool numeric_limits<unsigned int>::is_signed;
	const int numeric_limits<unsigned int>::digits;
	const int numeric_limits<unsigned int>::digits10;
	template<>
	class numeric_limits<long>: public _Num_int_base
	{
	public:
		typedef long _Ty;
		static _Ty(min)()throw()
		{
			return ((-2147483647L-1));
		}
		static _Ty(max)()throw()
		{
			return (2147483647L);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8*sizeof(long)-1);
		static const int digits10=(int)((8*sizeof(long)-1)*301L/1000);
	};
	const bool numeric_limits<long>::is_signed;
	const int numeric_limits<long>::digits;
	const int numeric_limits<long>::digits10;
	template<>
	class numeric_limits<unsigned long>: public _Num_int_base
	{
	public:
		typedef unsigned long _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xffffffffUL);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8*sizeof(unsigned long));
		static const int digits10=(int)((8*sizeof(unsigned long))*301L/1000);
	};
	const bool numeric_limits<unsigned long>::is_signed;
	const int numeric_limits<unsigned long>::digits;
	const int numeric_limits<unsigned long>::digits10;
	template<>
	class numeric_limits<__int64>: public _Num_int_base
	{
	public:
		typedef __int64 _Ty;
		static _Ty(min)()throw()
		{
			return (-0x7fffffffffffffff-1);
		}
		static _Ty(max)()throw()
		{
			return (0x7fffffffffffffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(true);
		static const int digits=(int)(8*sizeof(__int64)-1);
		static const int digits10=(int)((8*sizeof(__int64)-1)*301L/1000);
	};
	const bool numeric_limits<__int64>::is_signed;
	const int numeric_limits<__int64>::digits;
	const int numeric_limits<__int64>::digits10;
	template<>
	class numeric_limits<unsigned __int64>: public _Num_int_base
	{
	public:
		typedef unsigned __int64 _Ty;
		static _Ty(min)()throw()
		{
			return (0);
		}
		static _Ty(max)()throw()
		{
			return (0xffffffffffffffff);
		}
		static _Ty epsilon()throw()
		{
			return (0);
		}
		static _Ty round_error()throw()
		{
			return (0);
		}
		static _Ty denorm_min()throw()
		{
			return (0);
		}
		static _Ty infinity()throw()
		{
			return (0);
		}
		static _Ty quiet_NaN()throw()
		{
			return (0);
		}
		static _Ty signaling_NaN()throw()
		{
			return (0);
		}
		static const bool is_signed=(bool)(false);
		static const int digits=(int)(8*sizeof(unsigned __int64));
		static const int digits10=(int)((8*sizeof(unsigned __int64))*301L/1000);
	};
	const bool numeric_limits<unsigned __int64>::is_signed;
	const int numeric_limits<unsigned __int64>::digits;
	const int numeric_limits<unsigned __int64>::digits10;
	template<>
	class numeric_limits<float>: public _Num_float_base
	{
	public:
		typedef float _Ty;
		static _Ty(min)()throw()
		{
			return (1.175494351e-38F);
		}
		static _Ty(max)()throw()
		{
			return (3.402823466e+38F);
		}
		static _Ty epsilon()throw()
		{
			return (1.192092896e-07F);
		}
		static _Ty round_error()throw()
		{
			return (0.5);
		}
		static _Ty denorm_min()throw()
		{
			return (_FDenorm._Float);
		}
		static _Ty infinity()throw()
		{
			return (_FInf._Float);
		}
		static _Ty quiet_NaN()throw()
		{
			return (_FNan._Float);
		}
		static _Ty signaling_NaN()throw()
		{
			return (_FSnan._Float);
		}
		static const int digits=(int)(24);
		static const int digits10=(int)(6);
		static const int max_exponent=(int)((int)128);
		static const int max_exponent10=(int)((int)38);
		static const int min_exponent=(int)((int)(-125));
		static const int min_exponent10=(int)((int)(-37));
	};
	const int numeric_limits<float>::digits;
	const int numeric_limits<float>::digits10;
	const int numeric_limits<float>::max_exponent;
	const int numeric_limits<float>::max_exponent10;
	const int numeric_limits<float>::min_exponent;
	const int numeric_limits<float>::min_exponent10;
	template<>
	class numeric_limits<double>: public _Num_float_base
	{
	public:
		typedef double _Ty;
		static _Ty(min)()throw()
		{
			return (2.2250738585072014e-308);
		}
		static _Ty(max)()throw()
		{
			return (1.7976931348623158e+308);
		}
		static _Ty epsilon()throw()
		{
			return (2.2204460492503131e-016);
		}
		static _Ty round_error()throw()
		{
			return (0.5);
		}
		static _Ty denorm_min()throw()
		{
			return (_Denorm._Double);
		}
		static _Ty infinity()throw()
		{
			return (_Inf._Double);
		}
		static _Ty quiet_NaN()throw()
		{
			return (_Nan._Double);
		}
		static _Ty signaling_NaN()throw()
		{
			return (_Snan._Double);
		}
		static const int digits=(int)(53);
		static const int digits10=(int)(15);
		static const int max_exponent=(int)((int)1024);
		static const int max_exponent10=(int)((int)308);
		static const int min_exponent=(int)((int)(-1021));
		static const int min_exponent10=(int)((int)(-307));
	};
	const int numeric_limits<double>::digits;
	const int numeric_limits<double>::digits10;
	const int numeric_limits<double>::max_exponent;
	const int numeric_limits<double>::max_exponent10;
	const int numeric_limits<double>::min_exponent;
	const int numeric_limits<double>::min_exponent10;
	template<>
	class numeric_limits<long double>: public _Num_float_base
	{
	public:
		typedef long double _Ty;
		static _Ty(min)()throw()
		{
			return (2.2250738585072014e-308);
		}
		static _Ty(max)()throw()
		{
			return (1.7976931348623158e+308);
		}
		static _Ty epsilon()throw()
		{
			return (2.2204460492503131e-016);
		}
		static _Ty round_error()throw()
		{
			return (0.5);
		}
		static _Ty denorm_min()throw()
		{
			return (_LDenorm._Long_double);
		}
		static _Ty infinity()throw()
		{
			return (_LInf._Long_double);
		}
		static _Ty quiet_NaN()throw()
		{
			return (_LNan._Long_double);
		}
		static _Ty signaling_NaN()throw()
		{
			return (_LSnan._Long_double);
		}
		static const int digits=(int)(53);
		static const int digits10=(int)(15);
		static const int max_exponent=(int)((int)1024);
		static const int max_exponent10=(int)((int)308);
		static const int min_exponent=(int)((int)(-1021));
		static const int min_exponent10=(int)((int)(-307));
	};
	const int numeric_limits<long double>::digits;
	const int numeric_limits<long double>::digits10;
	const int numeric_limits<long double>::max_exponent;
	const int numeric_limits<long double>::max_exponent10;
	const int numeric_limits<long double>::min_exponent;
	const int numeric_limits<long double>::min_exponent10;
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			namespace flex_string_details
			{
				template<class InIt, class OutIt>
				OutIt copy_n(InIt b, typename std::iterator_traits<InIt>::difference_type n, OutIt d)
				{
					for(;
					n!=0;
					--n, ++b, ++d)
					{
						*d=*b;
					}
					return d;
				}
				template<class Pod, class T>
				inline void pod_fill(Pod*b, Pod*e, T c)
				{
					switch((e-b)&7)
					{
						case 0: while(b!=e)
						{
							*b=c;
							++b;
							case 7: *b=c;
							++b;
							case 6: *b=c;
							++b;
							case 5: *b=c;
							++b;
							case 4: *b=c;
							++b;
							case 3: *b=c;
							++b;
							case 2: *b=c;
							++b;
							case 1: *b=c;
							++b;
						}
					}
				}
				template<class Pod>
				inline void pod_move(const Pod*b, const Pod*e, Pod*d)
				{
					using namespace std;
					memmove(d, b, (e-b)*sizeof(*b));
				}
				template<class Pod>
				inline Pod*pod_copy(const Pod*b, const Pod*e, Pod*d)
				{
					const std::size_t s=e-b;
					using namespace std;
					memcpy(d, b, s*sizeof(*b));
					return d+s;
				}
				template<typename T>
				struct get_unsigned
				{
					typedef T result;
				};
				template<>
				struct get_unsigned<char>
				{
					typedef unsigned char result;
				};
				template<>
				struct get_unsigned<signed char>
				{
					typedef unsigned char result;
				};
				template<>
				struct get_unsigned<short int>
				{
					typedef unsigned short int result;
				};
				template<>
				struct get_unsigned<int>
				{
					typedef unsigned int result;
				};
				template<>
				struct get_unsigned<long int>
				{
					typedef unsigned long int result;
				};
				enum Shallow
				{
				};
			}
			template<class T>
			class mallocator
			{
			public:
				typedef T value_type;
				typedef value_type*pointer;
				typedef const value_type*const_pointer;
				typedef value_type&reference;
				typedef const value_type&const_reference;
				typedef std::size_t size_type;
				typedef int difference_type;
				template<class U>
				struct rebind
				{
					typedef mallocator<U>other;
				};
				mallocator()
				{
				}
				mallocator(const mallocator&)
				{
				}
				~mallocator()
				{
				}
				pointer address(reference x)const
				{
					return &x;
				}
				const_pointer address(const_reference x)const
				{
					return x;
				}
				pointer allocate(size_type n, const_pointer=0)
				{
					using namespace std;
					void*p=malloc(n*sizeof(T));
					if(!p)boost::throw_exception(std::bad_alloc());
					return static_cast<pointer>(p);
				}
				void deallocate(pointer p, size_type)
				{
					using namespace std;
					free(p);
				}
				size_type max_size()const
				{
					return static_cast<size_type>(-1)/sizeof(T);
				}
				void construct(pointer p, const value_type&x)
				{
					new(p)value_type(x);
				}
				void destroy(pointer p)
				{
					p->~value_type();
				}
			private:
				void operator=(const mallocator&);
			};
			template<>
			class mallocator<void>
			{
				typedef void value_type;
				typedef void*pointer;
				typedef const void*const_pointer;
				template<class U>
				struct rebind
				{
					typedef mallocator<U>other;
				};
			};
			template<class T>
			inline bool operator==(const mallocator<T>&, const mallocator<T>&)
			{
				return true;
			}
			template<class T>
			inline bool operator!=(const mallocator<T>&, const mallocator<T>&)
			{
				return false;
			}
			template<class Allocator>
			typename Allocator::pointer Reallocate(Allocator&alloc, typename Allocator::pointer p, typename Allocator::size_type oldObjCount, typename Allocator::size_type newObjCount, void*)
			{
				return 0;
			}
			template<class Allocator>
			typename Allocator::pointer Reallocate(Allocator&alloc, typename Allocator::pointer p, typename Allocator::size_type oldObjCount, typename Allocator::size_type newObjCount, mallocator<void>*)
			{
				return 0;
			}
			template<typename E, class A=std::allocator<E> >
			class SimpleStringStorage
			{
			public:
				struct Data
				{
					Data(): pEnd_(buffer_), pEndOfMem_(buffer_)
					{
						buffer_[0]=E(0);
					}
					E*pEnd_;
					E*pEndOfMem_;
					E buffer_[1];
				};
				static const Data emptyString_;
				typedef typename A::size_type size_type;
			private:
				Data*pData_;
				void Init(size_type size, size_type capacity)
				{
					(void)((!!(size<=capacity))||(_wassert(L"size <= capacity", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 336), 0));
					if(capacity==0)
					{
						pData_=const_cast<Data*>(&emptyString_);
					}
					else
					{
						pData_=static_cast<Data*>(malloc(sizeof(Data)+capacity*sizeof(E)));
						if(!pData_)boost::throw_exception(std::bad_alloc());
						pData_->pEnd_=pData_->buffer_+size;
						pData_->pEndOfMem_=pData_->buffer_+capacity;
					}
				}
			private:
				SimpleStringStorage()
				{
				}
			public:
				typedef E value_type;
				typedef E*iterator;
				typedef const E*const_iterator;
				typedef A allocator_type;
				SimpleStringStorage(const SimpleStringStorage&rhs)
				{
					const size_type sz=rhs.size();
					Init(sz, sz);
					if(sz)flex_string_details::pod_copy(rhs.begin(), rhs.end(), begin());
				}
				SimpleStringStorage(const SimpleStringStorage&s, flex_string_details::Shallow): pData_(s.pData_)
				{
				}
				SimpleStringStorage(const A&)
				{
					pData_=const_cast<Data*>(&emptyString_);
				}
				SimpleStringStorage(const E*s, size_type len, const A&)
				{
					Init(len, len);
					flex_string_details::pod_copy(s, s+len, begin());
				}
				SimpleStringStorage(size_type len, E c, const A&)
				{
					Init(len, len);
					flex_string_details::pod_fill(begin(), end(), c);
				}
				SimpleStringStorage&operator=(const SimpleStringStorage&rhs)
				{
					const size_type sz=rhs.size();
					reserve(sz);
					flex_string_details::pod_copy(&*rhs.begin(), &*rhs.end(), begin());
					pData_->pEnd_=&*begin()+sz;
					return *this;
				}
				~SimpleStringStorage()
				{
					(void)((!!(begin()<=end()))||(_wassert(L"begin() <= end()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 405), 0));
					if(pData_!=&emptyString_)free(pData_);
				}
				iterator begin()
				{
					return pData_->buffer_;
				}
				const_iterator begin()const
				{
					return pData_->buffer_;
				}
				iterator end()
				{
					return pData_->pEnd_;
				}
				const_iterator end()const
				{
					return pData_->pEnd_;
				}
				size_type size()const
				{
					return pData_->pEnd_-pData_->buffer_;
				}
				size_type max_size()const
				{
					return std::size_t(-1)/sizeof(E)-sizeof(Data)-1;
				}
				size_type capacity()const
				{
					return pData_->pEndOfMem_-pData_->buffer_;
				}
				void reserve(size_type res_arg)
				{
					if(res_arg<=capacity())
					{
						return ;
					}
					if(pData_==&emptyString_)
					{
						Init(0, res_arg);
					}
					else
					{
						const size_type sz=size();
						void*p=realloc(pData_, sizeof(Data)+res_arg*sizeof(E));
						if(!p)boost::throw_exception(std::bad_alloc());
						if(p!=pData_)
						{
							pData_=static_cast<Data*>(p);
							pData_->pEnd_=pData_->buffer_+sz;
						}
						pData_->pEndOfMem_=pData_->buffer_+res_arg;
					}
				}
				void append(const E*s, size_type sz)
				{
					const size_type neededCapacity=size()+sz;
					if(capacity()<neededCapacity)
					{
						const iterator b=begin();
						static std::less_equal<const E*>le;
						if(le(b, s)&&le(s, end()))
						{
							const size_type offset=s-b;
							reserve(neededCapacity);
							s=begin()+offset;
						}
						else
						{
							reserve(neededCapacity);
						}
					}
					flex_string_details::pod_copy(s, s+sz, end());
					pData_->pEnd_+=sz;
				}
				template<class InputIterator>
				void append(InputIterator b, InputIterator e)
				{
					for(;
					b!=e;
					++b)
					{
						*this+=*b;
					}
				}
				void resize(size_type newSize, E fill)
				{
					const int delta=int(newSize-size());
					if(delta==0)return ;
					if(delta>0)
					{
						if(newSize>capacity())
						{
							reserve(newSize);
						}
						E*e=&*end();
						flex_string_details::pod_fill(e, e+delta, fill);
					}
					pData_->pEnd_=pData_->buffer_+newSize;
				}
				void swap(SimpleStringStorage&rhs)
				{
					std::swap(pData_, rhs.pData_);
				}
				const E*c_str()const
				{
					if(pData_!=&emptyString_)*pData_->pEnd_=E();
					return pData_->buffer_;
				}
				const E*data()const
				{
					return pData_->buffer_;
				}
				A get_allocator()const
				{
					return A();
				}
			};
			template<typename E, class A>
			const typename SimpleStringStorage<E, A>::Data SimpleStringStorage<E, A>::emptyString_=typename SimpleStringStorage<E, A>::Data();
			template<typename E, class A=std::allocator<E> >
			class AllocatorStringStorage: public A
			{
				typedef typename A::size_type size_type;
				typedef typename SimpleStringStorage<E, A>::Data Data;
				void*Alloc(size_type sz, const void*p=0)
				{
					return A::allocate(1+(sz-1)/sizeof(E), static_cast<const char*>(p));
				}
				void*Realloc(void*p, size_type oldSz, size_type newSz)
				{
					void*r=Alloc(newSz);
					flex_string_details::pod_copy(p, p+Min(oldSz, newSz), r);
					Free(p, oldSz);
					return r;
				}
				void Free(void*p, size_type sz)
				{
					A::deallocate(static_cast<E*>(p), sz);
				}
				Data*pData_;
				void Init(size_type size, size_type cap)
				{
					(void)((!!(size<=cap))||(_wassert(L"size <= cap", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 568), 0));
					if(cap==0)
					{
						pData_=const_cast<Data*>(&SimpleStringStorage<E, A>::emptyString_);
					}
					else
					{
						pData_=static_cast<Data*>(Alloc(cap*sizeof(E)+sizeof(Data)));
						pData_->pEnd_=pData_->buffer_+size;
						pData_->pEndOfMem_=pData_->buffer_+cap;
					}
				}
			public:
				typedef E value_type;
				typedef E*iterator;
				typedef const E*const_iterator;
				typedef A allocator_type;
				AllocatorStringStorage(): A(), pData_(0)
				{
				}
				AllocatorStringStorage(const AllocatorStringStorage&rhs): A(rhs.get_allocator())
				{
					const size_type sz=rhs.size();
					Init(sz, sz);
					if(sz)flex_string_details::pod_copy(rhs.begin(), rhs.end(), begin());
				}
				AllocatorStringStorage(const AllocatorStringStorage&s, flex_string_details::Shallow): A(s.get_allocator())
				{
					pData_=s.pData_;
				}
				AllocatorStringStorage(const A&a): A(a)
				{
					pData_=const_cast<Data*>(&SimpleStringStorage<E, A>::emptyString_);
				}
				AllocatorStringStorage(const E*s, size_type len, const A&a): A(a)
				{
					Init(len, len);
					flex_string_details::pod_copy(s, s+len, begin());
				}
				AllocatorStringStorage(size_type len, E c, const A&a): A(a)
				{
					Init(len, len);
					flex_string_details::pod_fill(&*begin(), &*end(), c);
				}
				AllocatorStringStorage&operator=(const AllocatorStringStorage&rhs)
				{
					const size_type sz=rhs.size();
					reserve(sz);
					flex_string_details::pod_copy(&*rhs.begin(), &*rhs.end(), begin());
					pData_->pEnd_=&*begin()+rhs.size();
					return *this;
				}
				~AllocatorStringStorage()
				{
					if(capacity())
					{
						Free(pData_, sizeof(Data)+capacity()*sizeof(E));
					}
				}
				iterator begin()
				{
					return pData_->buffer_;
				}
				const_iterator begin()const
				{
					return pData_->buffer_;
				}
				iterator end()
				{
					return pData_->pEnd_;
				}
				const_iterator end()const
				{
					return pData_->pEnd_;
				}
				size_type size()const
				{
					return size_type(end()-begin());
				}
				size_type max_size()const
				{
					return A::max_size();
				}
				size_type capacity()const
				{
					return size_type(pData_->pEndOfMem_-pData_->buffer_);
				}
				void resize(size_type n, E c)
				{
					reserve(n);
					iterator newEnd=begin()+n;
					iterator oldEnd=end();
					if(newEnd>oldEnd)
					{
						flex_string_details::pod_fill(oldEnd, newEnd, c);
					}
					if(capacity())pData_->pEnd_=newEnd;
				}
				void reserve(size_type res_arg)
				{
					if(res_arg<=capacity())
					{
						return ;
					}
					A&myAlloc=*this;
					AllocatorStringStorage newStr(myAlloc);
					newStr.Init(size(), res_arg);
					flex_string_details::pod_copy(begin(), end(), newStr.begin());
					swap(newStr);
				}
				template<class ForwardIterator>
				void append(ForwardIterator b, ForwardIterator e)
				{
					const size_type sz=std::distance(b, e), neededCapacity=size()+sz;
					if(capacity()<neededCapacity)
					{
						reserve(neededCapacity);
					}
					std::copy(b, e, end());
					pData_->pEnd_+=sz;
				}
				void swap(AllocatorStringStorage&rhs)
				{
					std::swap(pData_, rhs.pData_);
				}
				const E*c_str()const
				{
					if(pData_!=&SimpleStringStorage<E, A>::emptyString_)
					{
						*pData_->pEnd_=E();
					}
					return &*begin();
				}
				const E*data()const
				{
					return &*begin();
				}
				A get_allocator()const
				{
					return *this;
				}
			};
			template<typename E, class A=std::allocator<E> >
			class VectorStringStorage: protected std::vector<E, A>
			{
				typedef std::vector<E, A>base;
			public:
				typedef E value_type;
				typedef typename base::iterator iterator;
				typedef typename base::const_iterator const_iterator;
				typedef A allocator_type;
				typedef typename A::size_type size_type;
				VectorStringStorage(const VectorStringStorage&s): base(s)
				{
				}
				VectorStringStorage(const A&a): base(1, E(), a)
				{
				}
				VectorStringStorage(const E*s, size_type len, const A&a): base(a)
				{
					base::reserve(len+1);
					base::insert(base::end(), s, s+len);
					base::insert(base::end(), E());
				}
				VectorStringStorage(size_type len, E c, const A&a): base(len+1, c, a)
				{
					base::back()=E();
				}
				VectorStringStorage&operator=(const VectorStringStorage&rhs)
				{
					base&v=*this;
					v=rhs;
					return *this;
				}
				iterator begin()
				{
					return base::begin();
				}
				const_iterator begin()const
				{
					return base::begin();
				}
				iterator end()
				{
					return base::end()-1;
				}
				const_iterator end()const
				{
					return base::end()-1;
				}
				size_type size()const
				{
					return base::size()-1;
				}
				size_type max_size()const
				{
					return base::max_size()-1;
				}
				size_type capacity()const
				{
					return base::capacity()-1;
				}
				void reserve(size_type res_arg)
				{
					(void)((!!(res_arg<max_size()))||(_wassert(L"res_arg < max_size()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 809), 0));
					base::reserve(res_arg+1);
				}
				void append(const E*s, size_type sz)
				{
					static std::less_equal<const E*>le;
					if(!base::empty())
					{
						const E*start=&base::front();
						if(le(start, s)&&le(s, start+size()))
						{
							const size_type offset=s-start;
							reserve(size()+sz);
							s=&base::front()+offset;
						}
					}
					base::insert(end(), s, s+sz);
				}
				template<class InputIterator>
				void append(InputIterator b, InputIterator e)
				{
					base::insert(end(), b, e);
				}
				void resize(size_type n, E c)
				{
					base::reserve(n+1);
					base::back()=c;
					base::resize(n+1, c);
					base::back()=E();
				}
				void swap(VectorStringStorage&rhs)
				{
					base::swap(rhs);
				}
				const E*c_str()const
				{
					return &*begin();
				}
				const E*data()const
				{
					return &*begin();
				}
				A get_allocator()const
				{
					return base::get_allocator();
				}
			};
			template<class Storage, unsigned int threshold, typename Align=typename Storage::value_type*>
			class SmallStringOpt
			{
			public:
				typedef typename Storage::value_type value_type;
				typedef value_type*iterator;
				typedef const value_type*const_iterator;
				typedef typename Storage::allocator_type allocator_type;
				typedef typename allocator_type::size_type size_type;
			private:
				enum
				{
					temp1=threshold*sizeof(value_type)>sizeof(Storage)?threshold*sizeof(value_type): sizeof(Storage)
				};
				enum
				{
					temp2=temp1>sizeof(Align)?temp1: sizeof(Align)
				};
			public:
				enum
				{
					maxSmallString=(temp2+sizeof(value_type)-1)/sizeof(value_type)
				};
			private:
				enum
				{
					magic=maxSmallString+1
				};
				union
				{
					mutable value_type buf_[maxSmallString+1];
					Align align_;
				};
				Storage&GetStorage()
				{
					(void)((!!(buf_[maxSmallString]==magic))||(_wassert(L"buf_[maxSmallString] == magic", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 896), 0));
					Storage*p=reinterpret_cast<Storage*>(&buf_[0]);
					return *p;
				}
				const Storage&GetStorage()const
				{
					(void)((!!(buf_[maxSmallString]==magic))||(_wassert(L"buf_[maxSmallString] == magic", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 903), 0));
					const Storage*p=reinterpret_cast<const Storage*>(&buf_[0]);
					return *p;
				}
				bool Small()const
				{
					return buf_[maxSmallString]!=magic;
				}
			public:
				SmallStringOpt(const SmallStringOpt&s)
				{
					if(s.Small())
					{
						flex_string_details::pod_copy(s.buf_, s.buf_+s.size(), buf_);
					}
					else
					{
						new(buf_)Storage(s.GetStorage());
					}
					buf_[maxSmallString]=s.buf_[maxSmallString];
				}
				SmallStringOpt(const allocator_type&)
				{
					buf_[maxSmallString]=maxSmallString;
				}
				SmallStringOpt(const value_type*s, size_type len, const allocator_type&a)
				{
					if(len<=maxSmallString)
					{
						flex_string_details::pod_copy(s, s+len, buf_);
						buf_[maxSmallString]=value_type(maxSmallString-len);
					}
					else
					{
						new(buf_)Storage(s, len, a);
						buf_[maxSmallString]=magic;
					}
				}
				SmallStringOpt(size_type len, value_type c, const allocator_type&a)
				{
					if(len<=maxSmallString)
					{
						flex_string_details::pod_fill(buf_, buf_+len, c);
						buf_[maxSmallString]=value_type(maxSmallString-len);
					}
					else
					{
						new(buf_)Storage(len, c, a);
						buf_[maxSmallString]=magic;
					}
				}
				SmallStringOpt&operator=(const SmallStringOpt&rhs)
				{
					reserve(rhs.size());
					resize(0, 0);
					append(rhs.data(), rhs.size());
					return *this;
				}
				~SmallStringOpt()
				{
					if(!Small())GetStorage().~Storage();
				}
				iterator begin()
				{
					if(Small())return buf_;
					return &*GetStorage().begin();
				}
				const_iterator begin()const
				{
					if(Small())return buf_;
					return &*GetStorage().begin();
				}
				iterator end()
				{
					if(Small())return buf_+maxSmallString-buf_[maxSmallString];
					return &*GetStorage().end();
				}
				const_iterator end()const
				{
					if(Small())return buf_+maxSmallString-buf_[maxSmallString];
					return &*GetStorage().end();
				}
				size_type size()const
				{
					(void)((!!(!Small()||maxSmallString>=buf_[maxSmallString]))||(_wassert(L"!Small() || maxSmallString >= buf_[maxSmallString]", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1002), 0));
					return Small()?maxSmallString-buf_[maxSmallString]: GetStorage().size();
				}
				size_type max_size()const
				{
					return get_allocator().max_size();
				}
				size_type capacity()const
				{
					return Small()?maxSmallString: GetStorage().capacity();
				}
				void reserve(size_type res_arg)
				{
					if(Small())
					{
						if(res_arg<=maxSmallString)return ;
						SmallStringOpt temp(*this);
						this->~SmallStringOpt();
						new(buf_)Storage(temp.data(), temp.size(), temp.get_allocator());
						buf_[maxSmallString]=magic;
						GetStorage().reserve(res_arg);
					}
					else
					{
						GetStorage().reserve(res_arg);
					}
					(void)((!!(capacity()>=res_arg))||(_wassert(L"capacity() >= res_arg", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1030), 0));
				}
				void append(const value_type*s, size_type sz)
				{
					if(!Small())
					{
						GetStorage().append(s, sz);
					}
					else
					{
						const size_type neededCapacity=maxSmallString-buf_[maxSmallString]+sz;
						if(maxSmallString<neededCapacity)
						{
							allocator_type alloc;
							Storage temp(alloc);
							temp.reserve(neededCapacity);
							temp.append(buf_, maxSmallString-buf_[maxSmallString]);
							temp.append(s, sz);
							buf_[maxSmallString]=magic;
							new(buf_)Storage(temp.get_allocator());
							GetStorage().swap(temp);
						}
						else
						{
							flex_string_details::pod_move(s, s+sz, buf_+maxSmallString-buf_[maxSmallString]);
							buf_[maxSmallString]-=value_type(sz);
						}
					}
				}
				template<class InputIterator>
				void append(InputIterator b, InputIterator e)
				{
					for(;
					b!=e;
					++b)
					{
						*this+=*b;
					}
				}
				void resize(size_type n, value_type c)
				{
					if(Small())
					{
						if(n>maxSmallString)
						{
							SmallStringOpt temp(*this);
							Storage newString(temp.data(), temp.size(), temp.get_allocator());
							newString.resize(n, c);
							this->~SmallStringOpt();
							new(&buf_[0])Storage(temp.get_allocator());
							buf_[maxSmallString]=value_type(magic);
							GetStorage().swap(newString);
						}
						else
						{
							size_type toFill=n>size()?n-size(): 0;
							flex_string_details::pod_fill(end(), end()+toFill, c);
							buf_[maxSmallString]=value_type(maxSmallString-n);
						}
					}
					else
					{
						if(n>maxSmallString)
						{
							GetStorage().resize(n, c);
						}
						else
						{
							(void)((!!(capacity()>n))||(_wassert(L"capacity() > n", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1115), 0));
							SmallStringOpt newObj(data(), n, get_allocator());
							newObj.swap(*this);
						}
					}
				}
				void swap(SmallStringOpt&rhs)
				{
					if(Small())
					{
						if(rhs.Small())
						{
							std::swap_ranges(buf_, buf_+maxSmallString+1, rhs.buf_);
						}
						else
						{
							SmallStringOpt temp(*this);
							this->~SmallStringOpt();
							new(buf_)Storage(0, value_type(), rhs.get_allocator());
							buf_[maxSmallString]=magic;
							swap(rhs);
							rhs.~SmallStringOpt();
							new(&rhs)SmallStringOpt(temp);
						}
					}
					else
					{
						if(rhs.Small())
						{
							rhs.swap(*this);
						}
						else
						{
							GetStorage().swap(rhs.GetStorage());
						}
					}
				}
				const value_type*c_str()const
				{
					if(!Small())return GetStorage().c_str();
					buf_[maxSmallString-buf_[maxSmallString]]=value_type();
					return buf_;
				}
				const value_type*data()const
				{
					return Small()?buf_: GetStorage().data();
				}
				allocator_type get_allocator()const
				{
					return allocator_type();
				}
			};
			template<typename Storage, typename Align=typename Storage::value_type*>
			class CowString
			{
				typedef typename Storage::value_type E;
				typedef typename flex_string_details::get_unsigned<E>::result RefCountType;
			public:
				typedef E value_type;
				typedef typename Storage::iterator iterator;
				typedef typename Storage::const_iterator const_iterator;
				typedef typename Storage::allocator_type allocator_type;
				typedef typename allocator_type::size_type size_type;
				typedef typename Storage::reference reference;
			private:
				union
				{
					mutable char buf_[sizeof(Storage)];
					Align align_;
				};
				Storage&Data()const
				{
					Storage*p=reinterpret_cast<Storage*>(&buf_[0]);
					return *p;
				}
				RefCountType GetRefs()const
				{
					const Storage&d=Data();
					(void)((!!(d.size()>0))||(_wassert(L"d.size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1218), 0));
					(void)((!!(static_cast<RefCountType>(*d.begin())!=0))||(_wassert(L"static_cast<RefCountType>(*d.begin()) != 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1219), 0));
					return *d.begin();
				}
				RefCountType&Refs()
				{
					Storage&d=Data();
					(void)((!!(d.size()>0))||(_wassert(L"d.size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1226), 0));
					return reinterpret_cast<RefCountType&>(*d.begin());
				}
				void MakeUnique()const
				{
					(void)((!!(GetRefs()>=1))||(_wassert(L"GetRefs() >= 1", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1232), 0));
					if(GetRefs()==1)return ;
					union
					{
						char buf_[sizeof(Storage)];
						Align align_;
					}
					temp;
					--(*Data().begin());
					Storage*p=reinterpret_cast<Storage*>(&temp.buf_[0]);
					new(buf_)Storage(*new(p)Storage(Data()), flex_string_details::Shallow());
					*Data().begin()=1;
				}
			public:
				CowString(const CowString&s)
				{
					if(s.GetRefs()==(std::numeric_limits<RefCountType>::max)())
					{
						new(buf_)Storage(s.Data());
						Refs()=1;
					}
					else
					{
						new(buf_)Storage(s.Data(), flex_string_details::Shallow());
						++Refs();
					}
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1264), 0));
				}
				CowString(const allocator_type&a)
				{
					new(buf_)Storage(1, 1, a);
				}
				CowString(const E*s, size_type len, const allocator_type&a)
				{
					new(buf_)Storage(a);
					Data().reserve(len+1);
					Data().resize(1, 1);
					Data().append(s, s+len);
				}
				CowString(size_type len, E c, const allocator_type&a)
				{
					new(buf_)Storage(len+1, c, a);
					Refs()=1;
				}
				CowString&operator=(const CowString&rhs)
				{
					if(--Refs()==0)Data().~Storage();
					if(rhs.GetRefs()==(std::numeric_limits<RefCountType>::max)())
					{
						new(buf_)Storage(rhs.Data());
						Refs()=1;
					}
					else
					{
						new(buf_)Storage(rhs.Data(), flex_string_details::Shallow());
						++Refs();
					}
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1305), 0));
					return *this;
				}
				~CowString()
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1311), 0));
					if(--Refs()==0)Data().~Storage();
				}
				iterator begin()
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1318), 0));
					MakeUnique();
					return Data().begin()+1;
				}
				const_iterator begin()const
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1325), 0));
					return Data().begin()+1;
				}
				iterator end()
				{
					MakeUnique();
					return Data().end();
				}
				const_iterator end()const
				{
					return Data().end();
				}
				size_type size()const
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1342), 0));
					return Data().size()-1;
				}
				size_type max_size()const
				{
					(void)((!!(Data().max_size()>0))||(_wassert(L"Data().max_size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1348), 0));
					return Data().max_size()-1;
				}
				size_type capacity()const
				{
					(void)((!!(Data().capacity()>0))||(_wassert(L"Data().capacity() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1354), 0));
					return Data().capacity()-1;
				}
				void resize(size_type n, E c)
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1360), 0));
					MakeUnique();
					Data().resize(n+1, c);
				}
				template<class FwdIterator>
				void append(FwdIterator b, FwdIterator e)
				{
					MakeUnique();
					Data().append(b, e);
				}
				void reserve(size_type res_arg)
				{
					if(capacity()>res_arg)return ;
					MakeUnique();
					Data().reserve(res_arg+1);
				}
				void swap(CowString&rhs)
				{
					Data().swap(rhs.Data());
				}
				const E*c_str()const
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1386), 0));
					return Data().c_str()+1;
				}
				const E*data()const
				{
					(void)((!!(Data().size()>0))||(_wassert(L"Data().size() > 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1392), 0));
					return Data().data()+1;
				}
				allocator_type get_allocator()const
				{
					return Data().get_allocator();
				}
			};
			template<typename E, class T=std::char_traits<E>, class A=std::allocator<E>, class Storage=AllocatorStringStorage<E, A> >
			class flex_string: private Storage
			{
				template<typename Exception>
				static inline void Enforce(bool condition, Exception*, const char*msg)
				{
					(void)((!!(condition&&msg))||(_wassert(L"condition && msg", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1421), 0));
				}
				bool Sane()const
				{
					return begin()<=end()&&empty()==(size()==0)&&empty()==(begin()==end())&&size()<=max_size()&&capacity()<=max_size()&&size()<=capacity();
				}
				struct Invariant;
				friend struct Invariant;
				struct Invariant
				{
					Invariant(const flex_string&s): s_(s)
					{
						(void)((!!(s_.Sane()))||(_wassert(L"s_.Sane()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1442), 0));
					}
					~Invariant()
					{
						(void)((!!(s_.Sane()))||(_wassert(L"s_.Sane()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1446), 0));
					}
				private:
					const flex_string&s_;
					Invariant&operator=(const Invariant&);
				};
			public:
				typedef T traits_type;
				typedef typename traits_type::char_type value_type;
				typedef A allocator_type;
				typedef typename A::size_type size_type;
				typedef typename A::difference_type difference_type;
				typedef typename A::reference reference;
				typedef typename A::const_reference const_reference;
				typedef typename A::pointer pointer;
				typedef typename A::const_pointer const_pointer;
				typedef typename Storage::iterator iterator;
				typedef typename Storage::const_iterator const_iterator;
				typedef boost::reverse_iterator<iterator>reverse_iterator;
				typedef boost::reverse_iterator<const_iterator>const_reverse_iterator;
				static const size_type npos;
			private:
				static size_type Min(size_type lhs, size_type rhs)
				{
					return lhs<rhs?lhs: rhs;
				}
				static void Procust(size_type&n, size_type nmax)
				{
					if(n>nmax)n=nmax;
				}
			public:
				explicit flex_string(const A&a=A()): Storage(a)
				{
				}
				flex_string(const flex_string&str): Storage(str)
				{
				}
				flex_string(const flex_string&str, size_type pos, size_type n=npos, const A&a=A()): Storage(a)
				{
					Enforce(pos<=str.size(), (std::out_of_range*)0, "");
					assign(str, pos, n);
				}
				flex_string(const value_type*s, const A&a=A()): Storage(s, traits_type::length(s), a)
				{
				}
				flex_string(const value_type*s, size_type n, const A&a=A()): Storage(s, n, a)
				{
				}
				flex_string(size_type n, value_type c, const A&a=A()): Storage(n, c, a)
				{
				}
				template<class InputIterator>
				flex_string(InputIterator begin, InputIterator end, const A&a=A()): Storage(a)
				{
					assign(begin, end);
				}
				~flex_string()
				{
				}
				flex_string&operator=(const flex_string&str)
				{
					if(this!=&str)
					{
						Storage&s=*this;
						s=str;
					}
					return *this;
				}
				flex_string&operator=(const value_type*s)
				{
					assign(s);
					return *this;
				}
				flex_string&operator=(value_type c)
				{
					assign(1, c);
					return *this;
				}
				iterator begin()
				{
					return Storage::begin();
				}
				const_iterator begin()const
				{
					return Storage::begin();
				}
				iterator end()
				{
					return Storage::end();
				}
				const_iterator end()const
				{
					return Storage::end();
				}
				reverse_iterator rbegin()
				{
					return reverse_iterator(end());
				}
				const_reverse_iterator rbegin()const
				{
					return const_reverse_iterator(end());
				}
				reverse_iterator rend()
				{
					return reverse_iterator(begin());
				}
				const_reverse_iterator rend()const
				{
					return const_reverse_iterator(begin());
				}
				size_type size()const
				{
					return Storage::size();
				}
				size_type length()const
				{
					return size();
				}
				size_type max_size()const
				{
					return Storage::max_size();
				}
				void resize(size_type n, value_type c)
				{
					Storage::resize(n, c);
				}
				void resize(size_type n)
				{
					resize(n, value_type());
				}
				size_type capacity()const
				{
					return Storage::capacity();
				}
				void reserve(size_type res_arg=0)
				{
					Enforce(res_arg<=max_size(), (std::length_error*)0, "");
					Storage::reserve(res_arg);
				}
				void clear()
				{
					resize(0);
				}
				bool empty()const
				{
					return size()==0;
				}
				const_reference operator[](size_type pos)const
				{
					return *(begin()+pos);
				}
				reference operator[](size_type pos)
				{
					return *(begin()+pos);
				}
				const_reference at(size_type n)const
				{
					Enforce(n<size(), (std::out_of_range*)0, "");
					return (*this)[n];
				}
				reference at(size_type n)
				{
					Enforce(n<size(), (std::out_of_range*)0, "");
					return (*this)[n];
				}
				flex_string&operator+=(const flex_string&str)
				{
					return append(str);
				}
				flex_string&operator+=(const value_type*s)
				{
					return append(s);
				}
				flex_string&operator+=(value_type c)
				{
					push_back(c);
					return *this;
				}
				flex_string&append(const flex_string&str)
				{
					return append(str, 0, npos);
				}
				flex_string&append(const flex_string&str, const size_type pos, size_type n)
				{
					const size_type sz=str.size();
					Enforce(pos<=sz, (std::out_of_range*)0, "");
					Procust(n, sz-pos);
					return append(str.c_str()+pos, n);
				}
				flex_string&append(const value_type*s, const size_type n)
				{
					Invariant checker(*this);
					if(IsAliasedRange(s, s+n))
					{
						const size_type offset=s-&*begin();
						Storage::reserve(size()+n);
						s=&*begin()+offset;
					}
					Storage::append(s, s+n);
					return *this;
				}
				flex_string&append(const value_type*s)
				{
					return append(s, traits_type::length(s));
				}
				flex_string&append(size_type n, value_type c)
				{
					resize(size()+n, c);
					return *this;
				}
				template<class InputIterator>
				flex_string&append(InputIterator first, InputIterator last)
				{
					insert(end(), first, last);
					return *this;
				}
				void push_back(value_type c)
				{
					const size_type cap=capacity();
					if(size()==cap)
					{
						reserve(cap<<1u);
					}
					Storage::append(&c, &c+1);
				}
				flex_string&assign(const flex_string&str)
				{
					if(&str==this)return *this;
					return assign(str.data(), str.size());
				}
				flex_string&assign(const flex_string&str, size_type pos, size_type n)
				{
					const size_type sz=str.size();
					Enforce(pos<=str.size(), (std::out_of_range*)0, "");
					Procust(n, sz-pos);
					return assign(str.data()+pos, n);
				}
				flex_string&assign(const value_type*s, size_type n)
				{
					Invariant checker(*this);
					if(size()>=n)
					{
						std::copy(s, s+n, begin());
						resize(n);
					}
					else
					{
						const value_type*const s2=s+size();
						std::copy(s, s2, begin());
						append(s2, n-size());
					}
					return *this;
				}
				flex_string&assign(const value_type*s)
				{
					return assign(s, traits_type::length(s));
				}
				template<class ItOrLength, class ItOrChar>
				flex_string&assign(ItOrLength first_or_n, ItOrChar last_or_c)
				{
					return replace(begin(), end(), first_or_n, last_or_c);
				}
				flex_string&insert(size_type pos1, const flex_string&str)
				{
					return insert(pos1, str.data(), str.size());
				}
				flex_string&insert(size_type pos1, const flex_string&str, size_type pos2, size_type n)
				{
					Enforce(pos2<=str.length(), (std::out_of_range*)0, "");
					Procust(n, str.length()-pos2);
					return insert(pos1, str.data()+pos2, n);
				}
				flex_string&insert(size_type pos, const value_type*s, size_type n)
				{
					Enforce(pos<=length(), (std::out_of_range*)0, "");
					insert(begin()+pos, s, s+n);
					return *this;
				}
				flex_string&insert(size_type pos, const value_type*s)
				{
					return insert(pos, s, traits_type::length(s));
				}
				flex_string&insert(size_type pos, size_type n, value_type c)
				{
					Enforce(pos<=length(), (std::out_of_range*)0, "");
					insert(begin()+pos, n, c);
					return *this;
				}
				iterator insert(iterator p, value_type c=value_type())
				{
					const size_type pos=p-begin();
					insert(pos, &c, 1);
					return begin()+pos;
				}
			private:
				template<class Iterator>
				const typename std::iterator_traits<Iterator>::value_type*DereferenceValidIterator(Iterator it)const
				{
					return &*it;
				}
				template<typename Iterator>
				const typename std::iterator_traits<Iterator>::value_type*DereferenceValidIterator(std::reverse_iterator<Iterator>it)const
				{
					return &*--it;
				}
				template<class Iterator>
				bool IsAliasedRange(Iterator beginIterator, Iterator endIterator)
				{
					if(!empty()&&beginIterator!=endIterator)
					{
						typedef const typename std::iterator_traits<Iterator>::value_type*pointer;
						pointer myBegin(&*begin());
						pointer myEnd(&*begin()+size());
						pointer rangeBegin(DereferenceValidIterator(beginIterator));
						const std::less_equal<pointer>less_equal=std::less_equal<pointer>();
						if(less_equal(myBegin, rangeBegin)&&less_equal(rangeBegin, myEnd))return true;
					}
					return false;
				}
				template<int i>
				class Selector
				{
				};
				flex_string&InsertImplDiscr(iterator p, size_type n, value_type c, Selector<1>)
				{
					Invariant checker(*this);
					(void)((!!(begin()<=p&&p<=end()))||(_wassert(L"begin() <= p && p <= end()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1821), 0));
					const size_type insertOffset(p-begin());
					const size_type originalSize(size());
					if(n<originalSize-insertOffset)
					{
						append(n, value_type(0));
						value_type*begin(&*begin());
						flex_string_details::pod_move(begin+insertOffset, begin+originalSize, begin+insertOffset+n);
						std::fill(begin+insertOffset, begin+insertOffset+n, c);
					}
					else
					{
						append(n, c);
						value_type*begin(&*begin());
						flex_string_details::pod_copy(begin+insertOffset, begin+originalSize, begin+insertOffset+n);
						std::fill(begin+insertOffset, begin+originalSize, c);
					}
					return *this;
				}
				template<class InputIterator>
				flex_string&InsertImplDiscr(iterator i, InputIterator b, InputIterator e, Selector<0>)
				{
					InsertImpl(i, b, e, typename std::iterator_traits<InputIterator>::iterator_category());
					return *this;
				}
				template<class FwdIterator>
				void InsertImpl(iterator i, FwdIterator s1, FwdIterator s2, std::forward_iterator_tag)
				{
					if(s1==s2)
					{
						return ;
					}
					if(IsAliasedRange(s1, s2))
					{
						const flex_string temporary(s1, s2);
						InsertImpl(i, temporary.begin(), temporary.end(), typename std::iterator_traits<FwdIterator>::iterator_category());
						return ;
					}
					Invariant checker(*this);
					const size_type pos=i-begin();
					const typename std::iterator_traits<FwdIterator>::difference_type n2=std::distance(s1, s2);
					(void)((!!(n2>=0))||(_wassert(L"n2 >= 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1887), 0));
					using namespace flex_string_details;
					(void)((!!(pos<=size()))||(_wassert(L"pos <= size()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1889), 0));
					const typename std::iterator_traits<FwdIterator>::difference_type maxn2=capacity()-size();
					if(maxn2<n2)
					{
						(void)((!!(!IsAliasedRange(s1, s2)))||(_wassert(L"!IsAliasedRange(s1, s2)", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1896), 0));
						reserve(size()+n2);
						i=begin()+pos;
					}
					if(pos+n2<=size())
					{
						const iterator tailBegin=end()-n2;
						Storage::append(tailBegin, tailBegin+n2);
						std::copy(reverse_iterator(tailBegin), reverse_iterator(i), reverse_iterator(tailBegin+n2));
						std::copy(s1, s2, i);
					}
					else
					{
						FwdIterator t=s1;
						const size_type old_size=size();
						std::advance(t, old_size-pos);
						(void)((!!(std::distance(t, s2)>=0))||(_wassert(L"std::distance(t, s2) >= 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 1913), 0));
						Storage::append(t, s2);
						Storage::append(data()+pos, data()+old_size);
						std::copy(s1, t, i);
					}
				}
				template<class InputIterator>
				void InsertImpl(iterator insertPosition, InputIterator inputBegin, InputIterator inputEnd, std::input_iterator_tag)
				{
					flex_string temporary(begin(), insertPosition);
					for(;
					inputBegin!=inputEnd;
					++inputBegin)
					{
						temporary.push_back(*inputBegin);
					}
					temporary.append(insertPosition, end());
					swap(temporary);
				}
			public:
				template<class ItOrLength, class ItOrChar>
				void insert(iterator p, ItOrLength first_or_n, ItOrChar last_or_c)
				{
					Selector<std::numeric_limits<ItOrLength>::is_specialized>sel;
					InsertImplDiscr(p, first_or_n, last_or_c, sel);
				}
				flex_string&erase(size_type pos=0, size_type n=npos)
				{
					Invariant checker(*this);
					Enforce(pos<=length(), (std::out_of_range*)0, "");
					Procust(n, length()-pos);
					std::copy(begin()+pos+n, end(), begin()+pos);
					resize(length()-n);
					return *this;
				}
				iterator erase(iterator position)
				{
					const size_type pos(position-begin());
					erase(pos, 1);
					return begin()+pos;
				}
				iterator erase(iterator first, iterator last)
				{
					const size_type pos(first-begin());
					erase(pos, last-first);
					return begin()+pos;
				}
				flex_string&replace(size_type pos1, size_type n1, const flex_string&str)
				{
					return replace(pos1, n1, str, 0, npos);
				}
				flex_string&replace(size_type pos1, size_type n1, const flex_string&str, size_type pos2, size_type n2)
				{
					Enforce(pos2<=str.length(), (std::out_of_range*)0, "");
					return replace(pos1, n1, str.data()+pos2, Min(n2, str.size()-pos2));
				}
				flex_string&replace(size_type pos, size_type n1, const value_type*s)
				{
					return replace(pos, n1, s, traits_type::length(s));
				}
				template<class StrOrLength, class NumOrChar>
				flex_string&replace(size_type pos, size_type n1, StrOrLength s_or_n2, NumOrChar n_or_c)
				{
					Invariant checker(*this);
					Enforce(pos<=size(), (std::out_of_range*)0, "");
					Procust(n1, length()-pos);
					const iterator b=begin()+pos;
					return replace(b, b+n1, s_or_n2, n_or_c);
				}
				flex_string&replace(iterator i1, iterator i2, const flex_string&str)
				{
					return replace(i1, i2, str.c_str(), str.length());
				}
				flex_string&replace(iterator i1, iterator i2, const value_type*s)
				{
					return replace(i1, i2, s, traits_type::length(s));
				}
			private:
				flex_string&ReplaceImplDiscr(iterator i1, iterator i2, const value_type*s, size_type n, Selector<2>)
				{
					(void)((!!(i1<=i2))||(_wassert(L"i1 <= i2", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 2014), 0));
					(void)((!!(begin()<=i1&&i1<=end()))||(_wassert(L"begin() <= i1 && i1 <= end()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 2015), 0));
					(void)((!!(begin()<=i2&&i2<=end()))||(_wassert(L"begin() <= i2 && i2 <= end()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 2016), 0));
					return replace(i1, i2, s, s+n);
				}
				flex_string&ReplaceImplDiscr(iterator i1, iterator i2, size_type n2, value_type c, Selector<1>)
				{
					const size_type n1=i2-i1;
					if(n1>n2)
					{
						std::fill(i1, i1+n2, c);
						erase(i1+n2, i2);
					}
					else
					{
						std::fill(i1, i2, c);
						insert(i2, n2-n1, c);
					}
					return *this;
				}
				template<class InputIterator>
				flex_string&ReplaceImplDiscr(iterator i1, iterator i2, InputIterator b, InputIterator e, Selector<0>)
				{
					ReplaceImpl(i1, i2, b, e, typename std::iterator_traits<InputIterator>::iterator_category());
					return *this;
				}
				template<class FwdIterator>
				void ReplaceImpl(iterator i1, iterator i2, FwdIterator s1, FwdIterator s2, std::forward_iterator_tag)
				{
					Invariant checker(*this);
					const typename std::iterator_traits<iterator>::difference_type n1=i2-i1;
					(void)((!!(n1>=0))||(_wassert(L"n1 >= 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 2055), 0));
					const typename std::iterator_traits<FwdIterator>::difference_type n2=std::distance(s1, s2);
					(void)((!!(n2>=0))||(_wassert(L"n2 >= 0", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\flex_string.hpp", 2058), 0));
					if(IsAliasedRange(s1, s2))
					{
						flex_string temporary;
						temporary.reserve(size()-n1+n2);
						temporary.append(begin(), i1).append(s1, s2).append(i2, end());
						swap(temporary);
						return ;
					}
					if(n1>n2)
					{
						std::copy(s1, s2, i1);
						erase(i1+n2, i2);
					}
					else
					{
						flex_string_details::copy_n(s1, n1, i1);
						std::advance(s1, n1);
						insert(i2, s1, s2);
					}
				}
				template<class InputIterator>
				void ReplaceImpl(iterator i1, iterator i2, InputIterator b, InputIterator e, std::input_iterator_tag)
				{
					flex_string temp(begin(), i1);
					temp.append(b, e).append(i2, end());
					swap(temp);
				}
			public:
				template<class T1, class T2>
				flex_string&replace(iterator i1, iterator i2, T1 first_or_n_or_s, T2 last_or_c_or_n)
				{
					const bool num1=std::numeric_limits<T1>::is_specialized, num2=std::numeric_limits<T2>::is_specialized;
					return ReplaceImplDiscr(i1, i2, first_or_n_or_s, last_or_c_or_n, Selector<num1?(num2?1: -1): (num2?2: 0)>());
				}
				size_type copy(value_type*s, size_type n, size_type pos=0)const
				{
					Enforce(pos<=size(), (std::out_of_range*)0, "");
					n=Min(n, size()-pos);
					flex_string_details::pod_copy(&*begin()+pos, &*begin()+pos+n, s);
					return n;
				}
				void swap(flex_string&rhs)
				{
					Storage&srhs=rhs;
					this->Storage::swap(srhs);
				}
				const value_type*c_str()const
				{
					return Storage::c_str();
				}
				const value_type*data()const
				{
					return Storage::data();
				}
				allocator_type get_allocator()const
				{
					return Storage::get_allocator();
				}
				size_type find(const flex_string&str, size_type pos=0)const
				{
					return find(str.data(), pos, str.length());
				}
				size_type find(const value_type*s, size_type pos, size_type n)const
				{
					const size_type size_(size());
					if(n+pos>size_)return npos;
					for(;
					pos<size_;
					++pos)
					{
						if(traits_type::compare(&*begin()+pos, s, n)==0)
						{
							return pos;
						}
					}
					return npos;
				}
				size_type find(const value_type*s, size_type pos=0)const
				{
					return find(s, pos, traits_type::length(s));
				}
				size_type find(value_type c, size_type pos=0)const
				{
					return find(&c, pos, 1);
				}
				size_type rfind(const flex_string&str, size_type pos=npos)const
				{
					return rfind(str.c_str(), pos, str.length());
				}
				size_type rfind(const value_type*s, size_type pos, size_type n)const
				{
					if(n>length())return npos;
					pos=Min(pos, length()-n);
					if(n==0)return pos;
					const_iterator i(begin()+pos);
					for(;
					;
					--i)
					{
						if(traits_type::eq(*i, *s)&&traits_type::compare(&*i, s, n)==0)
						{
							return i-begin();
						}
						if(i==begin())break;
					}
					return npos;
				}
				size_type rfind(const value_type*s, size_type pos=npos)const
				{
					return rfind(s, pos, traits_type::length(s));
				}
				size_type rfind(value_type c, size_type pos=npos)const
				{
					return rfind(&c, pos, 1);
				}
				size_type find_first_of(const flex_string&str, size_type pos=0)const
				{
					return find_first_of(str.c_str(), pos, str.length());
				}
				size_type find_first_of(const value_type*s, size_type pos, size_type n)const
				{
					if(pos>length()||n==0)return npos;
					const_iterator i(begin()+pos), finish(end());
					for(;
					i!=finish;
					++i)
					{
						if(traits_type::find(s, n, *i)!=0)
						{
							return i-begin();
						}
					}
					return npos;
				}
				size_type find_first_of(const value_type*s, size_type pos=0)const
				{
					return find_first_of(s, pos, traits_type::length(s));
				}
				size_type find_first_of(value_type c, size_type pos=0)const
				{
					return find_first_of(&c, pos, 1);
				}
				size_type find_last_of(const flex_string&str, size_type pos=npos)const
				{
					return find_last_of(str.c_str(), pos, str.length());
				}
				size_type find_last_of(const value_type*s, size_type pos, size_type n)const
				{
					if(!empty()&&n>0)
					{
						pos=Min(pos, length()-1);
						const_iterator i(begin()+pos);
						for(;
						;
						--i)
						{
							if(traits_type::find(s, n, *i)!=0)
							{
								return i-begin();
							}
							if(i==begin())break;
						}
					}
					return npos;
				}
				size_type find_last_of(const value_type*s, size_type pos=npos)const
				{
					return find_last_of(s, pos, traits_type::length(s));
				}
				size_type find_last_of(value_type c, size_type pos=npos)const
				{
					return find_last_of(&c, pos, 1);
				}
				size_type find_first_not_of(const flex_string&str, size_type pos=0)const
				{
					return find_first_not_of(str.data(), pos, str.size());
				}
				size_type find_first_not_of(const value_type*s, size_type pos, size_type n)const
				{
					if(pos<length())
					{
						const_iterator i(begin()+pos), finish(end());
						for(;
						i!=finish;
						++i)
						{
							if(traits_type::find(s, n, *i)==0)
							{
								return i-begin();
							}
						}
					}
					return npos;
				}
				size_type find_first_not_of(const value_type*s, size_type pos=0)const
				{
					return find_first_not_of(s, pos, traits_type::length(s));
				}
				size_type find_first_not_of(value_type c, size_type pos=0)const
				{
					return find_first_not_of(&c, pos, 1);
				}
				size_type find_last_not_of(const flex_string&str, size_type pos=npos)const
				{
					return find_last_not_of(str.c_str(), pos, str.length());
				}
				size_type find_last_not_of(const value_type*s, size_type pos, size_type n)const
				{
					if(!empty())
					{
						pos=Min(pos, size()-1);
						const_iterator i(begin()+pos);
						for(;
						;
						--i)
						{
							if(traits_type::find(s, n, *i)==0)
							{
								return i-begin();
							}
							if(i==begin())break;
						}
					}
					return npos;
				}
				size_type find_last_not_of(const value_type*s, size_type pos=npos)const
				{
					return find_last_not_of(s, pos, traits_type::length(s));
				}
				size_type find_last_not_of(value_type c, size_type pos=npos)const
				{
					return find_last_not_of(&c, pos, 1);
				}
				flex_string substr(size_type pos=0, size_type n=npos)const
				{
					Enforce(pos<=size(), (std::out_of_range*)0, "");
					return flex_string(data()+pos, Min(n, size()-pos));
				}
				std::ptrdiff_t compare(const flex_string&str)const
				{
					return compare(0, size(), str);
				}
				std::ptrdiff_t compare(size_type pos1, size_type n1, const flex_string&str)const
				{
					return compare(pos1, n1, str.data(), str.size());
				}
				std::ptrdiff_t compare(size_type pos1, size_type n1, const value_type*s)const
				{
					return compare(pos1, n1, s, traits_type::length(s));
				}
				std::ptrdiff_t compare(size_type pos1, size_type n1, const value_type*s, size_type n2)const
				{
					Enforce(pos1<=size(), (std::out_of_range*)0, "");
					Procust(n1, size()-pos1);
					const int r=traits_type::compare(pos1+data(), s, Min(n1, n2));
					return r!=0?r: n1>n2?1: n1<n2?-1: 0;
				}
				std::ptrdiff_t compare(size_type pos1, size_type n1, const flex_string&str, size_type pos2, size_type n2)const
				{
					Enforce(pos2<=str.size(), (std::out_of_range*)0, "");
					return compare(pos1, n1, str.data()+pos2, Min(n2, str.size()-pos2));
				}
				std::ptrdiff_t compare(const value_type*s)const
				{
					const size_type n1(size()), n2(traits_type::length(s));
					const int r=traits_type::compare(data(), s, Min(n1, n2));
					return r!=0?r: n1>n2?1: n1<n2?-1: 0;
				}
			};
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				flex_string<E, T, A, S>result;
				result.reserve(lhs.size()+rhs.size());
				result.append(lhs).append(rhs);
				return result;
			}
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				flex_string<E, T, A, S>result;
				const typename flex_string<E, T, A, S>::size_type len=flex_string<E, T, A, S>::traits_type::length(lhs);
				result.reserve(len+rhs.size());
				result.append(lhs, len).append(rhs);
				return result;
			}
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(typename flex_string<E, T, A, S>::value_type lhs, const flex_string<E, T, A, S>&rhs)
			{
				flex_string<E, T, A, S>result;
				result.reserve(1+rhs.size());
				result.push_back(lhs);
				result.append(rhs);
				return result;
			}
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				typedef typename flex_string<E, T, A, S>::size_type size_type;
				typedef typename flex_string<E, T, A, S>::traits_type traits_type;
				flex_string<E, T, A, S>result;
				const size_type len=traits_type::length(rhs);
				result.reserve(lhs.size()+len);
				result.append(lhs).append(rhs, len);
				return result;
			}
			template<typename E, class T, class A, class S>
			flex_string<E, T, A, S>operator+(const flex_string<E, T, A, S>&lhs, typename flex_string<E, T, A, S>::value_type rhs)
			{
				flex_string<E, T, A, S>result;
				result.reserve(lhs.size()+1);
				result.append(lhs);
				result.push_back(rhs);
				return result;
			}
			template<typename E, class T, class A, class S>
			inline bool operator==(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return lhs.compare(rhs)==0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator==(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return rhs==lhs;
			}
			template<typename E, class T, class A, class S>
			inline bool operator==(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return lhs.compare(rhs)==0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator!=(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(lhs==rhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator!=(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(lhs==rhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator!=(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return !(lhs==rhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator<(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return lhs.compare(rhs)<0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator<(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return lhs.compare(rhs)<0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator<(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return rhs.compare(lhs)>0;
			}
			template<typename E, class T, class A, class S>
			inline bool operator>(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return rhs<lhs;
			}
			template<typename E, class T, class A, class S>
			inline bool operator>(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return rhs<lhs;
			}
			template<typename E, class T, class A, class S>
			bool operator>(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return rhs<lhs;
			}
			template<typename E, class T, class A, class S>
			inline bool operator<=(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(rhs<lhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator<=(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return !(rhs<lhs);
			}
			template<typename E, class T, class A, class S>
			bool operator<=(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(rhs<lhs);
			}
			template<typename E, class T, class A, class S>
			bool operator>=(const flex_string<E, T, A, S>&lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(lhs<rhs);
			}
			template<typename E, class T, class A, class S>
			bool operator>=(const flex_string<E, T, A, S>&lhs, const typename flex_string<E, T, A, S>::value_type*rhs)
			{
				return !(lhs<rhs);
			}
			template<typename E, class T, class A, class S>
			inline bool operator>=(const typename flex_string<E, T, A, S>::value_type*lhs, const flex_string<E, T, A, S>&rhs)
			{
				return !(lhs<rhs);
			}
			template<typename E, class T, class A, class S>
			void swap(flex_string<E, T, A, S>&lhs, flex_string<E, T, A, S>&rhs)
			{
				lhs.swap(rhs);
			}
			template<typename E, class T, class A, class S>
			inline std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&operator>>(std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&is, flex_string<E, T, A, S>&str);
			template<typename E, class T, class A, class S>
			std::basic_ostream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&operator<<(std::basic_ostream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&os, const flex_string<E, T, A, S>&str)
			{
				return os<<str.c_str();
			}
			template<typename E, class T, class A, class S>
			std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&getline(std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&is, flex_string<E, T, A, S>&str, typename flex_string<E, T, A, S>::value_type delim)
			{
				size_t nread=0;
				typename std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>::sentry sentry(is, true);
				if(sentry)
				{
					std::basic_streambuf<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>*buf=is.rdbuf();
					str.clear();
					while(nread<str.max_size())
					{
						int c1=buf->sbumpc();
						if(flex_string<E, T, A, S>::traits_type::eq_int_type(c1, flex_string<E, T, A, S>::traits_type::eof()))
						{
							is.setstate(std::ios_base::eofbit);
							break;
						}
						else
						{
							++nread;
							typename flex_string<E, T, A, S>::value_type c=flex_string<E, T, A, S>::traits_type::to_char_type(c1);
							if(!flex_string<E, T, A, S>::traits_type::eq(c, delim))str.push_back(c);
							else break;
						}
					}
				}
				if(nread==0||nread>=str.max_size())is.setstate(std::ios_base::failbit);
				return is;
			}
			template<typename E, class T, class A, class S>
			std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&getline(std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>&is, flex_string<E, T, A, S>&str)
			{
				return getline(is, str, is.widen('\n'));
			}
			template<typename E1, class T, class A, class S>
			const typename flex_string<E1, T, A, S>::size_type flex_string<E1, T, A, S>::npos=(typename flex_string<E1, T, A, S>::size_type)(-1);
		}
	}
}
namespace boost
{
	namespace wave
	{
		typedef long int_literal_type;
		typedef unsigned long uint_literal_type;
	}
}
namespace boost
{
	namespace wave
	{
		enum token_category
		{
			IdentifierTokenType=0x10000000, ParameterTokenType=0x11000000, ExtParameterTokenType=0x11100000, KeywordTokenType=0x20000000, OperatorTokenType=0x30000000, LiteralTokenType=0x40000000, IntegerLiteralTokenType=0x41000000, FloatingLiteralTokenType=0x42000000, StringLiteralTokenType=0x43000000, CharacterLiteralTokenType=0x44000000, BoolLiteralTokenType=0x45000000, PPTokenType=0x50000000, PPConditionalTokenType=0x50800000, UnknownTokenType=0xA0000000, EOLTokenType=0xB0000000, EOFTokenType=0xC0000000, WhiteSpaceTokenType=0xD0000000, InternalTokenType=0xE0000000, TokenTypeMask=0xFF000000, AltTokenType=0x00100000, TriGraphTokenType=0x00200000, AltExtTokenType=0x00500000, ExtTokenTypeMask=0xFFF00000, ExtTokenOnlyMask=0x00F00000, TokenValueMask=0x000FFFFF, MainTokenMask=0xFF0FFFFF
		};
		enum token_id
		{
			T_UNKNOWN=0, T_FIRST_TOKEN=256, T_AND=((T_FIRST_TOKEN)|(OperatorTokenType)), T_AND_ALT=((T_FIRST_TOKEN)|(OperatorTokenType|AltExtTokenType)), T_ANDAND=((257)|(OperatorTokenType)), T_ANDAND_ALT=((257)|(OperatorTokenType|AltExtTokenType)), T_ASSIGN=((258)|(OperatorTokenType)), T_ANDASSIGN=((259)|(OperatorTokenType)), T_ANDASSIGN_ALT=((259)|(OperatorTokenType|AltExtTokenType)), T_OR=((260)|(OperatorTokenType)), T_OR_ALT=((260)|(OperatorTokenType|AltExtTokenType)), T_OR_TRIGRAPH=((260)|(OperatorTokenType|TriGraphTokenType)), T_ORASSIGN=((261)|(OperatorTokenType)), T_ORASSIGN_ALT=((261)|(OperatorTokenType|AltExtTokenType)), T_ORASSIGN_TRIGRAPH=((261)|(OperatorTokenType|TriGraphTokenType)), T_XOR=((262)|(OperatorTokenType)), T_XOR_ALT=((262)|(OperatorTokenType|AltExtTokenType)), T_XOR_TRIGRAPH=((262)|(OperatorTokenType|TriGraphTokenType)), T_XORASSIGN=((263)|(OperatorTokenType)), T_XORASSIGN_ALT=((263)|(OperatorTokenType|AltExtTokenType)), T_XORASSIGN_TRIGRAPH=((263)|(OperatorTokenType|TriGraphTokenType)), T_COMMA=((264)|(OperatorTokenType)), T_COLON=((265)|(OperatorTokenType)), T_DIVIDE=((266)|(OperatorTokenType)), T_DIVIDEASSIGN=((267)|(OperatorTokenType)), T_DOT=((268)|(OperatorTokenType)), T_DOTSTAR=((269)|(OperatorTokenType)), T_ELLIPSIS=((270)|(OperatorTokenType)), T_EQUAL=((271)|(OperatorTokenType)), T_GREATER=((272)|(OperatorTokenType)), T_GREATEREQUAL=((273)|(OperatorTokenType)), T_LEFTBRACE=((274)|(OperatorTokenType)), T_LEFTBRACE_ALT=((274)|(OperatorTokenType|AltTokenType)), T_LEFTBRACE_TRIGRAPH=((274)|(OperatorTokenType|TriGraphTokenType)), T_LESS=((275)|(OperatorTokenType)), T_LESSEQUAL=((276)|(OperatorTokenType)), T_LEFTPAREN=((277)|(OperatorTokenType)), T_LEFTBRACKET=((278)|(OperatorTokenType)), T_LEFTBRACKET_ALT=((278)|(OperatorTokenType|AltTokenType)), T_LEFTBRACKET_TRIGRAPH=((278)|(OperatorTokenType|TriGraphTokenType)), T_MINUS=((279)|(OperatorTokenType)), T_MINUSASSIGN=((280)|(OperatorTokenType)), T_MINUSMINUS=((281)|(OperatorTokenType)), T_PERCENT=((282)|(OperatorTokenType)), T_PERCENTASSIGN=((283)|(OperatorTokenType)), T_NOT=((284)|(OperatorTokenType)), T_NOT_ALT=((284)|(OperatorTokenType|AltExtTokenType)), T_NOTEQUAL=((285)|(OperatorTokenType)), T_NOTEQUAL_ALT=((285)|(OperatorTokenType|AltExtTokenType)), T_OROR=((286)|(OperatorTokenType)), T_OROR_ALT=((286)|(OperatorTokenType|AltExtTokenType)), T_OROR_TRIGRAPH=((286)|(OperatorTokenType|TriGraphTokenType)), T_PLUS=((287)|(OperatorTokenType)), T_PLUSASSIGN=((288)|(OperatorTokenType)), T_PLUSPLUS=((289)|(OperatorTokenType)), T_ARROW=((290)|(OperatorTokenType)), T_ARROWSTAR=((291)|(OperatorTokenType)), T_QUESTION_MARK=((292)|(OperatorTokenType)), T_RIGHTBRACE=((293)|(OperatorTokenType)), T_RIGHTBRACE_ALT=((293)|(OperatorTokenType|AltTokenType)), T_RIGHTBRACE_TRIGRAPH=((293)|(OperatorTokenType|TriGraphTokenType)), T_RIGHTPAREN=((294)|(OperatorTokenType)), T_RIGHTBRACKET=((295)|(OperatorTokenType)), T_RIGHTBRACKET_ALT=((295)|(OperatorTokenType|AltTokenType)), T_RIGHTBRACKET_TRIGRAPH=((295)|(OperatorTokenType|TriGraphTokenType)), T_COLON_COLON=((296)|(OperatorTokenType)), T_SEMICOLON=((297)|(OperatorTokenType)), T_SHIFTLEFT=((298)|(OperatorTokenType)), T_SHIFTLEFTASSIGN=((299)|(OperatorTokenType)), T_SHIFTRIGHT=((300)|(OperatorTokenType)), T_SHIFTRIGHTASSIGN=((301)|(OperatorTokenType)), T_STAR=((302)|(OperatorTokenType)), T_COMPL=((303)|(OperatorTokenType)), T_COMPL_ALT=((303)|(OperatorTokenType|AltExtTokenType)), T_COMPL_TRIGRAPH=((303)|(OperatorTokenType|TriGraphTokenType)), T_STARASSIGN=((304)|(OperatorTokenType)), T_ASM=((305)|(KeywordTokenType)), T_AUTO=((306)|(KeywordTokenType)), T_BOOL=((307)|(KeywordTokenType)), T_FALSE=((308)|(BoolLiteralTokenType)), T_TRUE=((309)|(BoolLiteralTokenType)), T_BREAK=((310)|(KeywordTokenType)), T_CASE=((311)|(KeywordTokenType)), T_CATCH=((312)|(KeywordTokenType)), T_CHAR=((313)|(KeywordTokenType)), T_CLASS=((314)|(KeywordTokenType)), T_CONST=((315)|(KeywordTokenType)), T_CONSTCAST=((316)|(KeywordTokenType)), T_CONTINUE=((317)|(KeywordTokenType)), T_DEFAULT=((318)|(KeywordTokenType)), T_DELETE=((319)|(KeywordTokenType)), T_DO=((320)|(KeywordTokenType)), T_DOUBLE=((321)|(KeywordTokenType)), T_DYNAMICCAST=((322)|(KeywordTokenType)), T_ELSE=((323)|(KeywordTokenType)), T_ENUM=((324)|(KeywordTokenType)), T_EXPLICIT=((325)|(KeywordTokenType)), T_EXPORT=((326)|(KeywordTokenType)), T_EXTERN=((327)|(KeywordTokenType)), T_FLOAT=((328)|(KeywordTokenType)), T_FOR=((329)|(KeywordTokenType)), T_FRIEND=((330)|(KeywordTokenType)), T_GOTO=((331)|(KeywordTokenType)), T_IF=((332)|(KeywordTokenType)), T_INLINE=((333)|(KeywordTokenType)), T_INT=((334)|(KeywordTokenType)), T_LONG=((335)|(KeywordTokenType)), T_MUTABLE=((336)|(KeywordTokenType)), T_NAMESPACE=((337)|(KeywordTokenType)), T_NEW=((338)|(KeywordTokenType)), T_OPERATOR=((339)|(KeywordTokenType)), T_PRIVATE=((340)|(KeywordTokenType)), T_PROTECTED=((341)|(KeywordTokenType)), T_PUBLIC=((342)|(KeywordTokenType)), T_REGISTER=((343)|(KeywordTokenType)), T_REINTERPRETCAST=((344)|(KeywordTokenType)), T_RETURN=((345)|(KeywordTokenType)), T_SHORT=((346)|(KeywordTokenType)), T_SIGNED=((347)|(KeywordTokenType)), T_SIZEOF=((348)|(KeywordTokenType)), T_STATIC=((349)|(KeywordTokenType)), T_STATICCAST=((350)|(KeywordTokenType)), T_STRUCT=((351)|(KeywordTokenType)), T_SWITCH=((352)|(KeywordTokenType)), T_TEMPLATE=((353)|(KeywordTokenType)), T_THIS=((354)|(KeywordTokenType)), T_THROW=((355)|(KeywordTokenType)), T_TRY=((356)|(KeywordTokenType)), T_TYPEDEF=((357)|(KeywordTokenType)), T_TYPEID=((358)|(KeywordTokenType)), T_TYPENAME=((359)|(KeywordTokenType)), T_UNION=((360)|(KeywordTokenType)), T_UNSIGNED=((361)|(KeywordTokenType)), T_USING=((362)|(KeywordTokenType)), T_VIRTUAL=((363)|(KeywordTokenType)), T_VOID=((364)|(KeywordTokenType)), T_VOLATILE=((365)|(KeywordTokenType)), T_WCHART=((366)|(KeywordTokenType)), T_WHILE=((367)|(KeywordTokenType)), T_PP_DEFINE=((368)|(PPTokenType)), T_PP_IF=((369)|(PPConditionalTokenType)), T_PP_IFDEF=((370)|(PPConditionalTokenType)), T_PP_IFNDEF=((371)|(PPConditionalTokenType)), T_PP_ELSE=((372)|(PPConditionalTokenType)), T_PP_ELIF=((373)|(PPConditionalTokenType)), T_PP_ENDIF=((374)|(PPConditionalTokenType)), T_PP_ERROR=((375)|(PPTokenType)), T_PP_LINE=((376)|(PPTokenType)), T_PP_PRAGMA=((377)|(PPTokenType)), T_PP_UNDEF=((378)|(PPTokenType)), T_PP_WARNING=((379)|(PPTokenType)), T_IDENTIFIER=((380)|(IdentifierTokenType)), T_OCTALINT=((381)|(IntegerLiteralTokenType)), T_DECIMALINT=((382)|(IntegerLiteralTokenType)), T_HEXAINT=((383)|(IntegerLiteralTokenType)), T_INTLIT=((384)|(IntegerLiteralTokenType)), T_LONGINTLIT=((385)|(IntegerLiteralTokenType)), T_FLOATLIT=((386)|(FloatingLiteralTokenType)), T_FIXEDPOINTLIT=((386)|(FloatingLiteralTokenType|AltTokenType)), T_CCOMMENT=((387)|(WhiteSpaceTokenType|AltTokenType)), T_CPPCOMMENT=((388)|(WhiteSpaceTokenType|AltTokenType)), T_CHARLIT=((389)|(CharacterLiteralTokenType)), T_STRINGLIT=((390)|(StringLiteralTokenType)), T_CONTLINE=((391)|(EOLTokenType)), T_SPACE=((392)|(WhiteSpaceTokenType)), T_SPACE2=((393)|(WhiteSpaceTokenType)), T_NEWLINE=((394)|(EOLTokenType)), T_GENERATEDNEWLINE=((394)|(EOLTokenType|AltTokenType)), T_POUND_POUND=((395)|(OperatorTokenType)), T_POUND_POUND_ALT=((395)|(OperatorTokenType|AltTokenType)), T_POUND_POUND_TRIGRAPH=((395)|(OperatorTokenType|TriGraphTokenType)), T_POUND=((396)|(OperatorTokenType)), T_POUND_ALT=((396)|(OperatorTokenType|AltTokenType)), T_POUND_TRIGRAPH=((396)|(OperatorTokenType|TriGraphTokenType)), T_ANY=((397)|(UnknownTokenType)), T_ANY_TRIGRAPH=((397)|(UnknownTokenType|TriGraphTokenType)), T_PP_INCLUDE=((398)|(PPTokenType)), T_PP_QHEADER=((399)|(PPTokenType)), T_PP_HHEADER=((400)|(PPTokenType)), T_PP_INCLUDE_NEXT=((398)|(PPTokenType|AltTokenType)), T_PP_QHEADER_NEXT=((399)|(PPTokenType|AltTokenType)), T_PP_HHEADER_NEXT=((400)|(PPTokenType|AltTokenType)), T_EOF=((401)|(EOFTokenType)), T_EOI=((402)|(EOFTokenType)), T_PP_NUMBER=((403)|(InternalTokenType)), T_MSEXT_INT8=((404)|(KeywordTokenType)), T_MSEXT_INT16=((405)|(KeywordTokenType)), T_MSEXT_INT32=((406)|(KeywordTokenType)), T_MSEXT_INT64=((407)|(KeywordTokenType)), T_MSEXT_BASED=((408)|(KeywordTokenType)), T_MSEXT_DECLSPEC=((409)|(KeywordTokenType)), T_MSEXT_CDECL=((410)|(KeywordTokenType)), T_MSEXT_FASTCALL=((411)|(KeywordTokenType)), T_MSEXT_STDCALL=((412)|(KeywordTokenType)), T_MSEXT_TRY=((413)|(KeywordTokenType)), T_MSEXT_EXCEPT=((414)|(KeywordTokenType)), T_MSEXT_FINALLY=((415)|(KeywordTokenType)), T_MSEXT_LEAVE=((416)|(KeywordTokenType)), T_MSEXT_INLINE=((417)|(KeywordTokenType)), T_MSEXT_ASM=((418)|(KeywordTokenType)), T_MSEXT_PP_REGION=((419)|(PPTokenType)), T_MSEXT_PP_ENDREGION=((420)|(PPTokenType)), T_IMPORT=((421)|(KeywordTokenType)), T_HAS_NOTHROW_CONSTRUCTOR=((422)|(KeywordTokenType)), T_HAS_NOTHROW_COPY=((423)|(KeywordTokenType)), T_HAS_TRIVIAL_ASSIGN=((424)|(KeywordTokenType)), T_HAS_TRIVIAL_CONSTRUCTOR=((425)|(KeywordTokenType)), T_HAS_TRIVIAL_COPY=((426)|(KeywordTokenType)), T_HAS_TRIVIAL_DESTRUCTOR=((427)|(KeywordTokenType)), T_HAS_VIRTUAL_DESTRUCTOR=((428)|(KeywordTokenType)), T_IS_ABSTRACT=((429)|(KeywordTokenType)), T_IS_BASE_OF=((430)|(KeywordTokenType)), T_IS_CLASS=((431)|(KeywordTokenType)), T_IS_CONVERTIBLE_TO=((432)|(KeywordTokenType)), T_IS_EMPTY=((433)|(KeywordTokenType)), T_IS_ENUM=((434)|(KeywordTokenType)), T_IS_POD=((435)|(KeywordTokenType)), T_IS_POLYMORPHIC=((436)|(KeywordTokenType)), T_IS_UNION=((437)|(KeywordTokenType)), T_IS_TRIVIAL=((438)|(KeywordTokenType)), T_IS_TRIVIALLY_CONSTRUCTIBLE=((439)|(KeywordTokenType)), T_IS_TRIVIALLY_ASSIGNABLE=((440)|(KeywordTokenType)), T_IS_TRIVIALLY_COPYABLE=((441)|(KeywordTokenType)), T_IS_STANDARD_LAYOUT=((442)|(KeywordTokenType)), T_IS_LITERAL_TYPE=((443)|(KeywordTokenType)), T_UNDERLYING_TYPE=((444)|(KeywordTokenType)), T_LAST_TOKEN_ID, T_LAST_TOKEN=((T_LAST_TOKEN_ID)&~TokenTypeMask), T_NONREPLACABLE_IDENTIFIER=((T_LAST_TOKEN+1)|(IdentifierTokenType)), T_PLACEHOLDER=((T_LAST_TOKEN+2)|(WhiteSpaceTokenType)), T_PLACEMARKER=((T_LAST_TOKEN+3)|(InternalTokenType)), T_PARAMETERBASE=((T_LAST_TOKEN+4)|(ParameterTokenType)), T_EXTPARAMETERBASE=((T_LAST_TOKEN+4)|(ExtParameterTokenType))
		};
		boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >get_token_name(token_id tokid);
		char const*get_token_value(token_id tokid);
	}
}
struct Name
{
	const char*value;
	Name(): value(0)
	{
	}
	explicit Name(const char*value): value(value)
	{
	}
	bool empty()const
	{
		return value==0;
	}
	const char*c_str()const
	{
		return value;
	}
	void clear()
	{
		value=0;
	}
};
inline bool operator==(const Name&left, const Name&right)
{
	return left.value==right.value;
}
inline bool operator!=(const Name&left, const Name&right)
{
	return left.value!=right.value;
}
inline bool operator<(const Name&left, const Name&right)
{
	return left.value<right.value;
}
typedef Name TokenValue;
const TokenValue TOKENVALUE_NULL;
typedef boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >Filename;
struct FilePosition
{
	Filename file;
	unsigned int line;
	unsigned int column;
};
inline bool operator==(const FilePosition&left, const FilePosition&right)
{
	return left.file==right.file&&left.line==right.line&&left.column==right.column;
}
struct IncludeEvents
{
	unsigned short push;
	unsigned short pop;
	IncludeEvents(): push(0), pop(0)
	{
	}
};
struct Path
{
	Name relative;
	Name absolute;
	Path()
	{
	}
	Path(Name relative, Name absolute): relative(relative), absolute(absolute)
	{
	}
	const char*c_str()const
	{
		return absolute.c_str();
	}
};
inline bool operator==(const Path&left, const Path&right)
{
	return left.absolute==right.absolute;
}
inline bool operator!=(const Path&left, const Path&right)
{
	return left.absolute!=right.absolute;
}
inline bool operator<(const Path&left, const Path&right)
{
	return left.absolute<right.absolute;
}
struct Source: Path
{
	unsigned int line;
	unsigned int column;
	Source()
	{
	}
	Source(Path path, unsigned int line, unsigned int column): Path(path), line(line), column(column)
	{
	}
};
inline bool operator==(const Source&left, const Source&right)
{
	return left.absolute==right.absolute&&left.line==right.line&&left.column==right.column;
}
inline bool operator!=(const Source&left, const Source&right)
{
	return !operator==(left, right);
}
typedef boost::wave::token_id LexTokenId;
inline bool isSeparated(LexTokenId id)
{
	return ((((id)&boost::wave::TokenTypeMask)==(boost::wave::KeywordTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(boost::wave::IdentifierTokenType))?true: false)||(((id)&boost::wave::TokenTypeMask)&boost::wave::LiteralTokenType)!=0||id==boost::wave::T_PP_NUMBER;
}
template<typename OutputStreamType>
struct TokenPrinter
{
	OutputStreamType&out;
	size_t line;
	size_t braceDepth;
	LexTokenId prev;
	LexTokenId prevprev;
	size_t templateDeclarationDepth;
	TokenPrinter(OutputStreamType&out): out(out), line(1), braceDepth(0), prev(boost::wave::T_UNKNOWN), prevprev(boost::wave::T_UNKNOWN), templateDeclarationDepth(0)
	{
	}
	void nextLine(LexTokenId id)
	{
		out<<std::endl;
		prev=boost::wave::T_NEWLINE;
		templateDeclarationDepth=id==boost::wave::T_TEMPLATE;
		++line;
	}
	void formatToken(LexTokenId id)
	{
		if((prev==boost::wave::T_SEMICOLON&&id!=boost::wave::T_RIGHTBRACE)||(prev==boost::wave::T_LEFTBRACE&&id!=boost::wave::T_RIGHTBRACE)||(prev==boost::wave::T_RIGHTBRACE&&id!=boost::wave::T_RIGHTBRACE&&id!=boost::wave::T_SEMICOLON)||(id==boost::wave::T_MSEXT_ASM))
		{
			nextLine(id);
		}
		if((prevprev==boost::wave::T_PUBLIC||prevprev==boost::wave::T_PRIVATE)&&prev==boost::wave::T_COLON)
		{
			nextLine(id);
		}
		if(templateDeclarationDepth!=0)
		{
			if(prev==boost::wave::T_LESS)
			{
				++templateDeclarationDepth;
			}
			else if(prev==boost::wave::T_GREATER)
			{
				--templateDeclarationDepth;
				if(templateDeclarationDepth==1)
				{
					nextLine(id);
				}
			}
		}
		if(id==boost::wave::T_LEFTBRACE)
		{
			nextLine(id);
			++braceDepth;
		}
		else if(id==boost::wave::T_RIGHTBRACE)
		{
			--braceDepth;
			nextLine(id);
		}
		if(prev==boost::wave::T_NEWLINE&&braceDepth!=0)
		{
			size_t i=0;
			if(id==boost::wave::T_LEFTBRACE||id==boost::wave::T_PUBLIC||id==boost::wave::T_PRIVATE)
			{
				++i;
			}
			for(;
			i!=braceDepth;
			++i)
			{
				out<<'\t';
			}
		}
		if((isSeparated(prev)&&isSeparated(id))||prev==boost::wave::T_COMMA||prev==boost::wave::T_COLON||prev==boost::wave::T_RETURN||prev==boost::wave::T_TYPEDEF||(prev==boost::wave::T_GREATER&&id==boost::wave::T_GREATER)||(prev==boost::wave::T_AND&&id==boost::wave::T_ASSIGN)||(prev==boost::wave::T_STAR&&id==boost::wave::T_ASSIGN)||(prev==boost::wave::T_LESS&&id==boost::wave::T_COLON_COLON))
		{
			out<<" ";
		}
		prevprev=prev;
		prev=id;
	}
	void printToken(LexTokenId id, const char*value)
	{
		formatToken(id);
		out<<value;
	}
};
namespace std
{
	extern istream*_Ptr_cin;
	extern ostream*_Ptr_cout;
	extern ostream*_Ptr_cerr;
	extern ostream*_Ptr_clog;
	class _Winit
	{
	public:
		_Winit();
		~_Winit();
	private:
		static int _Init_cnt;
	};
	extern wistream*_Ptr_wcin;
	extern wostream*_Ptr_wcout;
	extern wostream*_Ptr_wcerr;
	extern wostream*_Ptr_wclog;
	extern istream cin;
	extern ostream cout;
	extern ostream cerr;
	extern ostream clog;
	extern wistream wcin;
	extern wostream wcout;
	extern wostream wcerr;
	extern wostream wclog;
}
namespace std
{
	template<class _Elem>
	struct _Fillobj
	{
		_Fillobj(_Elem _Ch): _Fill(_Ch)
		{
		}
		_Elem _Fill;
	};
	template<class _Elem>
	inline _Fillobj<_Elem>setfill(_Elem _Ch)
	{
		return (_Fillobj<_Elem>(_Ch));
	}
	template<class _Elem, class _Traits>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, const _Fillobj<_Elem>&_Manip)
	{
		_Istr.fill(_Manip._Fill);
		return (_Istr);
	}
	template<class _Elem, class _Traits>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const _Fillobj<_Elem>&_Manip)
	{
		_Ostr.fill(_Manip._Fill);
		return (_Ostr);
	}
	template<class _Arg>
	struct _Smanip
	{
		_Smanip(void(*_Left)(ios_base&, _Arg), _Arg _Val): _Pfun(_Left), _Manarg(_Val)
		{
		}
		void(*_Pfun)(ios_base&, _Arg);
		_Arg _Manarg;
	};
	template<class _Elem, class _Traits, class _Arg>
	inline basic_istream<_Elem, _Traits>&operator>>(basic_istream<_Elem, _Traits>&_Istr, const _Smanip<_Arg>&_Manip)
	{
		(*_Manip._Pfun)(_Istr, _Manip._Manarg);
		return (_Istr);
	}
	template<class _Elem, class _Traits, class _Arg>
	inline basic_ostream<_Elem, _Traits>&operator<<(basic_ostream<_Elem, _Traits>&_Ostr, const _Smanip<_Arg>&_Manip)
	{
		(*_Manip._Pfun)(_Ostr, _Manip._Manarg);
		return (_Ostr);
	}
	_Smanip<ios_base::fmtflags>resetiosflags(ios_base::fmtflags);
	_Smanip<ios_base::fmtflags>setiosflags(ios_base::fmtflags);
	_Smanip<int>setbase(int);
	_Smanip<streamsize>setprecision(streamsize);
	_Smanip<streamsize>setw(streamsize);
}
typedef __int64 CPUTime;
CPUTime getCPUTimeElapsed();
struct ProfileEntry
{
	const char*name;
	CPUTime elapsed;
	CPUTime elapsedChild;
	ProfileEntry(const char*name): name(name), elapsed(0), elapsedChild(0)
	{
	}
};
struct Timer
{
	CPUTime time;
	void start()
	{
		time=getCPUTimeElapsed();
	}
	CPUTime elapsed()const
	{
		return getCPUTimeElapsed()-time;
	}
};
struct Profiler
{
	static struct ProfileScope*scope;
};
struct ProfileScope
{
	ProfileScope(ProfileEntry&entry)
	{
	}
};
inline void dumpProfile(ProfileEntry&entry)
{
	std::cout<<std::setw(12)<<std::left<<entry.name<<std::setw(0)<<" "<<std::right<<std::setw(20)<<(entry.elapsed-entry.elapsedChild)<<std::setw(0)<<"\n";
}
extern ProfileEntry gProfileIo;
extern ProfileEntry gProfileWave;
extern ProfileEntry gProfileLexer;
extern ProfileEntry gProfileParser;
extern ProfileEntry gProfileLookup;
extern ProfileEntry gProfileDiagnose;
extern ProfileEntry gProfileAllocator;
extern ProfileEntry gProfileIdentifier;
extern ProfileEntry gProfileTemplateId;
extern size_t gAllocatorFootprint;
template<class T>
class DebugAllocator: public std::allocator<T>
{
public:
	typedef std::allocator<T>Base;
	typedef typename Base::value_type value_type;
	typedef typename Base::pointer pointer;
	typedef typename Base::reference reference;
	typedef typename Base::const_pointer const_pointer;
	typedef typename Base::const_reference const_reference;
	typedef typename Base::size_type size_type;
	typedef typename Base::difference_type difference_type;
	template<class OtherT>
	struct rebind
	{
		typedef DebugAllocator<OtherT>other;
	};
	DebugAllocator()
	{
	}
	DebugAllocator(const DebugAllocator<T>&)
	{
	}
	template<class OtherT>
	DebugAllocator(const DebugAllocator<OtherT>&)
	{
	}
	template<class OtherT>
	DebugAllocator<T>&operator=(const DebugAllocator<OtherT>&)
	{
		return (*this);
	}
	void deallocate(pointer p, size_type count)
	{
		gAllocatorFootprint-=count*sizeof(T);
		return Base::deallocate(p, count);
	}
	pointer allocate(size_type count)
	{
		gAllocatorFootprint+=count*sizeof(T);
		return Base::allocate(count);
	}
	pointer allocate(size_type count, const void*hint)
	{
		gAllocatorFootprint+=count*sizeof(T);
		return Base::allocate(count, hint);
	}
};
template<class T, class OtherT>
inline bool operator==(const DebugAllocator<T>&, const DebugAllocator<OtherT>&)
{
	return (true);
}
template<class T, class OtherT>
inline bool operator!=(const DebugAllocator<T>&, const DebugAllocator<OtherT>&)
{
	return (false);
}
struct AllocatorError
{
	AllocatorError()
	{
		__debugbreak();
	}
};
struct IsAllocated
{
	bool operator()(char c)const
	{
		return c!=char(0xba);
	}
};
inline bool isAllocated(const char*first, const char*last)
{
	const char*p=std::find_if(first, last, IsAllocated());
	if(p!=last)
	{
		std::cout<<"allocation at: "<<static_cast<const void*>(p)<<": ";
		std::cout.write(p, 4);
		std::cout<<std::endl;
	}
	return p!=last;
}
struct IsDeallocated
{
	bool operator()(char c)const
	{
		return c==char(0xba);
	}
};
inline bool isDeallocated(const char*first, const char*last)
{
	const char*p=std::find_if(first, last, IsDeallocated());
	if(p!=last)
	{
		std::cout<<"deallocation at: "<<static_cast<const void*>(p)<<": ";
		std::cout.write(p, 4);
		std::cout<<std::endl;
	}
	return p!=last;
}
template<typename T>
inline bool isDeallocated(const T*p)
{
	return p!=0&&*reinterpret_cast<const size_t*>(p)==0xbabababa;
}
template<typename T>
inline void checkAllocated(const T*p)
{
	if(!(!isDeallocated(p)))
	{
		throw AllocatorError();
	};
}
template<typename T>
struct SafePtr
{
	typedef T Type;
	T*p;
	SafePtr()
	{
	}
	SafePtr(T*p): p(p)
	{
	}
	SafePtr(const SafePtr<T>&other): p(other.p)
	{
		checkAllocated(p);
	}
	SafePtr<T>&operator=(const SafePtr<T>&other)
	{
		p=other;
		checkAllocated(p);
		return *this;
	}
	SafePtr<T>&operator=(T*other)
	{
		p=other;
		checkAllocated(p);
		return *this;
	}
	T&operator*()const
	{
		checkAllocated(p);
		return *p;
	}
	T*operator->()const
	{
		checkAllocated(p);
		return p;
	}
	operator T*()const
	{
		checkAllocated(p);
		return p;
	}
};
template<typename T>
inline bool operator==(const SafePtr<T>&left, const SafePtr<T>&right)
{
	return left.p==right.p;
}
struct Page
{
	enum
	{
		SHIFT=17
	};
	enum
	{
		SIZE=1<<SHIFT
	};
	enum
	{
		MASK=SIZE-1
	};
	char buffer[SIZE];
	Page()
	{
		std::uninitialized_fill(buffer, buffer+SIZE, char(0xba));
	}
};
template<bool checked>
struct LinearAllocator
{
	typedef std::vector<Page*>Pages;
	Pages pages;
	size_t position;
	static void*debugAddress;
	static char debugValue[4];
	static size_t debugAllocationId;
	LinearAllocator(): position(0)
	{
	}
	~LinearAllocator()
	{
		ProfileScope profile(gProfileAllocator);
		for(Pages::iterator i=pages.begin();
		i!=pages.end();
		++i)
		{
			Page*p=*i;
			delete p;
		}
	}
	Page*getPage(size_t index)
	{
		if(index==pages.size())
		{
			ProfileScope profile(gProfileAllocator);
			pages.push_back(new Page);
		}
		return pages[index];
	}
	void*allocate(size_t size)
	{
		if(position==debugAllocationId)
		{
			std::cout<<"debug allocation!"<<std::endl;
		}
		size_t available=sizeof(Page)-(position&Page::MASK);
		if(size>available)
		{
			position+=available;
		}
		Page*page=getPage(position>>Page::SHIFT);
		void*p=page->buffer+(position&Page::MASK);
		if(!(!checked||!isAllocated(reinterpret_cast<char*>(p), reinterpret_cast<char*>(p)+size)))
		{
			throw AllocatorError();
		};
		std::uninitialized_fill(reinterpret_cast<char*>(p), reinterpret_cast<char*>(p)+size, char(0xcd));
		position+=size;
		return p;
	}
	void deallocate(void*p, size_t size)
	{
		std::uninitialized_fill(reinterpret_cast<char*>(p), reinterpret_cast<char*>(p)+size, char(0xba));
	}
	void backtrack(size_t original)
	{
		if(!(original<=position))
		{
			throw AllocatorError();
		};
		Pages::iterator first=pages.begin()+original/sizeof(Page);
		Pages::iterator last=pages.begin()+position/sizeof(Page);
		for(Pages::iterator i=first;
		i!=pages.end();
		++i)
		{
			if(!(!checked||!isAllocated((*i)->buffer+(i==first?original%sizeof(Page): 0), (*i)->buffer+(i==last?position%sizeof(Page): sizeof(Page)))))
			{
				throw AllocatorError();
			};
			if(i==last)
			{
				break;
			}
		}
		position=original;
	}
};
template<bool checked>
void*LinearAllocator<checked>::debugAddress;
template<bool checked>
char LinearAllocator<checked>::debugValue[4];
template<bool checked>
size_t LinearAllocator<checked>::debugAllocationId=0xffffffff;
typedef LinearAllocator<true>CheckedLinearAllocator;
inline CheckedLinearAllocator&NullAllocator()
{
	static CheckedLinearAllocator null;
	return null;
}
template<typename T, typename Instance=CheckedLinearAllocator>
class LinearAllocatorWrapper
{
public:
	Instance&instance;
	typedef T value_type;
	typedef T*pointer;
	typedef T&reference;
	typedef const T*const_pointer;
	typedef const T&const_reference;
	typedef std::size_t size_type;
	typedef std::ptrdiff_t difference_type;
	template<typename OtherT>
	struct rebind
	{
		typedef LinearAllocatorWrapper<OtherT, Instance>other;
	};
	LinearAllocatorWrapper(): instance(NullAllocator())
	{
		throw AllocatorError();
	}
	LinearAllocatorWrapper(Instance&instance): instance(instance)
	{
	}
	LinearAllocatorWrapper(const LinearAllocatorWrapper<T, Instance>&other): instance(other.instance)
	{
	}
	template<typename OtherT>
	LinearAllocatorWrapper(const LinearAllocatorWrapper<OtherT, Instance>&other): instance(other.instance)
	{
	}
	template<typename OtherT>
	LinearAllocatorWrapper<T>&operator=(const LinearAllocatorWrapper<OtherT, Instance>&other)
	{
		if(this!=&other)
		{
			this->~LinearAllocatorWrapper();
			new(this)LinearAllocatorWrapper(other);
		}
		return (*this);
	}
	void deallocate(pointer p, size_type count)
	{
		instance.deallocate(p, count*sizeof(T)+sizeof(size_t));
	}
	pointer allocate(size_type count)
	{
		pointer p=pointer(instance.allocate(count*sizeof(T)+sizeof(size_t)));
		return p;
	}
	pointer allocate(size_type count, const void*hint)
	{
		return allocate(count);
	}
	void construct(pointer p, const T&value)
	{
		new(p)T(value);
	}
	void destroy(pointer p)
	{
		p->~T();
	}
	size_type max_size()const
	{
		size_type _Count=size_type(-1)/sizeof(T);
		return (0<_Count?_Count: 1);
	}
};
template<typename T, typename Instance, typename OtherT>
inline bool operator==(const LinearAllocatorWrapper<T, Instance>&, const LinearAllocatorWrapper<OtherT, Instance>&)
{
	return true;
}
template<typename T, typename Instance, typename OtherT>
inline bool operator!=(const LinearAllocatorWrapper<T, Instance>&, const LinearAllocatorWrapper<OtherT, Instance>&)
{
	return false;
}
template<typename T>
inline void checkAllocation(LinearAllocatorWrapper<T>&a, T*p)
{
	if(CheckedLinearAllocator::debugAddress==p)
	{
		std::cout<<"debug allocation!"<<std::endl;
	}
	if(CheckedLinearAllocator::debugAddress>=p&&CheckedLinearAllocator::debugAddress<p+1)
	{
		if(memcmp(CheckedLinearAllocator::debugAddress, CheckedLinearAllocator::debugValue, 1)==0)
		{
			std::cout<<"debug allocation!"<<std::endl;
		}
	}
}
template<typename A, typename T>
inline void checkAllocation(A&a, T*p)
{
}
template<typename T, typename A>
inline T*allocatorNew(const A&a, const T&value)
{
	typename A::template rebind<T>::other tmp(a);
	T*p=tmp.allocate(1);
	tmp.construct(p, value);
	checkAllocation(tmp, p);
	return p;
}
template<typename T, typename A>
void allocatorDelete(const A&a, T*p)
{
	if(p!=0)
	{
		typename A::template rebind<T>::other tmp(a);
		tmp.destroy(p);
		tmp.deallocate(p, 1);
	}
}
template<typename T>
struct TypeTraits
{
	typedef T Value;
};
template<typename T>
struct TypeTraits<const T>
{
	typedef T Value;
};
struct TrueSized
{
	char m[1];
};
struct FalseSized
{
	char m[2];
};
template<typename T, typename Base>
struct IsConvertible
{
	static TrueSized test(Base*);
	static FalseSized test(...);
	static const bool RESULT=sizeof(IsConvertible<T, Base>::test(static_cast<T*>(0)))==sizeof(TrueSized);
};
template<bool b>
struct CompileTimeAssert;
template<>
struct CompileTimeAssert<true>
{
};
template<typename T>
struct ReferenceCounted: T
{
	size_t count;
	ReferenceCounted(): count(0)
	{
	}
	ReferenceCounted(const T&value): T(value), count(0)
	{
	}
	~ReferenceCounted()
	{
		if(!(count==0))
		{
			throw AllocatorError();
		};
	}
};
template<typename T>
inline ReferenceCounted<T>makeReferenceCounted(const T&t)
{
	return ReferenceCounted<T>(t);
}
template<typename T>
struct Reference
{
	typedef typename TypeTraits<T>::Value value_type;
	typedef ReferenceCounted<value_type>Value;
	void decrement()
	{
		if(p!=0)
		{
			--p->count;
		}
	}
	void increment()
	{
		if(p!=0)
		{
			++p->count;
		}
	}
	Value*p;
	Reference(): p(0)
	{
	}
	Reference(Value*p): p(p)
	{
		increment();
	}
	~Reference()
	{
		decrement();
	}
	Reference(const Reference&other): p(other.p)
	{
		increment();
	}
	Reference&operator=(Reference tmp)
	{
		tmp.swap(*this);
		return *this;
	}
	bool empty()const
	{
		return p==0;
	}
	void swap(Reference&other)
	{
		std::swap(p, other.p);
	}
	T&operator*()const
	{
		return *p;
	}
	T*operator->()const
	{
		return p;
	}
	T*get()const
	{
		return p;
	}
};
template<typename T, typename Other>
inline bool operator==(const Reference<T>&l, const Reference<Other>&r)
{
	return l.p==r.p;
}
template<typename T, typename Other>
inline bool operator!=(const Reference<T>&l, const Reference<Other>&r)
{
	return !(l==r);
}
typedef boost::wave::token_id LexTokenId;
struct LexContext;
struct LexIterator;
struct LexToken;
struct LexError
{
	LexError()
	{
	}
};
LexContext&createContext(std::ifstream&instring, const char*input);
bool add_include_path(LexContext&context, const char*path);
bool add_sysinclude_path(LexContext&context, const char*path);
bool add_macro_definition(LexContext&context, const char*macroname, bool is_predefined);
void release(LexContext&context);
LexIterator&createBegin(LexContext&lexer);
LexIterator&createEnd(LexContext&lexer);
LexIterator&cloneIterator(LexIterator&i);
void assignIterator(LexIterator&i, LexIterator&other);
void release(LexIterator&i);
bool operator==(const LexIterator&l, const LexIterator&r);
inline bool operator!=(const LexIterator&l, const LexIterator&r)
{
	return !(l==r);
}
void increment(LexIterator&i);
const LexToken&dereference(const LexIterator&i);
namespace std
{
	template<class _Traits>
	class _Tree_nod: public _Traits
	{
		protected: struct _Node;
		friend struct _Node;
		typedef typename _Traits::allocator_type allocator_type;
		typedef typename _Traits::key_compare key_compare;
		typedef typename _Traits::value_type value_type;
		typedef typename allocator_type::template rebind<_Node>::other::pointer _Genptr;
		struct _Node
		{
			_Node(_Genptr _Larg, _Genptr _Parg, _Genptr _Rarg, const value_type&_Val, char _Carg): _Left(_Larg), _Parent(_Parg), _Right(_Rarg), _Myval(_Val), _Color(_Carg), _Isnil(false)
			{
			}
			_Genptr _Left;
			_Genptr _Parent;
			_Genptr _Right;
			value_type _Myval;
			char _Color;
			char _Isnil;
		};
		_Tree_nod(const key_compare&_Parg, allocator_type _Al): _Traits(_Parg), _Alnod(_Al)
		{
		}
		typename allocator_type::template rebind<_Node>::other _Alnod;
	};
	template<class _Traits>
	class _Tree_ptr: public _Tree_nod<_Traits>
	{
	public:
		typedef typename _Tree_nod<_Traits>::_Node _Node;
		typedef typename _Traits::allocator_type allocator_type;
		typedef typename _Traits::key_compare key_compare;
		typedef typename allocator_type::template rebind<_Node>::other::pointer _Nodeptr;
		_Tree_ptr(const key_compare&_Parg, allocator_type _Al): _Tree_nod<_Traits>(_Parg, _Al), _Alptr(_Al)
		{
		}
		typename allocator_type::template rebind<_Nodeptr>::other _Alptr;
	};
	template<class _Traits>
	class _Tree_val: public _Tree_ptr<_Traits>
	{
		protected: typedef typename _Traits::allocator_type allocator_type;
		typedef typename _Traits::key_compare key_compare;
		_Tree_val(const key_compare&_Parg, allocator_type _Al): _Tree_ptr<_Traits>(_Parg, _Al), _Alval(_Al)
		{
		}
		allocator_type _Alval;
	};
	template<class _Traits>
	class _Tree: public _Tree_val<_Traits>
	{
	public:
		typedef _Tree<_Traits>_Myt;
		typedef _Tree_val<_Traits>_Mybase;
		typedef typename _Traits::key_type key_type;
		typedef typename _Traits::key_compare key_compare;
		typedef typename _Traits::value_compare value_compare;
		typedef typename _Traits::value_type value_type;
		typedef typename _Traits::allocator_type allocator_type;
		typedef typename _Traits::_ITptr _ITptr;
		typedef typename _Traits::_IReft _IReft;
		protected: typedef typename _Tree_nod<_Traits>::_Genptr _Genptr;
		typedef typename _Tree_nod<_Traits>::_Node _Node;
		enum _Redbl
		{
			_Red, _Black
		};
		typedef typename allocator_type::template rebind<_Node>::other::pointer _Nodeptr;
		typedef typename allocator_type::template rebind<_Nodeptr>::other::reference _Nodepref;
		typedef typename allocator_type::template rebind<key_type>::other::const_reference _Keyref;
		typedef typename allocator_type::template rebind<char>::other::reference _Charref;
		typedef typename allocator_type::template rebind<value_type>::other::reference _Vref;
		static _Charref _Color(_Nodeptr _Pnode)
		{
			return ((_Charref)(*_Pnode)._Color);
		}
		static _Charref _Isnil(_Nodeptr _Pnode)
		{
			return ((_Charref)(*_Pnode)._Isnil);
		}
		static _Keyref _Key(_Nodeptr _Pnode)
		{
			return (_Mybase::_Kfn(_Myval(_Pnode)));
		}
		static _Nodepref _Left(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Left);
		}
		static _Nodepref _Parent(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Parent);
		}
		static _Nodepref _Right(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Right);
		}
		static _Vref _Myval(_Nodeptr _Pnode)
		{
			return ((_Vref)(*_Pnode)._Myval);
		}
	public:
		typedef typename allocator_type::size_type size_type;
		typedef typename allocator_type::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename allocator_type::template rebind<value_type>::other::pointer _Tptr;
		typedef typename allocator_type::template rebind<value_type>::other::const_pointer _Ctptr;
		typedef typename allocator_type::template rebind<value_type>::other::reference _Reft;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef _Reft reference;
		typedef typename allocator_type::template rebind<value_type>::other::const_reference const_reference;
		class const_iterator;
		friend class const_iterator;
		class const_iterator: public _Bidit<value_type, _Dift, _Ctptr, const_reference>
		{
		public:
			friend class _Tree<_Traits>;
			typedef bidirectional_iterator_tag iterator_category;
			typedef _Dift difference_type;
			typedef _Ctptr pointer;
			typedef const_reference reference;
			typedef _Range_checked_iterator_tag _Checked_iterator_category;
			const_iterator(): _Ptr(0)
			{
			}
			const_iterator(_Nodeptr _Pnode, const _Myt*_Plist=0): _Ptr(_Pnode)
			{
				this->_Adopt(_Plist);
			}
			const_reference operator*()const
			{
				if(this->_Mycont==0||_Ptr==((_Myt*)this->_Mycont)->_Myhead)
				{
					_Debug_message(L"map/set iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 245);

					{
						(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 246, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 246, 0);
					};
				}
				return (_Myval(_Ptr));
			}
			_Ctptr operator->()const
			{
				return (&**this);
			}
			const_iterator&operator++()
			{
				_Inc();
				return (*this);
			}
			const_iterator operator++(int)
			{
				const_iterator _Tmp=*this;
				++*this;
				return (_Tmp);
			}
			const_iterator&operator--()
			{
				_Dec();
				return (*this);
			}
			const_iterator operator--(int)
			{
				const_iterator _Tmp=*this;
				--*this;
				return (_Tmp);
			}
			bool operator==(const const_iterator&_Right)const
			{
				if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
				{
					_Debug_message(L"map/set iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 293);

					{
						(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 294, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 294, 0);
					};
				}
				return (_Ptr==_Right._Ptr);
			}
			bool operator!=(const const_iterator&_Right)const
			{
				return (!(*this==_Right));
			}
			void _Dec()
			{
				if(this->_Mycont==0)
				{
					_Debug_message(L"map/set iterator not decrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 314);

					{
						(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 315, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 315, 0);
					};
				}
				if(_Isnil(_Ptr))
				{
					_Ptr=_Right(_Ptr);
					if(_Isnil(_Ptr))
					{
						_Debug_message(L"map/set iterator not decrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 327);

						{
							(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 328, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 328, 0);
						};
					}
				}
				else if(!_Isnil(_Left(_Ptr)))_Ptr=_Max(_Left(_Ptr));
				else
				{
					_Nodeptr _Pnode;
					while(!_Isnil(_Pnode=_Parent(_Ptr))&&_Ptr==_Left(_Pnode))_Ptr=_Pnode;
					if(_Isnil(_Ptr))
					{
						_Debug_message(L"map/set iterator not decrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 349);

						{
							(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 350, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 350, 0);
						};
					}
					else _Ptr=_Pnode;
				}
			}
			void _Inc()
			{
				if(this->_Mycont==0||_Isnil(_Ptr))
				{
					_Debug_message(L"map/set iterator not incrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 370);

					{
						(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 371, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 371, 0);
					};
				}
				else if(!_Isnil(_Right(_Ptr)))_Ptr=_Min(_Right(_Ptr));
				else
				{
					_Nodeptr _Pnode;
					while(!_Isnil(_Pnode=_Parent(_Ptr))&&_Ptr==_Right(_Pnode))_Ptr=_Pnode;
					_Ptr=_Pnode;
				}
			}
			_Nodeptr _Mynode()const
			{
				return (_Ptr);
			}
		public:
			_Nodeptr _Ptr;
		};
		class iterator;
		friend class iterator;
		class iterator: public const_iterator
		{
		public:
			typedef bidirectional_iterator_tag iterator_category;
			typedef _Dift difference_type;
			typedef _ITptr pointer;
			typedef _IReft reference;
			iterator()
			{
			}
			iterator(_Nodeptr _Pnode, const _Myt*_Plist=0): const_iterator(_Pnode, _Plist)
			{
			}
			reference operator*()const
			{
				return ((reference)**(const_iterator*)this);
			}
			pointer operator->()const
			{
				return (&**this);
			}
			iterator&operator++()
			{
				++(*(const_iterator*)this);
				return (*this);
			}
			iterator operator++(int)
			{
				iterator _Tmp=*this;
				++*this;
				return (_Tmp);
			}
			iterator&operator--()
			{
				--(*(const_iterator*)this);
				return (*this);
			}
			iterator operator--(int)
			{
				iterator _Tmp=*this;
				--*this;
				return (_Tmp);
			}
		};
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		typedef pair<iterator, bool>_Pairib;
		typedef pair<iterator, iterator>_Pairii;
		typedef pair<const_iterator, const_iterator>_Paircc;
		explicit _Tree(const key_compare&_Parg, const allocator_type&_Al): _Mybase(_Parg, _Al)
		{
			_Init();
		}
		_Tree(const value_type*_First, const value_type*_Last, const key_compare&_Parg, const allocator_type&_Al): _Mybase(_Parg, _Al)
		{
			_Init();
			try
			{
				insert(_First, _Last);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		_Tree(const _Myt&_Right): _Mybase(_Right.key_comp(), _Right.get_allocator())
		{
			_Init();
			try
			{
				_Copy(_Right);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		~_Tree()
		{
			_Tidy();
		}
		_Myt&operator=(const _Myt&_Right)
		{
			if(this!=&_Right)
			{
				erase(begin(), end());
				this->comp=_Right.comp;
				_Copy(_Right);
			}
			return (*this);
		}
		iterator begin()
		{
			return (iterator(_Lmost(), this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Lmost(), this));
		}
		iterator end()
		{
			return (iterator(_Myhead, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Myhead, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			return (this->_Alval.max_size());
		}
		bool empty()const
		{
			return (size()==0);
		}
		allocator_type get_allocator()const
		{
			return (this->_Alval);
		}
		key_compare key_comp()const
		{
			return (this->comp);
		}
		value_compare value_comp()const
		{
			return (value_compare(key_comp()));
		}
		_Pairib insert(const value_type&_Val)
		{
			_Nodeptr _Trynode=_Root();
			_Nodeptr _Wherenode=_Myhead;
			bool _Addleft=true;
			while(!_Isnil(_Trynode))
			{
				_Wherenode=_Trynode;
				_Addleft=_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Trynode), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 618);
				_Trynode=_Addleft?_Left(_Trynode): _Right(_Trynode);
			}
			if(this->_Multi)return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
			else
			{
				iterator _Where=iterator(_Wherenode, this);
				if(!_Addleft);
				else if(_Where==begin())return (_Pairib(_Insert(true, _Wherenode, _Val), true));
				else--_Where;
				if(_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 635))return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
				else return (_Pairib(_Where, false));
			}
		}
		iterator insert(iterator _Where, const value_type&_Val)
		{
			if(_Where._Mycont!=this)_Debug_message(L"map/set insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 649);
			iterator _Next;
			if(size()==0)return (_Insert(true, _Myhead, _Val));
			else if(this->_Multi)
			{
				if(_Where==begin())
				{
					if(!_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 660))return (_Insert(true, _Where._Mynode(), _Val));
				}
				else if(_Where==end())
				{
					if(!_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Rmost()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 666))return (_Insert(false, _Rmost(), _Val));
				}
				else if(!_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 670)&&!_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key((--(_Next=_Where))._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 672))
				{
					if(_Isnil(_Right(_Next._Mynode())))return (_Insert(false, _Next._Mynode(), _Val));
					else return (_Insert(true, _Where._Mynode(), _Val));
				}
				else if(!_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 680)&&(++(_Next=_Where)==end()||!_Debug_lt_pred(this->comp, _Key(_Next._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 683)))
				{
					if(_Isnil(_Right(_Where._Mynode())))return (_Insert(false, _Where._Mynode(), _Val));
					else return (_Insert(true, _Next._Mynode(), _Val));
				}
			}
			else
			{
				if(_Where==begin())
				{
					if(_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 696))return (_Insert(true, _Where._Mynode(), _Val));
				}
				else if(_Where==end())
				{
					if(_Debug_lt_pred(this->comp, _Key(_Rmost()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 702))return (_Insert(false, _Rmost(), _Val));
				}
				else if(_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 706)&&_Debug_lt_pred(this->comp, _Key((--(_Next=_Where))._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 708))
				{
					if(_Isnil(_Right(_Next._Mynode())))return (_Insert(false, _Next._Mynode(), _Val));
					else return (_Insert(true, _Where._Mynode(), _Val));
				}
				else if(_Debug_lt_pred(this->comp, _Key(_Where._Mynode()), this->_Kfn(_Val), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 716)&&(++(_Next=_Where)==end()||_Debug_lt_pred(this->comp, this->_Kfn(_Val), _Key(_Next._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 719)))
				{
					if(_Isnil(_Right(_Where._Mynode())))return (_Insert(false, _Where._Mynode(), _Val));
					else return (_Insert(true, _Next._Mynode(), _Val));
				}
			}
			return (insert(_Val).first);
		}
		template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 737);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"map/set insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 739);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
		iterator erase(iterator _Where)
		{
			if(_Where._Mycont!=this||_Isnil(_Where._Mynode()))_Debug_message(L"map/set erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 751);
			_Nodeptr _Erasednode=_Where._Mynode();
			++_Where;
			_Orphan_ptr(*this, _Erasednode);
			_Nodeptr _Fixnode;
			_Nodeptr _Fixnodeparent;
			_Nodeptr _Pnode=_Erasednode;
			if(_Isnil(_Left(_Pnode)))_Fixnode=_Right(_Pnode);
			else if(_Isnil(_Right(_Pnode)))_Fixnode=_Left(_Pnode);
			else
			{
				_Pnode=_Where._Mynode();
				_Fixnode=_Right(_Pnode);
			}
			if(_Pnode==_Erasednode)
			{
				_Fixnodeparent=_Parent(_Erasednode);
				if(!_Isnil(_Fixnode))_Parent(_Fixnode)=_Fixnodeparent;
				if(_Root()==_Erasednode)_Root()=_Fixnode;
				else if(_Left(_Fixnodeparent)==_Erasednode)_Left(_Fixnodeparent)=_Fixnode;
				else _Right(_Fixnodeparent)=_Fixnode;
				if(_Lmost()==_Erasednode)_Lmost()=_Isnil(_Fixnode)?_Fixnodeparent: _Min(_Fixnode);
				if(_Rmost()==_Erasednode)_Rmost()=_Isnil(_Fixnode)?_Fixnodeparent: _Max(_Fixnode);
			}
			else
			{
				_Parent(_Left(_Erasednode))=_Pnode;
				_Left(_Pnode)=_Left(_Erasednode);
				if(_Pnode==_Right(_Erasednode))_Fixnodeparent=_Pnode;
				else
				{
					_Fixnodeparent=_Parent(_Pnode);
					if(!_Isnil(_Fixnode))_Parent(_Fixnode)=_Fixnodeparent;
					_Left(_Fixnodeparent)=_Fixnode;
					_Right(_Pnode)=_Right(_Erasednode);
					_Parent(_Right(_Erasednode))=_Pnode;
				}
				if(_Root()==_Erasednode)_Root()=_Pnode;
				else if(_Left(_Parent(_Erasednode))==_Erasednode)_Left(_Parent(_Erasednode))=_Pnode;
				else _Right(_Parent(_Erasednode))=_Pnode;
				_Parent(_Pnode)=_Parent(_Erasednode);
				std::swap(_Color(_Pnode), _Color(_Erasednode));
			}
			if(_Color(_Erasednode)==_Black)
			{
				for(;
				_Fixnode!=_Root()&&_Color(_Fixnode)==_Black;
				_Fixnodeparent=_Parent(_Fixnode))if(_Fixnode==_Left(_Fixnodeparent))
				{
					_Pnode=_Right(_Fixnodeparent);
					if(_Color(_Pnode)==_Red)
					{
						_Color(_Pnode)=_Black;
						_Color(_Fixnodeparent)=_Red;
						_Lrotate(_Fixnodeparent);
						_Pnode=_Right(_Fixnodeparent);
					}
					if(_Isnil(_Pnode))_Fixnode=_Fixnodeparent;
					else if(_Color(_Left(_Pnode))==_Black&&_Color(_Right(_Pnode))==_Black)
					{
						_Color(_Pnode)=_Red;
						_Fixnode=_Fixnodeparent;
					}
					else
					{
						if(_Color(_Right(_Pnode))==_Black)
						{
							_Color(_Left(_Pnode))=_Black;
							_Color(_Pnode)=_Red;
							_Rrotate(_Pnode);
							_Pnode=_Right(_Fixnodeparent);
						}
						_Color(_Pnode)=_Color(_Fixnodeparent);
						_Color(_Fixnodeparent)=_Black;
						_Color(_Right(_Pnode))=_Black;
						_Lrotate(_Fixnodeparent);
						break;
					}
				}
				else
				{
					_Pnode=_Left(_Fixnodeparent);
					if(_Color(_Pnode)==_Red)
					{
						_Color(_Pnode)=_Black;
						_Color(_Fixnodeparent)=_Red;
						_Rrotate(_Fixnodeparent);
						_Pnode=_Left(_Fixnodeparent);
					}
					if(_Isnil(_Pnode))_Fixnode=_Fixnodeparent;
					else if(_Color(_Right(_Pnode))==_Black&&_Color(_Left(_Pnode))==_Black)
					{
						_Color(_Pnode)=_Red;
						_Fixnode=_Fixnodeparent;
					}
					else
					{
						if(_Color(_Left(_Pnode))==_Black)
						{
							_Color(_Right(_Pnode))=_Black;
							_Color(_Pnode)=_Red;
							_Lrotate(_Pnode);
							_Pnode=_Left(_Fixnodeparent);
						}
						_Color(_Pnode)=_Color(_Fixnodeparent);
						_Color(_Fixnodeparent)=_Black;
						_Color(_Left(_Pnode))=_Black;
						_Rrotate(_Fixnodeparent);
						break;
					}
				}
				_Color(_Fixnode)=_Black;
			}
			this->_Alnod.destroy(_Erasednode);
			this->_Alnod.deallocate(_Erasednode, 1);
			if(0<_Mysize)--_Mysize;
			return (_Where);
		}
		iterator erase(iterator _First, iterator _Last)
		{
			if(_First==begin()&&_Last==end())
			{
				clear();
				return (begin());
			}
			else
			{
				while(_First!=_Last)erase(_First++);
				return (_First);
			}
		}
		size_type erase(const key_type&_Keyval)
		{
			_Pairii _Where=equal_range(_Keyval);
			size_type _Num=0;
			_Distance(_Where.first, _Where.second, _Num);
			erase(_Where.first, _Where.second);
			return (_Num);
		}
		void erase(const key_type*_First, const key_type*_Last)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 942);
			while(_First!=_Last)erase(*_First++);
		}
		void clear()
		{
			this->_Orphan_ptr(*this, 0);
			_Erase(_Root());
			_Root()=_Myhead, _Mysize=0;
			_Lmost()=_Myhead, _Rmost()=_Myhead;
		}
		iterator find(const key_type&_Keyval)
		{
			iterator _Where=lower_bound(_Keyval);
			return (_Where==end()||_Debug_lt_pred(this->comp, _Keyval, _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 963)?end(): _Where);
		}
		const_iterator find(const key_type&_Keyval)const
		{
			const_iterator _Where=lower_bound(_Keyval);
			return (_Where==end()||_Debug_lt_pred(this->comp, _Keyval, _Key(_Where._Mynode()), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 972)?end(): _Where);
		}
		size_type count(const key_type&_Keyval)const
		{
			_Paircc _Ans=equal_range(_Keyval);
			size_type _Num=0;
			_Distance(_Ans.first, _Ans.second, _Num);
			return (_Num);
		}
		iterator lower_bound(const key_type&_Keyval)
		{
			return (iterator(_Lbound(_Keyval), this));
		}
		const_iterator lower_bound(const key_type&_Keyval)const
		{
			return (const_iterator(_Lbound(_Keyval), this));
		}
		iterator upper_bound(const key_type&_Keyval)
		{
			return (iterator(_Ubound(_Keyval), this));
		}
		const_iterator upper_bound(const key_type&_Keyval)const
		{
			return (const_iterator(_Ubound(_Keyval), this));
		}
		_Pairii equal_range(const key_type&_Keyval)
		{
			return (_Pairii(lower_bound(_Keyval), upper_bound(_Keyval)));
		}
		_Paircc equal_range(const key_type&_Keyval)const
		{
			return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));
		}
		void swap(_Myt&_Right)
		{
			if(get_allocator()==_Right.get_allocator())
			{
				this->_Swap_all(_Right);
				std::swap(this->comp, _Right.comp);
				std::swap(_Myhead, _Right._Myhead);
				std::swap(_Mysize, _Right._Mysize);
			}
			else
			{
				_Myt _Tmp=*this;
				*this=_Right, _Right=_Tmp;
			}
		}
		protected: void _Copy(const _Myt&_Right)
		{
			_Root()=_Copy(_Right._Root(), _Myhead);
			_Mysize=_Right.size();
			if(!_Isnil(_Root()))
			{
				_Lmost()=_Min(_Root());
				_Rmost()=_Max(_Root());
			}
			else _Lmost()=_Myhead, _Rmost()=_Myhead;
		}
		_Nodeptr _Copy(_Nodeptr _Rootnode, _Nodeptr _Wherenode)
		{
			_Nodeptr _Newroot=_Myhead;
			if(!_Isnil(_Rootnode))
			{
				_Nodeptr _Pnode=_Buynode(_Myhead, _Wherenode, _Myhead, _Myval(_Rootnode), _Color(_Rootnode));
				if(_Isnil(_Newroot))_Newroot=_Pnode;
				try
				{
					_Left(_Pnode)=_Copy(_Left(_Rootnode), _Pnode);
					_Right(_Pnode)=_Copy(_Right(_Rootnode), _Pnode);
				}
				catch(...)
				{
					_Erase(_Newroot);
					throw;
				}
			}
			return (_Newroot);
		}
		void _Erase(_Nodeptr _Rootnode)
		{
			for(_Nodeptr _Pnode=_Rootnode;
			!_Isnil(_Pnode);
			_Rootnode=_Pnode)
			{
				_Erase(_Right(_Pnode));
				_Pnode=_Left(_Pnode);
				this->_Alnod.destroy(_Rootnode);
				this->_Alnod.deallocate(_Rootnode, 1);
			}
		}
		void _Init()
		{
			_Myhead=_Buynode();
			_Isnil(_Myhead)=true;
			_Root()=_Myhead;
			_Lmost()=_Myhead, _Rmost()=_Myhead;
			_Mysize=0;
		}
		iterator _Insert(bool _Addleft, _Nodeptr _Wherenode, const value_type&_Val)
		{
			if(max_size()-1<=_Mysize)throw length_error("map/set<T> too long");
			_Nodeptr _Newnode=_Buynode(_Myhead, _Wherenode, _Myhead, _Val, _Red);
			++_Mysize;
			if(_Wherenode==_Myhead)
			{
				_Root()=_Newnode;
				_Lmost()=_Newnode, _Rmost()=_Newnode;
			}
			else if(_Addleft)
			{
				_Left(_Wherenode)=_Newnode;
				if(_Wherenode==_Lmost())_Lmost()=_Newnode;
			}
			else
			{
				_Right(_Wherenode)=_Newnode;
				if(_Wherenode==_Rmost())_Rmost()=_Newnode;
			}
			for(_Nodeptr _Pnode=_Newnode;
			_Color(_Parent(_Pnode))==_Red;
			)if(_Parent(_Pnode)==_Left(_Parent(_Parent(_Pnode))))
			{
				_Wherenode=_Right(_Parent(_Parent(_Pnode)));
				if(_Color(_Wherenode)==_Red)
				{
					_Color(_Parent(_Pnode))=_Black;
					_Color(_Wherenode)=_Black;
					_Color(_Parent(_Parent(_Pnode)))=_Red;
					_Pnode=_Parent(_Parent(_Pnode));
				}
				else
				{
					if(_Pnode==_Right(_Parent(_Pnode)))
					{
						_Pnode=_Parent(_Pnode);
						_Lrotate(_Pnode);
					}
					_Color(_Parent(_Pnode))=_Black;
					_Color(_Parent(_Parent(_Pnode)))=_Red;
					_Rrotate(_Parent(_Parent(_Pnode)));
				}
			}
			else
			{
				_Wherenode=_Left(_Parent(_Parent(_Pnode)));
				if(_Color(_Wherenode)==_Red)
				{
					_Color(_Parent(_Pnode))=_Black;
					_Color(_Wherenode)=_Black;
					_Color(_Parent(_Parent(_Pnode)))=_Red;
					_Pnode=_Parent(_Parent(_Pnode));
				}
				else
				{
					if(_Pnode==_Left(_Parent(_Pnode)))
					{
						_Pnode=_Parent(_Pnode);
						_Rrotate(_Pnode);
					}
					_Color(_Parent(_Pnode))=_Black;
					_Color(_Parent(_Parent(_Pnode)))=_Red;
					_Lrotate(_Parent(_Parent(_Pnode)));
				}
			}
			_Color(_Root())=_Black;
			return (iterator(_Newnode, this));
		}
		_Nodeptr _Lbound(const key_type&_Keyval)const
		{
			_Nodeptr _Pnode=_Root();
			_Nodeptr _Wherenode=_Myhead;
			while(!_Isnil(_Pnode))if(_Debug_lt_pred(this->comp, _Key(_Pnode), _Keyval, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 1174))_Pnode=_Right(_Pnode);
			else
			{
				_Wherenode=_Pnode;
				_Pnode=_Left(_Pnode);
			}
			return (_Wherenode);
		}
		_Nodeptr&_Lmost()const
		{
			return (_Left(_Myhead));
		}
		void _Lrotate(_Nodeptr _Wherenode)
		{
			_Nodeptr _Pnode=_Right(_Wherenode);
			_Right(_Wherenode)=_Left(_Pnode);
			if(!_Isnil(_Left(_Pnode)))_Parent(_Left(_Pnode))=_Wherenode;
			_Parent(_Pnode)=_Parent(_Wherenode);
			if(_Wherenode==_Root())_Root()=_Pnode;
			else if(_Wherenode==_Left(_Parent(_Wherenode)))_Left(_Parent(_Wherenode))=_Pnode;
			else _Right(_Parent(_Wherenode))=_Pnode;
			_Left(_Pnode)=_Wherenode;
			_Parent(_Wherenode)=_Pnode;
		}
		static _Nodeptr _Max(_Nodeptr _Pnode)
		{
			while(!_Isnil(_Right(_Pnode)))_Pnode=_Right(_Pnode);
			return (_Pnode);
		}
		static _Nodeptr _Min(_Nodeptr _Pnode)
		{
			while(!_Isnil(_Left(_Pnode)))_Pnode=_Left(_Pnode);
			return (_Pnode);
		}
		_Nodeptr&_Rmost()const
		{
			return (_Right(_Myhead));
		}
		_Nodeptr&_Root()const
		{
			return (_Parent(_Myhead));
		}
		void _Rrotate(_Nodeptr _Wherenode)
		{
			_Nodeptr _Pnode=_Left(_Wherenode);
			_Left(_Wherenode)=_Right(_Pnode);
			if(!_Isnil(_Right(_Pnode)))_Parent(_Right(_Pnode))=_Wherenode;
			_Parent(_Pnode)=_Parent(_Wherenode);
			if(_Wherenode==_Root())_Root()=_Pnode;
			else if(_Wherenode==_Right(_Parent(_Wherenode)))_Right(_Parent(_Wherenode))=_Pnode;
			else _Left(_Parent(_Wherenode))=_Pnode;
			_Right(_Pnode)=_Wherenode;
			_Parent(_Wherenode)=_Pnode;
		}
		_Nodeptr _Ubound(const key_type&_Keyval)const
		{
			_Nodeptr _Pnode=_Root();
			_Nodeptr _Wherenode=_Myhead;
			while(!_Isnil(_Pnode))if(_Debug_lt_pred(this->comp, _Keyval, _Key(_Pnode), L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xtree", 1260))
			{
				_Wherenode=_Pnode;
				_Pnode=_Left(_Pnode);
			}
			else _Pnode=_Right(_Pnode);
			return (_Wherenode);
		}
		void _Orphan_ptr(_Myt&_Cont, _Nodeptr _Ptr)const
		{
			_Lockit _Lock(3);
			const_iterator**_Pnext=(const_iterator**)&_Cont._Myfirstiter;
			while(*_Pnext!=0)if((*_Pnext)->_Ptr==_Myhead||_Ptr!=0&&(*_Pnext)->_Ptr!=_Ptr)_Pnext=(const_iterator**)&(*_Pnext)->_Mynextiter;
			else
			{
				(*_Pnext)->_Mycont=0;
				*_Pnext=(const_iterator*)(*_Pnext)->_Mynextiter;
			}
		}
		_Nodeptr _Buynode()
		{
			_Nodeptr _Wherenode=this->_Alnod.allocate(1);
			int _Linkcnt=0;
			try
			{
				this->_Alptr.construct(&_Left(_Wherenode), 0);
				++_Linkcnt;
				this->_Alptr.construct(&_Parent(_Wherenode), 0);
				++_Linkcnt;
				this->_Alptr.construct(&_Right(_Wherenode), 0);
			}
			catch(...)
			{
				if(1<_Linkcnt)this->_Alptr.destroy(&_Parent(_Wherenode));
				if(0<_Linkcnt)this->_Alptr.destroy(&_Left(_Wherenode));
				this->_Alnod.deallocate(_Wherenode, 1);
				throw;
			}
			_Color(_Wherenode)=_Black;
			_Isnil(_Wherenode)=false;
			return (_Wherenode);
		}
		_Nodeptr _Buynode(_Nodeptr _Larg, _Nodeptr _Parg, _Nodeptr _Rarg, const value_type&_Val, char _Carg)
		{
			_Nodeptr _Wherenode=this->_Alnod.allocate(1);
			try
			{
				new(_Wherenode)_Node(_Larg, _Parg, _Rarg, _Val, _Carg);
			}
			catch(...)
			{
				this->_Alnod.deallocate(_Wherenode, 1);
				throw;
			}
			return (_Wherenode);
		}
		void _Tidy()
		{
			erase(begin(), end());
			this->_Alptr.destroy(&_Left(_Myhead));
			this->_Alptr.destroy(&_Parent(_Myhead));
			this->_Alptr.destroy(&_Right(_Myhead));
			this->_Alnod.deallocate(_Myhead, 1);
			_Myhead=0, _Mysize=0;
		}
		static void _Xran()
		{
			throw out_of_range("invalid map/set<T> iterator");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid map/set<T> argument");
		}
		_Nodeptr _Myhead;
		size_type _Mysize;
	};
	template<class _Traits>
	class _Move_operation_category<_Tree<_Traits> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Traits>
	inline bool operator==(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (_Left.size()==_Right.size()&&equal(_Left.begin(), _Left.end(), _Right.begin()));
	}
	template<class _Traits>
	inline bool operator!=(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Traits>
	inline bool operator<(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end()));
	}
	template<class _Traits>
	inline bool operator>(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Traits>
	inline bool operator<=(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Traits>
	inline bool operator>=(const _Tree<_Traits>&_Left, const _Tree<_Traits>&_Right)
	{
		return (!(_Left<_Right));
	}
}
namespace std
{
	template<class _Kty, class _Pr, class _Alloc, bool _Mfl>
	class _Tset_traits: public _Container_base
	{
	public:
		typedef _Kty key_type;
		typedef _Kty value_type;
		typedef _Pr key_compare;
		typedef typename _Alloc::template rebind<value_type>::other allocator_type;
		typedef typename allocator_type::template rebind<value_type>::other::pointer _ITptr;
		typedef typename allocator_type::template rebind<value_type>::other::reference _IReft;
		enum
		{
			_Multi=_Mfl
		};
		_Tset_traits(): comp()
		{
		}
		_Tset_traits(_Pr _Parg): comp(_Parg)
		{
		}
		typedef key_compare value_compare;
		static const _Kty&_Kfn(const value_type&_Val)
		{
			return (_Val);
		}
		_Pr comp;
	};
	template<class _Kty, class _Pr=less<_Kty>, class _Alloc=allocator<_Kty> >
	class set: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> >
	{
	public:
		typedef set<_Kty, _Pr, _Alloc>_Myt;
		typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> >_Mybase;
		typedef _Kty key_type;
		typedef _Pr key_compare;
		typedef typename _Mybase::value_compare value_compare;
		typedef typename _Mybase::allocator_type allocator_type;
		typedef typename _Mybase::size_type size_type;
		typedef typename _Mybase::difference_type difference_type;
		typedef typename _Mybase::pointer pointer;
		typedef typename _Mybase::const_pointer const_pointer;
		typedef typename _Mybase::reference reference;
		typedef typename _Mybase::const_reference const_reference;
		typedef typename _Mybase::iterator iterator;
		typedef typename _Mybase::const_iterator const_iterator;
		typedef typename _Mybase::reverse_iterator reverse_iterator;
		typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
		typedef typename _Mybase::value_type value_type;
		set(): _Mybase(key_compare(), allocator_type())
		{
		}
		explicit set(const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
		}
		set(const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
		}
		template<class _Iter>
		set(_Iter _First, _Iter _Last): _Mybase(key_compare(), allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 109);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		set(_Iter _First, _Iter _Last, const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 119);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		set(_Iter _First, _Iter _Last, const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 129);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
	};
	template<class _Kty, class _Pr, class _Alloc>
	class _Move_operation_category<set<_Kty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Kty, class _Pr, class _Alloc>
	inline void swap(set<_Kty, _Pr, _Alloc>&_Left, set<_Kty, _Pr, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	template<class _Kty, class _Pr=less<_Kty>, class _Alloc=allocator<_Kty> >
	class multiset: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true> >
	{
	public:
		typedef multiset<_Kty, _Pr, _Alloc>_Myt;
		typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true> >_Mybase;
		typedef _Kty key_type;
		typedef _Pr key_compare;
		typedef typename _Mybase::value_compare value_compare;
		typedef typename _Mybase::allocator_type allocator_type;
		typedef typename _Mybase::size_type size_type;
		typedef typename _Mybase::difference_type difference_type;
		typedef typename _Mybase::pointer pointer;
		typedef typename _Mybase::const_pointer const_pointer;
		typedef typename _Mybase::reference reference;
		typedef typename _Mybase::const_reference const_reference;
		typedef typename _Mybase::iterator iterator;
		typedef typename _Mybase::const_iterator const_iterator;
		typedef typename _Mybase::reverse_iterator reverse_iterator;
		typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
		typedef typename _Mybase::value_type value_type;
		multiset(): _Mybase(key_compare(), allocator_type())
		{
		}
		explicit multiset(const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
		}
		multiset(const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
		}
		template<class _Iter>
		multiset(_Iter _First, _Iter _Last): _Mybase(key_compare(), allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 218);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		multiset(_Iter _First, _Iter _Last, const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 228);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		multiset(_Iter _First, _Iter _Last, const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 238);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		iterator insert(const value_type&_Val)
		{
			return (_Mybase::insert(_Val).first);
		}
		iterator insert(iterator _Where, const value_type&_Val)
		{
			return (_Mybase::insert(_Where, _Val));
		}
		template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 275);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"multiset insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\set", 277);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
	};
	template<class _Kty, class _Pr, class _Alloc>
	class _Move_operation_category<multiset<_Kty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Kty, class _Pr, class _Alloc>
	inline void swap(multiset<_Kty, _Pr, _Alloc>&_Left, multiset<_Kty, _Pr, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
}
namespace std
{
	template<class _Kty, class _Ty, class _Pr, class _Alloc, bool _Mfl>
	class _Tmap_traits: public _Container_base
	{
	public:
		typedef _Kty key_type;
		typedef pair<const _Kty, _Ty>value_type;
		typedef _Pr key_compare;
		typedef typename _Alloc::template rebind<value_type>::other allocator_type;
		typedef typename allocator_type::template rebind<value_type>::other::pointer _ITptr;
		typedef typename allocator_type::template rebind<value_type>::other::reference _IReft;
		enum
		{
			_Multi=_Mfl
		};
		_Tmap_traits(): comp()
		{
		}
		_Tmap_traits(_Pr _Parg): comp(_Parg)
		{
		}
		class value_compare: public binary_function<value_type, value_type, bool>
		{
			friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;
		public:
			bool operator()(const value_type&_Left, const value_type&_Right)const
			{
				return (comp(_Left.first, _Right.first));
			}
			value_compare(key_compare _Pred): comp(_Pred)
			{
			}
			protected: key_compare comp;
		};
		static const _Kty&_Kfn(const value_type&_Val)
		{
			return (_Val.first);
		}
		_Pr comp;
	};
	template<class _Kty, class _Ty, class _Pr=less<_Kty>, class _Alloc=allocator<pair<const _Kty, _Ty> > >
	class map: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{
	public:
		typedef map<_Kty, _Ty, _Pr, _Alloc>_Myt;
		typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >_Mybase;
		typedef _Kty key_type;
		typedef _Ty mapped_type;
		typedef _Ty referent_type;
		typedef _Pr key_compare;
		typedef typename _Mybase::value_compare value_compare;
		typedef typename _Mybase::allocator_type allocator_type;
		typedef typename _Mybase::size_type size_type;
		typedef typename _Mybase::difference_type difference_type;
		typedef typename _Mybase::pointer pointer;
		typedef typename _Mybase::const_pointer const_pointer;
		typedef typename _Mybase::reference reference;
		typedef typename _Mybase::const_reference const_reference;
		typedef typename _Mybase::iterator iterator;
		typedef typename _Mybase::const_iterator const_iterator;
		typedef typename _Mybase::reverse_iterator reverse_iterator;
		typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
		typedef typename _Mybase::value_type value_type;
		map(): _Mybase(key_compare(), allocator_type())
		{
		}
		explicit map(const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
		}
		map(const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
		}
		template<class _Iter>
		map(_Iter _First, _Iter _Last): _Mybase(key_compare(), allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 124);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		map(_Iter _First, _Iter _Last, const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 134);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		template<class _Iter>
		map(_Iter _First, _Iter _Last, const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 144);
			for(;
			_First!=_Last;
			++_First)this->insert(*_First);
		}
		mapped_type&operator[](const key_type&_Keyval)
		{
			iterator _Where=this->lower_bound(_Keyval);
			if(_Where==this->end()||this->comp(_Keyval, this->_Key(_Where._Mynode())))_Where=this->insert(_Where, value_type(_Keyval, mapped_type()));
			return ((*_Where).second);
		}
	};
	template<class _Kty, class _Ty, class _Pr, class _Alloc>
	class _Move_operation_category<map<_Kty, _Ty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Kty, class _Ty, class _Pr, class _Alloc>
	inline void swap(map<_Kty, _Ty, _Pr, _Alloc>&_Left, map<_Kty, _Ty, _Pr, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	template<class _Kty, class _Ty, class _Pr=less<_Kty>, class _Alloc=allocator<pair<const _Kty, _Ty> > >
	class multimap: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
	{
	public:
		typedef multimap<_Kty, _Ty, _Pr, _Alloc>_Myt;
		typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >_Mybase;
		typedef _Kty key_type;
		typedef _Ty mapped_type;
		typedef _Ty referent_type;
		typedef _Pr key_compare;
		typedef typename _Mybase::value_compare value_compare;
		typedef typename _Mybase::allocator_type allocator_type;
		typedef typename _Mybase::size_type size_type;
		typedef typename _Mybase::difference_type difference_type;
		typedef typename _Mybase::pointer pointer;
		typedef typename _Mybase::const_pointer const_pointer;
		typedef typename _Mybase::reference reference;
		typedef typename _Mybase::const_reference const_reference;
		typedef typename _Mybase::iterator iterator;
		typedef typename _Mybase::const_iterator const_iterator;
		typedef typename _Mybase::reverse_iterator reverse_iterator;
		typedef typename _Mybase::const_reverse_iterator const_reverse_iterator;
		typedef typename _Mybase::value_type value_type;
		multimap(): _Mybase(key_compare(), allocator_type())
		{
		}
		explicit multimap(const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
		}
		multimap(const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
		}
		template<class _Iter>
		multimap(_Iter _First, _Iter _Last): _Mybase(key_compare(), allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 243);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
		template<class _Iter>
		multimap(_Iter _First, _Iter _Last, const key_compare&_Pred): _Mybase(_Pred, allocator_type())
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 253);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
		template<class _Iter>
		multimap(_Iter _First, _Iter _Last, const key_compare&_Pred, const allocator_type&_Al): _Mybase(_Pred, _Al)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 263);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
		iterator insert(const value_type&_Val)
		{
			return (_Mybase::insert(_Val).first);
		}
		iterator insert(iterator _Where, const value_type&_Val)
		{
			return (_Mybase::insert(_Where, _Val));
		}
		template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 300);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"multimap insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\map", 302);
			for(;
			_First!=_Last;
			++_First)insert(*_First);
		}
	};
	template<class _Kty, class _Ty, class _Pr, class _Alloc>
	class _Move_operation_category<multimap<_Kty, _Ty, _Pr, _Alloc> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Kty, class _Ty, class _Pr, class _Alloc>
	inline void swap(multimap<_Kty, _Ty, _Pr, _Alloc>&_Left, multimap<_Kty, _Ty, _Pr, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
}
typedef std::set<const struct IncludeDependencyNode*>IncludeDependencyNodes;
struct IncludeDependencyNode: public IncludeDependencyNodes
{
	Name name;
	IncludeDependencyNode(Name name): name(name)
	{
	}
};
inline bool operator<(const IncludeDependencyNode&left, const IncludeDependencyNode&right)
{
	return left.name<right.name;
}
typedef std::pair<Name, const char*>MacroDeclaration;
typedef std::set<MacroDeclaration>MacroDeclarationSet;
const MacroDeclarationSet MACRODECLARATIONSET_NULL=MacroDeclarationSet();
typedef std::map<Name, MacroDeclarationSet>MacroDependencyMap;
struct IncludeDependencyGraph
{
	typedef std::set<IncludeDependencyNode>Includes;
	Includes includes;
	MacroDependencyMap macros;
	IncludeDependencyNode&get(Name name)
	{
		Includes::iterator i=includes.insert(name).first;
		return const_cast<IncludeDependencyNode&>(*i);
	}
};
inline bool isEOF(LexTokenId token)
{
	return ((((token)&boost::wave::TokenTypeMask)==(boost::wave::EOFTokenType))?true: false);
}
inline bool isWhiteSpace(LexTokenId token)
{
	return ((((token)&boost::wave::TokenTypeMask)==(boost::wave::WhiteSpaceTokenType))?true: false)||((((token)&boost::wave::TokenTypeMask)==(boost::wave::EOLTokenType))?true: false);
}
struct Token
{
	LexTokenId id;
	TokenValue value;
	FilePosition position;
	Source source;
	IncludeEvents events;
	Token(): id(boost::wave::T_UNKNOWN)
	{
	}
	Token(LexTokenId id, const TokenValue&value, const FilePosition&position, Source source=Source(Path(Name("\"$unknown\""), Name("$unknown")), 0, 0), IncludeEvents events=IncludeEvents()): id(id), value(value), position(position), events(events), source(source)
	{
	}
};
struct BacktrackStats
{
	size_t count;
	const char*symbol;
	FilePosition position;
	BacktrackStats(): count(0)
	{
	}
};
class TokenBuffer
{
	TokenBuffer(const TokenBuffer&);
	TokenBuffer&operator=(const TokenBuffer&);
public:
	Token*tokens;
	size_t m_size;
	TokenBuffer(): tokens(0), m_size(0)
	{
	}
	TokenBuffer(size_t size): tokens(new Token[size]), m_size(size)
	{
	}
	~TokenBuffer()
	{
		delete[]tokens;
	}
	Token*begin()
	{
		return tokens;
	}
	const Token*begin()const
	{
		return tokens;
	}
	Token*end()
	{
		return tokens+m_size;
	}
	const Token*end()const
	{
		return tokens+m_size;
	}
	void resize(size_t count)
	{
		this->~TokenBuffer();
		new(this)TokenBuffer(count);
	}
	void swap(TokenBuffer&other)
	{
		std::swap(tokens, other.tokens);
		std::swap(m_size, other.m_size);
	}
};
struct BacktrackBuffer: public TokenBuffer
{
	Token*position;
	typedef Token*iterator;
	typedef const Token*const_iterator;
	BacktrackBuffer(): position(0)
	{
	}
	BacktrackBuffer(size_t count): TokenBuffer(count), position(tokens)
	{
	}
	iterator next(iterator i)
	{
		++i;
		return i==TokenBuffer::end()?TokenBuffer::begin(): i;
	}
	const_iterator next(const_iterator i)const
	{
		++i;
		return i==TokenBuffer::end()?TokenBuffer::begin(): i;
	}
	size_t distance(const_iterator i, const_iterator other)const
	{
		return (i>other)?m_size-(i-other): other-i;
	}
	const_iterator backtrack(const_iterator i, size_t count)
	{
		return (count>size_t(i-tokens))?i+(m_size-count): i-count;
	}
	const_iterator advance(const_iterator i, size_t count)
	{
		return (i+count<tokens+m_size)?i+count: i-(m_size-count);
	}
	iterator begin()
	{
		return next(position);
	}
	iterator end()
	{
		return position;
	}
	const_iterator begin()const
	{
		return next(position);
	}
	const_iterator end()const
	{
		return position;
	}
	void push_back(const Token&token)
	{
		*position=token;
		position=next(position);
	}
	size_t size()const
	{
		return m_size;
	}
	void resize(size_t count)
	{
		TokenBuffer::resize(count);
		position=tokens;
	}
	void swap(BacktrackBuffer&other)
	{
		TokenBuffer::swap(other);
		std::swap(position, other.position);
	}
};
inline size_t distance(const BacktrackBuffer&buffer, BacktrackBuffer::const_iterator first, BacktrackBuffer::const_iterator last)
{
	return buffer.distance(first, last);
}
inline BacktrackBuffer::const_iterator next(const BacktrackBuffer&buffer, BacktrackBuffer::const_iterator position)
{
	return buffer.next(position);
}
inline BacktrackBuffer::const_iterator backtrack(BacktrackBuffer&buffer, BacktrackBuffer::const_iterator position, size_t count)
{
	return buffer.backtrack(position, count);
}
inline BacktrackBuffer::const_iterator advance(BacktrackBuffer&buffer, BacktrackBuffer::const_iterator position, size_t count)
{
	return buffer.advance(position, count);
}
typedef TokenPrinter<std::ostream>FileTokenPrinter;
struct Lexer
{
	LexContext&context;
	std::ofstream out;
	FileTokenPrinter printer;
	LexIterator&first;
	LexIterator&last;
	enum
	{
		BACKTRACK_MAX=1024*128
	};
	typedef BacktrackBuffer Tokens;
	Tokens history;
	Tokens::const_iterator position;
	Tokens::const_iterator error;
	typedef std::vector<size_t>Positions;
	Positions stacktrace;
	Positions::iterator stackpos;
	BacktrackStats stats;
	bool maxBacktrack;
	Lexer(LexContext&context, const char*path): context(context), out(path), printer(out), first(createBegin(context)), last(createEnd(context)), history(BACKTRACK_MAX), position(history.end()), error(history.end()), stackpos(stacktrace.end()), maxBacktrack(false)
	{
		depth=0;
		includes[depth++]=Name("<root>");
		refill();
	}
	~Lexer()
	{
		release(first);
		release(last);
	}
	bool canBacktrack(size_t count)
	{
		return ::distance(history, position, history.end())+count<history.size();
	}
	void backtrack(size_t count, const char*symbol=0)
	{
		if(count==0)
		{
			return ;
		}
		if(!canBacktrack(count))
		{
			maxBacktrack=true;
		}
		else
		{
			if(::distance(history, position, history.end())< ::distance(history, error, history.end()))
			{
				error=position;
			}
			position=::backtrack(history, position, count);
			if(count>stats.count&&symbol!=0)
			{
				stats.count=count;
				stats.symbol=symbol;
				stats.position=(*position).position;
			};
		}
	}
	void advance(size_t count)
	{
		if(count==0)
		{
			return ;
		}
		position=::advance(history, position, count);
	}
	bool finished()const
	{
		return isEOF((*position).id)&&first==last;
	}
	LexTokenId get_id()
	{
		return (*position).id;
	}
	const TokenValue&get_value()
	{
		return (*position).value;
	}
	const FilePosition&get_position()
	{
		return (*position).position;
	}
	IncludeEvents get_events()
	{
		return (*position).events;
	}
	const Source&get_source()
	{
		return (*position).source;
	}
	const TokenValue&getErrorValue()
	{
		return (*error).value;
	}
	FilePosition getErrorPosition()
	{
		return (*error).position;
	}
	Name includes[1024];
	size_t depth;
	void debugEvents(IncludeEvents events, Name source);
	Token*read(Token*first, Token*last);
	void refill()
	{
		if(position==history.end())
		{
			const size_t COUNT=1024;
			Token*end=history.TokenBuffer::end();
			history.position=read(history.position, std::min(end, history.position+COUNT));
			if(history.position==end)
			{
				history.position=history.TokenBuffer::begin();
			}
		}
		debugEvents((*position).events, (*position).source.absolute);
	}
	void increment()
	{
		position=::next(history, position);
		refill();
	}
	const IncludeDependencyGraph&getIncludeGraph()const;
	const char*makeIdentifier(const char*value);
};
inline void printPosition(const FilePosition&position)
{
	std::cout<<position.file.c_str()<<"("<<position.line<<"): ";
}
inline void printPosition(const Source&source)
{
	std::cout<<source.absolute.c_str()<<"("<<source.line<<"): ";
}
inline const char*findFilename(const char*path)
{
	const char*result=strrchr(path, '/');
	if(result==0)
	{
		result=strrchr(path, '\\');
		if(result==0)
		{
			return path;
		}
	}
	return ++result;
}
inline const char*findFilenameSafe(const char*path)
{
	if(path!=0)
	{
		return findFilename(path);
	}
	return "<error>";
}
inline const char*findExtension(const char*path)
{
	const char*result=strrchr(path, '.');
	return result==0?path+strlen(path): result;
}
inline bool string_equal(const char*string, const char*other)
{
	return strcmp(string, other)==0;
}
inline bool string_equal_nocase(const char*string, const char*other)
{
	return _stricmp(string, other)==0;
}
inline bool string_equal_prefix(const char*left, const char*right)
{
	for(;
	*left!='\0'&&*right!='\0';
	++left, ++right)
	{
		if(*left!=*right)
		{
			return false;
		}
	}
	return true;
}
struct StringRange
{
	const char*first;
	const char*last;
	StringRange(const char*first, const char*last): first(first), last(last)
	{
	}
};
inline StringRange makeRange(const char*s)
{
	return StringRange(s, s+strlen(s));
}
inline size_t getLength(const StringRange&range)
{
	return range.last-range.first;
}
inline StringRange makeRange(const std::vector<char>&buffer)
{
	return buffer.empty()?StringRange(0, 0): StringRange(&(*buffer.begin()), &(*buffer.begin())+buffer.size());
}
struct Concatenate
{
	typedef std::vector<char>Buffer;
	Buffer buffer;
	Concatenate(const StringRange&left, const StringRange&right)
	{
		buffer.reserve(getLength(left)+getLength(right)+1);
		append(left);
		append(right);
		buffer.push_back('\0');
	}
	Concatenate(const StringRange&left, const StringRange&mid, const StringRange&right)
	{
		buffer.reserve(getLength(left)+getLength(mid)+getLength(right)+1);
		append(left);
		append(mid);
		append(right);
		buffer.push_back('\0');
	}
	void append(const StringRange&range)
	{
		buffer.insert(buffer.end(), range.first, range.last);
	}
	const char*c_str()const
	{
		return &(*buffer.begin());
	}
};
template<typename T, size_t CAPACITY>
struct Stack
{
	Stack(): depth(0)
	{
	}
	typedef T value_type;
	typedef value_type*iterator;
	typedef const value_type*const_iterator;
	value_type stack[CAPACITY];
	size_t depth;
	bool empty()const
	{
		return depth==0;
	}
	value_type&top()
	{
		return stack[depth-1];
	}
	const value_type&top()const
	{
		return stack[depth-1];
	}
	void push(value_type v)
	{
		stack[depth++]=v;
	}
	void pop()
	{
		--depth;
	}
	const_iterator begin()const
	{
		return stack;
	}
	const_iterator end()const
	{
		return stack+depth;
	}
};
typedef Stack<const char*, 1024>StringStack;
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace std
{
	template<class _Elem, class _Traits, class _Alloc>
	class basic_stringbuf: public basic_streambuf<_Elem, _Traits>
	{
	public:
		typedef _Alloc allocator_type;
		typedef basic_streambuf<_Elem, _Traits>_Mysb;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystr;
		explicit basic_stringbuf(ios_base::openmode _Mode=ios_base::in|ios_base::out)
		{
			_Init(0, 0, _Getstate(_Mode));
		}
		explicit basic_stringbuf(const _Mystr&_Str, ios_base::openmode _Mode=ios_base::in|ios_base::out)
		{
			_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
		}
		virtual~basic_stringbuf()
		{
			_Tidy();
		}
		enum
		{
			_Allocated=1, _Constant=2, _Noread=4, _Append=8, _Atend=16
		};
		typedef int _Strstate;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		_Mystr str()const
		{
			if(!(_Mystate&_Constant)&&_Mysb::pptr()!=0)
			{
				_Mystr _Str(_Mysb::pbase(), (_Seekhigh<_Mysb::pptr()?_Mysb::pptr(): _Seekhigh)-_Mysb::pbase());
				return (_Str);
			}
			else if(!(_Mystate&_Noread)&&_Mysb::gptr()!=0)
			{
				_Mystr _Str(_Mysb::eback(), _Mysb::egptr()-_Mysb::eback());
				return (_Str);
			}
			else
			{
				_Mystr _Nul;
				return (_Nul);
			}
		}
		void str(const _Mystr&_Newstr)
		{
			_Tidy();
			_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
		}
		protected: virtual int_type overflow(int_type _Meta=_Traits::eof())
		{
			if(_Mystate&_Append&&_Mysb::pptr()!=0&&_Mysb::pptr()<_Seekhigh)_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
			if(_Traits::eq_int_type(_Traits::eof(), _Meta))return (_Traits::not_eof(_Meta));
			else if(_Mysb::pptr()!=0&&_Mysb::pptr()<_Mysb::epptr())
			{
				*_Mysb::_Pninc()=_Traits::to_char_type(_Meta);
				return (_Meta);
			}
			else if(_Mystate&_Constant)return (_Traits::eof());
			else
			{
				size_t _Oldsize=_Mysb::pptr()==0?0: _Mysb::epptr()-_Mysb::eback();
				size_t _Newsize=_Oldsize;
				size_t _Inc=_Newsize/2<_MINSIZE?_MINSIZE: _Newsize/2;
				_Elem*_Ptr=0;
				while(0<_Inc&&2147483647-_Inc<_Newsize)_Inc/=2;
				if(0<_Inc)
				{
					_Newsize+=_Inc;
					_Ptr=_Al.allocate(_Newsize);
				}
				if(0<_Oldsize)_Traits_helper::copy_s<_Traits>(_Ptr, _Newsize, _Mysb::eback(), _Oldsize);
				if(_Mystate&_Allocated)_Al.deallocate(_Mysb::eback(), _Oldsize);
				_Mystate|=_Allocated;
				if(_Oldsize==0)
				{
					_Seekhigh=_Ptr;
					_Mysb::setp(_Ptr, _Ptr+_Newsize);
					if(_Mystate&_Noread)_Mysb::setg(_Ptr, 0, _Ptr);
					else _Mysb::setg(_Ptr, _Ptr, _Ptr+1);
				}
				else
				{
					_Seekhigh=_Seekhigh-_Mysb::eback()+_Ptr;
					_Mysb::setp(_Mysb::pbase()-_Mysb::eback()+_Ptr, _Mysb::pptr()-_Mysb::eback()+_Ptr, _Ptr+_Newsize);
					if(_Mystate&_Noread)_Mysb::setg(_Ptr, 0, _Ptr);
					else _Mysb::setg(_Ptr, _Mysb::gptr()-_Mysb::eback()+_Ptr, _Mysb::pptr()+1);
				}
				*_Mysb::_Pninc()=_Traits::to_char_type(_Meta);
				return (_Meta);
			}
		}
		virtual int_type pbackfail(int_type _Meta=_Traits::eof())
		{
			if(_Mysb::gptr()==0||_Mysb::gptr()<=_Mysb::eback()||!_Traits::eq_int_type(_Traits::eof(), _Meta)&&!_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])&&_Mystate&_Constant)return (_Traits::eof());
			else
			{
				_Mysb::gbump(-1);
				if(!_Traits::eq_int_type(_Traits::eof(), _Meta))*_Mysb::gptr()=_Traits::to_char_type(_Meta);
				return (_Traits::not_eof(_Meta));
			}
		}
		virtual int_type underflow()
		{
			if(_Mysb::gptr()==0)return (_Traits::eof());
			else if(_Mysb::gptr()<_Mysb::egptr())return (_Traits::to_int_type(*_Mysb::gptr()));
			else if(_Mystate&_Noread||_Mysb::pptr()==0||_Mysb::pptr()<=_Mysb::gptr()&&_Seekhigh<=_Mysb::gptr())return (_Traits::eof());
			else
			{
				if(_Seekhigh<_Mysb::pptr())_Seekhigh=_Mysb::pptr();
				_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
				return (_Traits::to_int_type(*_Mysb::gptr()));
			}
		}
		virtual pos_type seekoff(off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Which=ios_base::in|ios_base::out)
		{
			if(_Mysb::pptr()!=0&&_Seekhigh<_Mysb::pptr())_Seekhigh=_Mysb::pptr();
			if(_Which&ios_base::in&&_Mysb::gptr()!=0)
			{
				if(_Way==ios_base::end)_Off+=(off_type)(_Seekhigh-_Mysb::eback());
				else if(_Way==ios_base::cur&&(_Which&ios_base::out)==0)_Off+=(off_type)(_Mysb::gptr()-_Mysb::eback());
				else if(_Way!=ios_base::beg)_Off=_BADOFF;
				if(0<=_Off&&_Off<=_Seekhigh-_Mysb::eback())
				{
					_Mysb::gbump((int)(_Mysb::eback()-_Mysb::gptr()+_Off));
					if(_Which&ios_base::out&&_Mysb::pptr()!=0)_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(), _Mysb::epptr());
				}
				else _Off=_BADOFF;
			}
			else if(_Which&ios_base::out&&_Mysb::pptr()!=0)
			{
				if(_Way==ios_base::end)_Off+=(off_type)(_Seekhigh-_Mysb::eback());
				else if(_Way==ios_base::cur)_Off+=(off_type)(_Mysb::pptr()-_Mysb::eback());
				else if(_Way!=ios_base::beg)_Off=_BADOFF;
				if(0<=_Off&&_Off<=_Seekhigh-_Mysb::eback())_Mysb::pbump((int)(_Mysb::eback()-_Mysb::pptr()+_Off));
				else _Off=_BADOFF;
			}
			else _Off=_BADOFF;
			return (pos_type(_Off));
		}
		virtual pos_type seekpos(pos_type _Ptr, ios_base::openmode _Mode=ios_base::in|ios_base::out)
		{
			streamoff _Off=(streamoff)_Ptr;
			if(_Mysb::pptr()!=0&&_Seekhigh<_Mysb::pptr())_Seekhigh=_Mysb::pptr();
			if(_Off==_BADOFF);
			else if(_Mode&ios_base::in&&_Mysb::gptr()!=0)
			{
				if(0<=_Off&&_Off<=_Seekhigh-_Mysb::eback())
				{
					_Mysb::gbump((int)(_Mysb::eback()-_Mysb::gptr()+_Off));
					if(_Mode&ios_base::out&&_Mysb::pptr()!=0)_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(), _Mysb::epptr());
				}
				else _Off=_BADOFF;
			}
			else if(_Mode&ios_base::out&&_Mysb::pptr()!=0)
			{
				if(0<=_Off&&_Off<=_Seekhigh-_Mysb::eback())_Mysb::pbump((int)(_Mysb::eback()-_Mysb::pptr()+_Off));
				else _Off=_BADOFF;
			}
			else _Off=_BADOFF;
			return (streampos(_Off));
		}
		void _Init(const _Elem*_Ptr, size_t _Count, _Strstate _State)
		{
			_Seekhigh=0;
			_Mystate=_State;
			if(_Count!=0&&(_Mystate&(_Noread|_Constant))!=(_Noread|_Constant))
			{
				_Elem*_Pnew=_Al.allocate(_Count);
				_Traits_helper::copy_s<_Traits>(_Pnew, _Count, _Ptr, _Count);
				_Seekhigh=_Pnew+_Count;
				if(!(_Mystate&_Noread))_Mysb::setg(_Pnew, _Pnew, _Pnew+_Count);
				if(!(_Mystate&_Constant))
				{
					_Mysb::setp(_Pnew, (_Mystate&_Atend)?_Pnew+_Count: _Pnew, _Pnew+_Count);
					if(_Mysb::gptr()==0)_Mysb::setg(_Pnew, 0, _Pnew);
				}
				_Mystate|=_Allocated;
			}
		}
		void _Tidy()
		{
			if(_Mystate&_Allocated)_Al.deallocate(_Mysb::eback(), (_Mysb::pptr()!=0?_Mysb::epptr(): _Mysb::egptr())-_Mysb::eback());
			_Mysb::setg(0, 0, 0);
			_Mysb::setp(0, 0);
			_Seekhigh=0;
			_Mystate&=~_Allocated;
		}
	private:
		enum
		{
			_MINSIZE=32
		};
		_Strstate _Getstate(ios_base::openmode _Mode)
		{
			_Strstate _State=(_Strstate)0;
			if(!(_Mode&ios_base::in))_State|=_Noread;
			if(!(_Mode&ios_base::out))_State|=_Constant;
			if(_Mode&ios_base::app)_State|=_Append;
			if(_Mode&ios_base::ate)_State|=_Atend;
			return (_State);
		}
		_Elem*_Seekhigh;
		_Strstate _Mystate;
		allocator_type _Al;
	};
	template<class _Elem, class _Traits, class _Alloc>
	class basic_istringstream: public basic_istream<_Elem, _Traits>
	{
	public:
		typedef _Alloc allocator_type;
		typedef basic_stringbuf<_Elem, _Traits, _Alloc>_Mysb;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystr;
		explicit basic_istringstream(ios_base::openmode _Mode=ios_base::in): basic_istream<_Elem, _Traits>(&_Stringbuffer), _Stringbuffer(_Mode|ios_base::in)
		{
		}
		explicit basic_istringstream(const _Mystr&_Str, ios_base::openmode _Mode=ios_base::in): basic_istream<_Elem, _Traits>(&_Stringbuffer), _Stringbuffer(_Str, _Mode|ios_base::in)
		{
		}
		virtual~basic_istringstream()
		{
		}
		_Mysb*rdbuf()const
		{
			return ((_Mysb*)&_Stringbuffer);
		}
		_Mystr str()const
		{
			return (_Stringbuffer.str());
		}
		void str(const _Mystr&_Newstr)
		{
			_Stringbuffer.str(_Newstr);
		}
	private:
		_Mysb _Stringbuffer;
	};
	template<class _Elem, class _Traits, class _Alloc>
	class basic_ostringstream: public basic_ostream<_Elem, _Traits>
	{
	public:
		typedef _Alloc allocator_type;
		typedef basic_stringbuf<_Elem, _Traits, _Alloc>_Mysb;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystr;
		explicit basic_ostringstream(ios_base::openmode _Mode=ios_base::out): basic_ostream<_Elem, _Traits>(&_Stringbuffer), _Stringbuffer(_Mode|ios_base::out)
		{
		}
		explicit basic_ostringstream(const _Mystr&_Str, ios_base::openmode _Mode=ios_base::out): basic_ostream<_Elem, _Traits>(&_Stringbuffer), _Stringbuffer(_Str, _Mode|ios_base::out)
		{
		}
		virtual~basic_ostringstream()
		{
		}
		_Mysb*rdbuf()const
		{
			return ((_Mysb*)&_Stringbuffer);
		}
		_Mystr str()const
		{
			return (_Stringbuffer.str());
		}
		void str(const _Mystr&_Newstr)
		{
			_Stringbuffer.str(_Newstr);
		}
	private:
		_Mysb _Stringbuffer;
	};
	template<class _Elem, class _Traits, class _Alloc>
	class basic_stringstream: public basic_iostream<_Elem, _Traits>
	{
	public:
		typedef _Elem char_type;
		typedef _Traits traits_type;
		typedef _Alloc allocator_type;
		typedef typename _Traits::int_type int_type;
		typedef typename _Traits::pos_type pos_type;
		typedef typename _Traits::off_type off_type;
		typedef basic_string<_Elem, _Traits, _Alloc>_Mystr;
		explicit basic_stringstream(ios_base::openmode _Mode=ios_base::in|ios_base::out): basic_iostream<_Elem, _Traits>(&_Stringbuffer), _Stringbuffer(_Mode)
		{
		}
		explicit basic_stringstream(const _Mystr&_Str, ios_base::openmode _Mode=ios_base::in|ios_base::out): basic_iostream<_Elem, _Traits>(&_Stringbuffer), _Stringbuffer(_Str, _Mode)
		{
		}
		virtual~basic_stringstream()
		{
		}
		basic_stringbuf<_Elem, _Traits, _Alloc>*rdbuf()const
		{
			return ((basic_stringbuf<_Elem, _Traits, _Alloc>*)&_Stringbuffer);
		}
		_Mystr str()const
		{
			return (_Stringbuffer.str());
		}
		void str(const _Mystr&_Newstr)
		{
			_Stringbuffer.str(_Newstr);
		}
	private:
		basic_stringbuf<_Elem, _Traits, _Alloc>_Stringbuffer;
	};
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			enum severity
			{
				severity_remark=0, severity_warning, severity_error, severity_fatal, severity_commandline_error, last_severity_code=severity_commandline_error
			};
			inline char const*get_severity(int level)
			{
				static char const*severity_text[]=
				{
					"remark", "warning", "error", "fatal error", "command line error"
				};
				(void)((!!(severity_remark<=level&&level<=last_severity_code))||(_wassert(L"severity_remark <= level && level <= last_severity_code", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpp_exceptions.hpp", 57), 0));
				return severity_text[level];
			}
		}
		class cpp_exception: public std::exception
		{
		public:
			cpp_exception(int line_, int column_, char const*filename_)throw(): line(line_), column(column_)
			{
				unsigned int off=0;
				while(off<sizeof(filename)-1&&*filename_)filename[off++]=*filename_++;
				filename[off]=0;
			}
			~cpp_exception()throw()
			{
			}
			virtual char const*what()const throw()=0;
			virtual char const*description()const throw()=0;
			virtual int get_errorcode()const throw()=0;
			virtual int get_severity()const throw()=0;
			virtual char const*get_related_name()const throw()=0;
			virtual bool is_recoverable()const throw()=0;
			int line_no()const throw()
			{
				return line;
			}
			int column_no()const throw()
			{
				return column;
			}
			char const*file_name()const throw()
			{
				return filename;
			}
			protected: char filename[512];
			int line;
			int column;
		};
		class preprocess_exception: public cpp_exception
		{
		public:
			enum error_code
			{
				no_error=0, unexpected_error, macro_redefinition, macro_insertion_error, bad_include_file, bad_include_statement, ill_formed_directive, error_directive, warning_directive, ill_formed_expression, missing_matching_if, missing_matching_endif, ill_formed_operator, bad_define_statement, bad_define_statement_va_args, too_few_macroarguments, too_many_macroarguments, empty_macroarguments, improperly_terminated_macro, bad_line_statement, bad_line_number, bad_line_filename, bad_undefine_statement, bad_macro_definition, illegal_redefinition, duplicate_parameter_name, invalid_concat, last_line_not_terminated, ill_formed_pragma_option, include_nesting_too_deep, misplaced_operator, alreadydefined_name, undefined_macroname, invalid_macroname, unexpected_qualified_name, division_by_zero, integer_overflow, illegal_operator_redefinition, ill_formed_integer_literal, ill_formed_character_literal, unbalanced_if_endif, character_literal_out_of_range, could_not_open_output_file, incompatible_config, ill_formed_pragma_message, pragma_message_directive, last_error_number=pragma_message_directive
			};
			preprocess_exception(char const*what_, error_code code, int line_, int column_, char const*filename_)throw(): cpp_exception(line_, column_, filename_), code(code)
			{
				unsigned int off=0;
				while(off<sizeof(buffer)&&*what_)buffer[off++]=*what_++;
				buffer[off]=0;
			}
			~preprocess_exception()throw()
			{
			}
			virtual char const*what()const throw()
			{
				return "boost::wave::preprocess_exception";
			}
			virtual char const*description()const throw()
			{
				return buffer;
			}
			virtual int get_severity()const throw()
			{
				return severity_level(code);
			}
			virtual int get_errorcode()const throw()
			{
				return code;
			}
			virtual char const*get_related_name()const throw()
			{
				return "<unknown>";
			}
			virtual bool is_recoverable()const throw()
			{
				switch(get_errorcode())
				{
					case preprocess_exception::no_error: case preprocess_exception::macro_redefinition: case preprocess_exception::macro_insertion_error: case preprocess_exception::bad_macro_definition: case preprocess_exception::illegal_redefinition: case preprocess_exception::duplicate_parameter_name: case preprocess_exception::invalid_macroname: case preprocess_exception::bad_include_file: case preprocess_exception::bad_include_statement: case preprocess_exception::ill_formed_directive: case preprocess_exception::error_directive: case preprocess_exception::warning_directive: case preprocess_exception::ill_formed_expression: case preprocess_exception::missing_matching_if: case preprocess_exception::missing_matching_endif: case preprocess_exception::unbalanced_if_endif: case preprocess_exception::bad_define_statement: case preprocess_exception::bad_define_statement_va_args: case preprocess_exception::bad_line_statement: case preprocess_exception::bad_line_number: case preprocess_exception::bad_line_filename: case preprocess_exception::bad_undefine_statement: case preprocess_exception::division_by_zero: case preprocess_exception::integer_overflow: case preprocess_exception::ill_formed_integer_literal: case preprocess_exception::ill_formed_character_literal: case preprocess_exception::character_literal_out_of_range: case preprocess_exception::last_line_not_terminated: case preprocess_exception::include_nesting_too_deep: case preprocess_exception::illegal_operator_redefinition: case preprocess_exception::incompatible_config: case preprocess_exception::ill_formed_pragma_option: case preprocess_exception::ill_formed_pragma_message: case preprocess_exception::pragma_message_directive: return true;
					case preprocess_exception::unexpected_error: case preprocess_exception::ill_formed_operator: case preprocess_exception::too_few_macroarguments: case preprocess_exception::too_many_macroarguments: case preprocess_exception::empty_macroarguments: case preprocess_exception::improperly_terminated_macro: case preprocess_exception::invalid_concat: case preprocess_exception::could_not_open_output_file: break;
				}
				return false;
			}
			static char const*error_text(int code)
			{
				static char const*preprocess_exception_errors[]=
				{
					"no error", "unexpected error (should not happen)", "illegal macro redefinition", "macro definition failed (out of memory?)", "could not find include file", "ill formed #include directive", "ill formed preprocessor directive", "encountered #error directive or #pragma wave stop()", "encountered #warning directive", "ill formed preprocessor expression", "the #if for this directive is missing", "detected at least one missing #endif directive", "ill formed preprocessing operator", "ill formed #define directive", "__VA_ARGS__ can only appear in the " "expansion of a C99 variadic macro", "too few macro arguments", "too many macro arguments", "empty macro arguments are not supported in pure C++ mode, " "use variadics mode to allow these", "improperly terminated macro invocation " "or replacement-list terminates in partial " "macro expansion (not supported yet)", "ill formed #line directive", "line number argument of #line directive " "should consist out of decimal digits " "only and must be in range of [1..INT_MAX]", "filename argument of #line directive should " "be a narrow string literal", "#undef may not be used on this predefined name", "invalid macro definition", "this predefined name may not be redefined", "duplicate macro parameter name", "pasting the following two tokens does not " "give a valid preprocessing token", "last line of file ends without a newline", "unknown or illformed pragma option", "include files nested too deep", "misplaced operator defined()", "the name is already used in this scope as " "a macro or scope name", "undefined macro or scope name may not be imported", "ill formed macro name", "qualified names are supported in C++0x mode only", "division by zero in preprocessor expression", "integer overflow in preprocessor expression", "this cannot be used as a macro name as it is " "an operator in C++", "ill formed integer literal or integer constant too large", "ill formed character literal", "unbalanced #if/#endif in include file", "expression contains out of range character literal", "could not open output file", "incompatible state information", "illformed pragma message", "encountered #pragma message directive"
				};
				(void)((!!(no_error<=code&&code<=last_error_number))||(_wassert(L"no_error <= code && code <= last_error_number", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpp_exceptions.hpp", 300), 0));
				return preprocess_exception_errors[code];
			}
			static util::severity severity_level(int code)
			{
				static util::severity preprocess_exception_severity[]=
				{
					util::severity_remark, util::severity_fatal, util::severity_warning, util::severity_fatal, util::severity_error, util::severity_error, util::severity_error, util::severity_fatal, util::severity_warning, util::severity_error, util::severity_error, util::severity_error, util::severity_error, util::severity_error, util::severity_error, util::severity_warning, util::severity_warning, util::severity_warning, util::severity_error, util::severity_warning, util::severity_warning, util::severity_warning, util::severity_warning, util::severity_commandline_error, util::severity_warning, util::severity_error, util::severity_error, util::severity_warning, util::severity_warning, util::severity_fatal, util::severity_error, util::severity_error, util::severity_error, util::severity_error, util::severity_error, util::severity_fatal, util::severity_error, util::severity_error, util::severity_error, util::severity_error, util::severity_warning, util::severity_warning, util::severity_error, util::severity_remark, util::severity_warning, util::severity_remark,
				};
				(void)((!!(no_error<=code&&code<=last_error_number))||(_wassert(L"no_error <= code && code <= last_error_number", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpp_exceptions.hpp", 354), 0));
				return preprocess_exception_severity[code];
			}
			static char const*severity_text(int code)
			{
				return util::get_severity(severity_level(code));
			}
		private:
			char buffer[512];
			error_code code;
		};
		class macro_handling_exception: public preprocess_exception
		{
		public:
			macro_handling_exception(char const*what_, error_code code, int line_, int column_, char const*filename_, char const*macroname)throw(): preprocess_exception(what_, code, line_, column_, filename_)
			{
				unsigned int off=0;
				while(off<sizeof(name)&&*macroname)name[off++]=*macroname++;
				name[off]=0;
			}
			~macro_handling_exception()throw()
			{
			}
			virtual char const*what()const throw()
			{
				return "boost::wave::macro_handling_exception";
			}
			char const*get_related_name()const throw()
			{
				return name;
			}
		private:
			char name[512];
		};
		inline bool is_recoverable(cpp_exception const&e)
		{
			return e.is_recoverable();
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace util
			{
				enum severity
				{
					severity_remark=0, severity_warning, severity_error, severity_fatal
				};
				inline char const*get_severity(severity level)
				{
					static char const*severity_text[]=
					{
						"remark", "warning", "error", "fatal error"
					};
					(void)((!!(severity_remark<=level&&level<=severity_fatal))||(_wassert(L"severity_remark <= level && level <= severity_fatal", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpplexer\\cpplexer_exceptions.hpp", 124), 0));
					return severity_text[level];
				}
			}
			class cpplexer_exception: public std::exception
			{
			public:
				cpplexer_exception(int line_, int column_, char const*filename_)throw(): line(line_), column(column_)
				{
					unsigned int off=0;
					while(off<sizeof(filename)-1&&*filename_)filename[off++]=*filename_++;
					filename[off]=0;
				}
				~cpplexer_exception()throw()
				{
				}
				virtual char const*what()const throw()=0;
				virtual char const*description()const throw()=0;
				virtual int get_errorcode()const throw()=0;
				virtual int get_severity()const throw()=0;
				virtual bool is_recoverable()const throw()=0;
				int line_no()const throw()
				{
					return line;
				}
				int column_no()const throw()
				{
					return column;
				}
				char const*file_name()const throw()
				{
					return filename;
				}
				protected: char filename[512];
				int line;
				int column;
			};
			class lexing_exception: public cpplexer_exception
			{
			public:
				enum error_code
				{
					unexpected_error=0, universal_char_invalid=1, universal_char_base_charset=2, universal_char_not_allowed=3, invalid_long_long_literal=4, generic_lexing_error=5, generic_lexing_warning=6
				};
				lexing_exception(char const*what_, error_code code, int line_, int column_, char const*filename_)throw(): cpplexer_exception(line_, column_, filename_), level(severity_level(code)), code(code)
				{
					unsigned int off=0;
					while(off<sizeof(buffer)&&*what_)buffer[off++]=*what_++;
					buffer[off]=0;
				}
				~lexing_exception()throw()
				{
				}
				virtual char const*what()const throw()
				{
					return "boost::wave::lexing_exception";
				}
				virtual char const*description()const throw()
				{
					return buffer;
				}
				virtual int get_severity()const throw()
				{
					return level;
				}
				virtual int get_errorcode()const throw()
				{
					return code;
				}
				virtual bool is_recoverable()const throw()
				{
					switch(get_errorcode())
					{
						case lexing_exception::universal_char_invalid: case lexing_exception::universal_char_base_charset: case lexing_exception::universal_char_not_allowed: case lexing_exception::invalid_long_long_literal: case lexing_exception::generic_lexing_warning: case lexing_exception::generic_lexing_error: return true;
						case lexing_exception::unexpected_error: default: break;
					}
					return false;
				}
				static char const*error_text(int code)
				{
					static char const*preprocess_exception_errors[]=
					{
						"unexpected error (should not happen)", "universal character name specifies an invalid character", "a universal character name cannot designate a character in the " "basic character set", "this universal character is not allowed in an identifier", "long long suffixes are not allowed in pure C++ mode, " "enable long_long mode to allow these", "generic lexer error", "generic lexer warning"
					};
					return preprocess_exception_errors[code];
				}
				static util::severity severity_level(int code)
				{
					static util::severity preprocess_exception_severity[]=
					{
						util::severity_fatal, util::severity_error, util::severity_error, util::severity_error, util::severity_warning, util::severity_error, util::severity_warning
					};
					return preprocess_exception_severity[code];
				}
				static char const*severity_text(int code)
				{
					return util::get_severity(severity_level(code));
				}
			private:
				char buffer[512];
				util::severity level;
				error_code code;
			};
			inline bool is_recoverable(lexing_exception const&e)
			{
				return e.is_recoverable();
			}
		}
	}
}
namespace std
{
	template<class _Ty, class _Ax=allocator<_Ty> >
	class deque;
	template<class _Ty, class _Alloc, bool _Secure_validation>
	class _Deque_const_iterator: public _Ranit<_Ty, typename _Alloc::difference_type, typename _Alloc::const_pointer, typename _Alloc::const_reference>
	{
	public:
		typedef _Deque_const_iterator<_Ty, _Alloc, _Secure_validation>_Myt;
		typedef deque<_Ty, _Alloc>_Mydeque;
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::const_pointer pointer;
		typedef typename _Alloc::const_reference reference;
		typedef typename _Alloc::size_type size_type;
		typedef typename _Secure_validation_helper<_Secure_validation>::_Checked_iterator_category _Checked_iterator_category;
		typedef typename _If<_Secure_validation, _Deque_const_iterator<_Ty, _Alloc, false>, _Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
		friend _Deque_const_iterator<_Ty, _Alloc, false>;
		friend _Deque_const_iterator<_Ty, _Alloc, true>;
		_Deque_const_iterator<_Ty, _Alloc, false>_Checked_iterator_base()const
		{
			_Deque_const_iterator<_Ty, _Alloc, false>_Base(this->_Myoff, this->_Mycont);
			return _Base;
		}
		void _Checked_iterator_assign_from_base(_Deque_const_iterator<_Ty, _Alloc, false>_Base)
		{

			{
				if(!(this->_Mycont==_Base._Mycont))
				{
					(void)((!!((("this->_Mycont == _Base._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 61, 0, L"(\"this->_Mycont == _Base._Mycont\", 0)"))||(__debugbreak(), 0));
					::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 61, 0);
				};
			};
			this->_Myoff=_Base._Myoff;
		}
		_Deque_const_iterator()
		{
			_Myoff=0;
		}
		_Deque_const_iterator(const _Myt&_Right): _Myoff(_Right._Myoff)
		{
			this->_Adopt(_Right._Mycont);
		}
		_Deque_const_iterator(size_type _Off, const _Container_base*_Pdeque)
		{

			{
				;
				;
				if(_Secure_validation)
				{

					{
						if(!(_Pdeque!=0&&((_Mydeque*)_Pdeque)->_Myoff<=_Off&&_Off<=(((_Mydeque*)_Pdeque)->_Myoff+((_Mydeque*)_Pdeque)->_Mysize)))
						{
							(void)((!!((("_Pdeque != 0 && ((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize)", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 80, 0, L"(\"_Pdeque != 0 && ((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize)\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 80, 0);
						};
					}
				};
			};
			this->_Adopt(_Pdeque);
			_Myoff=_Off;
		}
		reference operator*()const
		{
			size_type _Block=_Myoff/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1);
			size_type _Off=_Myoff&((sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1)-1);
			if(this->_Mycont==0||_Myoff<((_Mydeque*)this->_Mycont)->_Myoff||((_Mydeque*)this->_Mycont)->_Myoff+((_Mydeque*)this->_Mycont)->_Mysize<=_Myoff)
			{
				_Debug_message(L"deque iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 97);

				{
					;
					;
					if(_Secure_validation)
					{

						{
							(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 98, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 98, 0);
						}
					};
				};
			}
			if(((_Mydeque*)this->_Mycont)->_Mapsize<=_Block)_Block-=((_Mydeque*)this->_Mycont)->_Mapsize;
			return ((((_Mydeque*)this->_Mycont)->_Map)[_Block][_Off]);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{

			{
				;
				;
				if(_Secure_validation)
				{

					{
						if(!(this->_Mycont!=0))
						{
							(void)((!!((("this->_Mycont != 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 146, 0, L"(\"this->_Mycont != 0\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 146, 0);
						};
					}
				};
			};

			{
				;
				;
				if(_Secure_validation)
				{

					{
						if(!(_Myoff<((_Mydeque*)(this->_Mycont))->_Myoff+((_Mydeque*)(this->_Mycont))->_Mysize))
						{
							(void)((!!((("_Myoff < ((_Mydeque *)(this->_Mycont))->_Myoff + ((_Mydeque *)(this->_Mycont))->_Mysize", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 147, 0, L"(\"_Myoff < ((_Mydeque *)(this->_Mycont))->_Myoff + ((_Mydeque *)(this->_Mycont))->_Mysize\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 147, 0);
						};
					}
				};
			};
			++_Myoff;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{

			{
				;
				;
				if(_Secure_validation)
				{

					{
						if(!(this->_Mycont!=0))
						{
							(void)((!!((("this->_Mycont != 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 161, 0, L"(\"this->_Mycont != 0\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 161, 0);
						};
					}
				};
			};

			{
				;
				;
				if(_Secure_validation)
				{

					{
						if(!(_Myoff>((_Mydeque*)(this->_Mycont))->_Myoff))
						{
							(void)((!!((("_Myoff > ((_Mydeque *)(this->_Mycont))->_Myoff", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 162, 0, L"(\"_Myoff > ((_Mydeque *)(this->_Mycont))->_Myoff\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 162, 0);
						};
					}
				};
			};
			--_Myoff;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{

			{
				;
				;
				if(_Secure_validation)
				{

					{
						if(!(this->_Mycont!=0))
						{
							(void)((!!((("this->_Mycont != 0", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 176, 0, L"(\"this->_Mycont != 0\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 176, 0);
						};
					}
				};
			};

			{
				;
				;
				if(_Secure_validation)
				{

					{
						if(!(_Myoff+_Off<=((_Mydeque*)(this->_Mycont))->_Myoff+((_Mydeque*)(this->_Mycont))->_Mysize&&_Myoff+_Off>=((_Mydeque*)(this->_Mycont))->_Myoff))
						{
							(void)((!!((("_Myoff + _Off <= ((_Mydeque *)(this->_Mycont))->_Myoff + ((_Mydeque *)(this->_Mycont))->_Mysize && _Myoff + _Off >= ((_Mydeque *)(this->_Mycont))->_Myoff", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 177, 0, L"(\"_Myoff + _Off <= ((_Mydeque *)(this->_Mycont))->_Myoff + ((_Mydeque *)(this->_Mycont))->_Mysize && _Myoff + _Off >= ((_Mydeque *)(this->_Mycont))->_Myoff\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 177, 0);
						};
					}
				};
			};
			_Myoff+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Right._Myoff<=_Myoff?_Myoff-_Right._Myoff: -(difference_type)(_Right._Myoff-_Myoff));
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
		bool operator==(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myoff==_Right._Myoff);
		}
		bool operator!=(const _Myt&_Right)const
		{
			return (!(*this==_Right));
		}
		bool operator<(const _Myt&_Right)const
		{
			_Compat(_Right);
			return (_Myoff<_Right._Myoff);
		}
		bool operator>(const _Myt&_Right)const
		{
			return (_Right<*this);
		}
		bool operator<=(const _Myt&_Right)const
		{
			return (!(_Right<*this));
		}
		bool operator>=(const _Myt&_Right)const
		{
			return (!(*this<_Right));
		}
		static void _Xlen()
		{
			throw length_error("deque<T> too long");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid deque <T> argument");
		}
		static void _Xran()
		{
			throw out_of_range("invalid deque <T> subscript");
		}
		void _Compat(const _Myt&_Right)const
		{
			if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
			{
				_Debug_message(L"deque iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 297);

				{
					;
					;
					if(_Secure_validation)
					{

						{
							(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 298, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
							::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 298, 0);
						}
					};
				};
			}
		}
		size_type _Myoff;
	};
	template<class _Ty, class _Alloc, bool _Secure_validation>
	inline _Deque_const_iterator<_Ty, _Alloc, _Secure_validation>operator+(typename _Deque_const_iterator<_Ty, _Alloc, _Secure_validation>::difference_type _Off, _Deque_const_iterator<_Ty, _Alloc, _Secure_validation>_Next)
	{
		return (_Next+=_Off);
	}
	template<class _Ty, class _Alloc, bool _Secure_validation>
	class _Deque_iterator: public _Deque_const_iterator<_Ty, _Alloc, _Secure_validation>
	{
	public:
		typedef _Deque_iterator<_Ty, _Alloc, _Secure_validation>_Myt;
		typedef _Deque_const_iterator<_Ty, _Alloc, _Secure_validation>_Mybase;
		typedef deque<_Ty, _Alloc>_Mydeque;
		typedef random_access_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef typename _Alloc::difference_type difference_type;
		typedef typename _Alloc::pointer pointer;
		typedef typename _Alloc::reference reference;
		typedef typename _Alloc::size_type size_type;
		typedef typename _If<_Secure_validation, _Deque_iterator<_Ty, _Alloc, false>, _Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
		friend _Deque_iterator<_Ty, _Alloc, false>;
		friend _Deque_iterator<_Ty, _Alloc, true>;
		_Deque_iterator<_Ty, _Alloc, false>_Checked_iterator_base()const
		{
			_Deque_iterator<_Ty, _Alloc, false>_Base(this->_Myoff, this->_Mycont);
			return _Base;
		}
		void _Checked_iterator_assign_from_base(_Deque_iterator<_Ty, _Alloc, false>_Base)
		{
			this->_Myoff=_Base._Myoff;
			this->_Mycont=_Base._Mycont;
		}
		_Deque_iterator()
		{
		}
		_Deque_iterator(size_type _Off, const _Container_base*_Pdeque): _Mybase(_Off, _Pdeque)
		{
		}
		reference operator*()const
		{
			return ((reference)**(_Mybase*)this);
		}
		pointer operator->()const
		{
			return (&**this);
		}
		_Myt&operator++()
		{
			++*(_Mybase*)this;
			return (*this);
		}
		_Myt operator++(int)
		{
			_Myt _Tmp=*this;
			++*this;
			return (_Tmp);
		}
		_Myt&operator--()
		{
			--*(_Mybase*)this;
			return (*this);
		}
		_Myt operator--(int)
		{
			_Myt _Tmp=*this;
			--*this;
			return (_Tmp);
		}
		_Myt&operator+=(difference_type _Off)
		{
			*(_Mybase*)this+=_Off;
			return (*this);
		}
		_Myt operator+(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp+=_Off);
		}
		_Myt&operator-=(difference_type _Off)
		{
			return (*this+=-_Off);
		}
		_Myt operator-(difference_type _Off)const
		{
			_Myt _Tmp=*this;
			return (_Tmp-=_Off);
		}
		difference_type operator-(const _Mybase&_Right)const
		{
			return (*(_Mybase*)this-_Right);
		}
		reference operator[](difference_type _Off)const
		{
			return (*(*this+_Off));
		}
	};
	template<class _Ty, class _Alloc, bool _Secure_validation>
	inline _Deque_iterator<_Ty, _Alloc, _Secure_validation>operator+(typename _Deque_iterator<_Ty, _Alloc, _Secure_validation>::difference_type _Off, _Deque_iterator<_Ty, _Alloc, _Secure_validation>_Next)
	{
		return (_Next+=_Off);
	}
	template<class _Ty, class _Alloc>
	class _Deque_map: public _Container_base
	{
		protected: _Deque_map(_Alloc _Al): _Almap(_Al)
		{
		}
		typedef typename _Alloc::template rebind<_Ty>::other::pointer _Tptr;
		typedef typename _Alloc::template rebind<_Tptr>::other _Talmap;
		_Talmap _Almap;
	};
	template<class _Ty, class _Alloc>
	class _Deque_val: public _Deque_map<_Ty, _Alloc>
	{
		protected: _Deque_val(_Alloc _Al=_Alloc()): _Deque_map<_Ty, _Alloc>(_Al), _Alval(_Al)
		{
		}
		typedef _Deque_map<_Ty, _Alloc>_Mybase;
		typedef typename _Alloc::template rebind<_Ty>::other _Alty;
		_Alty _Alval;
	};
	template<class _Ty, class _Ax>
	class deque: public _Deque_val<_Ty, _Ax>
	{
	public:
		static const int _EEM_DS=(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1);
		enum
		{
			_EEN_DS=(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1)
		};
		typedef deque<_Ty, _Ax>_Myt;
		typedef _Deque_val<_Ty, _Ax>_Mybase;
		typedef typename _Mybase::_Alty _Alloc;
		typedef _Alloc allocator_type;
		typedef typename _Mybase::_Talmap _Talmap;
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename _Alloc::pointer _Tptr;
		typedef typename _Alloc::const_pointer _Ctptr;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef typename _Alloc::template rebind<_Tptr>::other::pointer _Mapptr;
		typedef typename _Alloc::reference _Reft;
		typedef _Reft reference;
		typedef typename _Alloc::const_reference const_reference;
		typedef typename _Alloc::value_type value_type;
		typedef _Deque_iterator<_Ty, _Alloc, true>iterator;
		typedef _Deque_const_iterator<_Ty, _Alloc, true>const_iterator;
		friend class _Deque_const_iterator<_Ty, _Alloc, false>;
		friend class _Deque_const_iterator<_Ty, _Alloc, true>;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		deque(): _Mybase(), _Map(0), _Mapsize(0), _Myoff(0), _Mysize(0)
		{
		}
		explicit deque(const _Alloc&_Al): _Mybase(_Al), _Map(0), _Mapsize(0), _Myoff(0), _Mysize(0)
		{
		}
		explicit deque(size_type _Count): _Mybase(), _Map(0), _Mapsize(0), _Myoff(0), _Mysize(0)
		{
			_Construct_n(_Count, _Ty());
		}
		deque(size_type _Count, const _Ty&_Val): _Mybase(), _Map(0), _Mapsize(0), _Myoff(0), _Mysize(0)
		{
			_Construct_n(_Count, _Val);
		}
		deque(size_type _Count, const _Ty&_Val, const _Alloc&_Al): _Mybase(_Al), _Map(0), _Mapsize(0), _Myoff(0), _Mysize(0)
		{
			_Construct_n(_Count, _Val);
		}
		deque(const _Myt&_Right): _Mybase(_Right._Alval), _Map(0), _Mapsize(0), _Myoff(0), _Mysize(0)
		{
			try
			{
				insert(begin(), _Right.begin(), _Right.end());
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		template<class _It>
		deque(_It _First, _It _Last): _Mybase(), _Map(0), _Mapsize(0), _Myoff(0), _Mysize(0)
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		deque(_It _First, _It _Last, const _Alloc&_Al): _Mybase(_Al), _Map(0), _Mapsize(0), _Myoff(0), _Mysize(0)
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		void _Construct(_It _Count, _It _Val, _Int_iterator_tag)
		{
			_Construct_n((size_type)_Count, (_Ty)_Val);
		}
		template<class _It>
		void _Construct(_It _First, _It _Last, input_iterator_tag)
		{
			try
			{
				insert(begin(), _First, _Last);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		void _Construct_n(size_type _Count, const _Ty&_Val)
		{
			try
			{
				_Insert_n(begin(), _Count, _Val);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		~deque()
		{
			_Tidy();
		}
		_Myt&operator=(const _Myt&_Right)
		{
			if(this==&_Right);
			else if(_Right._Mysize==0)clear();
			else if(_Right._Mysize<=_Mysize)
			{
				iterator _Mid=std::copy(_Right.begin(), _Right.end(), begin());
				erase(_Mid, end());
			}
			else
			{
				const_iterator _Mid=_Right.begin()+_Mysize;
				std::copy(_Right.begin(), _Mid, begin());
				insert(end(), _Mid, _Right.end());
			}
			return (*this);
		}
		iterator begin()
		{
			return (iterator(_Myoff, this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Myoff, this));
		}
		iterator end()
		{
			return (iterator(_Myoff+_Mysize, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Myoff+_Mysize, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		void resize(size_type _Newsize)
		{
			resize(_Newsize, _Ty());
		}
		void resize(size_type _Newsize, _Ty _Val)
		{
			if(_Mysize<_Newsize)_Insert_n(end(), _Newsize-_Mysize, _Val);
			else if(_Newsize<_Mysize)erase(begin()+_Newsize, end());
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			return (this->_Alval.max_size());
		}
		bool empty()const
		{
			return (_Mysize==0);
		}
		allocator_type get_allocator()const
		{
			return (this->_Alval);
		}
		const_reference at(size_type _Pos)const
		{
			if(_Mysize<=_Pos)_Xran();
			return (*(begin()+_Pos));
		}
		reference at(size_type _Pos)
		{
			if(_Mysize<=_Pos)_Xran();
			return (*(begin()+_Pos));
		}
		const_reference operator[](size_type _Pos)const
		{
			if(_Mysize<=_Pos)_Debug_message(L"deque subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 729);
			return (*(begin()+_Pos));
		}
		reference operator[](size_type _Pos)
		{
			if(_Mysize<=_Pos)_Debug_message(L"deque subscript out of range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 740);
			return (*(begin()+_Pos));
		}
		reference front()
		{
			return (*begin());
		}
		const_reference front()const
		{
			return (*begin());
		}
		reference back()
		{
			return (*(end()-1));
		}
		const_reference back()const
		{
			return (*(end()-1));
		}
		void push_front(const _Ty&_Val)
		{
			this->_Orphan_all();
			if(_Myoff%(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1)==0&&_Mapsize<=(_Mysize+(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1))/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1))_Growmap(1);
			size_type _Newoff=_Myoff!=0?_Myoff: _Mapsize*(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1);
			size_type _Block=--_Newoff/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1);
			if(_Map[_Block]==0)_Map[_Block]=this->_Alval.allocate((sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1));
			this->_Alval.construct(_Map[_Block]+_Newoff%(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1), _Val);
			_Myoff=_Newoff;
			++_Mysize;
		}
		void pop_front()
		{
			if(empty())_Debug_message(L"deque empty before pop", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 791);
			else
			{
				_Orphan_off(_Myoff);
				size_type _Block=_Myoff/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1);
				this->_Alval.destroy(_Map[_Block]+_Myoff%(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1));
				if(_Mapsize*(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1)<=++_Myoff)_Myoff=0;
				if(--_Mysize==0)_Myoff=0;
			}
		}
		void push_back(const _Ty&_Val)
		{
			this->_Orphan_all();
			if((_Myoff+_Mysize)%(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1)==0&&_Mapsize<=(_Mysize+(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1))/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1))_Growmap(1);
			size_type _Newoff=_Myoff+_Mysize;
			size_type _Block=_Newoff/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1);
			if(_Mapsize<=_Block)_Block-=_Mapsize;
			if(_Map[_Block]==0)_Map[_Block]=this->_Alval.allocate((sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1));
			this->_Alval.construct(_Map[_Block]+_Newoff%(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1), _Val);
			++_Mysize;
		}
		void pop_back()
		{
			if(empty())_Debug_message(L"deque empty before pop", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 835);
			else
			{
				_Orphan_off(_Myoff+_Mysize-1);
				size_type _Newoff=_Mysize+_Myoff-1;
				size_type _Block=_Newoff/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1);
				if(_Mapsize<=_Block)_Block-=_Mapsize;
				this->_Alval.destroy(_Map[_Block]+_Newoff%(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1));
				if(--_Mysize==0)_Myoff=0;
			}
		}
		template<class _It>
		void assign(_It _First, _It _Last)
		{
			_Assign(_First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		void _Assign(_It _Count, _It _Val, _Int_iterator_tag)
		{
			_Assign_n((size_type)_Count, (_Ty)_Val);
		}
		template<class _It>
		void _Assign(_It _First, _It _Last, input_iterator_tag)
		{
			erase(begin(), end());
			insert(begin(), _First, _Last);
		}
		void assign(size_type _Count, const _Ty&_Val)
		{
			_Assign_n(_Count, _Val);
		}
		iterator insert(iterator _Where, const _Ty&_Val)
		{
			if(_Where==begin())
			{
				push_front(_Val);
				return (begin());
			}
			else if(_Where==end())
			{
				push_back(_Val);
				return (end()-1);
			}
			else
			{
				iterator _Mid;
				size_type _Off=_Where-begin();
				_Ty _Tmp=_Val;
				if(_Mysize<_Off)_Debug_message(L"deque insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 899);
				if(_Off<_Mysize/2)
				{
					push_front(front());
					_Mid=begin()+_Off;
					std::copy(begin()+2, _Mid+1, begin()+1);
				}
				else
				{
					push_back(back());
					_Mid=begin()+_Off;
					copy_backward(_Mid, end()-2, end()-1);
				}
				*_Mid=_Tmp;
				return (_Mid);
			}
		}
		void insert(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			_Insert_n(_Where, _Count, _Val);
		}
		template<class _It>
		void insert(iterator _Where, _It _First, _It _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _It>
		void _Insert(iterator _Where, _It _Count, _It _Val, _Int_iterator_tag)
		{
			_Insert_n(_Where, (size_type)_Count, (_Ty)_Val);
		}
		template<class _It>
		void _Insert(iterator _Where, _It _First, _It _Last, input_iterator_tag)
		{
			size_type _Off=_Where-begin();
			for(;
			_First!=_Last;
			++_First, ++_Off)insert(begin()+_Off, *_First);
		}
		template<class _It>
		void _Insert(iterator _Where, _It _First, _It _Last, bidirectional_iterator_tag)
		{
			size_type _Off=_Where-begin();
			if(_Mysize<_Off)_Debug_message(L"deque insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 955);
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 956);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"deque insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 958);
			size_type _Rem=_Mysize-_Off;
			size_type _Oldsize=_Mysize;
			size_type _Count=0;
			_Distance(_First, _Last, _Count);
			size_type _Num;
			if(_Off<_Rem)
			{
				try
				{
					if(_Off<_Count)
					{
						_It _Mid=_First;
						advance(_Mid, _Count-_Off);
						for(_It _Next=_Mid;
						_First!=_Next;
						)push_front(*--_Next);
						for(_Num=_Off;
						0<_Num;
						--_Num)push_front(begin()[_Count-1]);
						std::copy(_Mid, _Last, begin()+_Count);
					}
					else
					{
						for(_Num=_Count;
						0<_Num;
						--_Num)push_front(begin()[_Count-1]);
						iterator _Mid=begin()+_Count;
						std::copy(_Mid+_Count, _Mid+_Off, _Mid);
						std::copy(_First, _Last, begin()+_Off);
					}
				}
				catch(...)
				{
					for(;
					_Oldsize<_Mysize;
					)pop_front();
					throw;
				}
			}
			else
			{
				try
				{
					if(_Rem<_Count)
					{
						_It _Mid=_First;
						advance(_Mid, _Rem);
						for(_It _Next=_Mid;
						_Next!=_Last;
						++_Next)push_back(*_Next);
						for(_Num=0;
						_Num<_Rem;
						++_Num)push_back(begin()[_Off+_Num]);
						std::copy(_First, _Mid, begin()+_Off);
					}
					else
					{
						for(_Num=0;
						_Num<_Count;
						++_Num)push_back(begin()[_Off+_Rem-_Count+_Num]);
						iterator _Mid=begin()+_Off;
						copy_backward(_Mid, _Mid+_Rem-_Count, _Mid+_Rem);
						std::copy(_First, _Last, _Mid);
					}
				}
				catch(...)
				{
					for(;
					_Oldsize<_Mysize;
					)pop_back();
					throw;
				}
			}
		}
		iterator erase(iterator _Where)
		{
			return (erase(_Where, _Where+1));
		}
		iterator erase(iterator _First, iterator _Last)
		{
			if(_Last<_First||_First<begin()||end()<_Last)_Debug_message(L"deque erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 1045);
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 1046);
			size_type _Off=_First-begin();
			size_type _Count=_Last-_First;
			bool _Moved=0<_Off&&_Off+_Count<_Mysize;
			if(_Off<(size_type)(end()-_Last))
			{
				copy_backward(begin(), _First, _Last);
				for(;
				0<_Count;
				--_Count)pop_front();
			}
			else
			{
				std::copy(_Last, end(), _First);
				for(;
				0<_Count;
				--_Count)pop_back();
			}
			if(_Moved)this->_Orphan_all();
			return (begin()+_Off);
		}
		void clear()
		{
			_Tidy();
		}
		void swap(_Myt&_Right)
		{
			if(this->_Alval==_Right._Alval)
			{
				this->_Swap_all(_Right);
				std::swap(_Map, _Right._Map);
				std::swap(_Mapsize, _Right._Mapsize);
				std::swap(_Myoff, _Right._Myoff);
				std::swap(_Mysize, _Right._Mysize);
			}
			else
			{
				_Myt _Ts=*this;
				*this=_Right, _Right=_Ts;
			}
		}
		protected: void _Assign_n(size_type _Count, const _Ty&_Val)
		{
			_Ty _Tmp=_Val;
			erase(begin(), end());
			_Insert_n(begin(), _Count, _Tmp);
		}
		void _Insert_n(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			iterator _Mid;
			size_type _Num;
			size_type _Off=_Where-begin();
			size_type _Rem=_Mysize-_Off;
			size_type _Oldsize=_Mysize;
			if(_Mysize<_Off)_Debug_message(L"deque insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 1122);
			if(_Off<_Rem)
			{
				try
				{
					if(_Off<_Count)
					{
						for(_Num=_Count-_Off;
						0<_Num;
						--_Num)push_front(_Val);
						for(_Num=_Off;
						0<_Num;
						--_Num)push_front(begin()[_Count-1]);
						_Mid=begin()+_Count;
						fill(_Mid, _Mid+_Off, _Val);
					}
					else
					{
						for(_Num=_Count;
						0<_Num;
						--_Num)push_front(begin()[_Count-1]);
						_Mid=begin()+_Count;
						_Ty _Tmp=_Val;
						std::copy(_Mid+_Count, _Mid+_Off, _Mid);
						fill(begin()+_Off, _Mid+_Off, _Tmp);
					}
				}
				catch(...)
				{
					for(;
					_Oldsize<_Mysize;
					)pop_front();
					throw;
				}
			}
			else
			{
				try
				{
					if(_Rem<_Count)
					{
						for(_Num=_Count-_Rem;
						0<_Num;
						--_Num)push_back(_Val);
						for(_Num=0;
						_Num<_Rem;
						++_Num)push_back(begin()[_Off+_Num]);
						_Mid=begin()+_Off;
						fill(_Mid, _Mid+_Rem, _Val);
					}
					else
					{
						for(_Num=0;
						_Num<_Count;
						++_Num)push_back(begin()[_Off+_Rem-_Count+_Num]);
						_Mid=begin()+_Off;
						_Ty _Tmp=_Val;
						copy_backward(_Mid, _Mid+_Rem-_Count, _Mid+_Rem);
						fill(_Mid, _Mid+_Count, _Tmp);
					}
				}
				catch(...)
				{
					for(;
					_Oldsize<_Mysize;
					)pop_back();
					throw;
				}
			}
		}
		static void _Xlen()
		{
			throw length_error("deque<T> too long");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid deque <T> argument");
		}
		static void _Xran()
		{
			throw out_of_range("invalid deque <T> subscript");
		}
		void _Growmap(size_type _Count)
		{
			if(max_size()/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1)-_Mapsize<_Count)_Xlen();
			size_type _Inc=_Mapsize/2;
			if(_Inc<8)_Inc=8;
			if(_Count<_Inc&&_Mapsize<=max_size()/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1)-_Inc)_Count=_Inc;
			size_type _Myboff=_Myoff/(sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1);
			_Mapptr _Newmap=this->_Almap.allocate(_Mapsize+_Count);
			_Mapptr _Myptr=_Newmap+_Myboff;
			_Myptr=::stdext::unchecked_uninitialized_copy(_Map+_Myboff, _Map+_Mapsize, _Myptr, this->_Almap);
			if(_Myboff<=_Count)
			{
				_Myptr=::stdext::unchecked_uninitialized_copy(_Map, _Map+_Myboff, _Myptr, this->_Almap);
				::stdext::unchecked_uninitialized_fill_n(_Myptr, _Count-_Myboff, (_Tptr)0, this->_Almap);
				::stdext::unchecked_uninitialized_fill_n(_Newmap, _Myboff, (_Tptr)0, this->_Almap);
			}
			else
			{
				::stdext::unchecked_uninitialized_copy(_Map, _Map+_Count, _Myptr, this->_Almap);
				_Myptr=::stdext::unchecked_uninitialized_copy(_Map+_Count, _Map+_Myboff, _Newmap, this->_Almap);
				::stdext::unchecked_uninitialized_fill_n(_Myptr, _Count, (_Tptr)0, this->_Almap);
			}
			_Destroy_range(_Map+_Myboff, _Map+_Mapsize, this->_Almap);
			if(_Map)this->_Almap.deallocate(_Map, _Mapsize);
			_Map=_Newmap;
			_Mapsize+=_Count;
		}
		void _Tidy()
		{
			while(!empty())pop_back();
			for(size_type _Count=_Mapsize;
			0<_Count;
			)
			{
				if(*(_Map+--_Count)!=0)this->_Alval.deallocate(*(_Map+_Count), (sizeof(_Ty)<=1?16: sizeof(_Ty)<=2?8: sizeof(_Ty)<=4?4: sizeof(_Ty)<=8?2: 1));
				this->_Almap.destroy(_Map+_Count);
			}
			if(_Map)this->_Almap.deallocate(_Map, _Mapsize);
			_Mapsize=0;
			_Map=0;
		}
		void _Orphan_off(size_type _Offlo)const
		{
			if(_Mysize==0)_Debug_message(L"deque empty before pop", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\deque", 1267);
			size_type _Offhigh=_Myoff+_Mysize<=_Offlo+1?(size_type)(-1): _Offlo;
			if(_Offlo==_Myoff)_Offlo=0;
			_Lockit _Lock(3);
			const_iterator**_Pnext=(const_iterator**)&this->_Myfirstiter;
			while(*_Pnext!=0)if((*_Pnext)->_Myoff<_Offlo||_Offhigh<(*_Pnext)->_Myoff)_Pnext=(const_iterator**)&(*_Pnext)->_Mynextiter;
			else
			{
				(*_Pnext)->_Mycont=0;
				*_Pnext=(const_iterator*)(*_Pnext)->_Mynextiter;
			}
		}
		_Mapptr _Map;
		size_type _Mapsize;
		size_type _Myoff;
		size_type _Mysize;
	};
	template<class _Ty, class _Ax>
	class _Move_operation_category<deque<_Ty, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Ty, class _Alloc>
	inline void swap(deque<_Ty, _Alloc>&_Left, deque<_Ty, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	template<class _Ty, class _Alloc>
	inline bool operator==(const deque<_Ty, _Alloc>&_Left, const deque<_Ty, _Alloc>&_Right)
	{
		return (_Left.size()==_Right.size()&&equal(_Left.begin(), _Left.end(), _Right.begin()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator!=(const deque<_Ty, _Alloc>&_Left, const deque<_Ty, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty, class _Alloc>
	inline bool operator<(const deque<_Ty, _Alloc>&_Left, const deque<_Ty, _Alloc>&_Right)
	{
		return (lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator<=(const deque<_Ty, _Alloc>&_Left, const deque<_Ty, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>(const deque<_Ty, _Alloc>&_Left, const deque<_Ty, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Ty, class _Alloc>
	inline bool operator>=(const deque<_Ty, _Alloc>&_Left, const deque<_Ty, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
}
namespace std
{
	template<class _Ty, class _Container=deque<_Ty> >
	class stack
	{
	public:
		typedef _Container container_type;
		typedef typename _Container::value_type value_type;
		typedef typename _Container::size_type size_type;
		typedef typename _Container::reference reference;
		typedef typename _Container::const_reference const_reference;
		stack(): c()
		{
		}
		explicit stack(const _Container&_Cont): c(_Cont)
		{
		}
		bool empty()const
		{
			return (c.empty());
		}
		size_type size()const
		{
			return (c.size());
		}
		reference top()
		{
			return (c.back());
		}
		const_reference top()const
		{
			return (c.back());
		}
		void push(const value_type&_Val)
		{
			c.push_back(_Val);
		}
		void pop()
		{
			c.pop_back();
		}
		_Container c;
	};
	template<class _Ty, class _Container>
	inline bool operator==(const stack<_Ty, _Container>&_Left, const stack<_Ty, _Container>&_Right)
	{
		return (_Left.c==_Right.c);
	}
	template<class _Ty, class _Container>
	inline bool operator!=(const stack<_Ty, _Container>&_Left, const stack<_Ty, _Container>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty, class _Container>
	inline bool operator<(const stack<_Ty, _Container>&_Left, const stack<_Ty, _Container>&_Right)
	{
		return (_Left.c<_Right.c);
	}
	template<class _Ty, class _Container>
	inline bool operator>(const stack<_Ty, _Container>&_Left, const stack<_Ty, _Container>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Ty, class _Container>
	inline bool operator<=(const stack<_Ty, _Container>&_Left, const stack<_Ty, _Container>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Ty, class _Container>
	inline bool operator>=(const stack<_Ty, _Container>&_Left, const stack<_Ty, _Container>&_Right)
	{
		return (!(_Left<_Right));
	}
}
namespace boost
{
	namespace concept
	{
		namespace detail
		{
			typedef char yes;
			typedef char(&no)[2];
			template<class Model, void(Model::*)()>
			struct wrap_constraints
			{
			};
			template<class Model>
			inline yes has_constraints_(Model*, wrap_constraints<Model, &Model::constraints>* =0);
			inline no has_constraints_(...);
		}
		template<class Model>
		struct not_satisfied
		{
			static const bool value=sizeof(detail::has_constraints_((Model*)0))==sizeof(detail::yes);
			typedef mpl::bool_<value>type;
		};
	}
}
namespace boost
{
	namespace concept
	{
		template<class Model>
		struct check
		{
			virtual void failed(Model*x)
			{
				x->~Model();
			}
		};
		namespace detail
		{
			struct constraint
			{
			};
		}
		template<class Model>
		struct require: mpl::if_c<not_satisfied<Model>::value, detail::constraint, check<Model> >::type
		{
		};
		template<class Model>
		require<Model>require_(void(*)(Model));
	}
}
namespace boost
{
	namespace concept
	{
		template<class Model>
		struct usage_requirements
		{
			~usage_requirements()
			{
				((Model*)0)->~Model();
			}
		};
	}
}
namespace boost
{
	template<class Model>
	inline void function_requires(Model* =0)
	{
		enum
		{
			boost_concept_check43=sizeof(::boost::concept::require_((void(*)(Model))0))
		};
	}
	template<class T>
	inline void ignore_unused_variable_warning(T const&)
	{
	}
	template<typename T>
	struct Integer;
	template<typename T>
	struct IntegerConcept: Integer<T>
	{
	};
	template<typename T>
	struct Integer
	{
		enum
		{
			boost_concept_check65=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Integer>))0))
		};
		~Integer()
		{
			x.error_type_must_be_an_integer_type();
		}
	private:
		T x;
	};
	template<>
	struct Integer<signed char>
	{
	};
	template<>
	struct Integer<unsigned char>
	{
	};
	template<>
	struct Integer<short>
	{
	};
	template<>
	struct Integer<unsigned short>
	{
	};
	template<>
	struct Integer<int>
	{
	};
	template<>
	struct Integer<unsigned int>
	{
	};
	template<>
	struct Integer<long>
	{
	};
	template<>
	struct Integer<unsigned long>
	{
	};
	template<>
	struct Integer<__int64>
	{
	};
	template<>
	struct Integer<unsigned __int64>
	{
	};
	template<typename T>
	struct SignedInteger;
	template<typename T>
	struct SignedIntegerConcept: SignedInteger<T>
	{
	};
	template<typename T>
	struct SignedInteger
	{
		enum
		{
			boost_concept_check90=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<SignedInteger>))0))
		};
		~SignedInteger()
		{
			x.error_type_must_be_a_signed_integer_type();
		}
	private:
		T x;
	};
	template<>
	struct SignedInteger<signed char>
	{
	};
	template<>
	struct SignedInteger<short>
	{
	};
	template<>
	struct SignedInteger<int>
	{
	};
	template<>
	struct SignedInteger<long>
	{
	};
	template<>
	struct SignedInteger<__int64>
	{
	};
	template<typename T>
	struct UnsignedInteger;
	template<typename T>
	struct UnsignedIntegerConcept: UnsignedInteger<T>
	{
	};
	template<typename T>
	struct UnsignedInteger
	{
		enum
		{
			boost_concept_check107=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<UnsignedInteger>))0))
		};
		~UnsignedInteger()
		{
			x.error_type_must_be_an_unsigned_integer_type();
		}
	private:
		T x;
	};
	template<>
	struct UnsignedInteger<unsigned char>
	{
	};
	template<>
	struct UnsignedInteger<unsigned short>
	{
	};
	template<>
	struct UnsignedInteger<unsigned int>
	{
	};
	template<>
	struct UnsignedInteger<unsigned long>
	{
	};
	template<>
	struct UnsignedInteger<unsigned __int64>
	{
	};
	template<typename TT>
	struct DefaultConstructible;
	template<typename TT>
	struct DefaultConstructibleConcept: DefaultConstructible<TT>
	{
	};
	template<typename TT>
	struct DefaultConstructible
	{
		enum
		{
			boost_concept_check129=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<DefaultConstructible>))0))
		};
		~DefaultConstructible()
		{
			TT a;
			ignore_unused_variable_warning(a);
		}
	};
	template<typename TT>
	struct Assignable;
	template<typename TT>
	struct AssignableConcept: Assignable<TT>
	{
	};
	template<typename TT>
	struct Assignable
	{
		enum
		{
			boost_concept_check137=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Assignable>))0))
		};
		~Assignable()
		{
			const_constraints(a);
		}
	private:
		void const_constraints(const TT&b)
		{
			ignore_unused_variable_warning(b);
		}
	private:
		TT a;
	};
	template<typename TT>
	struct CopyConstructible;
	template<typename TT>
	struct CopyConstructibleConcept: CopyConstructible<TT>
	{
	};
	template<typename TT>
	struct CopyConstructible
	{
		enum
		{
			boost_concept_check158=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<CopyConstructible>))0))
		};
		~CopyConstructible()
		{
			TT a(b);
			TT*ptr=&a;
			const_constraints(a);
			ignore_unused_variable_warning(ptr);
		}
	private:
		void const_constraints(const TT&a)
		{
			TT c(a);
			const TT*ptr=&a;
			ignore_unused_variable_warning(c);
			ignore_unused_variable_warning(ptr);
		}
		TT b;
	};
	template<typename TT>
	struct SGIAssignable;
	template<typename TT>
	struct SGIAssignableConcept: SGIAssignable<TT>
	{
	};
	template<typename TT>
	struct SGIAssignable
	{
		enum
		{
			boost_concept_check182=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<SGIAssignable>))0))
		};
		~SGIAssignable()
		{
			TT b(a);
			const_constraints(a);
			ignore_unused_variable_warning(b);
		}
	private:
		void const_constraints(const TT&b)
		{
			TT c(b);
			ignore_unused_variable_warning(c);
		}
		TT a;
	};
	template<typename X, typename Y>
	struct Convertible;
	template<typename X, typename Y>
	struct ConvertibleConcept: Convertible<X, Y>
	{
	};
	template<typename X, typename Y>
	struct Convertible
	{
		enum
		{
			boost_concept_check206=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Convertible>))0))
		};
		~Convertible()
		{
			Y y=x;
			ignore_unused_variable_warning(y);
		}
	private:
		X x;
	};
	template<class TT>
	void require_boolean_expr(const TT&t)
	{
		bool x=t;
		ignore_unused_variable_warning(x);
	}
	template<typename TT>
	struct EqualityComparable;
	template<typename TT>
	struct EqualityComparableConcept: EqualityComparable<TT>
	{
	};
	template<typename TT>
	struct EqualityComparable
	{
		enum
		{
			boost_concept_check231=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<EqualityComparable>))0))
		};
		~EqualityComparable()
		{
			require_boolean_expr(a==b);
			require_boolean_expr(a!=b);
		}
	private:
		TT a, b;
	};
	template<typename TT>
	struct LessThanComparable;
	template<typename TT>
	struct LessThanComparableConcept: LessThanComparable<TT>
	{
	};
	template<typename TT>
	struct LessThanComparable
	{
		enum
		{
			boost_concept_check241=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<LessThanComparable>))0))
		};
		~LessThanComparable()
		{
			require_boolean_expr(a<b);
		}
	private:
		TT a, b;
	};
	template<typename TT>
	struct Comparable;
	template<typename TT>
	struct ComparableConcept: Comparable<TT>
	{
	};
	template<typename TT>
	struct Comparable
	{
		enum
		{
			boost_concept_check251=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Comparable>))0))
		};
		~Comparable()
		{
			require_boolean_expr(a<b);
			require_boolean_expr(a>b);
			require_boolean_expr(a<=b);
			require_boolean_expr(a>=b);
		}
	private:
		TT a, b;
	};
	template<typename First, typename Second>
	struct EqualOp;
	template<typename First, typename Second>
	struct EqualOpConcept: EqualOp<First, Second>
	{
	};
	template<typename First, typename Second>
	struct EqualOp
	{
		enum
		{
			boost_concept_check281=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<EqualOp>))0))
		};
		~EqualOp()
		{
			(void)constraints_();
		}
	private:
		bool constraints_()
		{
			return a==b;
		}
		First a;
		Second b;
	};
	template<typename First, typename Second>
	struct NotEqualOp;
	template<typename First, typename Second>
	struct NotEqualOpConcept: NotEqualOp<First, Second>
	{
	};
	template<typename First, typename Second>
	struct NotEqualOp
	{
		enum
		{
			boost_concept_check282=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<NotEqualOp>))0))
		};
		~NotEqualOp()
		{
			(void)constraints_();
		}
	private:
		bool constraints_()
		{
			return a!=b;
		}
		First a;
		Second b;
	};
	template<typename First, typename Second>
	struct LessThanOp;
	template<typename First, typename Second>
	struct LessThanOpConcept: LessThanOp<First, Second>
	{
	};
	template<typename First, typename Second>
	struct LessThanOp
	{
		enum
		{
			boost_concept_check283=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<LessThanOp>))0))
		};
		~LessThanOp()
		{
			(void)constraints_();
		}
	private:
		bool constraints_()
		{
			return a<b;
		}
		First a;
		Second b;
	};
	template<typename First, typename Second>
	struct LessEqualOp;
	template<typename First, typename Second>
	struct LessEqualOpConcept: LessEqualOp<First, Second>
	{
	};
	template<typename First, typename Second>
	struct LessEqualOp
	{
		enum
		{
			boost_concept_check284=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<LessEqualOp>))0))
		};
		~LessEqualOp()
		{
			(void)constraints_();
		}
	private:
		bool constraints_()
		{
			return a<=b;
		}
		First a;
		Second b;
	};
	template<typename First, typename Second>
	struct GreaterThanOp;
	template<typename First, typename Second>
	struct GreaterThanOpConcept: GreaterThanOp<First, Second>
	{
	};
	template<typename First, typename Second>
	struct GreaterThanOp
	{
		enum
		{
			boost_concept_check285=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<GreaterThanOp>))0))
		};
		~GreaterThanOp()
		{
			(void)constraints_();
		}
	private:
		bool constraints_()
		{
			return a>b;
		}
		First a;
		Second b;
	};
	template<typename First, typename Second>
	struct GreaterEqualOp;
	template<typename First, typename Second>
	struct GreaterEqualOpConcept: GreaterEqualOp<First, Second>
	{
	};
	template<typename First, typename Second>
	struct GreaterEqualOp
	{
		enum
		{
			boost_concept_check286=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<GreaterEqualOp>))0))
		};
		~GreaterEqualOp()
		{
			(void)constraints_();
		}
	private:
		bool constraints_()
		{
			return a>=b;
		}
		First a;
		Second b;
	};
	template<typename Ret, typename First, typename Second>
	struct PlusOp;
	template<typename Ret, typename First, typename Second>
	struct PlusOpConcept: PlusOp<Ret, First, Second>
	{
	};
	template<typename Ret, typename First, typename Second>
	struct PlusOp
	{
		enum
		{
			boost_concept_check288=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<PlusOp>))0))
		};
		~PlusOp()
		{
			(void)constraints_();
		}
	private:
		Ret constraints_()
		{
			return a+b;
		}
		First a;
		Second b;
	};
	template<typename Ret, typename First, typename Second>
	struct TimesOp;
	template<typename Ret, typename First, typename Second>
	struct TimesOpConcept: TimesOp<Ret, First, Second>
	{
	};
	template<typename Ret, typename First, typename Second>
	struct TimesOp
	{
		enum
		{
			boost_concept_check289=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<TimesOp>))0))
		};
		~TimesOp()
		{
			(void)constraints_();
		}
	private:
		Ret constraints_()
		{
			return a*b;
		}
		First a;
		Second b;
	};
	template<typename Ret, typename First, typename Second>
	struct DivideOp;
	template<typename Ret, typename First, typename Second>
	struct DivideOpConcept: DivideOp<Ret, First, Second>
	{
	};
	template<typename Ret, typename First, typename Second>
	struct DivideOp
	{
		enum
		{
			boost_concept_check290=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<DivideOp>))0))
		};
		~DivideOp()
		{
			(void)constraints_();
		}
	private:
		Ret constraints_()
		{
			return a/b;
		}
		First a;
		Second b;
	};
	template<typename Ret, typename First, typename Second>
	struct SubtractOp;
	template<typename Ret, typename First, typename Second>
	struct SubtractOpConcept: SubtractOp<Ret, First, Second>
	{
	};
	template<typename Ret, typename First, typename Second>
	struct SubtractOp
	{
		enum
		{
			boost_concept_check291=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<SubtractOp>))0))
		};
		~SubtractOp()
		{
			(void)constraints_();
		}
	private:
		Ret constraints_()
		{
			return a-b;
		}
		First a;
		Second b;
	};
	template<typename Ret, typename First, typename Second>
	struct ModOp;
	template<typename Ret, typename First, typename Second>
	struct ModOpConcept: ModOp<Ret, First, Second>
	{
	};
	template<typename Ret, typename First, typename Second>
	struct ModOp
	{
		enum
		{
			boost_concept_check292=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<ModOp>))0))
		};
		~ModOp()
		{
			(void)constraints_();
		}
	private:
		Ret constraints_()
		{
			return a%b;
		}
		First a;
		Second b;
	};
	template<typename Func, typename Return>
	struct Generator;
	template<typename Func, typename Return>
	struct GeneratorConcept: Generator<Func, Return>
	{
	};
	template<typename Func, typename Return>
	struct Generator
	{
		enum
		{
			boost_concept_check299=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Generator>))0))
		};
		~Generator()
		{
			test(is_void<Return>());
		}
	private:
		void test(boost::mpl::false_)
		{
			const Return&r=f();
			ignore_unused_variable_warning(r);
		}
		void test(boost::mpl::true_)
		{
			f();
		}
		Func f;
	};
	template<typename Func, typename Return, typename Arg>
	struct UnaryFunction;
	template<typename Func, typename Return, typename Arg>
	struct UnaryFunctionConcept: UnaryFunction<Func, Return, Arg>
	{
	};
	template<typename Func, typename Return, typename Arg>
	struct UnaryFunction
	{
		enum
		{
			boost_concept_check319=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<UnaryFunction>))0))
		};
		~UnaryFunction()
		{
			test(is_void<Return>());
		}
	private:
		void test(boost::mpl::false_)
		{
			f(arg);
			Return r=f(arg);
			ignore_unused_variable_warning(r);
		}
		void test(boost::mpl::true_)
		{
			f(arg);
		}
		Func f;
		Arg arg;
	};
	template<typename Func, typename Return, typename First, typename Second>
	struct BinaryFunction;
	template<typename Func, typename Return, typename First, typename Second>
	struct BinaryFunctionConcept: BinaryFunction<Func, Return, First, Second>
	{
	};
	template<typename Func, typename Return, typename First, typename Second>
	struct BinaryFunction
	{
		enum
		{
			boost_concept_check340=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<BinaryFunction>))0))
		};
		~BinaryFunction()
		{
			test(is_void<Return>());
		}
	private:
		void test(boost::mpl::false_)
		{
			f(first, second);
			Return r=f(first, second);
			(void)r;
		}
		void test(boost::mpl::true_)
		{
			f(first, second);
		}
		Func f;
		First first;
		Second second;
	};
	template<typename Func, typename Arg>
	struct UnaryPredicate;
	template<typename Func, typename Arg>
	struct UnaryPredicateConcept: UnaryPredicate<Func, Arg>
	{
	};
	template<typename Func, typename Arg>
	struct UnaryPredicate
	{
		enum
		{
			boost_concept_check361=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<UnaryPredicate>))0))
		};
		~UnaryPredicate()
		{
			require_boolean_expr(f(arg));
		}
	private:
		Func f;
		Arg arg;
	};
	template<typename Func, typename First, typename Second>
	struct BinaryPredicate;
	template<typename Func, typename First, typename Second>
	struct BinaryPredicateConcept: BinaryPredicate<Func, First, Second>
	{
	};
	template<typename Func, typename First, typename Second>
	struct BinaryPredicate
	{
		enum
		{
			boost_concept_check371=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<BinaryPredicate>))0))
		};
		~BinaryPredicate()
		{
			require_boolean_expr(f(a, b));
		}
	private:
		Func f;
		First a;
		Second b;
	};
	template<typename Func, typename First, typename Second>
	struct Const_BinaryPredicate;
	template<typename Func, typename First, typename Second>
	struct Const_BinaryPredicateConcept: Const_BinaryPredicate<Func, First, Second>
	{
	};
	template<typename Func, typename First, typename Second>
	struct Const_BinaryPredicate: BinaryPredicate<Func, First, Second>
	{
		enum
		{
			boost_concept_check384=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Const_BinaryPredicate>))0))
		};
		~Const_BinaryPredicate()
		{
			const_constraints(f);
		}
	private:
		void const_constraints(const Func&fun)
		{
			require_boolean_expr(fun(a, b));
		}
		Func f;
		First a;
		Second b;
	};
	template<typename Func, typename Return>
	struct AdaptableGenerator;
	template<typename Func, typename Return>
	struct AdaptableGeneratorConcept: AdaptableGenerator<Func, Return>
	{
	};
	template<typename Func, typename Return>
	struct AdaptableGenerator: Generator<Func, typename Func::result_type>
	{
		typedef typename Func::result_type result_type;
		enum
		{
			boost_concept_check402=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<AdaptableGenerator>))0))
		};
		~AdaptableGenerator()
		{
			enum
			{
				boost_concept_check404=sizeof(::boost::concept::require_((void(*)(Convertible<result_type, Return>))0))
			};
		}
	};
	template<typename Func, typename Return, typename Arg>
	struct AdaptableUnaryFunction;
	template<typename Func, typename Return, typename Arg>
	struct AdaptableUnaryFunctionConcept: AdaptableUnaryFunction<Func, Return, Arg>
	{
	};
	template<typename Func, typename Return, typename Arg>
	struct AdaptableUnaryFunction: UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
	{
		typedef typename Func::argument_type argument_type;
		typedef typename Func::result_type result_type;
		~AdaptableUnaryFunction()
		{
			enum
			{
				boost_concept_check416=sizeof(::boost::concept::require_((void(*)(Convertible<result_type, Return>))0))
			};
			enum
			{
				boost_concept_check417=sizeof(::boost::concept::require_((void(*)(Convertible<Arg, argument_type>))0))
			};
		}
	};
	template<typename Func, typename Return, typename First, typename Second>
	struct AdaptableBinaryFunction;
	template<typename Func, typename Return, typename First, typename Second>
	struct AdaptableBinaryFunctionConcept: AdaptableBinaryFunction<Func, Return, First, Second>
	{
	};
	template<typename Func, typename Return, typename First, typename Second>
	struct AdaptableBinaryFunction: BinaryFunction<Func, typename Func::result_type, typename Func::first_argument_type, typename Func::second_argument_type>
	{
		typedef typename Func::first_argument_type first_argument_type;
		typedef typename Func::second_argument_type second_argument_type;
		typedef typename Func::result_type result_type;
		~AdaptableBinaryFunction()
		{
			enum
			{
				boost_concept_check435=sizeof(::boost::concept::require_((void(*)(Convertible<result_type, Return>))0))
			};
			enum
			{
				boost_concept_check436=sizeof(::boost::concept::require_((void(*)(Convertible<First, first_argument_type>))0))
			};
			enum
			{
				boost_concept_check437=sizeof(::boost::concept::require_((void(*)(Convertible<Second, second_argument_type>))0))
			};
		}
	};
	template<typename Func, typename Arg>
	struct AdaptablePredicate;
	template<typename Func, typename Arg>
	struct AdaptablePredicateConcept: AdaptablePredicate<Func, Arg>
	{
	};
	template<typename Func, typename Arg>
	struct AdaptablePredicate: UnaryPredicate<Func, Arg>, AdaptableUnaryFunction<Func, bool, Arg>
	{
	};
	template<typename Func, typename First, typename Second>
	struct AdaptableBinaryPredicate;
	template<typename Func, typename First, typename Second>
	struct AdaptableBinaryPredicateConcept: AdaptableBinaryPredicate<Func, First, Second>
	{
	};
	template<typename Func, typename First, typename Second>
	struct AdaptableBinaryPredicate: BinaryPredicate<Func, First, Second>, AdaptableBinaryFunction<Func, bool, First, Second>
	{
	};
	template<typename TT>
	struct InputIterator;
	template<typename TT>
	struct InputIteratorConcept: InputIterator<TT>
	{
	};
	template<typename TT>
	struct InputIterator: Assignable<TT>, EqualityComparable<TT>
	{
		typedef typename boost::detail::iterator_traits<TT>::value_type value_type;
		typedef typename boost::detail::iterator_traits<TT>::difference_type difference_type;
		typedef typename boost::detail::iterator_traits<TT>::reference reference;
		typedef typename boost::detail::iterator_traits<TT>::pointer pointer;
		typedef typename boost::detail::iterator_traits<TT>::iterator_category iterator_category;
		enum
		{
			boost_concept_check466=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<InputIterator>))0))
		};
		~InputIterator()
		{
			enum
			{
				boost_concept_check468=sizeof(::boost::concept::require_((void(*)(SignedInteger<difference_type>))0))
			};
			enum
			{
				boost_concept_check469=sizeof(::boost::concept::require_((void(*)(Convertible<iterator_category, std::input_iterator_tag>))0))
			};
			TT j(i);
			(void)*i;
			++j;
			i++;
		}
	private:
		TT i;
	};
	template<typename TT, typename ValueT>
	struct OutputIterator;
	template<typename TT, typename ValueT>
	struct OutputIteratorConcept: OutputIterator<TT, ValueT>
	{
	};
	template<typename TT, typename ValueT>
	struct OutputIterator: Assignable<TT>
	{
		enum
		{
			boost_concept_check483=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<OutputIterator>))0))
		};
		~OutputIterator()
		{
			++i;
			i++;
			*i++=t;
		}
	private:
		TT i, j;
		ValueT t;
	};
	template<typename TT>
	struct ForwardIterator;
	template<typename TT>
	struct ForwardIteratorConcept: ForwardIterator<TT>
	{
	};
	template<typename TT>
	struct ForwardIterator: InputIterator<TT>
	{
		enum
		{
			boost_concept_check497=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<ForwardIterator>))0))
		};
		~ForwardIterator()
		{
			enum
			{
				boost_concept_check499=sizeof(::boost::concept::require_((void(*)(Convertible<typename ForwardIterator::iterator_category, std::forward_iterator_tag>))0))
			};
			typename InputIterator<TT>::reference r=*i;
			ignore_unused_variable_warning(r);
		}
	private:
		TT i;
	};
	template<typename TT>
	struct Mutable_ForwardIterator;
	template<typename TT>
	struct Mutable_ForwardIteratorConcept: Mutable_ForwardIterator<TT>
	{
	};
	template<typename TT>
	struct Mutable_ForwardIterator: ForwardIterator<TT>
	{
		enum
		{
			boost_concept_check515=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Mutable_ForwardIterator>))0))
		};
		~Mutable_ForwardIterator()
		{
			*i++=*i;
		}
	private:
		TT i;
	};
	template<typename TT>
	struct BidirectionalIterator;
	template<typename TT>
	struct BidirectionalIteratorConcept: BidirectionalIterator<TT>
	{
	};
	template<typename TT>
	struct BidirectionalIterator: ForwardIterator<TT>
	{
		enum
		{
			boost_concept_check525=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<BidirectionalIterator>))0))
		};
		~BidirectionalIterator()
		{
			enum
			{
				boost_concept_check527=sizeof(::boost::concept::require_((void(*)(Convertible<typename BidirectionalIterator::iterator_category, std::bidirectional_iterator_tag>))0))
			};
			--i;
			i--;
		}
	private:
		TT i;
	};
	template<typename TT>
	struct Mutable_BidirectionalIterator;
	template<typename TT>
	struct Mutable_BidirectionalIteratorConcept: Mutable_BidirectionalIterator<TT>
	{
	};
	template<typename TT>
	struct Mutable_BidirectionalIterator: BidirectionalIterator<TT>, Mutable_ForwardIterator<TT>
	{
		enum
		{
			boost_concept_check543=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Mutable_BidirectionalIterator>))0))
		};
		~Mutable_BidirectionalIterator()
		{
			*i--=*i;
		}
	private:
		TT i;
	};
	template<typename TT>
	struct RandomAccessIterator;
	template<typename TT>
	struct RandomAccessIteratorConcept: RandomAccessIterator<TT>
	{
	};
	template<typename TT>
	struct RandomAccessIterator: BidirectionalIterator<TT>, Comparable<TT>
	{
		enum
		{
			boost_concept_check555=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<RandomAccessIterator>))0))
		};
		~RandomAccessIterator()
		{
			enum
			{
				boost_concept_check557=sizeof(::boost::concept::require_((void(*)(Convertible<typename BidirectionalIterator<TT>::iterator_category, std::random_access_iterator_tag>))0))
			};
			i+=n;
			i=i+n;
			i=n+i;
			i-=n;
			i=i-n;
			n=i-j;
			(void)i[n];
		}
	private:
		TT a, b;
		TT i, j;
		typename boost::detail::iterator_traits<TT>::difference_type n;
	};
	template<typename TT>
	struct Mutable_RandomAccessIterator;
	template<typename TT>
	struct Mutable_RandomAccessIteratorConcept: Mutable_RandomAccessIterator<TT>
	{
	};
	template<typename TT>
	struct Mutable_RandomAccessIterator: RandomAccessIterator<TT>, Mutable_BidirectionalIterator<TT>
	{
		enum
		{
			boost_concept_check580=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Mutable_RandomAccessIterator>))0))
		};
		~Mutable_RandomAccessIterator()
		{
			i[n]=*i;
		}
	private:
		TT i;
		typename boost::detail::iterator_traits<TT>::difference_type n;
	};
	template<typename C>
	struct Container;
	template<typename C>
	struct ContainerConcept: Container<C>
	{
	};
	template<typename C>
	struct Container: Assignable<C>
	{
		typedef typename C::value_type value_type;
		typedef typename C::difference_type difference_type;
		typedef typename C::size_type size_type;
		typedef typename C::const_reference const_reference;
		typedef typename C::const_pointer const_pointer;
		typedef typename C::const_iterator const_iterator;
		enum
		{
			boost_concept_check602=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Container>))0))
		};
		~Container()
		{
			enum
			{
				boost_concept_check604=sizeof(::boost::concept::require_((void(*)(InputIterator<const_iterator>))0))
			};
			const_constraints(c);
		}
	private:
		void const_constraints(const C&cc)
		{
			i=cc.begin();
			i=cc.end();
			n=cc.size();
			n=cc.max_size();
			b=cc.empty();
		}
		C c;
		bool b;
		const_iterator i;
		size_type n;
	};
	template<typename C>
	struct Mutable_Container;
	template<typename C>
	struct Mutable_ContainerConcept: Mutable_Container<C>
	{
	};
	template<typename C>
	struct Mutable_Container: Container<C>
	{
		typedef typename C::reference reference;
		typedef typename C::iterator iterator;
		typedef typename C::pointer pointer;
		enum
		{
			boost_concept_check629=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Mutable_Container>))0))
		};
		~Mutable_Container()
		{
			enum
			{
				boost_concept_check631=sizeof(::boost::concept::require_((void(*)(Assignable<typename Mutable_Container::value_type>))0))
			};
			enum
			{
				boost_concept_check634=sizeof(::boost::concept::require_((void(*)(InputIterator<iterator>))0))
			};
			i=c.begin();
			i=c.end();
			c.swap(c2);
		}
	private:
		iterator i;
		C c, c2;
	};
	template<typename C>
	struct ForwardContainer;
	template<typename C>
	struct ForwardContainerConcept: ForwardContainer<C>
	{
	};
	template<typename C>
	struct ForwardContainer: Container<C>
	{
		enum
		{
			boost_concept_check649=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<ForwardContainer>))0))
		};
		~ForwardContainer()
		{
			enum
			{
				boost_concept_check651=sizeof(::boost::concept::require_((void(*)(ForwardIterator<typename ForwardContainer::const_iterator>))0))
			};
		}
	};
	template<typename C>
	struct Mutable_ForwardContainer;
	template<typename C>
	struct Mutable_ForwardContainerConcept: Mutable_ForwardContainer<C>
	{
	};
	template<typename C>
	struct Mutable_ForwardContainer: ForwardContainer<C>, Mutable_Container<C>
	{
		enum
		{
			boost_concept_check662=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Mutable_ForwardContainer>))0))
		};
		~Mutable_ForwardContainer()
		{
			enum
			{
				boost_concept_check664=sizeof(::boost::concept::require_((void(*)(Mutable_ForwardIterator<typename Mutable_ForwardContainer::iterator>))0))
			};
		}
	};
	template<typename C>
	struct ReversibleContainer;
	template<typename C>
	struct ReversibleContainerConcept: ReversibleContainer<C>
	{
	};
	template<typename C>
	struct ReversibleContainer: ForwardContainer<C>
	{
		typedef typename C::const_reverse_iterator const_reverse_iterator;
		enum
		{
			boost_concept_check678=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<ReversibleContainer>))0))
		};
		~ReversibleContainer()
		{
			enum
			{
				boost_concept_check680=sizeof(::boost::concept::require_((void(*)(BidirectionalIterator<typename ReversibleContainer::const_iterator>))0))
			};
			enum
			{
				boost_concept_check684=sizeof(::boost::concept::require_((void(*)(BidirectionalIterator<const_reverse_iterator>))0))
			};
			const_constraints(c);
		}
	private:
		void const_constraints(const C&cc)
		{
			const_reverse_iterator i=cc.rbegin();
			i=cc.rend();
		}
		C c;
	};
	template<typename C>
	struct Mutable_ReversibleContainer;
	template<typename C>
	struct Mutable_ReversibleContainerConcept: Mutable_ReversibleContainer<C>
	{
	};
	template<typename C>
	struct Mutable_ReversibleContainer: Mutable_ForwardContainer<C>, ReversibleContainer<C>
	{
		typedef typename C::reverse_iterator reverse_iterator;
		enum
		{
			boost_concept_check703=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Mutable_ReversibleContainer>))0))
		};
		~Mutable_ReversibleContainer()
		{
			typedef typename Mutable_ForwardContainer<C>::iterator iterator;
			enum
			{
				boost_concept_check706=sizeof(::boost::concept::require_((void(*)(Mutable_BidirectionalIterator<iterator>))0))
			};
			enum
			{
				boost_concept_check707=sizeof(::boost::concept::require_((void(*)(Mutable_BidirectionalIterator<reverse_iterator>))0))
			};
			reverse_iterator i=c.rbegin();
			i=c.rend();
		}
	private:
		C c;
	};
	template<typename C>
	struct RandomAccessContainer;
	template<typename C>
	struct RandomAccessContainerConcept: RandomAccessContainer<C>
	{
	};
	template<typename C>
	struct RandomAccessContainer: ReversibleContainer<C>
	{
		typedef typename C::size_type size_type;
		typedef typename C::const_reference const_reference;
		enum
		{
			boost_concept_check722=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<RandomAccessContainer>))0))
		};
		~RandomAccessContainer()
		{
			enum
			{
				boost_concept_check724=sizeof(::boost::concept::require_((void(*)(RandomAccessIterator<typename RandomAccessContainer::const_iterator>))0))
			};
			const_constraints(c);
		}
	private:
		void const_constraints(const C&cc)
		{
			const_reference r=cc[n];
			ignore_unused_variable_warning(r);
		}
		C c;
		size_type n;
	};
	template<typename C>
	struct Mutable_RandomAccessContainer;
	template<typename C>
	struct Mutable_RandomAccessContainerConcept: Mutable_RandomAccessContainer<C>
	{
	};
	template<typename C>
	struct Mutable_RandomAccessContainer: Mutable_ReversibleContainer<C>, RandomAccessContainer<C>
	{
	private:
		typedef Mutable_RandomAccessContainer self;
	public:
		enum
		{
			boost_concept_check749=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Mutable_RandomAccessContainer>))0))
		};
		~Mutable_RandomAccessContainer()
		{
			enum
			{
				boost_concept_check751=sizeof(::boost::concept::require_((void(*)(Mutable_RandomAccessIterator<typename self::iterator>))0))
			};
			enum
			{
				boost_concept_check752=sizeof(::boost::concept::require_((void(*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>))0))
			};
			typename self::reference r=c[i];
			ignore_unused_variable_warning(r);
		}
	private:
		typename Mutable_ReversibleContainer<C>::size_type i;
		C c;
	};
	template<typename S>
	struct Sequence;
	template<typename S>
	struct SequenceConcept: Sequence<S>
	{
	};
	template<typename S>
	struct Sequence: Mutable_ForwardContainer<S>, DefaultConstructible<S>
	{
		enum
		{
			boost_concept_check771=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<Sequence>))0))
		};
		~Sequence()
		{
			S c(n), c2(n, t), c3(first, last);
			c.insert(p, t);
			c.insert(p, n, t);
			c.insert(p, first, last);
			c.erase(p);
			c.erase(p, q);
			typename Sequence::reference r=c.front();
			ignore_unused_variable_warning(c);
			ignore_unused_variable_warning(c2);
			ignore_unused_variable_warning(c3);
			ignore_unused_variable_warning(r);
			const_constraints(c);
		}
	private:
		void const_constraints(const S&c)
		{
			typename Sequence::const_reference r=c.front();
			ignore_unused_variable_warning(r);
		}
		typename S::value_type t;
		typename S::size_type n;
		typename S::value_type*first, *last;
		typename S::iterator p, q;
	};
	template<typename S>
	struct FrontInsertionSequence;
	template<typename S>
	struct FrontInsertionSequenceConcept: FrontInsertionSequence<S>
	{
	};
	template<typename S>
	struct FrontInsertionSequence: Sequence<S>
	{
		enum
		{
			boost_concept_check808=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<FrontInsertionSequence>))0))
		};
		~FrontInsertionSequence()
		{
			c.push_front(t);
			c.pop_front();
		}
	private:
		S c;
		typename S::value_type t;
	};
	template<typename S>
	struct BackInsertionSequence;
	template<typename S>
	struct BackInsertionSequenceConcept: BackInsertionSequence<S>
	{
	};
	template<typename S>
	struct BackInsertionSequence: Sequence<S>
	{
		enum
		{
			boost_concept_check821=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<BackInsertionSequence>))0))
		};
		~BackInsertionSequence()
		{
			c.push_back(t);
			c.pop_back();
			typename BackInsertionSequence::reference r=c.back();
			ignore_unused_variable_warning(r);
			const_constraints(c);
		}
	private:
		void const_constraints(const S&cc)
		{
			typename BackInsertionSequence::const_reference r=cc.back();
			ignore_unused_variable_warning(r);
		};
		S c;
		typename S::value_type t;
	};
	template<typename C>
	struct AssociativeContainer;
	template<typename C>
	struct AssociativeContainerConcept: AssociativeContainer<C>
	{
	};
	template<typename C>
	struct AssociativeContainer: ForwardContainer<C>, DefaultConstructible<C>
	{
		typedef typename C::key_type key_type;
		typedef typename C::key_compare key_compare;
		typedef typename C::value_compare value_compare;
		typedef typename C::iterator iterator;
		enum
		{
			boost_concept_check848=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<AssociativeContainer>))0))
		};
		~AssociativeContainer()
		{
			i=c.find(k);
			r=c.equal_range(k);
			c.erase(k);
			c.erase(i);
			c.erase(r.first, r.second);
			const_constraints(c);
			enum
			{
				boost_concept_check856=sizeof(::boost::concept::require_((void(*)(BinaryPredicate<key_compare, key_type, key_type>))0))
			};
			typedef typename AssociativeContainer::value_type value_type_;
			enum
			{
				boost_concept_check859=sizeof(::boost::concept::require_((void(*)(BinaryPredicate<value_compare, value_type_, value_type_>))0))
			};
		}
		typedef typename C::const_iterator const_iterator;
	private:
		void const_constraints(const C&cc)
		{
			ci=cc.find(k);
			n=cc.count(k);
			cr=cc.equal_range(k);
		}
		C c;
		iterator i;
		std::pair<iterator, iterator>r;
		const_iterator ci;
		std::pair<const_iterator, const_iterator>cr;
		typename C::key_type k;
		typename C::size_type n;
	};
	template<typename C>
	struct UniqueAssociativeContainer;
	template<typename C>
	struct UniqueAssociativeContainerConcept: UniqueAssociativeContainer<C>
	{
	};
	template<typename C>
	struct UniqueAssociativeContainer: AssociativeContainer<C>
	{
		enum
		{
			boost_concept_check884=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<UniqueAssociativeContainer>))0))
		};
		~UniqueAssociativeContainer()
		{
			C c(first, last);
			pos_flag=c.insert(t);
			c.insert(first, last);
			ignore_unused_variable_warning(c);
		}
	private:
		std::pair<typename C::iterator, bool>pos_flag;
		typename C::value_type t;
		typename C::value_type*first, *last;
	};
	template<typename C>
	struct MultipleAssociativeContainer;
	template<typename C>
	struct MultipleAssociativeContainerConcept: MultipleAssociativeContainer<C>
	{
	};
	template<typename C>
	struct MultipleAssociativeContainer: AssociativeContainer<C>
	{
		enum
		{
			boost_concept_check902=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<MultipleAssociativeContainer>))0))
		};
		~MultipleAssociativeContainer()
		{
			C c(first, last);
			pos=c.insert(t);
			c.insert(first, last);
			ignore_unused_variable_warning(c);
			ignore_unused_variable_warning(pos);
		}
	private:
		typename C::iterator pos;
		typename C::value_type t;
		typename C::value_type*first, *last;
	};
	template<typename C>
	struct SimpleAssociativeContainer;
	template<typename C>
	struct SimpleAssociativeContainerConcept: SimpleAssociativeContainer<C>
	{
	};
	template<typename C>
	struct SimpleAssociativeContainer: AssociativeContainer<C>
	{
		enum
		{
			boost_concept_check921=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<SimpleAssociativeContainer>))0))
		};
		~SimpleAssociativeContainer()
		{
			typedef typename C::key_type key_type;
			typedef typename C::value_type value_type;
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_arg((void(*)(boost::is_same<key_type, value_type>))0, 1)));
		}
	};
	template<typename C>
	struct PairAssociativeContainer;
	template<typename C>
	struct PairAssociativeContainerConcept: PairAssociativeContainer<C>
	{
	};
	template<typename C>
	struct PairAssociativeContainer: AssociativeContainer<C>
	{
		enum
		{
			boost_concept_check932=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<PairAssociativeContainer>))0))
		};
		~PairAssociativeContainer()
		{
			typedef typename C::key_type key_type;
			typedef typename C::value_type value_type;
			typedef typename C::mapped_type mapped_type;
			typedef std::pair<const key_type, mapped_type>required_value_type;
			static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<false>(boost::mpl::assert_arg((void(*)(boost::is_same<value_type, required_value_type>))0, 1)));
		}
	};
	template<typename C>
	struct SortedAssociativeContainer;
	template<typename C>
	struct SortedAssociativeContainerConcept: SortedAssociativeContainer<C>
	{
	};
	template<typename C>
	struct SortedAssociativeContainer: AssociativeContainer<C>, ReversibleContainer<C>
	{
		enum
		{
			boost_concept_check946=sizeof(::boost::concept::require_((void(*)(boost::concept::usage_requirements<SortedAssociativeContainer>))0))
		};
		~SortedAssociativeContainer()
		{
			C c(kc), c2(first, last), c3(first, last, kc);
			p=c.upper_bound(k);
			p=c.lower_bound(k);
			r=c.equal_range(k);
			c.insert(p, t);
			ignore_unused_variable_warning(c);
			ignore_unused_variable_warning(c2);
			ignore_unused_variable_warning(c3);
			const_constraints(c);
		}
		void const_constraints(const C&c)
		{
			kc=c.key_comp();
			vc=c.value_comp();
			cp=c.upper_bound(k);
			cp=c.lower_bound(k);
			cr=c.equal_range(k);
		}
	private:
		typename C::key_compare kc;
		typename C::value_compare vc;
		typename C::value_type t;
		typename C::key_type k;
		typedef typename C::iterator iterator;
		typedef typename C::const_iterator const_iterator;
		typedef SortedAssociativeContainer self;
		iterator p;
		const_iterator cp;
		std::pair<typename self::iterator, typename self::iterator>r;
		std::pair<typename self::const_iterator, typename self::const_iterator>cr;
		typename C::value_type*first, *last;
	};
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	typedef signed char int8_t;
	typedef signed char int_least8_t;
	typedef signed char int_fast8_t;
	typedef unsigned char uint8_t;
	typedef unsigned char uint_least8_t;
	typedef unsigned char uint_fast8_t;
	typedef short int16_t;
	typedef short int_least16_t;
	typedef short int_fast16_t;
	typedef unsigned short uint16_t;
	typedef unsigned short uint_least16_t;
	typedef unsigned short uint_fast16_t;
	typedef long int32_t;
	typedef long int_least32_t;
	typedef long int_fast32_t;
	typedef unsigned long uint32_t;
	typedef unsigned long uint_least32_t;
	typedef unsigned long uint_fast32_t;
	typedef __int64 intmax_t;
	typedef unsigned __int64 uintmax_t;
	typedef __int64 int64_t;
	typedef __int64 int_least64_t;
	typedef __int64 int_fast64_t;
	typedef unsigned __int64 uint64_t;
	typedef unsigned __int64 uint_least64_t;
	typedef unsigned __int64 uint_fast64_t;
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		class empty_base
		{
		};
	}
}
namespace boost
{
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct less_than_comparable2: B
	{
		friend bool operator<=(const T&x, const U&y)
		{
			return !static_cast<bool>(x>y);
		}
		friend bool operator>=(const T&x, const U&y)
		{
			return !static_cast<bool>(x<y);
		}
		friend bool operator>(const U&x, const T&y)
		{
			return y<x;
		}
		friend bool operator<(const U&x, const T&y)
		{
			return y>x;
		}
		friend bool operator<=(const U&x, const T&y)
		{
			return !static_cast<bool>(y<x);
		}
		friend bool operator>=(const U&x, const T&y)
		{
			return !static_cast<bool>(y>x);
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct less_than_comparable1: B
	{
		friend bool operator>(const T&x, const T&y)
		{
			return y<x;
		}
		friend bool operator<=(const T&x, const T&y)
		{
			return !static_cast<bool>(y<x);
		}
		friend bool operator>=(const T&x, const T&y)
		{
			return !static_cast<bool>(x<y);
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct equality_comparable2: B
	{
		friend bool operator==(const U&y, const T&x)
		{
			return x==y;
		}
		friend bool operator!=(const U&y, const T&x)
		{
			return !static_cast<bool>(x==y);
		}
		friend bool operator!=(const T&y, const U&x)
		{
			return !static_cast<bool>(y==x);
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct equality_comparable1: B
	{
		friend bool operator!=(const T&x, const T&y)
		{
			return !static_cast<bool>(x==y);
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct multipliable2: B
	{
		friend T operator*(T lhs, const U&rhs)
		{
			return lhs*=rhs;
		}
		friend T operator*(const U&lhs, T rhs)
		{
			return rhs*=lhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct multipliable1: B
	{
		friend T operator*(T lhs, const T&rhs)
		{
			return lhs*=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct addable2: B
	{
		friend T operator+(T lhs, const U&rhs)
		{
			return lhs+=rhs;
		}
		friend T operator+(const U&lhs, T rhs)
		{
			return rhs+=lhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct addable1: B
	{
		friend T operator+(T lhs, const T&rhs)
		{
			return lhs+=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct subtractable2: B
	{
		friend T operator-(T lhs, const U&rhs)
		{
			return lhs-=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct subtractable2_left: B
	{
		friend T operator-(const U&lhs, const T&rhs)
		{
			return T(lhs)-=rhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct subtractable1: B
	{
		friend T operator-(T lhs, const T&rhs)
		{
			return lhs-=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct dividable2: B
	{
		friend T operator/(T lhs, const U&rhs)
		{
			return lhs/=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct dividable2_left: B
	{
		friend T operator/(const U&lhs, const T&rhs)
		{
			return T(lhs)/=rhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct dividable1: B
	{
		friend T operator/(T lhs, const T&rhs)
		{
			return lhs/=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct modable2: B
	{
		friend T operator%(T lhs, const U&rhs)
		{
			return lhs%=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct modable2_left: B
	{
		friend T operator%(const U&lhs, const T&rhs)
		{
			return T(lhs)%=rhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct modable1: B
	{
		friend T operator%(T lhs, const T&rhs)
		{
			return lhs%=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct xorable2: B
	{
		friend T operator^(T lhs, const U&rhs)
		{
			return lhs^=rhs;
		}
		friend T operator^(const U&lhs, T rhs)
		{
			return rhs^=lhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct xorable1: B
	{
		friend T operator^(T lhs, const T&rhs)
		{
			return lhs^=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct andable2: B
	{
		friend T operator&(T lhs, const U&rhs)
		{
			return lhs&=rhs;
		}
		friend T operator&(const U&lhs, T rhs)
		{
			return rhs&=lhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct andable1: B
	{
		friend T operator&(T lhs, const T&rhs)
		{
			return lhs&=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct orable2: B
	{
		friend T operator|(T lhs, const U&rhs)
		{
			return lhs|=rhs;
		}
		friend T operator|(const U&lhs, T rhs)
		{
			return rhs|=lhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct orable1: B
	{
		friend T operator|(T lhs, const T&rhs)
		{
			return lhs|=rhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct incrementable: B
	{
		friend T operator++(T&x, int)
		{
			incrementable_type nrv(x);
			++x;
			return nrv;
		}
	private:
		typedef T incrementable_type;
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct decrementable: B
	{
		friend T operator--(T&x, int)
		{
			decrementable_type nrv(x);
			--x;
			return nrv;
		}
	private:
		typedef T decrementable_type;
	};
	template<class T, class P, class B=::boost::detail::empty_base<T> >
	struct dereferenceable: B
	{
		P operator->()const
		{
			return &*static_cast<const T&>(*this);
		}
	};
	template<class T, class I, class R, class B=::boost::detail::empty_base<T> >
	struct indexable: B
	{
		R operator[](I n)const
		{
			return *(static_cast<const T&>(*this)+n);
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct left_shiftable2: B
	{
		friend T operator<<(T lhs, const U&rhs)
		{
			return lhs<<=rhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct left_shiftable1: B
	{
		friend T operator<<(T lhs, const T&rhs)
		{
			return lhs<<=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct right_shiftable2: B
	{
		friend T operator>>(T lhs, const U&rhs)
		{
			return lhs>>=rhs;
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct right_shiftable1: B
	{
		friend T operator>>(T lhs, const T&rhs)
		{
			return lhs>>=rhs;
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct equivalent2: B
	{
		friend bool operator==(const T&x, const U&y)
		{
			return !static_cast<bool>(x<y)&&!static_cast<bool>(x>y);
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct equivalent1: B
	{
		friend bool operator==(const T&x, const T&y)
		{
			return !static_cast<bool>(x<y)&&!static_cast<bool>(y<x);
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct partially_ordered2: B
	{
		friend bool operator<=(const T&x, const U&y)
		{
			return static_cast<bool>(x<y)||static_cast<bool>(x==y);
		}
		friend bool operator>=(const T&x, const U&y)
		{
			return static_cast<bool>(x>y)||static_cast<bool>(x==y);
		}
		friend bool operator>(const U&x, const T&y)
		{
			return y<x;
		}
		friend bool operator<(const U&x, const T&y)
		{
			return y>x;
		}
		friend bool operator<=(const U&x, const T&y)
		{
			return static_cast<bool>(y>x)||static_cast<bool>(y==x);
		}
		friend bool operator>=(const U&x, const T&y)
		{
			return static_cast<bool>(y<x)||static_cast<bool>(y==x);
		}
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct partially_ordered1: B
	{
		friend bool operator>(const T&x, const T&y)
		{
			return y<x;
		}
		friend bool operator<=(const T&x, const T&y)
		{
			return static_cast<bool>(x<y)||static_cast<bool>(x==y);
		}
		friend bool operator>=(const T&x, const T&y)
		{
			return static_cast<bool>(y<x)||static_cast<bool>(x==y);
		}
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct totally_ordered2: less_than_comparable2<T, U, equality_comparable2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct totally_ordered1: less_than_comparable1<T, equality_comparable1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct additive2: addable2<T, U, subtractable2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct additive1: addable1<T, subtractable1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct multiplicative2: multipliable2<T, U, dividable2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct multiplicative1: multipliable1<T, dividable1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct integer_multiplicative2: multiplicative2<T, U, modable2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct integer_multiplicative1: multiplicative1<T, modable1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct arithmetic2: additive2<T, U, multiplicative2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct arithmetic1: additive1<T, multiplicative1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct integer_arithmetic2: additive2<T, U, integer_multiplicative2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct integer_arithmetic1: additive1<T, integer_multiplicative1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct bitwise2: xorable2<T, U, andable2<T, U, orable2<T, U, B> > >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct bitwise1: xorable1<T, andable1<T, orable1<T, B> > >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct unit_steppable: incrementable<T, decrementable<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct shiftable2: left_shiftable2<T, U, right_shiftable2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct shiftable1: left_shiftable1<T, right_shiftable1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct ring_operators2: additive2<T, U, subtractable2_left<T, U, multipliable2<T, U, B> > >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct ring_operators1: additive1<T, multipliable1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct ordered_ring_operators2: ring_operators2<T, U, totally_ordered2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct ordered_ring_operators1: ring_operators1<T, totally_ordered1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct field_operators2: ring_operators2<T, U, dividable2<T, U, dividable2_left<T, U, B> > >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct field_operators1: ring_operators1<T, dividable1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct ordered_field_operators2: field_operators2<T, U, totally_ordered2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct ordered_field_operators1: field_operators1<T, totally_ordered1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct euclidian_ring_operators2: ring_operators2<T, U, dividable2<T, U, dividable2_left<T, U, modable2<T, U, modable2_left<T, U, B> > > > >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct euclidian_ring_operators1: ring_operators1<T, dividable1<T, modable1<T, B> > >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct ordered_euclidian_ring_operators2: totally_ordered2<T, U, euclidian_ring_operators2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct ordered_euclidian_ring_operators1: totally_ordered1<T, euclidian_ring_operators1<T, B> >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct euclidean_ring_operators2: ring_operators2<T, U, dividable2<T, U, dividable2_left<T, U, modable2<T, U, modable2_left<T, U, B> > > > >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct euclidean_ring_operators1: ring_operators1<T, dividable1<T, modable1<T, B> > >
	{
	};
	template<class T, class U, class B=::boost::detail::empty_base<T> >
	struct ordered_euclidean_ring_operators2: totally_ordered2<T, U, euclidean_ring_operators2<T, U, B> >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct ordered_euclidean_ring_operators1: totally_ordered1<T, euclidean_ring_operators1<T, B> >
	{
	};
	template<class T, class P, class B=::boost::detail::empty_base<T> >
	struct input_iteratable: equality_comparable1<T, incrementable<T, dereferenceable<T, P, B> > >
	{
	};
	template<class T, class B=::boost::detail::empty_base<T> >
	struct output_iteratable: incrementable<T, B>
	{
	};
	template<class T, class P, class B=::boost::detail::empty_base<T> >
	struct forward_iteratable: input_iteratable<T, P, B>
	{
	};
	template<class T, class P, class B=::boost::detail::empty_base<T> >
	struct bidirectional_iteratable: forward_iteratable<T, P, decrementable<T, B> >
	{
	};
	template<class T, class P, class D, class R, class B=::boost::detail::empty_base<T> >
	struct random_access_iteratable: bidirectional_iteratable<T, P, less_than_comparable1<T, additive2<T, D, indexable<T, D, R, B> > > >
	{
	};
}
namespace boost
{
	namespace detail
	{
		struct true_t
		{
		};
		struct false_t
		{
		};
	}
	template<class T>
	struct is_chained_base
	{
		typedef ::boost::detail::false_t value;
	};
}
namespace boost
{
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct less_than_comparable: less_than_comparable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct less_than_comparable<T, U, B, ::boost::detail::true_t>: less_than_comparable1<T, U>
	{
	};
	template<class T, class B>
	struct less_than_comparable<T, T, B, ::boost::detail::false_t>: less_than_comparable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::less_than_comparable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::less_than_comparable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::less_than_comparable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct equality_comparable: equality_comparable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct equality_comparable<T, U, B, ::boost::detail::true_t>: equality_comparable1<T, U>
	{
	};
	template<class T, class B>
	struct equality_comparable<T, T, B, ::boost::detail::false_t>: equality_comparable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::equality_comparable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::equality_comparable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::equality_comparable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct multipliable: multipliable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct multipliable<T, U, B, ::boost::detail::true_t>: multipliable1<T, U>
	{
	};
	template<class T, class B>
	struct multipliable<T, T, B, ::boost::detail::false_t>: multipliable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::multipliable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::multipliable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::multipliable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct addable: addable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct addable<T, U, B, ::boost::detail::true_t>: addable1<T, U>
	{
	};
	template<class T, class B>
	struct addable<T, T, B, ::boost::detail::false_t>: addable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::addable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::addable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::addable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct subtractable: subtractable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct subtractable<T, U, B, ::boost::detail::true_t>: subtractable1<T, U>
	{
	};
	template<class T, class B>
	struct subtractable<T, T, B, ::boost::detail::false_t>: subtractable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::subtractable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::subtractable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::subtractable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::subtractable2_left<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct dividable: dividable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct dividable<T, U, B, ::boost::detail::true_t>: dividable1<T, U>
	{
	};
	template<class T, class B>
	struct dividable<T, T, B, ::boost::detail::false_t>: dividable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::dividable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::dividable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::dividable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::dividable2_left<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct modable: modable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct modable<T, U, B, ::boost::detail::true_t>: modable1<T, U>
	{
	};
	template<class T, class B>
	struct modable<T, T, B, ::boost::detail::false_t>: modable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::modable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::modable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::modable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::modable2_left<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct xorable: xorable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct xorable<T, U, B, ::boost::detail::true_t>: xorable1<T, U>
	{
	};
	template<class T, class B>
	struct xorable<T, T, B, ::boost::detail::false_t>: xorable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::xorable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::xorable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::xorable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct andable: andable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct andable<T, U, B, ::boost::detail::true_t>: andable1<T, U>
	{
	};
	template<class T, class B>
	struct andable<T, T, B, ::boost::detail::false_t>: andable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::andable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::andable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::andable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct orable: orable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct orable<T, U, B, ::boost::detail::true_t>: orable1<T, U>
	{
	};
	template<class T, class B>
	struct orable<T, T, B, ::boost::detail::false_t>: orable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::orable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::orable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::orable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::incrementable<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::decrementable<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::dereferenceable<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class V, class B>
	struct is_chained_base< ::boost::indexable<T, U, V, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct left_shiftable: left_shiftable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct left_shiftable<T, U, B, ::boost::detail::true_t>: left_shiftable1<T, U>
	{
	};
	template<class T, class B>
	struct left_shiftable<T, T, B, ::boost::detail::false_t>: left_shiftable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::left_shiftable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::left_shiftable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::left_shiftable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct right_shiftable: right_shiftable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct right_shiftable<T, U, B, ::boost::detail::true_t>: right_shiftable1<T, U>
	{
	};
	template<class T, class B>
	struct right_shiftable<T, T, B, ::boost::detail::false_t>: right_shiftable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::right_shiftable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::right_shiftable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::right_shiftable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct equivalent: equivalent2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct equivalent<T, U, B, ::boost::detail::true_t>: equivalent1<T, U>
	{
	};
	template<class T, class B>
	struct equivalent<T, T, B, ::boost::detail::false_t>: equivalent1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::equivalent<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::equivalent2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::equivalent1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct partially_ordered: partially_ordered2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct partially_ordered<T, U, B, ::boost::detail::true_t>: partially_ordered1<T, U>
	{
	};
	template<class T, class B>
	struct partially_ordered<T, T, B, ::boost::detail::false_t>: partially_ordered1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::partially_ordered<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::partially_ordered2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::partially_ordered1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct totally_ordered: totally_ordered2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct totally_ordered<T, U, B, ::boost::detail::true_t>: totally_ordered1<T, U>
	{
	};
	template<class T, class B>
	struct totally_ordered<T, T, B, ::boost::detail::false_t>: totally_ordered1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::totally_ordered<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::totally_ordered2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::totally_ordered1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct additive: additive2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct additive<T, U, B, ::boost::detail::true_t>: additive1<T, U>
	{
	};
	template<class T, class B>
	struct additive<T, T, B, ::boost::detail::false_t>: additive1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::additive<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::additive2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::additive1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct multiplicative: multiplicative2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct multiplicative<T, U, B, ::boost::detail::true_t>: multiplicative1<T, U>
	{
	};
	template<class T, class B>
	struct multiplicative<T, T, B, ::boost::detail::false_t>: multiplicative1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::multiplicative<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::multiplicative2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::multiplicative1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct integer_multiplicative: integer_multiplicative2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct integer_multiplicative<T, U, B, ::boost::detail::true_t>: integer_multiplicative1<T, U>
	{
	};
	template<class T, class B>
	struct integer_multiplicative<T, T, B, ::boost::detail::false_t>: integer_multiplicative1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::integer_multiplicative<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::integer_multiplicative2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::integer_multiplicative1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct arithmetic: arithmetic2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct arithmetic<T, U, B, ::boost::detail::true_t>: arithmetic1<T, U>
	{
	};
	template<class T, class B>
	struct arithmetic<T, T, B, ::boost::detail::false_t>: arithmetic1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::arithmetic<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::arithmetic2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::arithmetic1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct integer_arithmetic: integer_arithmetic2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct integer_arithmetic<T, U, B, ::boost::detail::true_t>: integer_arithmetic1<T, U>
	{
	};
	template<class T, class B>
	struct integer_arithmetic<T, T, B, ::boost::detail::false_t>: integer_arithmetic1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::integer_arithmetic<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::integer_arithmetic2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::integer_arithmetic1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct bitwise: bitwise2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct bitwise<T, U, B, ::boost::detail::true_t>: bitwise1<T, U>
	{
	};
	template<class T, class B>
	struct bitwise<T, T, B, ::boost::detail::false_t>: bitwise1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::bitwise<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::bitwise2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::bitwise1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::unit_steppable<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct shiftable: shiftable2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct shiftable<T, U, B, ::boost::detail::true_t>: shiftable1<T, U>
	{
	};
	template<class T, class B>
	struct shiftable<T, T, B, ::boost::detail::false_t>: shiftable1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::shiftable<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::shiftable2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::shiftable1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct ring_operators: ring_operators2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct ring_operators<T, U, B, ::boost::detail::true_t>: ring_operators1<T, U>
	{
	};
	template<class T, class B>
	struct ring_operators<T, T, B, ::boost::detail::false_t>: ring_operators1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::ring_operators<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::ring_operators2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::ring_operators1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct ordered_ring_operators: ordered_ring_operators2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct ordered_ring_operators<T, U, B, ::boost::detail::true_t>: ordered_ring_operators1<T, U>
	{
	};
	template<class T, class B>
	struct ordered_ring_operators<T, T, B, ::boost::detail::false_t>: ordered_ring_operators1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::ordered_ring_operators<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::ordered_ring_operators2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::ordered_ring_operators1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct field_operators: field_operators2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct field_operators<T, U, B, ::boost::detail::true_t>: field_operators1<T, U>
	{
	};
	template<class T, class B>
	struct field_operators<T, T, B, ::boost::detail::false_t>: field_operators1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::field_operators<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::field_operators2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::field_operators1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct ordered_field_operators: ordered_field_operators2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct ordered_field_operators<T, U, B, ::boost::detail::true_t>: ordered_field_operators1<T, U>
	{
	};
	template<class T, class B>
	struct ordered_field_operators<T, T, B, ::boost::detail::false_t>: ordered_field_operators1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::ordered_field_operators<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::ordered_field_operators2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::ordered_field_operators1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct euclidian_ring_operators: euclidian_ring_operators2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct euclidian_ring_operators<T, U, B, ::boost::detail::true_t>: euclidian_ring_operators1<T, U>
	{
	};
	template<class T, class B>
	struct euclidian_ring_operators<T, T, B, ::boost::detail::false_t>: euclidian_ring_operators1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::euclidian_ring_operators<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::euclidian_ring_operators2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::euclidian_ring_operators1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct ordered_euclidian_ring_operators: ordered_euclidian_ring_operators2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct ordered_euclidian_ring_operators<T, U, B, ::boost::detail::true_t>: ordered_euclidian_ring_operators1<T, U>
	{
	};
	template<class T, class B>
	struct ordered_euclidian_ring_operators<T, T, B, ::boost::detail::false_t>: ordered_euclidian_ring_operators1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::ordered_euclidian_ring_operators<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::ordered_euclidian_ring_operators2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::ordered_euclidian_ring_operators1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct euclidean_ring_operators: euclidean_ring_operators2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct euclidean_ring_operators<T, U, B, ::boost::detail::true_t>: euclidean_ring_operators1<T, U>
	{
	};
	template<class T, class B>
	struct euclidean_ring_operators<T, T, B, ::boost::detail::false_t>: euclidean_ring_operators1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::euclidean_ring_operators<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::euclidean_ring_operators2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::euclidean_ring_operators1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U=T, class B=::boost::detail::empty_base<T>, class O=typename is_chained_base<U>::value>
	struct ordered_euclidean_ring_operators: ordered_euclidean_ring_operators2<T, U, B>
	{
	};
	template<class T, class U, class B>
	struct ordered_euclidean_ring_operators<T, U, B, ::boost::detail::true_t>: ordered_euclidean_ring_operators1<T, U>
	{
	};
	template<class T, class B>
	struct ordered_euclidean_ring_operators<T, T, B, ::boost::detail::false_t>: ordered_euclidean_ring_operators1<T, B>
	{
	};
	template<class T, class U, class B, class O>
	struct is_chained_base< ::boost::ordered_euclidean_ring_operators<T, U, B, O> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::ordered_euclidean_ring_operators2<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::ordered_euclidean_ring_operators1<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::input_iteratable<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class B>
	struct is_chained_base< ::boost::output_iteratable<T, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::forward_iteratable<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class B>
	struct is_chained_base< ::boost::bidirectional_iteratable<T, U, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U, class V, class W, class B>
	struct is_chained_base< ::boost::random_access_iteratable<T, U, V, W, B> >
	{
		typedef ::boost::detail::true_t value;
	};
	template<class T, class U>
	struct operators2: totally_ordered2<T, U, integer_arithmetic2<T, U, bitwise2<T, U> > >
	{
	};
	template<class T, class U=T>
	struct operators: operators2<T, U>
	{
	};
	template<class T>
	struct operators<T, T>: totally_ordered<T, integer_arithmetic<T, bitwise<T, unit_steppable<T> > > >
	{
	};
	template<class T, class V, class D=std::ptrdiff_t, class P=V const*, class R=V const&>
	struct input_iterator_helper: input_iteratable<T, P, boost::iterator<std::input_iterator_tag, V, D, P, R> >
	{
	};
	template<class T>
	struct output_iterator_helper: output_iteratable<T, boost::iterator<std::output_iterator_tag, void, void, void, void> >
	{
		T&operator*()
		{
			return static_cast<T&>(*this);
		}
		T&operator++()
		{
			return static_cast<T&>(*this);
		}
	};
	template<class T, class V, class D=std::ptrdiff_t, class P=V*, class R=V&>
	struct forward_iterator_helper: forward_iteratable<T, P, boost::iterator<std::forward_iterator_tag, V, D, P, R> >
	{
	};
	template<class T, class V, class D=std::ptrdiff_t, class P=V*, class R=V&>
	struct bidirectional_iterator_helper: bidirectional_iteratable<T, P, boost::iterator<std::bidirectional_iterator_tag, V, D, P, R> >
	{
	};
	template<class T, class V, class D=std::ptrdiff_t, class P=V*, class R=V&>
	struct random_access_iterator_helper: random_access_iteratable<T, P, D, R, boost::iterator<std::random_access_iterator_tag, V, D, P, R> >
	{
		friend D requires_difference_operator(const T&x, const T&y)
		{
			return x-y;
		}
	};
}
extern "C"
{
}
namespace std
{
}
namespace boost
{
	namespace system
	{
		class error_code;
		class error_condition;
		template<class T>
		struct is_error_code_enum
		{
			static const bool value=false;
		};
		template<class T>
		struct is_error_condition_enum
		{
			static const bool value=false;
		};
		namespace errc
		{
			enum errc_t
			{
				success=0, address_family_not_supported=9901, address_in_use=9902, address_not_available=9903, already_connected=9904, argument_list_too_long=7, argument_out_of_domain=33, bad_address=14, bad_file_descriptor=9, bad_message=9905, broken_pipe=32, connection_aborted=9906, connection_already_in_progress=9907, connection_refused=9908, connection_reset=9909, cross_device_link=18, destination_address_required=9910, device_or_resource_busy=16, directory_not_empty=41, executable_format_error=8, file_exists=17, file_too_large=27, filename_too_long=38, function_not_supported=40, host_unreachable=9911, identifier_removed=9912, illegal_byte_sequence=42, inappropriate_io_control_operation=25, interrupted=4, invalid_argument=22, invalid_seek=29, io_error=5, is_a_directory=21, message_size=9913, network_down=9914, network_reset=9915, network_unreachable=9916, no_buffer_space=9917, no_child_process=10, no_link=9918, no_lock_available=39, no_message_available=9919, no_message=9920, no_protocol_option=9921, no_space_on_device=28, no_stream_resources=9922, no_such_device_or_address=6, no_such_device=19, no_such_file_or_directory=2, no_such_process=3, not_a_directory=20, not_a_socket=9923, not_a_stream=9924, not_connected=9925, not_enough_memory=12, not_supported=9926, operation_canceled=9927, operation_in_progress=9928, operation_not_permitted=1, operation_not_supported=9929, operation_would_block=9930, owner_dead=9931, permission_denied=13, protocol_error=9932, protocol_not_supported=9933, read_only_file_system=30, resource_deadlock_would_occur=36, resource_unavailable_try_again=11, result_out_of_range=34, state_not_recoverable=9934, stream_timeout=9935, text_file_busy=9936, timed_out=9938, too_many_files_open_in_system=23, too_many_files_open=24, too_many_links=31, too_many_symbolic_link_levels=9939, value_too_large=9940, wrong_protocol_type=9941
			};
		}
		namespace posix=errc;
		namespace posix_error=errc;
		template<>
		struct is_error_condition_enum<errc::errc_t>
		{
			static const bool value=true;
		};
		class error_category: public noncopyable
		{
		public:
			virtual~error_category()
			{
			}
			virtual const char*name()const=0;
			virtual std::string message(int ev)const=0;
			virtual error_condition default_error_condition(int ev)const;
			virtual bool equivalent(int code, const error_condition&condition)const;
			virtual bool equivalent(const error_code&code, int condition)const;
			bool operator==(const error_category&rhs)const
			{
				return this==&rhs;
			}
			bool operator!=(const error_category&rhs)const
			{
				return this!=&rhs;
			}
			bool operator<(const error_category&rhs)const
			{
				return std::less<const error_category*>()(this, &rhs);
			}
		};
		const error_category&get_system_category();
		const error_category&get_generic_category();
		static const error_category&system_category=get_system_category();
		static const error_category&generic_category=get_generic_category();
		inline const error_category&get_posix_category()
		{
			return get_generic_category();
		}
		static const error_category&posix_category=get_generic_category();
		static const error_category&errno_ecat=get_generic_category();
		static const error_category&native_ecat=get_system_category();
		class error_condition
		{
		public:
			error_condition(): m_val(0), m_cat(&get_generic_category())
			{
			}
			error_condition(int val, const error_category&cat): m_val(val), m_cat(&cat)
			{
			}
			template<class ErrorConditionEnum>
			error_condition(ErrorConditionEnum e, typename boost::enable_if<is_error_condition_enum<ErrorConditionEnum> >::type* =0)
			{
				*this=make_error_condition(e);
			}
			void assign(int val, const error_category&cat)
			{
				m_val=val;
				m_cat=&cat;
			}
			template<typename ErrorConditionEnum>
			typename boost::enable_if<is_error_condition_enum<ErrorConditionEnum>, error_condition>::type&operator=(ErrorConditionEnum val)
			{
				*this=make_error_condition(val);
				return *this;
			}
			void clear()
			{
				m_val=0;
				m_cat=&get_generic_category();
			}
			int value()const
			{
				return m_val;
			}
			const error_category&category()const
			{
				return *m_cat;
			}
			std::string message()const
			{
				return m_cat->message(value());
			}
			typedef void(*unspecified_bool_type)();
			static void unspecified_bool_true()
			{
			}
			operator unspecified_bool_type()const
			{
				return m_val==0?0: unspecified_bool_true;
			}
			bool operator!()const
			{
				return m_val==0;
			}
			inline friend bool operator==(const error_condition&lhs, const error_condition&rhs)
			{
				return lhs.m_cat==rhs.m_cat&&lhs.m_val==rhs.m_val;
			}
			inline friend bool operator<(const error_condition&lhs, const error_condition&rhs)
			{
				return (lhs.m_cat<rhs.m_cat)||(lhs.m_cat==rhs.m_cat&&lhs.m_val<rhs.m_val);
			}
		private:
			int m_val;
			const error_category*m_cat;
		};
		class error_code
		{
		public:
			error_code(): m_val(0), m_cat(&get_system_category())
			{
			}
			error_code(int val, const error_category&cat): m_val(val), m_cat(&cat)
			{
			}
			template<class ErrorCodeEnum>
			error_code(ErrorCodeEnum e, typename boost::enable_if<is_error_code_enum<ErrorCodeEnum> >::type* =0)
			{
				*this=make_error_code(e);
			}
			void assign(int val, const error_category&cat)
			{
				m_val=val;
				m_cat=&cat;
			}
			template<typename ErrorCodeEnum>
			typename boost::enable_if<is_error_code_enum<ErrorCodeEnum>, error_code>::type&operator=(ErrorCodeEnum val)
			{
				*this=make_error_code(val);
				return *this;
			}
			void clear()
			{
				m_val=0;
				m_cat=&get_system_category();
			}
			int value()const
			{
				return m_val;
			}
			const error_category&category()const
			{
				return *m_cat;
			}
			error_condition default_error_condition()const
			{
				return m_cat->default_error_condition(value());
			}
			std::string message()const
			{
				return m_cat->message(value());
			}
			typedef void(*unspecified_bool_type)();
			static void unspecified_bool_true()
			{
			}
			operator unspecified_bool_type()const
			{
				return m_val==0?0: unspecified_bool_true;
			}
			bool operator!()const
			{
				return m_val==0;
			}
			inline friend bool operator==(const error_code&lhs, const error_code&rhs)
			{
				return lhs.m_cat==rhs.m_cat&&lhs.m_val==rhs.m_val;
			}
			inline friend bool operator<(const error_code&lhs, const error_code&rhs)
			{
				return (lhs.m_cat<rhs.m_cat)||(lhs.m_cat==rhs.m_cat&&lhs.m_val<rhs.m_val);
			}
		private:
			int m_val;
			const error_category*m_cat;
		};
		extern error_code throws;
	}
	namespace detail
	{
		inline system::error_code*throws()
		{
			return 0;
		}
	}
	inline system::error_code&throws()
	{
		return *detail::throws();
	}
	namespace system
	{
		inline bool operator!=(const error_code&lhs, const error_code&rhs)
		{
			return !(lhs==rhs);
		}
		inline bool operator!=(const error_condition&lhs, const error_condition&rhs)
		{
			return !(lhs==rhs);
		}
		inline bool operator==(const error_code&code, const error_condition&condition)
		{
			return code.category().equivalent(code.value(), condition)||condition.category().equivalent(code, condition.value());
		}
		inline bool operator!=(const error_code&lhs, const error_condition&rhs)
		{
			return !(lhs==rhs);
		}
		inline bool operator==(const error_condition&condition, const error_code&code)
		{
			return condition.category().equivalent(code, condition.value())||code.category().equivalent(code.value(), condition);
		}
		inline bool operator!=(const error_condition&lhs, const error_code&rhs)
		{
			return !(lhs==rhs);
		}
		template<class charT, class traits>
		inline std::basic_ostream<charT, traits>&operator<<(std::basic_ostream<charT, traits>&os, error_code ec)
		{
			os<<ec.category().name()<<':'<<ec.value();
			return os;
		}
		inline std::size_t hash_value(const error_code&ec)
		{
			return static_cast<std::size_t>(ec.value())+reinterpret_cast<std::size_t>(&ec.category());
		}
		namespace errc
		{
			inline error_code make_error_code(errc_t e)
			{
				return error_code(e, get_generic_category());
			}
			inline error_condition make_error_condition(errc_t e)
			{
				return error_condition(e, get_generic_category());
			}
		}
		inline error_condition error_category::default_error_condition(int ev)const
		{
			return error_condition(ev, *this);
		}
		inline bool error_category::equivalent(int code, const error_condition&condition)const
		{
			return default_error_condition(code)==condition;
		}
		inline bool error_category::equivalent(const error_code&code, int condition)const
		{
			return *this==code.category()&&code.value()==condition;
		}
	}
}
namespace boost
{
	namespace system
	{
		class system_error: public std::runtime_error
		{
		public:
			system_error(error_code ec): std::runtime_error(""), m_error_code(ec)
			{
			}
			system_error(error_code ec, const std::string&what_arg): std::runtime_error(what_arg), m_error_code(ec)
			{
			}
			system_error(error_code ec, const char*what_arg): std::runtime_error(what_arg), m_error_code(ec)
			{
			}
			system_error(int ev, const error_category&ecat): std::runtime_error(""), m_error_code(ev, ecat)
			{
			}
			system_error(int ev, const error_category&ecat, const std::string&what_arg): std::runtime_error(what_arg), m_error_code(ev, ecat)
			{
			}
			system_error(int ev, const error_category&ecat, const char*what_arg): std::runtime_error(what_arg), m_error_code(ev, ecat)
			{
			}
			virtual~system_error()throw()
			{
			}
			const error_code&code()const throw()
			{
				return m_error_code;
			}
			const char*what()const throw();
		private:
			error_code m_error_code;
			mutable std::string m_what;
		};
		inline const char*system_error::what()const throw()
		{
			if(m_what.empty())
			{
				try
				{
					m_what=this->std::runtime_error::what();
					if(m_error_code)
					{
						if(!m_what.empty())m_what+=": ";
						m_what+=m_error_code.message();
					}
				}
				catch(...)
				{
					return std::runtime_error::what();
				}
			}
			return m_what.c_str();
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	class bad_weak_ptr: public std::exception
	{
	public:
		virtual char const*what()const throw()
		{
			return "tr1::bad_weak_ptr";
		}
	};
}
extern "C" long _InterlockedIncrement(long volatile*);
extern "C" long _InterlockedDecrement(long volatile*);
extern "C" long _InterlockedCompareExchange(long volatile*, long, long);
extern "C" long _InterlockedExchange(long volatile*, long);
extern "C" long _InterlockedExchangeAdd(long volatile*, long);
namespace boost
{
	namespace detail
	{
		typedef std::type_info sp_typeinfo;
	}
}
namespace boost
{
	namespace detail
	{
		class sp_counted_base
		{
		private:
			sp_counted_base(sp_counted_base const&);
			sp_counted_base&operator=(sp_counted_base const&);
			long use_count_;
			long weak_count_;
		public:
			sp_counted_base(): use_count_(1), weak_count_(1)
			{
			}
			virtual~sp_counted_base()
			{
			}
			virtual void dispose()=0;
			virtual void destroy()
			{
				delete this;
			}
			virtual void*get_deleter(sp_typeinfo const&ti)=0;
			void add_ref_copy()
			{
				_InterlockedIncrement(&use_count_);
			}
			bool add_ref_lock()
			{
				for(;
				;
				)
				{
					long tmp=static_cast<long const volatile&>(use_count_);
					if(tmp==0)return false;
					if(_InterlockedCompareExchange(&use_count_, tmp+1, tmp)==tmp)return true;
				}
			}
			void release()
			{
				if(_InterlockedDecrement(&use_count_)==0)
				{
					dispose();
					weak_release();
				}
			}
			void weak_add_ref()
			{
				_InterlockedIncrement(&weak_count_);
			}
			void weak_release()
			{
				if(_InterlockedDecrement(&weak_count_)==0)
				{
					destroy();
				}
			}
			long use_count()const
			{
				return static_cast<long const volatile&>(use_count_);
			}
		};
	}
}
namespace boost
{
	namespace detail
	{
		template<class X>
		class sp_counted_impl_p: public sp_counted_base
		{
		private:
			X*px_;
			sp_counted_impl_p(sp_counted_impl_p const&);
			sp_counted_impl_p&operator=(sp_counted_impl_p const&);
			typedef sp_counted_impl_p<X>this_type;
		public:
			explicit sp_counted_impl_p(X*px): px_(px)
			{
			}
			virtual void dispose()
			{
				boost::checked_delete(px_);
			}
			virtual void*get_deleter(detail::sp_typeinfo const&)
			{
				return 0;
			}
		};
		template<class P, class D>
		class sp_counted_impl_pd: public sp_counted_base
		{
		private:
			P ptr;
			D del;
			sp_counted_impl_pd(sp_counted_impl_pd const&);
			sp_counted_impl_pd&operator=(sp_counted_impl_pd const&);
			typedef sp_counted_impl_pd<P, D>this_type;
		public:
			sp_counted_impl_pd(P p, D d): ptr(p), del(d)
			{
			}
			virtual void dispose()
			{
				del(ptr);
			}
			virtual void*get_deleter(detail::sp_typeinfo const&ti)
			{
				return ti==typeid(D)?&reinterpret_cast<char&>(del): 0;
			}
		};
		template<class P, class D, class A>
		class sp_counted_impl_pda: public sp_counted_base
		{
		private:
			P p_;
			D d_;
			A a_;
			sp_counted_impl_pda(sp_counted_impl_pda const&);
			sp_counted_impl_pda&operator=(sp_counted_impl_pda const&);
			typedef sp_counted_impl_pda<P, D, A>this_type;
		public:
			sp_counted_impl_pda(P p, D d, A a): p_(p), d_(d), a_(a)
			{
			}
			virtual void dispose()
			{
				d_(p_);
			}
			virtual void destroy()
			{
				typedef typename A::template rebind<this_type>::other A2;
				A2 a2(a_);
				this->~this_type();
				a2.deallocate(this, 1);
			}
			virtual void*get_deleter(detail::sp_typeinfo const&ti)
			{
				return ti==typeid(D)?&reinterpret_cast<char&>(d_): 0;
			}
		};
	}
}
namespace boost
{
	namespace detail
	{
		struct sp_nothrow_tag
		{
		};
		class weak_count;
		class shared_count
		{
		private:
			sp_counted_base*pi_;
			friend class weak_count;
		public:
			shared_count(): pi_(0)
			{
			}
			template<class Y>
			explicit shared_count(Y*p): pi_(0)
			{
				pi_=new sp_counted_impl_p<Y>(p);
				if(pi_==0)
				{
					boost::checked_delete(p);
					boost::throw_exception(std::bad_alloc());
				}
			}
			template<class P, class D>
			shared_count(P p, D d): pi_(0)
			{
				pi_=new sp_counted_impl_pd<P, D>(p, d);
				if(pi_==0)
				{
					d(p);
					boost::throw_exception(std::bad_alloc());
				}
			}
			template<class P, class D, class A>
			shared_count(P p, D d, A a): pi_(0)
			{
				typedef sp_counted_impl_pda<P, D, A>impl_type;
				typedef typename A::template rebind<impl_type>::other A2;
				A2 a2(a);
				pi_=a2.allocate(1, static_cast<impl_type*>(0));
				if(pi_!=0)
				{
					new(static_cast<void*>(pi_))impl_type(p, d, a);
				}
				else
				{
					d(p);
					boost::throw_exception(std::bad_alloc());
				}
			}
			template<class Y>
			explicit shared_count(std::auto_ptr<Y>&r): pi_(new sp_counted_impl_p<Y>(r.get()))
			{
				if(pi_==0)
				{
					boost::throw_exception(std::bad_alloc());
				}
				r.release();
			}
			~shared_count()
			{
				if(pi_!=0)pi_->release();
			}
			shared_count(shared_count const&r): pi_(r.pi_)
			{
				if(pi_!=0)pi_->add_ref_copy();
			}
			explicit shared_count(weak_count const&r);
			shared_count(weak_count const&r, sp_nothrow_tag);
			shared_count&operator=(shared_count const&r)
			{
				sp_counted_base*tmp=r.pi_;
				if(tmp!=pi_)
				{
					if(tmp!=0)tmp->add_ref_copy();
					if(pi_!=0)pi_->release();
					pi_=tmp;
				}
				return *this;
			}
			void swap(shared_count&r)
			{
				sp_counted_base*tmp=r.pi_;
				r.pi_=pi_;
				pi_=tmp;
			}
			long use_count()const
			{
				return pi_!=0?pi_->use_count(): 0;
			}
			bool unique()const
			{
				return use_count()==1;
			}
			bool empty()const
			{
				return pi_==0;
			}
			friend inline bool operator==(shared_count const&a, shared_count const&b)
			{
				return a.pi_==b.pi_;
			}
			friend inline bool operator<(shared_count const&a, shared_count const&b)
			{
				return std::less<sp_counted_base*>()(a.pi_, b.pi_);
			}
			void*get_deleter(sp_typeinfo const&ti)const
			{
				return pi_?pi_->get_deleter(ti): 0;
			}
		};
		class weak_count
		{
		private:
			sp_counted_base*pi_;
			friend class shared_count;
		public:
			weak_count(): pi_(0)
			{
			}
			weak_count(shared_count const&r): pi_(r.pi_)
			{
				if(pi_!=0)pi_->weak_add_ref();
			}
			weak_count(weak_count const&r): pi_(r.pi_)
			{
				if(pi_!=0)pi_->weak_add_ref();
			}
			~weak_count()
			{
				if(pi_!=0)pi_->weak_release();
			}
			weak_count&operator=(shared_count const&r)
			{
				sp_counted_base*tmp=r.pi_;
				if(tmp!=pi_)
				{
					if(tmp!=0)tmp->weak_add_ref();
					if(pi_!=0)pi_->weak_release();
					pi_=tmp;
				}
				return *this;
			}
			weak_count&operator=(weak_count const&r)
			{
				sp_counted_base*tmp=r.pi_;
				if(tmp!=pi_)
				{
					if(tmp!=0)tmp->weak_add_ref();
					if(pi_!=0)pi_->weak_release();
					pi_=tmp;
				}
				return *this;
			}
			void swap(weak_count&r)
			{
				sp_counted_base*tmp=r.pi_;
				r.pi_=pi_;
				pi_=tmp;
			}
			long use_count()const
			{
				return pi_!=0?pi_->use_count(): 0;
			}
			bool empty()const
			{
				return pi_==0;
			}
			friend inline bool operator==(weak_count const&a, weak_count const&b)
			{
				return a.pi_==b.pi_;
			}
			friend inline bool operator<(weak_count const&a, weak_count const&b)
			{
				return std::less<sp_counted_base*>()(a.pi_, b.pi_);
			}
		};
		inline shared_count::shared_count(weak_count const&r): pi_(r.pi_)
		{
			if(pi_==0||!pi_->add_ref_lock())
			{
				boost::throw_exception(boost::bad_weak_ptr());
			}
		}
		inline shared_count::shared_count(weak_count const&r, sp_nothrow_tag): pi_(r.pi_)
		{
			if(pi_!=0&&!pi_->add_ref_lock())
			{
				pi_=0;
			}
		}
	}
}
namespace boost
{
	namespace detail
	{
		template<class Y, class T>
		struct sp_convertible
		{
			typedef char(&yes)[1];
			typedef char(&no)[2];
			static yes f(T*);
			static no f(...);
			enum _vt
			{
				value=sizeof(f(static_cast<Y*>(0)))==sizeof(yes)
			};
		};
		struct sp_empty
		{
		};
		template<bool>
		struct sp_enable_if_convertible_impl;
		template<>
		struct sp_enable_if_convertible_impl<true>
		{
			typedef sp_empty type;
		};
		template<>
		struct sp_enable_if_convertible_impl<false>
		{
		};
		template<class Y, class T>
		struct sp_enable_if_convertible: public sp_enable_if_convertible_impl<sp_convertible<Y, T>::value>
		{
		};
	}
}
extern "C" void _mm_pause();
namespace boost
{
	namespace detail
	{
		extern "C" void Sleep(unsigned ms);
		inline void yield(unsigned k)
		{
			if(k<4)
			{
			}
			else if(k<16)
			{
				_mm_pause();
			}
			else if(k<32)
			{
				Sleep(0);
			}
			else
			{
				Sleep(1);
			}
		}
	}
}
extern "C" void _ReadWriteBarrier();
namespace boost
{
	namespace detail
	{
		class spinlock
		{
		public:
			long v_;
		public:
			bool try_lock()
			{
				long r=_InterlockedExchange(&v_, 1);
				_ReadWriteBarrier();
				return r==0;
			}
			void lock()
			{
				for(unsigned k=0;
				!try_lock();
				++k)
				{
					boost::detail::yield(k);
				}
			}
			void unlock()
			{
				_ReadWriteBarrier();
				*const_cast<long volatile*>(&v_)=0;
			}
		public:
			class scoped_lock
			{
			private:
				spinlock&sp_;
				scoped_lock(scoped_lock const&);
				scoped_lock&operator=(scoped_lock const&);
			public:
				explicit scoped_lock(spinlock&sp): sp_(sp)
				{
					sp.lock();
				}
				~scoped_lock()
				{
					sp_.unlock();
				}
			};
		};
	}
}
namespace boost
{
	namespace detail
	{
		template<int I>
		class spinlock_pool
		{
		private:
			static spinlock pool_[41];
		public:
			static spinlock&spinlock_for(void const*pv)
			{
				std::size_t i=reinterpret_cast<std::size_t>(pv)%41;
				return pool_[i];
			}
			class scoped_lock
			{
			private:
				spinlock&sp_;
				scoped_lock(scoped_lock const&);
				scoped_lock&operator=(scoped_lock const&);
			public:
				explicit scoped_lock(void const*pv): sp_(spinlock_for(pv))
				{
					sp_.lock();
				}
				~scoped_lock()
				{
					sp_.unlock();
				}
			};
		};
		template<int I>
		spinlock spinlock_pool<I>::pool_[41]=
		{

			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
			,
			{
				0
			}
		};
	}
}
namespace boost
{
	enum memory_order
	{
		memory_order_relaxed=0, memory_order_acquire=1, memory_order_release=2, memory_order_acq_rel=3, memory_order_seq_cst=7
	};
}
namespace boost
{
	template<class T>
	class shared_ptr;
	template<class T>
	class weak_ptr;
	template<class T>
	class enable_shared_from_this;
	template<class T>
	class enable_shared_from_this2;
	namespace detail
	{
		struct static_cast_tag
		{
		};
		struct const_cast_tag
		{
		};
		struct dynamic_cast_tag
		{
		};
		struct polymorphic_cast_tag
		{
		};
		template<class T>
		struct shared_ptr_traits
		{
			typedef T&reference;
		};
		template<>
		struct shared_ptr_traits<void>
		{
			typedef void reference;
		};
		template<>
		struct shared_ptr_traits<void const>
		{
			typedef void reference;
		};
		template<>
		struct shared_ptr_traits<void volatile>
		{
			typedef void reference;
		};
		template<>
		struct shared_ptr_traits<void const volatile>
		{
			typedef void reference;
		};
		template<class X, class Y, class T>
		inline void sp_enable_shared_from_this(boost::shared_ptr<X>const*ppx, Y const*py, boost::enable_shared_from_this<T>const*pe)
		{
			if(pe!=0)
			{
				pe->_internal_accept_owner(ppx, const_cast<Y*>(py));
			}
		}
		template<class X, class Y, class T>
		inline void sp_enable_shared_from_this(boost::shared_ptr<X>*ppx, Y const*py, boost::enable_shared_from_this2<T>const*pe)
		{
			if(pe!=0)
			{
				pe->_internal_accept_owner(ppx, const_cast<Y*>(py));
			}
		}
		inline void sp_enable_shared_from_this(...)
		{
		}
		template<class T, class R>
		struct sp_enable_if_auto_ptr
		{
		};
		template<class T, class R>
		struct sp_enable_if_auto_ptr<std::auto_ptr<T>, R>
		{
			typedef R type;
		};
	}
	template<class T>
	class shared_ptr
	{
	private:
		typedef shared_ptr<T>this_type;
	public:
		typedef T element_type;
		typedef T value_type;
		typedef T*pointer;
		typedef typename boost::detail::shared_ptr_traits<T>::reference reference;
		shared_ptr(): px(0), pn()
		{
		}
		template<class Y>
		explicit shared_ptr(Y*p): px(p), pn(p)
		{
			boost::detail::sp_enable_shared_from_this(this, p, p);
		}
		template<class Y, class D>
		shared_ptr(Y*p, D d): px(p), pn(p, d)
		{
			boost::detail::sp_enable_shared_from_this(this, p, p);
		}
		template<class Y, class D, class A>
		shared_ptr(Y*p, D d, A a): px(p), pn(p, d, a)
		{
			boost::detail::sp_enable_shared_from_this(this, p, p);
		}
		template<class Y>
		explicit shared_ptr(weak_ptr<Y>const&r): pn(r.pn)
		{
			px=r.px;
		}
		template<class Y>
		shared_ptr(weak_ptr<Y>const&r, boost::detail::sp_nothrow_tag): px(0), pn(r.pn, boost::detail::sp_nothrow_tag())
		{
			if(!pn.empty())
			{
				px=r.px;
			}
		}
		template<class Y>
		shared_ptr(shared_ptr<Y>const&r, typename detail::sp_enable_if_convertible<Y, T>::type=detail::sp_empty()): px(r.px), pn(r.pn)
		{
		}
		template<class Y>
		shared_ptr(shared_ptr<Y>const&r, T*p): px(p), pn(r.pn)
		{
		}
		template<class Y>
		shared_ptr(shared_ptr<Y>const&r, boost::detail::static_cast_tag): px(static_cast<element_type*>(r.px)), pn(r.pn)
		{
		}
		template<class Y>
		shared_ptr(shared_ptr<Y>const&r, boost::detail::const_cast_tag): px(const_cast<element_type*>(r.px)), pn(r.pn)
		{
		}
		template<class Y>
		shared_ptr(shared_ptr<Y>const&r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type*>(r.px)), pn(r.pn)
		{
			if(px==0)
			{
				pn=boost::detail::shared_count();
			}
		}
		template<class Y>
		shared_ptr(shared_ptr<Y>const&r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type*>(r.px)), pn(r.pn)
		{
			if(px==0)
			{
				boost::throw_exception(std::bad_cast());
			}
		}
		template<class Y>
		explicit shared_ptr(std::auto_ptr<Y>&r): px(r.get()), pn()
		{
			Y*tmp=r.get();
			pn=boost::detail::shared_count(r);
			boost::detail::sp_enable_shared_from_this(this, tmp, tmp);
		}
		template<class Ap>
		explicit shared_ptr(Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type=0): px(r.get()), pn()
		{
			typename Ap::element_type*tmp=r.get();
			pn=boost::detail::shared_count(r);
			boost::detail::sp_enable_shared_from_this(this, tmp, tmp);
		}
		shared_ptr&operator=(shared_ptr const&r)
		{
			this_type(r).swap(*this);
			return *this;
		}
		template<class Y>
		shared_ptr&operator=(shared_ptr<Y>const&r)
		{
			this_type(r).swap(*this);
			return *this;
		}
		template<class Y>
		shared_ptr&operator=(std::auto_ptr<Y>&r)
		{
			this_type(r).swap(*this);
			return *this;
		}
		template<class Ap>
		typename boost::detail::sp_enable_if_auto_ptr<Ap, shared_ptr&>::type operator=(Ap r)
		{
			this_type(r).swap(*this);
			return *this;
		}
		void reset()
		{
			this_type().swap(*this);
		}
		template<class Y>
		void reset(Y*p)
		{
			(void)((!!(p==0||p!=px))||(_wassert(L"p == 0 || p != px", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\shared_ptr.hpp", 391), 0));
			this_type(p).swap(*this);
		}
		template<class Y, class D>
		void reset(Y*p, D d)
		{
			this_type(p, d).swap(*this);
		}
		template<class Y, class D, class A>
		void reset(Y*p, D d, A a)
		{
			this_type(p, d, a).swap(*this);
		}
		template<class Y>
		void reset(shared_ptr<Y>const&r, T*p)
		{
			this_type(r, p).swap(*this);
		}
		reference operator*()const
		{
			(void)((!!(px!=0))||(_wassert(L"px != 0", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\shared_ptr.hpp", 412), 0));
			return *px;
		}
		T*operator->()const
		{
			(void)((!!(px!=0))||(_wassert(L"px != 0", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\shared_ptr.hpp", 418), 0));
			return px;
		}
		T*get()const
		{
			return px;
		}
		typedef T*this_type::*unspecified_bool_type;
		operator unspecified_bool_type()const
		{
			return px==0?0: &this_type::px;
		}
		bool operator!()const
		{
			return px==0;
		}
		bool unique()const
		{
			return pn.unique();
		}
		long use_count()const
		{
			return pn.use_count();
		}
		void swap(shared_ptr<T>&other)
		{
			std::swap(px, other.px);
			pn.swap(other.pn);
		}
		template<class Y>
		bool _internal_less(shared_ptr<Y>const&rhs)const
		{
			return pn<rhs.pn;
		}
		void*_internal_get_deleter(detail::sp_typeinfo const&ti)const
		{
			return pn.get_deleter(ti);
		}
		bool _internal_equiv(shared_ptr const&r)const
		{
			return px==r.px&&pn==r.pn;
		}
		T*px;
		boost::detail::shared_count pn;
	};
	template<class T, class U>
	inline bool operator==(shared_ptr<T>const&a, shared_ptr<U>const&b)
	{
		return a.get()==b.get();
	}
	template<class T, class U>
	inline bool operator!=(shared_ptr<T>const&a, shared_ptr<U>const&b)
	{
		return a.get()!=b.get();
	}
	template<class T, class U>
	inline bool operator<(shared_ptr<T>const&a, shared_ptr<U>const&b)
	{
		return a._internal_less(b);
	}
	template<class T>
	inline void swap(shared_ptr<T>&a, shared_ptr<T>&b)
	{
		a.swap(b);
	}
	template<class T, class U>
	shared_ptr<T>static_pointer_cast(shared_ptr<U>const&r)
	{
		return shared_ptr<T>(r, boost::detail::static_cast_tag());
	}
	template<class T, class U>
	shared_ptr<T>const_pointer_cast(shared_ptr<U>const&r)
	{
		return shared_ptr<T>(r, boost::detail::const_cast_tag());
	}
	template<class T, class U>
	shared_ptr<T>dynamic_pointer_cast(shared_ptr<U>const&r)
	{
		return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
	}
	template<class T, class U>
	shared_ptr<T>shared_static_cast(shared_ptr<U>const&r)
	{
		return shared_ptr<T>(r, boost::detail::static_cast_tag());
	}
	template<class T, class U>
	shared_ptr<T>shared_dynamic_cast(shared_ptr<U>const&r)
	{
		return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
	}
	template<class T, class U>
	shared_ptr<T>shared_polymorphic_cast(shared_ptr<U>const&r)
	{
		return shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
	}
	template<class T, class U>
	shared_ptr<T>shared_polymorphic_downcast(shared_ptr<U>const&r)
	{
		(void)((!!(dynamic_cast<T*>(r.get())==r.get()))||(_wassert(L"dynamic_cast<T *>(r.get()) == r.get()", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\shared_ptr.hpp", 544), 0));
		return shared_static_cast<T>(r);
	}
	template<class T>
	inline T*get_pointer(shared_ptr<T>const&p)
	{
		return p.get();
	}
	template<class E, class T, class Y>
	std::basic_ostream<E, T>&operator<<(std::basic_ostream<E, T>&os, shared_ptr<Y>const&p)
	{
		os<<p.get();
		return os;
	}
	template<class D, class T>
	D*get_deleter(shared_ptr<T>const&p)
	{
		return static_cast<D*>(p._internal_get_deleter(typeid(D)));
	}
	template<class T>
	inline bool atomic_is_lock_free(shared_ptr<T>const*)
	{
		return false;
	}
	template<class T>
	shared_ptr<T>atomic_load(shared_ptr<T>const*p)
	{
		boost::detail::spinlock_pool<2>::scoped_lock lock(p);
		return *p;
	}
	template<class T>
	inline shared_ptr<T>atomic_load_explicit(shared_ptr<T>const*p, memory_order)
	{
		return atomic_load(p);
	}
	template<class T>
	void atomic_store(shared_ptr<T>*p, shared_ptr<T>r)
	{
		boost::detail::spinlock_pool<2>::scoped_lock lock(p);
		p->swap(r);
	}
	template<class T>
	inline void atomic_store_explicit(shared_ptr<T>*p, shared_ptr<T>r, memory_order)
	{
		atomic_store(p, r);
	}
	template<class T>
	shared_ptr<T>atomic_exchange(shared_ptr<T>*p, shared_ptr<T>r)
	{
		boost::detail::spinlock&sp=boost::detail::spinlock_pool<2>::spinlock_for(p);
		sp.lock();
		p->swap(r);
		sp.unlock();
		return r;
	}
	template<class T>
	shared_ptr<T>atomic_exchange_explicit(shared_ptr<T>*p, shared_ptr<T>r, memory_order)
	{
		return atomic_exchange(p, r);
	}
	template<class T>
	bool atomic_compare_exchange(shared_ptr<T>*p, shared_ptr<T>*v, shared_ptr<T>w)
	{
		boost::detail::spinlock&sp=boost::detail::spinlock_pool<2>::spinlock_for(p);
		sp.lock();
		if(p->_internal_equiv(*v))
		{
			p->swap(w);
			sp.unlock();
			return true;
		}
		else
		{
			shared_ptr<T>tmp(*p);
			sp.unlock();
			tmp.swap(*v);
			return false;
		}
	}
	template<class T>
	inline bool atomic_compare_exchange_explicit(shared_ptr<T>*p, shared_ptr<T>*v, shared_ptr<T>w, memory_order, memory_order)
	{
		return atomic_compare_exchange(p, v, w);
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace std
{
	struct messages_base: public locale::facet
	{
		typedef int catalog;
		explicit messages_base(size_t _Refs=0): locale::facet(_Refs)
		{
		}
		~messages_base()
		{
		}
	};
	template<class _Elem>
	class messages: public messages_base
	{
	public:
		typedef _Elem char_type;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >string_type;
		catalog open(const string&_Catname, const locale&_Loc)const
		{
			return (do_open(_Catname, _Loc));
		}
		string_type get(catalog _Catval, int _Set, int _Message, const string_type&_Dflt)const
		{
			return (do_get(_Catval, _Set, _Message, _Dflt));
		}
		void close(catalog _Catval)const
		{
			do_close(_Catval);
		}
		static locale::id id;
		explicit messages(size_t _Refs=0): messages_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		messages(const _Locinfo&_Lobj, size_t _Refs=0): messages_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocmes", 76)messages<_Elem>;
			return (6);
		}
		protected: messages(const char*_Locname, size_t _Refs=0): messages_base(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		virtual~messages()
		{
		}
		protected: void _Init(const _Locinfo&)
		{
		}
		virtual catalog do_open(const string&, const locale&)const
		{
			return (-1);
		}
		virtual string_type do_get(catalog, int, int, const string_type&_Dflt)const
		{
			return (_Dflt);
		}
		virtual void do_close(catalog)const
		{
		}
	};
	template<class _Elem>
	locale::id messages<_Elem>::id;
	template<class _Elem>
	class messages_byname: public messages<_Elem>
	{
	public:
		explicit messages_byname(const char*_Locname, size_t _Refs=0): messages<_Elem>(_Locname, _Refs)
		{
		}
		protected: virtual~messages_byname()
		{
		}
	};
}
namespace std
{
	const size_t _PATTERN_FIELD_SIZE=4;
	struct money_base: public locale::facet
	{
		enum
		{
			symbol='$', sign='+', space=' ', value='v', none='x'
		};
		typedef int part;
		struct pattern
		{
			char field[_PATTERN_FIELD_SIZE];
		};
		money_base(size_t _Refs=0): locale::facet(_Refs)
		{
		}
		~money_base()
		{
		}
	};
	template<class _Elem>
	class _Mpunct: public money_base
	{
	public:
		typedef _Elem char_type;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >string_type;
		_Elem decimal_point()const
		{
			return (do_decimal_point());
		}
		_Elem thousands_sep()const
		{
			return (do_thousands_sep());
		}
		string grouping()const
		{
			return (do_grouping());
		}
		string_type curr_symbol()const
		{
			return (do_curr_symbol());
		}
		string_type positive_sign()const
		{
			return (do_positive_sign());
		}
		string_type negative_sign()const
		{
			return (do_negative_sign());
		}
		int frac_digits()const
		{
			return (do_frac_digits());
		}
		pattern pos_format()const
		{
			return (do_pos_format());
		}
		pattern neg_format()const
		{
			return (do_neg_format());
		}
		explicit _Mpunct(size_t _Refs, bool _Intl): money_base(_Refs), _International(_Intl)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		_Mpunct(const _Locinfo&_Lobj, size_t _Refs, bool _Intl): money_base(_Refs), _International(_Intl)
		{
			_Init(_Lobj);
		}
		protected: virtual~_Mpunct()
		{
			_Tidy();
		}
		protected: _Mpunct(const char*_Locname, size_t _Refs, bool _Intl): money_base(_Refs), _International(_Intl)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
			const lconv*_Ptr=_Lobj._Getlconv();
			_Grouping=0;
			_Currencysign=0;
			_Plussign=0;
			_Minussign=0;
			try
			{
				_Grouping=_Maklocstr(_Ptr->mon_grouping, (char*)0, _Cvt);
				_Currencysign=_Maklocstr(_International?_Ptr->int_curr_symbol: _Ptr->currency_symbol, (_Elem*)0, _Cvt);
				_Plussign=_Maklocstr(4<(unsigned int)_Ptr->p_sign_posn?"": _Ptr->positive_sign, (_Elem*)0, _Cvt);
				_Minussign=_Maklocstr(4<(unsigned int)_Ptr->n_sign_posn?"-": _Ptr->negative_sign, (_Elem*)0, _Cvt);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
			_Decimalpoint=_Maklocchr(_Ptr->mon_decimal_point[0], (_Elem*)0, _Cvt);
			_Kseparator=_Maklocchr(_Ptr->mon_thousands_sep[0], (_Elem*)0, _Cvt);
			_Fracdigits=_International?_Ptr->int_frac_digits: _Ptr->frac_digits;
			if(_Fracdigits<0||127<=_Fracdigits)_Fracdigits=0;
			_Makpat(_Plusformat, _Ptr->p_sep_by_space, _Ptr->p_cs_precedes, _Ptr->p_sign_posn);
			_Makpat(_Minusformat, _Ptr->n_sep_by_space, _Ptr->n_cs_precedes, _Ptr->n_sign_posn);
		}
		virtual _Elem do_decimal_point()const
		{
			return (_Decimalpoint);
		}
		virtual _Elem do_thousands_sep()const
		{
			return (_Kseparator);
		}
		virtual string do_grouping()const
		{
			return (string(_Grouping));
		}
		virtual string_type do_curr_symbol()const
		{
			return (string_type(_Currencysign));
		}
		virtual string_type do_positive_sign()const
		{
			return (string_type(_Plussign));
		}
		virtual string_type do_negative_sign()const
		{
			return (string_type(_Minussign));
		}
		virtual int do_frac_digits()const
		{
			return (_Fracdigits);
		}
		virtual pattern do_pos_format()const
		{
			return (_Plusformat);
		}
		virtual pattern do_neg_format()const
		{
			return (_Minusformat);
		}
	private:
		void _Makpat(pattern&_Pattern, unsigned int _Sepbyspace, unsigned int _Symbolprecedes, unsigned int _Signposition)
		{
			const char*_Ptr=_International||2<_Sepbyspace||1<_Symbolprecedes||4<_Signposition?"$+xv": &("+v$x" "+v$x" "v$+x" "v+$x" "v$+x" "+$vx" "+$vx" "$v+x" "+$vx" "$+vx" "+v $" "+v $" "v $+" "v +$" "v $+" "+$ v" "+$ v" "$ v+" "+$ v" "$+ v" "+xv$" "+ v$" "v$ +" "v+ $" "v$ +" "+x$v" "+ $v" "$v +" "+ $v" "$ +v")[_Signposition*4+_Symbolprecedes*20+_Sepbyspace*40];
			::memcpy_s((_Pattern.field), (sizeof(_Pattern.field)), (_Ptr), (4));
		}
		void _Tidy()
		{
			std::_DebugHeapDelete((void*)(void*)_Grouping);
			std::_DebugHeapDelete((void*)(void*)_Currencysign);
			std::_DebugHeapDelete((void*)(void*)_Plussign);
			std::_DebugHeapDelete((void*)(void*)_Minussign);
		}
		const char*_Grouping;
		_Elem _Decimalpoint;
		_Elem _Kseparator;
		const _Elem*_Currencysign;
		const _Elem*_Plussign;
		const _Elem*_Minussign;
		int _Fracdigits;
		pattern _Plusformat;
		pattern _Minusformat;
		bool _International;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem, bool _Intl=false>
	class moneypunct: public _Mpunct<_Elem>
	{
	public:
		static const bool intl;
		static locale::id id;
		explicit moneypunct(size_t _Refs=0): _Mpunct<_Elem>(_Refs, _Intl)
		{
		}
		moneypunct(const _Locinfo&_Lobj, size_t _Refs=0): _Mpunct<_Elem>(_Lobj, _Refs, _Intl)
		{
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocmon", 273)moneypunct<_Elem, _Intl>;
			return (3);
		}
		protected: moneypunct(const char*_Locname, size_t _Refs=0): _Mpunct<_Elem>(_Locname, _Refs, _Intl)
		{
		}
		virtual~moneypunct()
		{
		}
	};
	template<class _Elem, bool _Intl>
	const bool moneypunct<_Elem, _Intl>::intl=_Intl;
	template<class _Elem, bool _Intl>
	locale::id moneypunct<_Elem, _Intl>::id;
	template<class _Elem, bool _Intl=false>
	class moneypunct_byname: public moneypunct<_Elem, _Intl>
	{
	public:
		explicit moneypunct_byname(const char*_Locname, size_t _Refs=0): moneypunct<_Elem, _Intl>(_Locname, _Refs)
		{
		}
		protected: virtual~moneypunct_byname()
		{
		}
	};
	template<class _Elem, class _InIt=istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class money_get: public locale::facet
	{
		typedef moneypunct<_Elem, false>_Mypunct0;
		typedef moneypunct<_Elem, true>_Mypunct1;
	public:
		typedef _Elem char_type;
		typedef _InIt iter_type;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >string_type;
		_InIt get(_InIt _First, _InIt _Last, bool _Intl, ios_base&_Iosbase, ios_base::iostate&_State, long double&_Val)const
		{
			return (do_get(_First, _Last, _Intl, _Iosbase, _State, _Val));
		}
		_InIt get(_InIt _First, _InIt _Last, bool _Intl, ios_base&_Iosbase, ios_base::iostate&_State, string_type&_Val)const
		{
			return (do_get(_First, _Last, _Intl, _Iosbase, _State, _Val));
		}
		static locale::id id;
		explicit money_get(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		money_get(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocmon", 364)money_get<_Elem, _InIt>;
			return (3);
		}
		protected: virtual~money_get()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, bool _Intl, ios_base&_Iosbase, ios_base::iostate&_State, long double&_Val)const
		{
			string_type _Str=_Getmfld(_First, _Last, _Intl, _Iosbase);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Str.size()==0)_State|=ios_base::failbit;
			else
			{
				const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
				string _Str2;
				_Str2.reserve(_Str.size());
				size_t _Off=0;
				if(_Str[0]<_E0||_E0+9<_Str[0])_Str2+='-', ++_Off;
				for(;
				_Off<_Str.size();
				++_Off)_Str2+=(char)(_Str[_Off]-_E0+'0');
				const char*_Eb=_Str2.c_str();
				char*_Ep;
				int _Errno=0;
				const long double _Ans=_Stoldx(_Eb, &_Ep, 0, &_Errno);
				if(_Ep==_Eb||_Errno!=0)_State|=ios_base::failbit;
				else _Val=_Ans;
			}
			return (_First);
		}
		virtual _InIt do_get(_InIt _First, _InIt _Last, bool _Intl, ios_base&_Iosbase, ios_base::iostate&_State, string_type&_Val)const
		{
			string_type _Str=_Getmfld(_First, _Last, _Intl, _Iosbase);
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Str.size()==0)_State|=ios_base::failbit;
			else _Val=_Str;
			return (_First);
		}
	private:
		string_type _Getmfld(_InIt&_First, _InIt&_Last, bool _Intl, ios_base&_Iosbase)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocmon", 434);
			const _Mpunct<_Elem>*_Ppunct_fac;
			if(_Intl)_Ppunct_fac=&use_facet<_Mypunct1>(_Iosbase.getloc());
			else _Ppunct_fac=&use_facet<_Mypunct0>(_Iosbase.getloc());
			bool _Bad=false, _Neg=false;
			string_type _Sign, _Val;
			const money_base::pattern _Pattern=_Ppunct_fac->neg_format();
			for(size_t _Off=0;
			!_Bad&&_Off<4;
			++_Off)switch(_Pattern.field[_Off])
			{
				case money_base::symbol:
				{
					string_type _Symbol=_Ppunct_fac->curr_symbol();
					typename string_type::const_iterator _Source;
					if(!(_Iosbase.flags()&ios_base::showbase)&&*_First!=*_Symbol.c_str())_Symbol.erase();
					else if(_Off==3&&_Sign.size()<=1&&(_First==_Last||*_First!=*_Symbol.c_str()))_Symbol.erase();
					for(_Source=_Symbol.begin();
					_First!=_Last&&_Source!=_Symbol.end()&&*_First==*_Source;
					++_Source, ++_First);
					if(_Source!=_Symbol.end())_Bad=true;
					break;
				}
				case money_base::sign: if(_First==_Last);
				else if(0<(_Ppunct_fac->positive_sign()).size()&&_Ppunct_fac->positive_sign()[0]==*_First)
				{
					++_First;
					_Sign=_Ppunct_fac->positive_sign();
				}
				else if(0<(_Ppunct_fac->negative_sign()).size()&&_Ppunct_fac->negative_sign()[0]==*_First)
				{
					++_First;
					_Sign=_Ppunct_fac->negative_sign();
					_Neg=true;
				}
				break;
				case money_base::value:
				{
					int _Fracdigseen=0;
					int _Fracdigits=_Ppunct_fac->frac_digits();
					const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
					const string _Grouping=_Ppunct_fac->grouping();
					if(127<=(unsigned char)*_Grouping.c_str())for(;
					_First!=_Last&&_E0<=*_First&&*_First<=_E0+9;
					++_First)_Val+=*_First;
					else
					{
						const _Elem _Kseparator=_Ppunct_fac->thousands_sep();
						string _Groups((size_t)1, '\0');
						size_t _Group=0;
						for(;
						_First!=_Last;
						++_First)if(_E0<=*_First&&*_First<=_E0+9)
						{
							_Val+=*_First;
							if(_Groups[_Group]!=127)++_Groups[_Group];
						}
						else if(_Groups[_Group]=='\0'||_Kseparator==(_Elem)0||*_First!=_Kseparator)break;
						else
						{
							_Groups.append((size_t)1, '\0');
							++_Group;
						}
						if(_Group==0);
						else if('\0'<_Groups[_Group])++_Group;
						else _Bad=true;
						for(const char*_Pg=_Grouping.c_str();
						!_Bad&&0<_Group;
						)if(*_Pg==127)break;
						else if(0<--_Group&&*_Pg!=_Groups[_Group]||0==_Group&&*_Pg<_Groups[_Group])_Bad=true;
						else if('\0'<_Pg[1])++_Pg;
						if(_Bad)break;
					}
					if(_First!=_Last&&*_First==_Ppunct_fac->decimal_point())
					{
						while(++_First!=_Last&&_E0<=*_First&&*_First<=_E0+9)if(_Fracdigseen<_Fracdigits)_Val+=*_First, ++_Fracdigseen;
					}
					if(_Val.size()==0)_Bad=true;
					else for(;
					_Fracdigseen<_Fracdigits;
					++_Fracdigseen)_Val+=_E0;
					break;
				}
				case money_base::space: case money_base::none:
				{
					if(_Off==3)break;
					const ctype<_Elem>&_Ctype_fac=use_facet<ctype<_Elem> >(_Iosbase.getloc());
					while(_First!=_Last&&_Ctype_fac.is(ctype_base::space, *_First))++_First;
				}
			}
			if(!_Bad&&1<_Sign.size())
			{
				typename string_type::const_iterator _Source;
				for(_Source=_Sign.begin();
				_First!=_Last&&++_Source!=_Sign.end()&&*_First==*_Source;
				++_First);
				if(_Source!=_Sign.end())_Bad=true;
			}
			if(_Bad)_Val.erase();
			else if(_Neg)_Val.insert((size_t)0, (size_t)1, _Maklocchr('-', (_Elem*)0, _Cvt));
			return (_Val);
		}
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem, class _InIt>
	locale::id money_get<_Elem, _InIt>::id;
	template<class _Elem, class _OutIt=ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class money_put: public locale::facet
	{
		typedef moneypunct<_Elem, false>_Mypunct0;
		typedef moneypunct<_Elem, true>_Mypunct1;
	public:
		typedef _Elem char_type;
		typedef _OutIt iter_type;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >string_type;
		_OutIt put(_OutIt _Dest, bool _Intl, ios_base&_Iosbase, _Elem _Fill, long double _Val)const
		{
			return (do_put(_Dest, _Intl, _Iosbase, _Fill, _Val));
		}
		_OutIt put(_OutIt _Dest, bool _Intl, ios_base&_Iosbase, _Elem _Fill, const string_type&_Val)const
		{
			return (do_put(_Dest, _Intl, _Iosbase, _Fill, _Val));
		}
		static locale::id id;
		explicit money_put(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		money_put(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocmon", 649)money_put<_Elem, _OutIt>;
			return (3);
		}
		protected: virtual~money_put()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
		}
		virtual _OutIt do_put(_OutIt _Dest, bool _Intl, ios_base&_Iosbase, _Elem _Fill, long double _Val)const
		{
			const int _Buf_size=40;
			bool _Negative=false;
			if(_Val<0)_Negative=true, _Val=-_Val;
			size_t _Exp;
			for(_Exp=0;
			1e35<=_Val&&_Exp<5000;
			_Exp+=10)_Val/=1e10;
			string_type _Val2;
			char _Buf[_Buf_size];
			int _Count=::sprintf_s(_Buf, _Buf_size, "%.0Lf", _Val);
			for(int _Off=0;
			_Off<_Count;
			++_Off)_Val2.append((typename string_type::size_type)1, _Maklocchr(_Buf[_Off], (_Elem*)0, _Cvt));
			_Val2.append(_Exp, _Maklocchr('0', (_Elem*)0, _Cvt));
			return (_Putmfld(_Dest, _Intl, _Iosbase, _Fill, _Negative, _Val2));
		}
		virtual _OutIt do_put(_OutIt _Dest, bool _Intl, ios_base&_Iosbase, _Elem _Fill, const string_type&_Val)const
		{
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			const _Elem*_Ptr=_Val.c_str();
			bool _Negative=false;
			if(*_Ptr==_Maklocchr('-', (_Elem*)0, _Cvt))_Negative=true, ++_Ptr;
			size_t _Count;
			for(_Count=0;
			_E0<=_Ptr[_Count]&&_Ptr[_Count]<=_E0+9;
			++_Count);
			string_type _Val2(_Ptr, _Count);
			if(_Count==0)_Val2.append((typename string_type::size_type)1, _E0);
			return (_Putmfld(_Dest, _Intl, _Iosbase, _Fill, _Negative, _Val2));
		}
	private:
		_OutIt _Putmfld(_OutIt _Dest, bool _Intl, ios_base&_Iosbase, _Elem _Fill, bool _Neg, string_type _Val)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xlocmon", 716);
			const _Mpunct<_Elem>*_Ppunct_fac;
			if(_Intl)_Ppunct_fac=&use_facet<_Mypunct1>(_Iosbase.getloc());
			else _Ppunct_fac=&use_facet<_Mypunct0>(_Iosbase.getloc());
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			const string _Grouping=_Ppunct_fac->grouping();
			int _Ifracdigits=_Ppunct_fac->frac_digits();
			unsigned int _Fracdigits=_Ifracdigits<0?-_Ifracdigits: _Ifracdigits;
			if(_Val.size()<=_Fracdigits)_Val.insert((size_t)0, _Fracdigits-_Val.size()+1, _E0);
			else if(*_Grouping.c_str()!=127&&'\0'<*_Grouping.c_str())
			{
				const _Elem _Kseparator=_Ppunct_fac->thousands_sep();
				const char*_Pg=_Grouping.c_str();
				size_t _Off=_Val.size()-_Fracdigits;
				while(*_Pg!=127&&'\0'<*_Pg&&(size_t)*_Pg<_Off)
				{
					_Val.insert(_Off-=*_Pg, (size_t)1, _Kseparator);
					if('\0'<_Pg[1])++_Pg;
				}
			}
			money_base::pattern _Pattern;
			string_type _Sign;
			if(_Neg)
			{
				_Pattern=_Ppunct_fac->neg_format();
				_Sign=_Ppunct_fac->negative_sign();
			}
			else
			{
				_Pattern=_Ppunct_fac->pos_format();
				_Sign=_Ppunct_fac->positive_sign();
			}
			string_type _Symbol;
			if(_Iosbase.flags()&ios_base::showbase)_Symbol=_Ppunct_fac->curr_symbol();
			bool _Intern=false;
			size_t _Fillcount, _Off;
			for(_Fillcount=0, _Off=0;
			_Off<4;
			++_Off)switch(_Pattern.field[_Off])
			{
				case money_base::symbol: _Fillcount+=_Symbol.size();
				break;
				case money_base::sign: _Fillcount+=_Sign.size();
				break;
				case money_base::value: _Fillcount+=_Val.size()+(0<_Fracdigits?1: 0)+(_Val.size()<=_Fracdigits?_Fracdigits-_Val.size()+1: 0);
				break;
				case money_base::space: ++_Fillcount;
				case money_base::none: if(_Off!=3)_Intern=true;
				break;
			}
			_Fillcount=_Iosbase.width()<=0||(size_t)_Iosbase.width()<=_Fillcount?0: (size_t)_Iosbase.width()-_Fillcount;
			ios_base::fmtflags _Afl=_Iosbase.flags()&ios_base::adjustfield;
			if(_Afl!=ios_base::left&&(_Afl!=ios_base::internal||!_Intern))
			{
				_Dest=_Rep(_Dest, _Fill, _Fillcount);
				_Fillcount=0;
			}
			for(_Off=0;
			_Off<4;
			++_Off)switch(_Pattern.field[_Off])
			{
				case money_base::symbol: _Dest=_Put(_Dest, _Symbol.begin(), _Symbol.size());
				break;
				case money_base::sign: if(0<_Sign.size())_Dest=_Put(_Dest, _Sign.begin(), 1);
				break;
				case money_base::value: if(_Fracdigits==0)_Dest=_Put(_Dest, _Val.begin(), _Val.size());
				else if(_Val.size()<=_Fracdigits)
				{
					*_Dest++=_E0;
					*_Dest++=_Ppunct_fac->decimal_point();
					_Dest=_Rep(_Dest, _E0, _Fracdigits-_Val.size());
					_Dest=_Put(_Dest, _Val.begin(), _Val.size());
				}
				else
				{
					_Dest=_Put(_Dest, _Val.begin(), _Val.size()-_Fracdigits);
					*_Dest++=_Ppunct_fac->decimal_point();
					_Dest=_Put(_Dest, _Val.end()-_Fracdigits, _Fracdigits);
				}
				break;
				case money_base::space: _Dest=_Rep(_Dest, _Fill, 1);
				case money_base::none: if(_Afl==ios_base::internal)
				{
					_Dest=_Rep(_Dest, _Fill, _Fillcount);
					_Fillcount=0;
				}
			}
			if(1<_Sign.size())_Dest=_Put(_Dest, _Sign.begin()+1, _Sign.size()-1);
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));
		}
		static _OutIt _Put(_OutIt _Dest, typename string_type::const_iterator _Source, size_t _Count)
		{
			for(;
			0<_Count;
			--_Count, ++_Dest, ++_Source)*_Dest=*_Source;
			return (_Dest);
		}
		static _OutIt _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count)
		{
			for(;
			0<_Count;
			--_Count, ++_Dest)*_Dest=_Ch;
			return (_Dest);
		}
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem, class _OutIt>
	locale::id money_put<_Elem, _OutIt>::id;
}
extern "C"
{
	typedef long clock_t;
	int*__daylight(void);
	long*__dstbias(void);
	long*__timezone(void);
	char**__tzname(void);
	errno_t _get_daylight(int*_Daylight);
	errno_t _get_dstbias(long*_Daylight_savings_bias);
	errno_t _get_timezone(long*_Timezone);
	errno_t _get_tzname(size_t*_ReturnValue, char*_Buffer, size_t _SizeInBytes, int _Index);
	char*asctime(const struct tm*_Tm);
	errno_t asctime_s(char*_Buf, size_t _SizeInBytes, const struct tm*_Tm);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t asctime_s(char(&_Buffer)[_SizeFIXED], const struct tm*_Time)
		{
			return asctime_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	char*_ctime32(const __time32_t*_Time);
	errno_t _ctime32_s(char*_Buf, size_t _SizeInBytes, const __time32_t*_Time);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ctime32_s(char(&_Buffer)[_SizeFIXED], const __time32_t*_Time)
		{
			return _ctime32_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	clock_t clock(void);
	double _difftime32(__time32_t _Time1, __time32_t _Time2);
	struct tm*_gmtime32(const __time32_t*_Time);
	errno_t _gmtime32_s(struct tm*_Tm, const __time32_t*_Time);
	struct tm*_localtime32(const __time32_t*_Time);
	errno_t _localtime32_s(struct tm*_Tm, const __time32_t*_Time);
	size_t strftime(char*_Buf, size_t _SizeInBytes, const char*_Format, const struct tm*_Tm);
	size_t _strftime_l(char*_Buf, size_t _Max_size, const char*_Format, const struct tm*_Tm, _locale_t _Locale);
	errno_t _strdate_s(char*_Buf, size_t _SizeInBytes);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strdate_s(char(&_Buffer)[_SizeFIXED])
		{
			return _strdate_s(_Buffer, _SizeFIXED);
		}
	}
	char*_strdate(char*_Buffer);
	errno_t _strtime_s(char*_Buf, size_t _SizeInBytes);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _strtime_s(char(&_Buffer)[_SizeFIXED])
		{
			return _strtime_s(_Buffer, _SizeFIXED);
		}
	}
	char*_strtime(char*_Buffer);
	__time32_t _time32(__time32_t*_Time);
	__time32_t _mktime32(struct tm*_Tm);
	__time32_t _mkgmtime32(struct tm*_Tm);
	void _tzset(void);
	double _difftime64(__time64_t _Time1, __time64_t _Time2);
	char*_ctime64(const __time64_t*_Time);
	errno_t _ctime64_s(char*_Buf, size_t _SizeInBytes, const __time64_t*_Time);
	extern "C++"
	{
		template<size_t _SizeFIXED>
		inline errno_t _ctime64_s(char(&_Buffer)[_SizeFIXED], const __time64_t*_Time)
		{
			return _ctime64_s(_Buffer, _SizeFIXED, _Time);
		}
	}
	struct tm*_gmtime64(const __time64_t*_Time);
	errno_t _gmtime64_s(struct tm*_Tm, const __time64_t*_Time);
	struct tm*_localtime64(const __time64_t*_Time);
	errno_t _localtime64_s(struct tm*_Tm, const __time64_t*_Time);
	__time64_t _mktime64(struct tm*_Tm);
	__time64_t _mkgmtime64(struct tm*_Tm);
	__time64_t _time64(__time64_t*_Time);
	unsigned _getsystime(struct tm*_Tm);
	unsigned _setsystime(struct tm*_Tm, unsigned _MilliSec);
	static double difftime(time_t _Time1, time_t _Time2)
	{
		return _difftime64(_Time1, _Time2);
	}
	static char*ctime(const time_t*_Time)
	{
		return _ctime64(_Time);
	}
	static errno_t ctime_s(char*_Buffer, size_t _SizeInBytes, const time_t*_Time)
	{
		return _ctime64_s(_Buffer, _SizeInBytes, _Time);
	}
	static struct tm*gmtime(const time_t*_Time)
	{
		return _gmtime64(_Time);
	}
	static errno_t gmtime_s(struct tm*_Tm, const time_t*_Time)
	{
		return _gmtime64_s(_Tm, _Time);
	}
	static struct tm*localtime(const time_t*_Time)
	{
		return _localtime64(_Time);
	}
	static errno_t localtime_s(struct tm*_Tm, const time_t*_Time)
	{
		return _localtime64_s(_Tm, _Time);
	}
	static time_t mktime(struct tm*_Tm)
	{
		return _mktime64(_Tm);
	}
	static time_t _mkgmtime(struct tm*_Tm)
	{
		return _mkgmtime64(_Tm);
	}
	static time_t time(time_t*_Time)
	{
		return _time64(_Time);
	}
}
namespace std
{
	using::clock_t;
	using::size_t;
	using::time_t;
	using::tm;
	using::asctime;
	using::clock;
	using::ctime;
	using::difftime;
	using::gmtime;
	using::localtime;
	using::mktime;
	using::strftime;
	using::time;
}
namespace std
{
	struct time_base: public locale::facet
	{
		enum dateorder
		{
			no_order, dmy, mdy, ymd, ydm
		};
		time_base(size_t _Refs=0): locale::facet(_Refs)
		{
		}
		~time_base()
		{
		}
	};
	template<class _Elem, class _InIt=istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_get: public time_base
	{
	public:
		typedef _Elem char_type;
		typedef _InIt iter_type;
		static locale::id id;
		dateorder date_order()const
		{
			return (do_date_order());
		}
		_InIt get_time(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, tm*_Pt)const
		{
			return (do_get_time(_First, _Last, _Iosbase, _State, _Pt));
		}
		_InIt get_date(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, tm*_Pt)const
		{
			return (do_get_date(_First, _Last, _Iosbase, _State, _Pt));
		}
		_InIt get_weekday(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, tm*_Pt)const
		{
			return (do_get_weekday(_First, _Last, _Iosbase, _State, _Pt));
		}
		_InIt get_monthname(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, tm*_Pt)const
		{
			return (do_get_monthname(_First, _Last, _Iosbase, _State, _Pt));
		}
		_InIt get_year(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, tm*_Pt)const
		{
			return (do_get_year(_First, _Last, _Iosbase, _State, _Pt));
		}
		explicit time_get(size_t _Refs=0): time_base(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		time_get(const _Locinfo&_Lobj, size_t _Refs=0): time_base(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 97)time_get<_Elem, _InIt>;
			return (5);
		}
		protected: virtual~time_get()
		{
			_Tidy();
		}
		protected: time_get(const char*_Locname, size_t _Refs=0): time_base(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
			_Days=0;
			_Months=0;
			try
			{
				_Days=_Maklocstr(_Lobj._Getdays(), (_Elem*)0, _Cvt);
				_Months=_Maklocstr(_Lobj._Getmonths(), (_Elem*)0, _Cvt);
				_Dateorder=(dateorder)_Lobj._Getdateorder();
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		virtual dateorder do_date_order()const
		{
			return (_Dateorder);
		}
		virtual _InIt do_get_time(_InIt _First, _InIt _Last, ios_base&, ios_base::iostate&_State, tm*_Pt)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 140);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 141);
			const _Elem _Colon=_Maklocchr(':', (_Elem*)0, _Cvt);
			_State|=_Getint(_First, _Last, 0, 23, _Pt->tm_hour);
			if(_State!=ios_base::goodbit||*_First!=_Colon)_State|=ios_base::failbit;
			else _State|=_Getint(++_First, _Last, 0, 59, _Pt->tm_min);
			if(_State!=ios_base::goodbit||*_First!=_Colon)_State|=ios_base::failbit;
			else _State|=_Getint(++_First, _Last, 0, 59, _Pt->tm_sec);
			return (_First);
		}
		virtual _InIt do_get_date(_InIt _First, _InIt _Last, ios_base&_Iosbase, ios_base::iostate&_State, tm*_Pt)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 161);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 162);
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			const _Elem _Colon=_Maklocchr(':', (_Elem*)0, _Cvt);
			const _Elem _Comma=_Maklocchr(',', (_Elem*)0, _Cvt);
			const _Elem _Slash=_Maklocchr('/', (_Elem*)0, _Cvt);
			const _Elem _Space=_Maklocchr(' ', (_Elem*)0, _Cvt);
			dateorder _Dorder=date_order();
			if(_Dorder==no_order)_Dorder=mdy;
			if(*_First<_E0||_E0+9<*_First)
			{
				_First=get_monthname(_First, _Last, _Iosbase, _State, _Pt);
				_Dorder=mdy;
			}
			else if(_Dorder==mdy)
			{
				_State|=_Getint(_First, _Last, 1, 12, _Pt->tm_mon);
				--_Pt->tm_mon;
			}
			else if(_Dorder==dmy)_State|=_Getint(_First, _Last, 1, 31, _Pt->tm_mday);
			else _First=get_year(_First, _Last, _Iosbase, _State, _Pt);
			if(_State==ios_base::goodbit)
			{
				while(*_First==_Space)++_First;
				if(*_First==_Colon||*_First==_Comma||*_First==_Slash)++_First;
				while(*_First==_Space)++_First;
			}
			if(_State!=ios_base::goodbit);
			else if(*_First<_E0||_E0+9<*_First)if(_Dorder==mdy)_State|=ios_base::failbit;
			else
			{
				_First=get_monthname(_First, _Last, _Iosbase, _State, _Pt);
				if(_Dorder==ydm)_Dorder=ymd;
			}
			else if(_Dorder==dmy||_Dorder==ymd)
			{
				_State|=_Getint(_First, _Last, 1, 12, _Pt->tm_mon);
				--_Pt->tm_mon;
			}
			else _State|=_Getint(_First, _Last, 1, 31, _Pt->tm_mday);
			if(_State==ios_base::goodbit)
			{
				while(*_First==_Space)++_First;
				if(*_First==_Colon||*_First==_Comma||*_First==_Slash)++_First;
				while(*_First==_Space)++_First;
			}
			if(_State!=ios_base::goodbit);
			else if(*_First<_E0||_E0+9<*_First)if(_Dorder!=ydm)_State|=ios_base::failbit;
			else _First=get_monthname(_First, _Last, _Iosbase, _State, _Pt);
			else if(_Dorder==ydm)
			{
				_State|=_Getint(_First, _Last, 1, 12, _Pt->tm_mon);
				--_Pt->tm_mon;
			}
			else if(_Dorder==ymd)_State|=_Getint(_First, _Last, 1, 31, _Pt->tm_mday);
			else _First=get_year(_First, _Last, _Iosbase, _State, _Pt);
			if(_First==_Last)_State|=ios_base::eofbit;
			return (_First);
		}
		virtual _InIt do_get_weekday(_InIt _First, _InIt _Last, ios_base&, ios_base::iostate&_State, tm*_Pt)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 252);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 253);
			int _Num=_Getloctxt(_First, _Last, (size_t)0, _Days);
			if(_Num<0)_State|=ios_base::failbit;
			else _Pt->tm_wday=_Num>>1;
			return (_First);
		}
		virtual _InIt do_get_monthname(_InIt _First, _InIt _Last, ios_base&, ios_base::iostate&_State, tm*_Pt)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 266);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 267);
			int _Num=_Getloctxt(_First, _Last, (size_t)0, _Months);
			if(_Num<0)_State|=ios_base::failbit;
			else _Pt->tm_mon=_Num>>1;
			return (_First);
		}
		virtual _InIt do_get_year(_InIt _First, _InIt _Last, ios_base&, ios_base::iostate&_State, tm*_Pt)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 280);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 281);
			int _Ans=0;
			_State|=_Getint(_First, _Last, 0, 2035, _Ans);
			if(_State&ios_base::failbit);
			else if(1900<=_Ans)_Ans-=1900;
			else if(2035-1900<_Ans)_State|=ios_base::failbit;
			if(!(_State&ios_base::failbit))_Pt->tm_year=_Ans;
			return (_First);
		}
	private:
		ios_base::iostate _Getint(_InIt&_First, _InIt&_Last, int _Lo, int _Hi, int&_Val)const
		{
			const _Elem _E0=_Maklocchr('0', (_Elem*)0, _Cvt);
			char _Ac[32], *_Ep;
			char*_Ptr=_Ac;
			if(_First==_Last);
			else if(*_First==_Maklocchr('+', (_Elem*)0, _Cvt))*_Ptr++='+', ++_First;
			else if(*_First==_Maklocchr('-', (_Elem*)0, _Cvt))*_Ptr++='-', ++_First;
			bool _Seendigit=false;
			while(_First!=_Last&&*_First==_E0)_Seendigit=true, ++_First;
			if(_Seendigit)*_Ptr++='0';
			for(char*const _Pe=&_Ac[32-1];
			_First!=_Last&&_E0<=*_First&&*_First<=_E0+9;
			_Seendigit=true, ++_First)
			{
				*_Ptr=(char)((*_First-_E0)+'0');
				if(_Ptr<_Pe)++_Ptr;
			}
			if(!_Seendigit)_Ptr=_Ac;
			*_Ptr='\0';
			int _Errno=0;
			const long _Ans=::_Stolx(_Ac, &_Ep, 10, &_Errno);
			ios_base::iostate _State=ios_base::goodbit;
			if(_First==_Last)_State|=ios_base::eofbit;
			if(_Ep==_Ac||_Errno!=0||_Ans<_Lo||_Hi<_Ans)_State|=ios_base::failbit;
			else _Val=_Ans;
			return (_State);
		}
		void _Tidy()
		{
			std::_DebugHeapDelete((void*)(void*)_Days);
			std::_DebugHeapDelete((void*)(void*)_Months);
		}
		const _Elem*_Days;
		const _Elem*_Months;
		dateorder _Dateorder;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem, class _InIt>
	locale::id time_get<_Elem, _InIt>::id;
	template<class _Elem, class _InIt=istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_get_byname: public time_get<_Elem, _InIt>
	{
	public:
		explicit time_get_byname(const char*_Locname, size_t _Refs=0): time_get<_Elem, _InIt>(_Locname, _Refs)
		{
		}
		protected: virtual~time_get_byname()
		{
		}
	};
	template<class _Elem, class _OutIt=ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_put: public locale::facet
	{
	public:
		typedef _Elem char_type;
		typedef _OutIt iter_type;
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const tm*_Pt, const _Elem*_Fmtfirst, const _Elem*_Fmtlast)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 392);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 393);
			const _Elem _Percent=_Maklocchr('%', (_Elem*)0, _Cvt);
			for(;
			_Fmtfirst!=_Fmtlast;
			++_Fmtfirst)if(*_Fmtfirst!=_Percent)*_Dest++=*_Fmtfirst;
			else if(++_Fmtfirst==_Fmtlast)
			{
				*_Dest++=_Percent;
				break;
			}
			else
			{
				char _Specifier=_Maklocbyte((_Elem)*_Fmtfirst, _Cvt);
				char _Qualifier='\0';
				if(_Specifier!='E'&&_Specifier!='O'&&_Specifier!='Q'&&_Specifier!='#');
				else if(++_Fmtfirst==_Fmtlast)
				{
					*_Dest++=_Percent, *_Dest++=_Specifier;
					break;
				}
				else
				{
					_Qualifier=_Specifier;
					_Specifier=_Maklocbyte((_Elem)*_Fmtfirst, _Cvt);
				}
				_Dest=do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Qualifier);
			}
			return (_Dest);
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const tm*_Pt, char _Specifier, char _Modifier=0)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier));
		}
		static locale::id id;
		explicit time_put(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		time_put(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 454)time_put<_Elem, _OutIt>;
			return (5);
		}
		protected: virtual~time_put()
		{
		}
		protected: void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
			_Tnames=_Lobj._Gettnames();
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&, _Elem, const tm*_Pt, char _Specifier, char _Modifier=0)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 474);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 475);
			char _Fmt[5]="!%x\0";
			size_t _Count, _Num;
			string _Str;
			if(_Modifier==(_Elem)0)_Fmt[2]=_Specifier;
			else _Fmt[2]=_Modifier, _Fmt[3]=_Specifier;
			for(_Num=16;
			;
			_Num*=2)
			{
				_Str.append(_Num, '\0');
				if(0<(_Count=_Strftime(&*_Str.begin(), _Str.size(), _Fmt, _Pt, _Tnames._Getptr())))break;
			}
			for(string::const_iterator _Snext=_Str.begin();
			0<--_Count;
			++_Dest)*_Dest=_Maklocchr(*++_Snext, (_Elem*)0, _Cvt);
			return (_Dest);
		}
	private:
		_Locinfo::_Timevec _Tnames;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _Elem, class _OutIt>
	locale::id time_put<_Elem, _OutIt>::id;
	template<class _OutIt>
	class time_put<wchar_t, _OutIt>: public locale::facet
	{
	public:
		typedef wchar_t _Elem;
		typedef _Elem char_type;
		typedef _OutIt iter_type;
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const tm*_Pt, const _Elem*_Fmtfirst, const _Elem*_Fmtlast)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 523);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 524);
			const _Elem _Percent=_Maklocchr('%', (_Elem*)0, _Cvt);
			for(;
			_Fmtfirst!=_Fmtlast;
			++_Fmtfirst)if(*_Fmtfirst!=_Percent)*_Dest++=*_Fmtfirst;
			else if(++_Fmtfirst==_Fmtlast)
			{
				*_Dest++=_Percent;
				break;
			}
			else
			{
				char _Specifier=_Maklocbyte((_Elem)*_Fmtfirst, _Cvt);
				char _Qualifier='\0';
				if(_Specifier!='E'&&_Specifier!='O'&&_Specifier!='Q'&&_Specifier!='#');
				else if(++_Fmtfirst==_Fmtlast)
				{
					*_Dest++=_Percent, *_Dest++=_Specifier;
					break;
				}
				else
				{
					_Qualifier=_Specifier;
					_Specifier=_Maklocbyte((_Elem)*_Fmtfirst, _Cvt);
				}
				_Dest=do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Qualifier);
			}
			return (_Dest);
		}
		_OutIt put(_OutIt _Dest, ios_base&_Iosbase, _Elem _Fill, const tm*_Pt, char _Specifier, char _Modifier=0)const
		{
			return (do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier));
		}
		static locale::id id;
		explicit time_put(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		time_put(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 585)time_put<_Elem, _OutIt>;
			return (5);
		}
		protected: virtual~time_put()
		{
		}
		protected: time_put(const char*_Locname, size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			_Cvt=_Lobj._Getcvt();
			_Tnames=_Lobj._Gettnames();
		}
		virtual _OutIt do_put(_OutIt _Dest, ios_base&, _Elem, const tm*_Pt, char _Specifier, char _Modifier=0)const
		{
			_Debug_pointer(_Dest, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 613);
			_Debug_pointer(_Pt, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\xloctime", 614);
			char _Fmt[5]="!%x\0";
			size_t _Count, _Num;
			string _Str;
			if(_Modifier==(_Elem)0)_Fmt[2]=_Specifier;
			else _Fmt[2]=_Modifier, _Fmt[3]=_Specifier;
			for(_Num=16;
			;
			_Num*=2)
			{
				_Str.append(_Num, '\0');
				if(0<(_Count=_Strftime(&*_Str.begin(), _Str.size(), _Fmt, _Pt, _Tnames._Getptr())))break;
			}
			int _Bytes;
			mbstate_t _Mbst=
			{
				0
			};
			wchar_t _Wc;
			--_Count;
			for(string::const_iterator _Snext=_Str.begin()+1;
			0<_Count;
			_Count-=_Bytes, _Snext+=_Bytes, *_Dest++=_Wc)switch(_Bytes=_Mbrtowc(&_Wc, &*_Snext, _Count, &_Mbst, &_Cvt))
			{
				case-2: case-1: return (_Dest);
				case 0: if(_Wc==L'\0')_Bytes=(int)::strlen(&*_Snext)+1;
				break;
				case-3: _Bytes=0;
			}
			return (_Dest);
		}
	private:
		_Locinfo::_Timevec _Tnames;
		_Locinfo::_Cvtvec _Cvt;
	};
	template<class _OutIt>
	locale::id time_put<wchar_t, _OutIt>::id;
	template<class _Elem, class _OutIt=ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_put_byname: public time_put<_Elem, _OutIt>
	{
	public:
		explicit time_put_byname(const char*_Locname, size_t _Refs=0): time_put<_Elem, _OutIt>(_Locname, _Refs)
		{
		}
		protected: virtual~time_put_byname()
		{
		}
	};
}
namespace std
{
	template<class _Elem>
	class collate: public locale::facet
	{
	public:
		typedef _Elem char_type;
		typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >string_type;
		int compare(const _Elem*_First1, const _Elem*_Last1, const _Elem*_First2, const _Elem*_Last2)const
		{
			return (do_compare(_First1, _Last1, _First2, _Last2));
		}
		string_type transform(const _Elem*_First, const _Elem*_Last)const
		{
			return (do_transform(_First, _Last));
		}
		long hash(const _Elem*_First, const _Elem*_Last)const
		{
			return (do_hash(_First, _Last));
		}
		static locale::id id;
		explicit collate(size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj;
				_Init(_Lobj);
			}
		}
		collate(const _Locinfo&_Lobj, size_t _Refs=0): locale::facet(_Refs)
		{
			_Init(_Lobj);
		}
		static size_t _Getcat(const locale::facet**_Ppf=0)
		{
			if(_Ppf!=0&&*_Ppf==0)*_Ppf=new(std::_DebugHeapTag_func(), "D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\locale", 64)collate<_Elem>;
			return (1);
		}
		protected: ~collate()
		{
		}
		protected: collate(const char*_Locname, size_t _Refs=0): locale::facet(_Refs)
		{

			{
				_Locinfo _Lobj(_Locname);
				_Init(_Lobj);
			}
		}
		void _Init(const _Locinfo&_Lobj)
		{
			_Coll=_Lobj._Getcoll();
		}
		virtual int do_compare(const _Elem*_First1, const _Elem*_Last1, const _Elem*_First2, const _Elem*_Last2)const
		{
			_Debug_range(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\locale", 90);
			_Debug_range(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\locale", 91);
			return (_LStrcoll(_First1, _Last1, _First2, _Last2, &_Coll));
		}
		virtual string_type do_transform(const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\locale", 98);
			size_t _Count;
			string_type _Str;
			for(_Count=_Last-_First;
			0<_Count;
			)
			{
				_Str.resize(_Count);
				if((_Count=_LStrxfrm(&*_Str.begin(), &*_Str.begin()+_Str.size(), _First, _Last, &_Coll))<=_Str.size())break;
			}
			_Str.resize(_Count);
			return (_Str);
		}
		virtual long do_hash(const _Elem*_First, const _Elem*_Last)const
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\locale", 117);
			unsigned long _Val=0;
			for(;
			_First!=_Last;
			++_First)_Val=(_Val<<8|_Val>>24)+*_First;
			return ((long)_Val);
		}
	private:
		_Locinfo::_Collvec _Coll;
	};
	template<class _Elem>
	locale::id collate<_Elem>::id;
	template<class _Elem>
	class collate_byname: public collate<_Elem>
	{
	public:
		explicit collate_byname(const char*_Locname, size_t _Refs=0): collate<_Elem>(_Locname, _Refs)
		{
		}
		protected: virtual~collate_byname()
		{
		}
	};
	template<class _Facet>
	inline bool has_facet(const locale&_Loc)throw()
	{

		{
			::std::_Lockit _Lock(0);
			size_t _Id=_Facet::id;
			return (_Loc._Getfacet(_Id)!=0||_Facet::_Getcat()!=(size_t)(-1));
		}
	}
	template<class _Facet>
	inline bool has_facet(const locale&_Loc, const _Facet*)throw()
	{
		return (has_facet<_Facet>(_Loc));
	}
	template<class _Elem>
	inline bool(isalnum)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::alnum, _Ch));
	}
	template<class _Elem>
	inline bool(isalpha)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::alpha, _Ch));
	}
	template<class _Elem>
	inline bool(iscntrl)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::cntrl, _Ch));
	}
	template<class _Elem>
	inline bool(isdigit)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::digit, _Ch));
	}
	template<class _Elem>
	inline bool(isgraph)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::graph, _Ch));
	}
	template<class _Elem>
	inline bool(islower)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::lower, _Ch));
	}
	template<class _Elem>
	inline bool(isprint)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::print, _Ch));
	}
	template<class _Elem>
	inline bool(ispunct)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::punct, _Ch));
	}
	template<class _Elem>
	inline bool(isspace)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::space, _Ch));
	}
	template<class _Elem>
	inline bool(isupper)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::upper, _Ch));
	}
	template<class _Elem>
	inline bool(isxdigit)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).is(ctype_base::xdigit, _Ch));
	}
	template<class _Elem>
	inline _Elem(tolower)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).tolower(_Ch));
	}
	template<class _Elem>
	inline _Elem(toupper)(_Elem _Ch, const locale&_Loc)
	{
		return (use_facet<ctype<_Elem> >(_Loc).toupper(_Ch));
	}
}
namespace boost
{
	namespace filesystem
	{
		template<class String, class Traits>
		class basic_path;
		struct path_traits;
		typedef basic_path<std::string, path_traits>path;
		struct path_traits
		{
			typedef std::string internal_string_type;
			typedef std::string external_string_type;
			static external_string_type to_external(const path&, const internal_string_type&src)
			{
				return src;
			}
			static internal_string_type to_internal(const external_string_type&src)
			{
				return src;
			}
		};
		struct wpath_traits;
		typedef basic_path<std::wstring, wpath_traits>wpath;
		struct wpath_traits
		{
			typedef std::wstring internal_string_type;
			typedef std::wstring external_string_type;
			static external_string_type to_external(const wpath&, const internal_string_type&src)
			{
				return src;
			}
			static internal_string_type to_internal(const external_string_type&src)
			{
				return src;
			}
			static void imbue(const std::locale&loc);
			static bool imbue(const std::locale&loc, const std::nothrow_t&);
		};
		template<class Path>
		struct is_basic_path
		{
			static const bool value=false;
		};
		template<>
		struct is_basic_path<path>
		{
			static const bool value=true;
		};
		template<>
		struct is_basic_path<wpath>
		{
			static const bool value=true;
		};
		template<class Path>
		struct slash
		{
			static const char value='/';
		};
		template<class Path>
		struct dot
		{
			static const char value='.';
		};
		template<class Path>
		struct colon
		{
			static const char value=':';
		};
		template<>
		struct slash<wpath>
		{
			static const wchar_t value=L'/';
		};
		template<>
		struct dot<wpath>
		{
			static const wchar_t value=L'.';
		};
		template<>
		struct colon<wpath>
		{
			static const wchar_t value=L':';
		};
		template<class Path>
		struct path_alt_separator
		{
			static const char value='\\';
		};
		template<>
		struct path_alt_separator<wpath>
		{
			static const wchar_t value=L'\\';
		};
		namespace detail
		{
			template<class Path>
			class iterator_helper
			{
			public:
				typedef typename Path::iterator iterator;
				static void do_increment(iterator&ph);
				static void do_decrement(iterator&ph);
			};
		}
		template<class String, class Traits>
		class basic_path
		{
		public:
			typedef basic_path<String, Traits>path_type;
			typedef String string_type;
			typedef typename String::value_type value_type;
			typedef Traits traits_type;
			typedef typename Traits::external_string_type external_string_type;
			basic_path()
			{
			}
			basic_path(const string_type&s)
			{
				operator/=(s);
			}
			basic_path(const value_type*s)
			{
				operator/=(s);
			}
			template<class InputIterator>
			basic_path(InputIterator first, InputIterator last)
			{
				append(first, last);
			}
			~basic_path()
			{
			}
			basic_path&operator=(const string_type&s)
			{
				m_path.clear();
				operator/=(s);
				return *this;
			}
			basic_path&operator=(const value_type*s)
			{
				m_path.clear();
				operator/=(s);
				return *this;
			}
			template<class InputIterator>
			basic_path&assign(InputIterator first, InputIterator last)
			{
				m_path.clear();
				append(first, last);
				return *this;
			}
			basic_path&operator/=(const basic_path&rhs)
			{
				return operator/=(rhs.string().c_str());
			}
			basic_path&operator/=(const string_type&rhs)
			{
				return operator/=(rhs.c_str());
			}
			basic_path&operator/=(const value_type*s);
			template<class InputIterator>
			basic_path&append(InputIterator first, InputIterator last);
			void clear()
			{
				m_path.clear();
			}
			void swap(basic_path&rhs)
			{
				m_path.swap(rhs.m_path);
			}
			basic_path&remove_filename();
			basic_path&replace_extension(const string_type&new_extension=string_type());
			basic_path&remove_leaf()
			{
				return remove_filename();
			}
			const string_type&string()const
			{
				return m_path;
			}
			const string_type file_string()const;
			const string_type directory_string()const
			{
				return file_string();
			}
			const external_string_type external_file_string()const
			{
				return Traits::to_external(*this, file_string());
			}
			const external_string_type external_directory_string()const
			{
				return Traits::to_external(*this, directory_string());
			}
			basic_path root_path()const;
			string_type root_name()const;
			string_type root_directory()const;
			basic_path relative_path()const;
			basic_path parent_path()const;
			string_type filename()const;
			string_type stem()const;
			string_type extension()const;
			string_type leaf()const
			{
				return filename();
			}
			basic_path branch_path()const
			{
				return parent_path();
			}
			bool has_leaf()const
			{
				return !m_path.empty();
			}
			bool has_branch_path()const
			{
				return !parent_path().empty();
			}
			bool empty()const
			{
				return m_path.empty();
			}
			bool is_complete()const;
			bool has_root_path()const;
			bool has_root_name()const;
			bool has_root_directory()const;
			bool has_relative_path()const
			{
				return !relative_path().empty();
			}
			bool has_filename()const
			{
				return !m_path.empty();
			}
			bool has_parent_path()const
			{
				return !parent_path().empty();
			}
			class iterator: public boost::iterator_facade<iterator, string_type const, boost::bidirectional_traversal_tag>
			{
			private:
				friend class boost::iterator_core_access;
				friend class boost::filesystem::basic_path<String, Traits>;
				const string_type&dereference()const
				{
					return m_name;
				}
				bool equal(const iterator&rhs)const
				{
					return m_path_ptr==rhs.m_path_ptr&&m_pos==rhs.m_pos;
				}
				friend class boost::filesystem::detail::iterator_helper<path_type>;
				void increment()
				{
					boost::filesystem::detail::iterator_helper<path_type>::do_increment(*this);
				}
				void decrement()
				{
					boost::filesystem::detail::iterator_helper<path_type>::do_decrement(*this);
				}
				string_type m_name;
				const basic_path*m_path_ptr;
				typename string_type::size_type m_pos;
			};
			typedef iterator const_iterator;
			iterator begin()const;
			iterator end()const;
		private:
			string_type m_path;
			void m_append_separator_if_needed();
			void m_append(value_type value);
			friend class iterator;
			friend class boost::filesystem::detail::iterator_helper<path_type>;
		public:
			typedef bool(*name_check)(const std::string&name);
			basic_path(const string_type&str, name_check)
			{
				operator/=(str);
			}
			basic_path(const typename string_type::value_type*s, name_check)
			{
				operator/=(s);
			}
			string_type native_file_string()const
			{
				return file_string();
			}
			string_type native_directory_string()const
			{
				return directory_string();
			}
			static bool default_name_check_writable()
			{
				return false;
			}
			static void default_name_check(name_check)
			{
			}
			static name_check default_name_check()
			{
				return 0;
			}
			basic_path&canonize();
			basic_path&normalize();
		};
		template<class String, class Traits>
		inline void swap(basic_path<String, Traits>&lhs, basic_path<String, Traits>&rhs)
		{
			lhs.swap(rhs);
		}
		template<class String, class Traits>
		bool operator<(const basic_path<String, Traits>&lhs, const basic_path<String, Traits>&rhs)
		{
			return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
		}
		template<class String, class Traits>
		bool operator<(const typename basic_path<String, Traits>::string_type::value_type*lhs, const basic_path<String, Traits>&rhs)
		{
			basic_path<String, Traits>tmp(lhs);
			return std::lexicographical_compare(tmp.begin(), tmp.end(), rhs.begin(), rhs.end());
		}
		template<class String, class Traits>
		bool operator<(const typename basic_path<String, Traits>::string_type&lhs, const basic_path<String, Traits>&rhs)
		{
			basic_path<String, Traits>tmp(lhs);
			return std::lexicographical_compare(tmp.begin(), tmp.end(), rhs.begin(), rhs.end());
		}
		template<class String, class Traits>
		bool operator<(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type::value_type*rhs)
		{
			basic_path<String, Traits>tmp(rhs);
			return std::lexicographical_compare(lhs.begin(), lhs.end(), tmp.begin(), tmp.end());
		}
		template<class String, class Traits>
		bool operator<(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type&rhs)
		{
			basic_path<String, Traits>tmp(rhs);
			return std::lexicographical_compare(lhs.begin(), lhs.end(), tmp.begin(), tmp.end());
		}
		template<class String, class Traits>
		inline bool operator==(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type::value_type*rhs)
		{
			typedef typename boost::filesystem::basic_path<String, Traits>path_type;
			const typename path_type::string_type::value_type*l(lhs.string().c_str());
			while((*l==*rhs||(*l==path_alt_separator<path_type>::value&&*rhs==slash<path_type>::value)||(*l==slash<path_type>::value&&*rhs==path_alt_separator<path_type>::value))&&*l)
			{
				++l;
				++rhs;
			}
			return *l==*rhs||(*l==path_alt_separator<path_type>::value&&*rhs==slash<path_type>::value)||(*l==slash<path_type>::value&&*rhs==path_alt_separator<path_type>::value);
		}
		template<class String, class Traits>
		inline bool operator==(const basic_path<String, Traits>&lhs, const basic_path<String, Traits>&rhs)
		{
			return lhs==rhs.string().c_str();
		}
		template<class String, class Traits>
		inline bool operator==(const typename basic_path<String, Traits>::string_type::value_type*lhs, const basic_path<String, Traits>&rhs)
		{
			return rhs==lhs;
		}
		template<class String, class Traits>
		inline bool operator==(const typename basic_path<String, Traits>::string_type&lhs, const basic_path<String, Traits>&rhs)
		{
			return rhs==lhs.c_str();
		}
		template<class String, class Traits>
		inline bool operator==(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type&rhs)
		{
			return lhs==rhs.c_str();
		}
		template<class String, class Traits>
		inline bool operator!=(const basic_path<String, Traits>&lhs, const basic_path<String, Traits>&rhs)
		{
			return !(lhs==rhs);
		}
		template<class String, class Traits>
		inline bool operator!=(const typename basic_path<String, Traits>::string_type::value_type*lhs, const basic_path<String, Traits>&rhs)
		{
			return !(lhs==rhs);
		}
		template<class String, class Traits>
		inline bool operator!=(const typename basic_path<String, Traits>::string_type&lhs, const basic_path<String, Traits>&rhs)
		{
			return !(lhs==rhs);
		}
		template<class String, class Traits>
		inline bool operator!=(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type::value_type*rhs)
		{
			return !(lhs==rhs);
		}
		template<class String, class Traits>
		inline bool operator!=(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type&rhs)
		{
			return !(lhs==rhs);
		}
		template<class String, class Traits>
		inline bool operator>(const basic_path<String, Traits>&lhs, const basic_path<String, Traits>&rhs)
		{
			return rhs<lhs;
		}
		template<class String, class Traits>
		inline bool operator>(const typename basic_path<String, Traits>::string_type::value_type*lhs, const basic_path<String, Traits>&rhs)
		{
			return rhs<basic_path<String, Traits>(lhs);
		}
		template<class String, class Traits>
		inline bool operator>(const typename basic_path<String, Traits>::string_type&lhs, const basic_path<String, Traits>&rhs)
		{
			return rhs<basic_path<String, Traits>(lhs);
		}
		template<class String, class Traits>
		inline bool operator>(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type::value_type*rhs)
		{
			return basic_path<String, Traits>(rhs)<lhs;
		}
		template<class String, class Traits>
		inline bool operator>(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type&rhs)
		{
			return basic_path<String, Traits>(rhs)<lhs;
		}
		template<class String, class Traits>
		inline bool operator<=(const basic_path<String, Traits>&lhs, const basic_path<String, Traits>&rhs)
		{
			return !(rhs<lhs);
		}
		template<class String, class Traits>
		inline bool operator<=(const typename basic_path<String, Traits>::string_type::value_type*lhs, const basic_path<String, Traits>&rhs)
		{
			return !(rhs<basic_path<String, Traits>(lhs));
		}
		template<class String, class Traits>
		inline bool operator<=(const typename basic_path<String, Traits>::string_type&lhs, const basic_path<String, Traits>&rhs)
		{
			return !(rhs<basic_path<String, Traits>(lhs));
		}
		template<class String, class Traits>
		inline bool operator<=(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type::value_type*rhs)
		{
			return !(basic_path<String, Traits>(rhs)<lhs);
		}
		template<class String, class Traits>
		inline bool operator<=(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type&rhs)
		{
			return !(basic_path<String, Traits>(rhs)<lhs);
		}
		template<class String, class Traits>
		inline bool operator>=(const basic_path<String, Traits>&lhs, const basic_path<String, Traits>&rhs)
		{
			return !(lhs<rhs);
		}
		template<class String, class Traits>
		inline bool operator>=(const typename basic_path<String, Traits>::string_type::value_type*lhs, const basic_path<String, Traits>&rhs)
		{
			return !(lhs<basic_path<String, Traits>(rhs));
		}
		template<class String, class Traits>
		inline bool operator>=(const typename basic_path<String, Traits>::string_type&lhs, const basic_path<String, Traits>&rhs)
		{
			return !(lhs<basic_path<String, Traits>(rhs));
		}
		template<class String, class Traits>
		inline bool operator>=(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type::value_type*rhs)
		{
			return !(basic_path<String, Traits>(lhs)<rhs);
		}
		template<class String, class Traits>
		inline bool operator>=(const basic_path<String, Traits>&lhs, const typename basic_path<String, Traits>::string_type&rhs)
		{
			return !(basic_path<String, Traits>(lhs)<rhs);
		}
		template<class String, class Traits>
		inline basic_path<String, Traits>operator/(const basic_path<String, Traits>&lhs, const basic_path<String, Traits>&rhs)
		{
			return basic_path<String, Traits>(lhs)/=rhs;
		}
		template<class String, class Traits>
		inline basic_path<String, Traits>operator/(const basic_path<String, Traits>&lhs, const typename String::value_type*rhs)
		{
			return basic_path<String, Traits>(lhs)/=basic_path<String, Traits>(rhs);
		}
		template<class String, class Traits>
		inline basic_path<String, Traits>operator/(const basic_path<String, Traits>&lhs, const String&rhs)
		{
			return basic_path<String, Traits>(lhs)/=basic_path<String, Traits>(rhs);
		}
		template<class String, class Traits>
		inline basic_path<String, Traits>operator/(const typename String::value_type*lhs, const basic_path<String, Traits>&rhs)
		{
			return basic_path<String, Traits>(lhs)/=rhs;
		}
		template<class String, class Traits>
		inline basic_path<String, Traits>operator/(const String&lhs, const basic_path<String, Traits>&rhs)
		{
			return basic_path<String, Traits>(lhs)/=rhs;
		}
		template<class Path>
		std::basic_ostream<typename Path::string_type::value_type, typename Path::string_type::traits_type>&operator<<(std::basic_ostream<typename Path::string_type::value_type, typename Path::string_type::traits_type>&os, const Path&ph)
		{
			os<<ph.string();
			return os;
		}
		template<class Path>
		std::basic_istream<typename Path::string_type::value_type, typename Path::string_type::traits_type>&operator>>(std::basic_istream<typename Path::string_type::value_type, typename Path::string_type::traits_type>&is, Path&ph)
		{
			typename Path::string_type str;
			is>>str;
			ph=str;
			return is;
		}
		namespace detail
		{
			inline const char*what(const char*sys_err_what, const path&path1_arg, const path&path2_arg, std::string&target)
			{
				try
				{
					if(target.empty())
					{
						target=sys_err_what;
						if(!path1_arg.empty())
						{
							target+=": \"";
							target+=path1_arg.file_string();
							target+="\"";
						}
						if(!path2_arg.empty())
						{
							target+=", \"";
							target+=path2_arg.file_string();
							target+="\"";
						}
					}
					return target.c_str();
				}
				catch(...)
				{
					return sys_err_what;
				}
			}
			template<class Path>
			const char*what(const char*sys_err_what, const Path&, const Path&, std::string&)
			{
				return sys_err_what;
			}
		}
		template<class Path>
		class basic_filesystem_error: public system::system_error
		{
		public:
			typedef Path path_type;
			basic_filesystem_error(const std::string&what_arg, system::error_code ec);
			basic_filesystem_error(const std::string&what_arg, const path_type&path1_arg, system::error_code ec);
			basic_filesystem_error(const std::string&what_arg, const path_type&path1_arg, const path_type&path2_arg, system::error_code ec);
			~basic_filesystem_error()throw()
			{
			}
			const path_type&path1()const
			{
				static const path_type empty_path;
				return m_imp_ptr.get()?m_imp_ptr->m_path1: empty_path;
			}
			const path_type&path2()const
			{
				static const path_type empty_path;
				return m_imp_ptr.get()?m_imp_ptr->m_path2: empty_path;
			}
			const char*what()const throw()
			{
				if(!m_imp_ptr.get())return system::system_error::what();
				return detail::what(system::system_error::what(), m_imp_ptr->m_path1, m_imp_ptr->m_path2, m_imp_ptr->m_what);
			}
		private:
			struct m_imp
			{
				path_type m_path1;
				path_type m_path2;
				std::string m_what;
			};
			boost::shared_ptr<m_imp>m_imp_ptr;
		};
		typedef basic_filesystem_error<path>filesystem_error;
		typedef basic_filesystem_error<wpath>wfilesystem_error;
		bool portable_posix_name(const std::string&name);
		bool windows_name(const std::string&name);
		bool portable_name(const std::string&name);
		bool portable_directory_name(const std::string&name);
		bool portable_file_name(const std::string&name);
		bool native(const std::string&name);
		inline bool no_check(const std::string&)
		{
			return true;
		}
		namespace detail
		{
			template<class Path>
			inline bool is_separator(typename Path::string_type::value_type c)
			{
				return c==slash<Path>::value||c==path_alt_separator<Path>::value;
			}
			template<class String, class Traits>
			typename String::size_type filename_pos(const String&str, typename String::size_type end_pos)
			{
				typedef typename boost::filesystem::basic_path<String, Traits>path_type;
				if(end_pos==2&&str[0]==slash<path_type>::value&&str[1]==slash<path_type>::value)return 0;
				if(end_pos&&str[end_pos-1]==slash<path_type>::value)return end_pos-1;
				typename String::size_type pos(str.find_last_of(slash<path_type>::value, end_pos-1));
				if(pos==String::npos)pos=str.find_last_of(path_alt_separator<path_type>::value, end_pos-1);
				if(pos==String::npos)pos=str.find_last_of(colon<path_type>::value, end_pos-2);
				return (pos==String::npos||(pos==1&&str[0]==slash<path_type>::value))?0: pos+1;
			}
			template<class String, class Traits>
			void first_element(const String&src, typename String::size_type&element_pos, typename String::size_type&element_size, typename String::size_type size=String::npos)
			{
				if(size==String::npos)size=src.size();
				element_pos=0;
				element_size=0;
				if(src.empty())return ;
				typedef typename boost::filesystem::basic_path<String, Traits>path_type;
				typename String::size_type cur(0);
				if(size>=2&&src[0]==slash<path_type>::value&&src[1]==slash<path_type>::value&&(size==2||src[2]!=slash<path_type>::value))
				{
					cur+=2;
					element_size+=2;
				}
				else if(src[0]==slash<path_type>::value)
				{
					++element_size;
					while(cur+1<size&&src[cur+1]==slash<path_type>::value)
					{
						++cur;
						++element_pos;
					}
					return ;
				}
				while(cur<size&&src[cur]!=colon<path_type>::value&&src[cur]!=slash<path_type>::value)
				{
					++cur;
					++element_size;
				}
				if(cur==size)return ;
				if(src[cur]==colon<path_type>::value)
				{
					++element_size;
				}
				return ;
			}
			template<class String, class Traits>
			typename String::size_type root_directory_start(const String&s, typename String::size_type size)
			{
				typedef typename boost::filesystem::basic_path<String, Traits>path_type;
				if(size>2&&s[1]==colon<path_type>::value&&s[2]==slash<path_type>::value)return 2;
				if(size==2&&s[0]==slash<path_type>::value&&s[1]==slash<path_type>::value)return String::npos;
				if(size>3&&s[0]==slash<path_type>::value&&s[1]==slash<path_type>::value&&s[2]!=slash<path_type>::value)
				{
					typename String::size_type pos(s.find(slash<path_type>::value, 2));
					return pos<size?pos: String::npos;
				}
				if(size>0&&s[0]==slash<path_type>::value)return 0;
				return String::npos;
			}
			template<class String, class Traits>
			bool is_non_root_slash(const String&str, typename String::size_type pos)
			{
				typedef typename boost::filesystem::basic_path<String, Traits>path_type;
				(void)((!!(!str.empty()&&str[pos]==slash<path_type>::value&&"precondition violation"))||(_wassert(L"!str.empty() && str[pos] == slash<path_type>::value && \"precondition violation\"", L"D:\\dev\\boost_1_41_0\\boost\\filesystem\\path.hpp", 921), 0));
				while(pos>0&&str[pos-1]==slash<path_type>::value)--pos;
				return pos!=0&&(pos<=2||str[1]!=slash<path_type>::value||str.find(slash<path_type>::value, 2)!=pos)&&(pos!=2||str[1]!=colon<path_type>::value);
			}
		}
		template<class String, class Traits>
		String basic_path<String, Traits>::filename()const
		{
			typename String::size_type end_pos(detail::filename_pos<String, Traits>(m_path, m_path.size()));
			return (m_path.size()&&end_pos&&m_path[end_pos]==slash<path_type>::value&&detail::is_non_root_slash<String, Traits>(m_path, end_pos))?String(1, dot<path_type>::value): m_path.substr(end_pos);
		}
		template<class String, class Traits>
		String basic_path<String, Traits>::stem()const
		{
			string_type name=filename();
			typename string_type::size_type n=name.rfind(dot<path_type>::value);
			return name.substr(0, n);
		}
		template<class String, class Traits>
		String basic_path<String, Traits>::extension()const
		{
			string_type name=filename();
			typename string_type::size_type n=name.rfind(dot<path_type>::value);
			if(n!=string_type::npos)return name.substr(n);
			else return string_type();
		}
		template<class String, class Traits>
		basic_path<String, Traits>basic_path<String, Traits>::parent_path()const
		{
			typename String::size_type end_pos(detail::filename_pos<String, Traits>(m_path, m_path.size()));
			bool filename_was_separator(m_path.size()&&m_path[end_pos]==slash<path_type>::value);
			typename string_type::size_type root_dir_pos(detail::root_directory_start<string_type, traits_type>(m_path, end_pos));
			for(;
			end_pos>0&&(end_pos-1)!=root_dir_pos&&m_path[end_pos-1]==slash<path_type>::value;
			--end_pos)
			{
			}
			return (end_pos==1&&root_dir_pos==0&&filename_was_separator)?path_type(): path_type(m_path.substr(0, end_pos));
		}
		template<class String, class Traits>
		basic_path<String, Traits>basic_path<String, Traits>::relative_path()const
		{
			iterator itr(begin());
			for(;
			itr.m_pos!=m_path.size()&&(itr.m_name[0]==slash<path_type>::value||itr.m_name[itr.m_name.size()-1]==colon<path_type>::value);
			++itr)
			{
			}
			return basic_path<String, Traits>(m_path.substr(itr.m_pos));
		}
		template<class String, class Traits>
		String basic_path<String, Traits>::root_name()const
		{
			iterator itr(begin());
			return (itr.m_pos!=m_path.size()&&((itr.m_name.size()>1&&itr.m_name[0]==slash<path_type>::value&&itr.m_name[1]==slash<path_type>::value)||itr.m_name[itr.m_name.size()-1]==colon<path_type>::value))?*itr: String();
		}
		template<class String, class Traits>
		String basic_path<String, Traits>::root_directory()const
		{
			typename string_type::size_type start(detail::root_directory_start<String, Traits>(m_path, m_path.size()));
			return start==string_type::npos?string_type(): m_path.substr(start, 1);
		}
		template<class String, class Traits>
		basic_path<String, Traits>basic_path<String, Traits>::root_path()const
		{
			return basic_path<String, Traits>(root_name())/=root_directory();
		}
		template<class String, class Traits>
		inline bool basic_path<String, Traits>::is_complete()const
		{
			return has_root_name()&&has_root_directory();
		}
		template<class String, class Traits>
		inline bool basic_path<String, Traits>::has_root_path()const
		{
			return !root_path().empty();
		}
		template<class String, class Traits>
		inline bool basic_path<String, Traits>::has_root_name()const
		{
			return !root_name().empty();
		}
		template<class String, class Traits>
		inline bool basic_path<String, Traits>::has_root_directory()const
		{
			return !root_directory().empty();
		}
		template<class String, class Traits>
		void basic_path<String, Traits>::m_append_separator_if_needed()
		{
			if(*(m_path.end()-1)!=colon<path_type>::value&&*(m_path.end()-1)!=slash<path_type>::value)
			{
				m_path+=slash<path_type>::value;
			}
		}
		template<class String, class Traits>
		void basic_path<String, Traits>::m_append(value_type value)
		{
			m_path+=(value==path_alt_separator<path_type>::value?slash<path_type>::value: value);
		}
		template<class String, class Traits>
		basic_path<String, Traits>&basic_path<String, Traits>::operator/=(const value_type*next_p)
		{
			if(*next_p==slash<path_type>::value&&*(next_p+1)==slash<path_type>::value&&*(next_p+2)==colon<path_type>::value)next_p+=3;
			if(!empty()&&*next_p!=0&&!detail::is_separator<path_type>(*next_p))
			{
				m_append_separator_if_needed();
			}
			for(;
			*next_p!=0;
			++next_p)m_append(*next_p);
			return *this;
		}
		template<class String, class Traits>
		template<class InputIterator>
		basic_path<String, Traits>&basic_path<String, Traits>::append(InputIterator first, InputIterator last)
		{
			if(!empty()&&first!=last&&!detail::is_separator<path_type>(*first))
			{
				m_append_separator_if_needed();
			}
			bool was_escape_sequence(true);
			std::size_t append_count(0);
			typename String::size_type initial_pos(m_path.size());
			for(;
			first!=last&&*first;
			++first)
			{
				if(append_count==0&&*first!=slash<path_type>::value)was_escape_sequence=false;
				if(append_count==1&&*first!=slash<path_type>::value)was_escape_sequence=false;
				if(append_count==2&&*first!=colon<path_type>::value)was_escape_sequence=false;
				m_append(*first);
				++append_count;
			}
			if(was_escape_sequence&&append_count>=3)m_path.erase(initial_pos, 3);
			return *this;
		}
		template<class String, class Traits>
		basic_path<String, Traits>&basic_path<String, Traits>::canonize()
		{
			static const typename string_type::value_type dot_str[]=
			{
				dot<path_type>::value, 0
			};
			if(m_path.empty())return *this;
			path_type temp;
			for(iterator itr(begin());
			itr!=end();
			++itr)
			{
				temp/=*itr;
			};
			if(temp.empty())temp/=dot_str;
			m_path=temp.m_path;
			return *this;
		}
		template<class String, class Traits>
		basic_path<String, Traits>&basic_path<String, Traits>::normalize()
		{
			static const typename string_type::value_type dot_str[]=
			{
				dot<path_type>::value, 0
			};
			if(m_path.empty())return *this;
			path_type temp;
			iterator start(begin());
			iterator last(end());
			iterator stop(last--);
			for(iterator itr(start);
			itr!=stop;
			++itr)
			{
				if(itr->size()==1&&(*itr)[0]==dot<path_type>::value&&itr!=start&&itr!=last)continue;
				if(!temp.empty()&&itr->size()==2&&(*itr)[0]==dot<path_type>::value&&(*itr)[1]==dot<path_type>::value)
				{
					string_type lf(temp.filename());
					if(lf.size()>0&&(lf.size()!=1||(lf[0]!=dot<path_type>::value&&lf[0]!=slash<path_type>::value))&&(lf.size()!=2||(lf[0]!=dot<path_type>::value&&lf[1]!=dot<path_type>::value&&lf[1]!=colon<path_type>::value)))
					{
						temp.remove_filename();
						if(temp.m_path.size()>0&&temp.m_path[temp.m_path.size()-1]==slash<path_type>::value)
						{
							typename string_type::size_type rds(detail::root_directory_start<String, Traits>(temp.m_path, temp.m_path.size()));
							if(rds==string_type::npos||rds!=temp.m_path.size()-1)
							{
								temp.m_path.erase(temp.m_path.size()-1);
							}
						}
						iterator next(itr);
						if(temp.empty()&&++next!=stop&&next==last&&*last==dot_str)temp/=dot_str;
						continue;
					}
				}
				temp/=*itr;
			};
			if(temp.empty())temp/=dot_str;
			m_path=temp.m_path;
			return *this;
		}
		template<class String, class Traits>
		basic_path<String, Traits>&basic_path<String, Traits>::remove_filename()
		{
			m_path.erase(detail::filename_pos<String, Traits>(m_path, m_path.size()));
			return *this;
		}
		template<class String, class Traits>
		basic_path<String, Traits>&basic_path<String, Traits>::replace_extension(const string_type&new_ext)
		{
			string_type old_ext=extension();
			if(!old_ext.empty())m_path.erase(m_path.size()-old_ext.size());
			if(!new_ext.empty()&&new_ext[0]!=dot<path_type>::value)m_path+=dot<path_type>::value;
			m_path+=new_ext;
			return *this;
		}
		template<class String, class Traits>
		const String basic_path<String, Traits>::file_string()const
		{
			typename string_type::size_type root_dir_start(detail::root_directory_start<String, Traits>(m_path, m_path.size()));
			bool in_root(root_dir_start!=string_type::npos);
			String s;
			for(typename string_type::size_type pos(0);
			pos!=m_path.size();
			++pos)
			{
				if(pos==0&&m_path.size()>1&&m_path[0]==slash<path_type>::value&&m_path[1]==slash<path_type>::value&&(m_path.size()==2||!detail::is_separator<path_type>(m_path[2])))
				{
					++pos;
					s+=path_alt_separator<path_type>::value;
					s+=path_alt_separator<path_type>::value;
					continue;
				}
				if(in_root)
				{
					if(s.size()>0&&s[s.size()-1]==path_alt_separator<path_type>::value&&m_path[pos]==slash<path_type>::value)continue;
				}
				if(m_path[pos]==slash<path_type>::value)s+=path_alt_separator<path_type>::value;
				else s+=m_path[pos];
				if(pos>root_dir_start&&m_path[pos]==slash<path_type>::value)
				{
					in_root=false;
				}
			}
			return s;
		}
		template<class String, class Traits>
		typename basic_path<String, Traits>::iterator basic_path<String, Traits>::begin()const
		{
			iterator itr;
			itr.m_path_ptr=this;
			typename string_type::size_type element_size;
			detail::first_element<String, Traits>(m_path, itr.m_pos, element_size);
			itr.m_name=m_path.substr(itr.m_pos, element_size);
			return itr;
		}
		template<class String, class Traits>
		typename basic_path<String, Traits>::iterator basic_path<String, Traits>::end()const
		{
			iterator itr;
			itr.m_path_ptr=this;
			itr.m_pos=m_path.size();
			return itr;
		}
		namespace detail
		{
			template<class Path>
			void iterator_helper<Path>::do_increment(iterator&itr)
			{
				typedef typename Path::string_type string_type;
				typedef typename Path::traits_type traits_type;
				(void)((!!(itr.m_pos<itr.m_path_ptr->m_path.size()&&"basic_path::iterator increment past end()"))||(_wassert(L"itr.m_pos < itr.m_path_ptr->m_path.size() && \"basic_path::iterator increment past end()\"", L"D:\\dev\\boost_1_41_0\\boost\\filesystem\\path.hpp", 1385), 0));
				bool was_net(itr.m_name.size()>2&&itr.m_name[0]==slash<Path>::value&&itr.m_name[1]==slash<Path>::value&&itr.m_name[2]!=slash<Path>::value);
				itr.m_pos+=itr.m_name.size();
				if(itr.m_pos==itr.m_path_ptr->m_path.size())
				{
					itr.m_name.erase(itr.m_name.begin(), itr.m_name.end());
					return ;
				}
				if(itr.m_path_ptr->m_path[itr.m_pos]==slash<Path>::value)
				{
					if(was_net||itr.m_name[itr.m_name.size()-1]==colon<Path>::value)
					{
						itr.m_name=slash<Path>::value;
						return ;
					}
					while(itr.m_pos!=itr.m_path_ptr->m_path.size()&&itr.m_path_ptr->m_path[itr.m_pos]==slash<Path>::value)
					{
						++itr.m_pos;
					}
					if(itr.m_pos==itr.m_path_ptr->m_path.size()&&detail::is_non_root_slash<string_type, traits_type>(itr.m_path_ptr->m_path, itr.m_pos-1))
					{
						--itr.m_pos;
						itr.m_name=dot<Path>::value;
						return ;
					}
				}
				typename string_type::size_type end_pos(itr.m_path_ptr->m_path.find(slash<Path>::value, itr.m_pos));
				itr.m_name=itr.m_path_ptr->m_path.substr(itr.m_pos, end_pos-itr.m_pos);
			}
			template<class Path>
			void iterator_helper<Path>::do_decrement(iterator&itr)
			{
				(void)((!!(itr.m_pos&&"basic_path::iterator decrement past begin()"))||(_wassert(L"itr.m_pos && \"basic_path::iterator decrement past begin()\"", L"D:\\dev\\boost_1_41_0\\boost\\filesystem\\path.hpp", 1444), 0));
				typedef typename Path::string_type string_type;
				typedef typename Path::traits_type traits_type;
				typename string_type::size_type end_pos(itr.m_pos);
				typename string_type::size_type root_dir_pos(detail::root_directory_start<string_type, traits_type>(itr.m_path_ptr->m_path, end_pos));
				if(itr.m_pos==itr.m_path_ptr->m_path.size()&&itr.m_path_ptr->m_path.size()>1&&itr.m_path_ptr->m_path[itr.m_pos-1]==slash<Path>::value&&detail::is_non_root_slash<string_type, traits_type>(itr.m_path_ptr->m_path, itr.m_pos-1))
				{
					--itr.m_pos;
					itr.m_name=dot<Path>::value;
					return ;
				}
				for(;
				end_pos>0&&(end_pos-1)!=root_dir_pos&&itr.m_path_ptr->m_path[end_pos-1]==slash<Path>::value;
				--end_pos)
				{
				}
				itr.m_pos=detail::filename_pos<string_type, traits_type>(itr.m_path_ptr->m_path, end_pos);
				itr.m_name=itr.m_path_ptr->m_path.substr(itr.m_pos, end_pos-itr.m_pos);
			}
		}
		template<class Path>
		basic_filesystem_error<Path>::basic_filesystem_error(const std::string&what_arg, system::error_code ec): system::system_error(ec, what_arg)
		{
			try
			{
				m_imp_ptr.reset(new m_imp);
			}
			catch(...)
			{
				m_imp_ptr.reset();
			}
		}
		template<class Path>
		basic_filesystem_error<Path>::basic_filesystem_error(const std::string&what_arg, const path_type&path1_arg, system::error_code ec): system::system_error(ec, what_arg)
		{
			try
			{
				m_imp_ptr.reset(new m_imp);
				m_imp_ptr->m_path1=path1_arg;
			}
			catch(...)
			{
				m_imp_ptr.reset();
			}
		}
		template<class Path>
		basic_filesystem_error<Path>::basic_filesystem_error(const std::string&what_arg, const path_type&path1_arg, const path_type&path2_arg, system::error_code ec): system::system_error(ec, what_arg)
		{
			try
			{
				m_imp_ptr.reset(new m_imp);
				m_imp_ptr->m_path1=path1_arg;
				m_imp_ptr->m_path2=path2_arg;
			}
			catch(...)
			{
				m_imp_ptr.reset();
			}
		}
	}
}
namespace boost
{
	namespace details
	{
		namespace pool
		{
			class null_mutex
			{
			private:
				null_mutex(const null_mutex&);
				void operator=(const null_mutex&);
			public:
				null_mutex()
				{
				}
				static void lock()
				{
				}
				static void unlock()
				{
				}
			};
			typedef null_mutex default_mutex;
		}
	}
}
namespace boost
{
	template<typename SizeType=std::size_t>
	class simple_segregated_storage;
	struct default_user_allocator_new_delete;
	struct default_user_allocator_malloc_free;
	template<typename UserAllocator=default_user_allocator_new_delete>
	class pool;
	template<typename T, typename UserAllocator=default_user_allocator_new_delete>
	class object_pool;
	template<typename Tag, unsigned RequestedSize, typename UserAllocator=default_user_allocator_new_delete, typename Mutex=details::pool::default_mutex, unsigned NextSize=32>
	struct singleton_pool;
	struct pool_allocator_tag;
	template<typename T, typename UserAllocator=default_user_allocator_new_delete, typename Mutex=details::pool::default_mutex, unsigned NextSize=32>
	class pool_allocator;
	struct fast_pool_allocator_tag;
	template<typename T, typename UserAllocator=default_user_allocator_new_delete, typename Mutex=details::pool::default_mutex, unsigned NextSize=32>
	class fast_pool_allocator;
}
namespace boost
{
	namespace details
	{
		namespace pool
		{
			namespace details
			{
				template<unsigned A, unsigned B, bool Bis0>
				struct ct_gcd_helper;
				template<unsigned A, unsigned B>
				struct ct_gcd_helper<A, B, false>
				{
					static const unsigned A_mod_B_=A%B;
					static const unsigned value=(::boost::details::pool::details::ct_gcd_helper<B, static_cast<unsigned>(A_mod_B_), ::boost::type_traits::ice_eq<A_mod_B_, 0>::value>::value);
				};
				template<unsigned A, unsigned B>
				struct ct_gcd_helper<A, B, true>
				{
					static const unsigned value=A;
				};
			}
			template<unsigned A, unsigned B>
			struct ct_gcd
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(A!=0&&B!=0)>)>boost_static_assert_typedef___COUNTER__;
				static const unsigned value=(::boost::details::pool::details::ct_gcd_helper<A, B, false>::value);
			};
			template<unsigned A, unsigned B>
			struct ct_lcm
			{
				static const unsigned value=(A/::boost::details::pool::ct_gcd<A, B>::value*B);
			};
		}
	}
}
namespace boost
{
	namespace details
	{
		namespace pool
		{
			template<typename Integer>
			Integer gcd(Integer A, Integer B)
			{
				do
				{
					const Integer tmp(B);
					B=A%B;
					A=tmp;
				}
				while(B!=0);
				return A;
			}
			template<typename Integer>
			Integer lcm(const Integer&A, const Integer&B)
			{
				Integer ret=A;
				ret/=gcd(A, B);
				ret*=B;
				return ret;
			}
		}
	}
}
namespace boost
{
	template<typename SizeType>
	class simple_segregated_storage
	{
	public:
		typedef SizeType size_type;
	private:
		simple_segregated_storage(const simple_segregated_storage&);
		void operator=(const simple_segregated_storage&);
		static void*try_malloc_n(void*&start, size_type n, size_type partition_size);
		protected: void*first;
		void*find_prev(void*ptr);
		static void*&nextof(void*const ptr)
		{
			return *(static_cast<void**>(ptr));
		}
	public:
		simple_segregated_storage(): first(0)
		{
		}
		static void*segregate(void*block, size_type nsz, size_type npartition_sz, void*end=0);
		void add_block(void*const block, const size_type nsz, const size_type npartition_sz)
		{
			first=segregate(block, nsz, npartition_sz, first);
		}
		void add_ordered_block(void*const block, const size_type nsz, const size_type npartition_sz)
		{
			void*const loc=find_prev(block);
			if(loc==0)add_block(block, nsz, npartition_sz);
			else nextof(loc)=segregate(block, nsz, npartition_sz, nextof(loc));
		}
		bool empty()const
		{
			return (first==0);
		}
		void*malloc()
		{
			void*const ret=first;
			first=nextof(first);
			return ret;
		}
		void free(void*const chunk)
		{
			nextof(chunk)=first;
			first=chunk;
		}
		void ordered_free(void*const chunk)
		{
			void*const loc=find_prev(chunk);
			if(loc==0)free(chunk);
			else
			{
				nextof(chunk)=nextof(loc);
				nextof(loc)=chunk;
			}
		}
		void*malloc_n(size_type n, size_type partition_size);
		void free_n(void*const chunks, const size_type n, const size_type partition_size)
		{
			add_block(chunks, n*partition_size, partition_size);
		}
		void ordered_free_n(void*const chunks, const size_type n, const size_type partition_size)
		{
			add_ordered_block(chunks, n*partition_size, partition_size);
		}
	};
	template<typename SizeType>
	void*simple_segregated_storage<SizeType>::find_prev(void*const ptr)
	{
		if(first==0||std::greater<void*>()(first, ptr))return 0;
		void*iter=first;
		while(true)
		{
			if(nextof(iter)==0||std::greater<void*>()(nextof(iter), ptr))return iter;
			iter=nextof(iter);
		}
	}
	template<typename SizeType>
	void*simple_segregated_storage<SizeType>::segregate(void*const block, const size_type sz, const size_type partition_sz, void*const end)
	{
		char*old=static_cast<char*>(block)+((sz-partition_sz)/partition_sz)*partition_sz;
		nextof(old)=end;
		if(old==block)return block;
		for(char*iter=old-partition_sz;
		iter!=block;
		old=iter, iter-=partition_sz)nextof(iter)=old;
		nextof(block)=old;
		return block;
	}
	template<typename SizeType>
	void*simple_segregated_storage<SizeType>::try_malloc_n(void*&start, size_type n, const size_type partition_size)
	{
		void*iter=nextof(start);
		while(--n!=0)
		{
			void*next=nextof(iter);
			if(next!=static_cast<char*>(iter)+partition_size)
			{
				start=iter;
				return 0;
			}
			iter=next;
		}
		return iter;
	}
	template<typename SizeType>
	void*simple_segregated_storage<SizeType>::malloc_n(const size_type n, const size_type partition_size)
	{
		void*start=&first;
		void*iter;
		do
		{
			if(nextof(start)==0)return 0;
			iter=try_malloc_n(start, n, partition_size);
		}
		while(iter==0);
		void*const ret=nextof(start);
		nextof(start)=nextof(iter);
		return ret;
	}
}
namespace boost
{
	struct default_user_allocator_new_delete
	{
		typedef std::size_t size_type;
		typedef std::ptrdiff_t difference_type;
		static char*malloc(const size_type bytes)
		{
			return new(std::nothrow)char[bytes];
		}
		static void free(char*const block)
		{
			delete[]block;
		}
	};
	struct default_user_allocator_malloc_free
	{
		typedef std::size_t size_type;
		typedef std::ptrdiff_t difference_type;
		static char*malloc(const size_type bytes)
		{
			return reinterpret_cast<char*>(std::malloc(bytes));
		}
		static void free(char*const block)
		{
			std::free(block);
		}
	};
	namespace details
	{
		template<typename SizeType>
		class PODptr
		{
		public:
			typedef SizeType size_type;
		private:
			char*ptr;
			size_type sz;
			char*ptr_next_size()const
			{
				return (ptr+sz-sizeof(size_type));
			}
			char*ptr_next_ptr()const
			{
				return (ptr_next_size()-pool::ct_lcm<sizeof(size_type), sizeof(void*)>::value);
			}
		public:
			PODptr(char*const nptr, const size_type nsize): ptr(nptr), sz(nsize)
			{
			}
			PODptr(): ptr(0), sz(0)
			{
			}
			bool valid()const
			{
				return (begin()!=0);
			}
			void invalidate()
			{
				begin()=0;
			}
			char*&begin()
			{
				return ptr;
			}
			char*begin()const
			{
				return ptr;
			}
			char*end()const
			{
				return ptr_next_ptr();
			}
			size_type total_size()const
			{
				return sz;
			}
			size_type element_size()const
			{
				return (sz-sizeof(size_type)-pool::ct_lcm<sizeof(size_type), sizeof(void*)>::value);
			}
			size_type&next_size()const
			{
				return *(reinterpret_cast<size_type*>(ptr_next_size()));
			}
			char*&next_ptr()const
			{
				return *(reinterpret_cast<char**>(ptr_next_ptr()));
			}
			PODptr next()const
			{
				return PODptr<size_type>(next_ptr(), next_size());
			}
			void next(const PODptr&arg)const
			{
				next_ptr()=arg.begin();
				next_size()=arg.total_size();
			}
		};
	}
	template<typename UserAllocator>
	class pool: protected simple_segregated_storage<typename UserAllocator::size_type>
	{
	public:
		typedef UserAllocator user_allocator;
		typedef typename UserAllocator::size_type size_type;
		typedef typename UserAllocator::difference_type difference_type;
	private:
		static const unsigned min_alloc_size=(::boost::details::pool::ct_lcm<sizeof(void*), sizeof(size_type)>::value);
		void*malloc_need_resize();
		void*ordered_malloc_need_resize();
		protected: details::PODptr<size_type>list;
		simple_segregated_storage<size_type>&store()
		{
			return *this;
		}
		const simple_segregated_storage<size_type>&store()const
		{
			return *this;
		}
		const size_type requested_size;
		size_type next_size;
		size_type start_size;
		details::PODptr<size_type>find_POD(void*const chunk)const;
		static bool is_from(void*const chunk, char*const i, const size_type sizeof_i)
		{
			std::less_equal<void*>lt_eq;
			std::less<void*>lt;
			return (lt_eq(i, chunk)&&lt(chunk, i+sizeof_i));
		}
		size_type alloc_size()const
		{
			const unsigned min_size=min_alloc_size;
			return details::pool::lcm<size_type>(requested_size, min_size);
		}
		static void*&nextof(void*const ptr)
		{
			return *(static_cast<void**>(ptr));
		}
	public:
		explicit pool(const size_type nrequested_size, const size_type nnext_size=32): list(0, 0), requested_size(nrequested_size), next_size(nnext_size), start_size(nnext_size)
		{
		}
		~pool()
		{
			purge_memory();
		}
		bool release_memory();
		bool purge_memory();
		size_type get_next_size()const
		{
			return next_size;
		}
		void set_next_size(const size_type nnext_size)
		{
			next_size=start_size=nnext_size;
		}
		size_type get_requested_size()const
		{
			return requested_size;
		}
		void*malloc()
		{
			if(!store().empty())return store().malloc();
			return malloc_need_resize();
		}
		void*ordered_malloc()
		{
			if(!store().empty())return store().malloc();
			return ordered_malloc_need_resize();
		}
		void*ordered_malloc(size_type n);
		void free(void*const chunk)
		{
			store().free(chunk);
		}
		void ordered_free(void*const chunk)
		{
			store().ordered_free(chunk);
		}
		void free(void*const chunks, const size_type n)
		{
			const size_type partition_size=alloc_size();
			const size_type total_req_size=n*requested_size;
			const size_type num_chunks=total_req_size/partition_size+((total_req_size%partition_size)?true: false);
			store().free_n(chunks, num_chunks, partition_size);
		}
		void ordered_free(void*const chunks, const size_type n)
		{
			const size_type partition_size=alloc_size();
			const size_type total_req_size=n*requested_size;
			const size_type num_chunks=total_req_size/partition_size+((total_req_size%partition_size)?true: false);
			store().ordered_free_n(chunks, num_chunks, partition_size);
		}
		bool is_from(void*const chunk)const
		{
			return (find_POD(chunk).valid());
		}
	};
	template<typename UserAllocator>
	bool pool<UserAllocator>::release_memory()
	{
		bool ret=false;
		details::PODptr<size_type>ptr=list;
		details::PODptr<size_type>prev;
		void*free_p=this->first;
		void*prev_free_p=0;
		const size_type partition_size=alloc_size();
		while(ptr.valid())
		{
			if(free_p==0)break;
			bool all_chunks_free=true;
			void*saved_free=free_p;
			for(char*i=ptr.begin();
			i!=ptr.end();
			i+=partition_size)
			{
				if(i!=free_p)
				{
					all_chunks_free=false;
					free_p=saved_free;
					break;
				}
				free_p=nextof(free_p);
			}
			const details::PODptr<size_type>next=ptr.next();
			if(!all_chunks_free)
			{
				if(is_from(free_p, ptr.begin(), ptr.element_size()))
				{
					std::less<void*>lt;
					void*const end=ptr.end();
					do
					{
						prev_free_p=free_p;
						free_p=nextof(free_p);
					}
					while(free_p&&lt(free_p, end));
				}
				prev=ptr;
			}
			else
			{
				if(prev.valid())prev.next(next);
				else list=next;
				if(prev_free_p!=0)nextof(prev_free_p)=free_p;
				else this->first=free_p;
				UserAllocator::free(ptr.begin());
				ret=true;
			}
			ptr=next;
		}
		next_size=start_size;
		return ret;
	}
	template<typename UserAllocator>
	bool pool<UserAllocator>::purge_memory()
	{
		details::PODptr<size_type>iter=list;
		if(!iter.valid())return false;
		do
		{
			const details::PODptr<size_type>next=iter.next();
			UserAllocator::free(iter.begin());
			iter=next;
		}
		while(iter.valid());
		list.invalidate();
		this->first=0;
		next_size=start_size;
		return true;
	}
	template<typename UserAllocator>
	void*pool<UserAllocator>::malloc_need_resize()
	{
		const size_type partition_size=alloc_size();
		const size_type POD_size=next_size*partition_size+details::pool::ct_lcm<sizeof(size_type), sizeof(void*)>::value+sizeof(size_type);
		char*const ptr=UserAllocator::malloc(POD_size);
		if(ptr==0)return 0;
		const details::PODptr<size_type>node(ptr, POD_size);
		next_size<<=1;
		store().add_block(node.begin(), node.element_size(), partition_size);
		node.next(list);
		list=node;
		return store().malloc();
	}
	template<typename UserAllocator>
	void*pool<UserAllocator>::ordered_malloc_need_resize()
	{
		const size_type partition_size=alloc_size();
		const size_type POD_size=next_size*partition_size+details::pool::ct_lcm<sizeof(size_type), sizeof(void*)>::value+sizeof(size_type);
		char*const ptr=UserAllocator::malloc(POD_size);
		if(ptr==0)return 0;
		const details::PODptr<size_type>node(ptr, POD_size);
		next_size<<=1;
		store().add_block(node.begin(), node.element_size(), partition_size);
		if(!list.valid()||std::greater<void*>()(list.begin(), node.begin()))
		{
			node.next(list);
			list=node;
		}
		else
		{
			details::PODptr<size_type>prev=list;
			while(true)
			{
				if(prev.next_ptr()==0||std::greater<void*>()(prev.next_ptr(), node.begin()))break;
				prev=prev.next();
			}
			node.next(prev.next());
			prev.next(node);
		}
		return store().malloc();
	}
	template<typename UserAllocator>
	void*pool<UserAllocator>::ordered_malloc(const size_type n)
	{
		const size_type partition_size=alloc_size();
		const size_type total_req_size=n*requested_size;
		const size_type num_chunks=total_req_size/partition_size+((total_req_size%partition_size)?true: false);
		void*ret=store().malloc_n(num_chunks, partition_size);
		if(ret!=0)return ret;
		using std::max;
		next_size=max(next_size, num_chunks);
		const size_type POD_size=next_size*partition_size+details::pool::ct_lcm<sizeof(size_type), sizeof(void*)>::value+sizeof(size_type);
		char*const ptr=UserAllocator::malloc(POD_size);
		if(ptr==0)return 0;
		const details::PODptr<size_type>node(ptr, POD_size);
		if(next_size>num_chunks)store().add_block(node.begin()+num_chunks*partition_size, node.element_size()-num_chunks*partition_size, partition_size);
		next_size<<=1;
		if(!list.valid()||std::greater<void*>()(list.begin(), node.begin()))
		{
			node.next(list);
			list=node;
		}
		else
		{
			details::PODptr<size_type>prev=list;
			while(true)
			{
				if(prev.next_ptr()==0||std::greater<void*>()(prev.next_ptr(), node.begin()))break;
				prev=prev.next();
			}
			node.next(prev.next());
			prev.next(node);
		}
		return node.begin();
	}
	template<typename UserAllocator>
	details::PODptr<typename pool<UserAllocator>::size_type>pool<UserAllocator>::find_POD(void*const chunk)const
	{
		details::PODptr<size_type>iter=list;
		while(iter.valid())
		{
			if(is_from(chunk, iter.begin(), iter.element_size()))return iter;
			iter=iter.next();
		}
		return iter;
	}
}
namespace boost
{
	namespace details
	{
		namespace pool
		{
			template<typename T>
			struct singleton_default
			{
			private:
				struct object_creator
				{
					object_creator()
					{
						singleton_default<T>::instance();
					}
					inline void do_nothing()const
					{
					}
				};
				static object_creator create_object;
				singleton_default();
			public:
				typedef T object_type;
				static object_type&instance()
				{
					static object_type obj;
					create_object.do_nothing();
					return obj;
				}
			};
			template<typename T>
			typename singleton_default<T>::object_creator singleton_default<T>::create_object;
		}
	}
}
namespace boost
{
	namespace details
	{
		namespace pool
		{
			template<typename Mutex>
			class guard
			{
			private:
				Mutex&mtx;
				guard(const guard&);
				void operator=(const guard&);
			public:
				explicit guard(Mutex&nmtx): mtx(nmtx)
				{
					mtx.lock();
				}
				~guard()
				{
					mtx.unlock();
				}
			};
		}
	}
}
namespace boost
{
	template<typename Tag, unsigned RequestedSize, typename UserAllocator, typename Mutex, unsigned NextSize>
	struct singleton_pool
	{
	public:
		typedef Tag tag;
		typedef Mutex mutex;
		typedef UserAllocator user_allocator;
		typedef typename pool<UserAllocator>::size_type size_type;
		typedef typename pool<UserAllocator>::difference_type difference_type;
		static const unsigned requested_size=RequestedSize;
		static const unsigned next_size=NextSize;
	private:
		struct pool_type: Mutex
		{
			pool<UserAllocator>p;
			pool_type(): p(RequestedSize, NextSize)
			{
			}
		};
		typedef details::pool::singleton_default<pool_type>singleton;
		singleton_pool();
	public:
		static void*malloc()
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			return p.p.malloc();
		}
		static void*ordered_malloc()
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			return p.p.ordered_malloc();
		}
		static void*ordered_malloc(const size_type n)
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			return p.p.ordered_malloc(n);
		}
		static bool is_from(void*const ptr)
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			return p.p.is_from(ptr);
		}
		static void free(void*const ptr)
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			p.p.free(ptr);
		}
		static void ordered_free(void*const ptr)
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			p.p.ordered_free(ptr);
		}
		static void free(void*const ptr, const size_type n)
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			p.p.free(ptr, n);
		}
		static void ordered_free(void*const ptr, const size_type n)
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			p.p.ordered_free(ptr, n);
		}
		static bool release_memory()
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			return p.p.release_memory();
		}
		static bool purge_memory()
		{
			pool_type&p=singleton::instance();
			details::pool::guard<Mutex>g(p);
			return p.p.purge_memory();
		}
	};
}
namespace boost
{
	struct pool_allocator_tag
	{
	};
	template<typename T, typename UserAllocator, typename Mutex, unsigned NextSize>
	class pool_allocator
	{
	public:
		typedef T value_type;
		typedef UserAllocator user_allocator;
		typedef Mutex mutex;
		static const unsigned next_size=NextSize;
		typedef value_type*pointer;
		typedef const value_type*const_pointer;
		typedef value_type&reference;
		typedef const value_type&const_reference;
		typedef typename pool<UserAllocator>::size_type size_type;
		typedef typename pool<UserAllocator>::difference_type difference_type;
		template<typename U>
		struct rebind
		{
			typedef pool_allocator<U, UserAllocator, Mutex, NextSize>other;
		};
	public:
		pool_allocator()
		{
			singleton_pool<pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::is_from(0);
		}
		template<typename U>
		pool_allocator(const pool_allocator<U, UserAllocator, Mutex, NextSize>&)
		{
			singleton_pool<pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::is_from(0);
		}
		static pointer address(reference r)
		{
			return &r;
		}
		static const_pointer address(const_reference s)
		{
			return &s;
		}
		static size_type max_size()
		{
			return (std::numeric_limits<size_type>::max)();
		}
		static void construct(const pointer ptr, const value_type&t)
		{
			new(ptr)T(t);
		}
		static void destroy(const pointer ptr)
		{
			ptr->~T();
			(void)ptr;
		}
		bool operator==(const pool_allocator&)const
		{
			return true;
		}
		bool operator!=(const pool_allocator&)const
		{
			return false;
		}
		static pointer allocate(const size_type n)
		{
			const pointer ret=static_cast<pointer>(singleton_pool<pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::ordered_malloc(n));
			if(ret==0)boost::throw_exception(std::bad_alloc());
			return ret;
		}
		static pointer allocate(const size_type n, const void*const)
		{
			return allocate(n);
		}
		static void deallocate(const pointer ptr, const size_type n)
		{
			singleton_pool<pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::ordered_free(ptr, n);
		}
	};
	template<typename UserAllocator, typename Mutex, unsigned NextSize>
	class pool_allocator<void, UserAllocator, Mutex, NextSize>
	{
	public:
		typedef void*pointer;
		typedef const void*const_pointer;
		typedef void value_type;
		template<class U>
		struct rebind
		{
			typedef pool_allocator<U, UserAllocator, Mutex, NextSize>other;
		};
	};
	struct fast_pool_allocator_tag
	{
	};
	template<typename T, typename UserAllocator, typename Mutex, unsigned NextSize>
	class fast_pool_allocator
	{
	public:
		typedef T value_type;
		typedef UserAllocator user_allocator;
		typedef Mutex mutex;
		static const unsigned next_size=NextSize;
		typedef value_type*pointer;
		typedef const value_type*const_pointer;
		typedef value_type&reference;
		typedef const value_type&const_reference;
		typedef typename pool<UserAllocator>::size_type size_type;
		typedef typename pool<UserAllocator>::difference_type difference_type;
		template<typename U>
		struct rebind
		{
			typedef fast_pool_allocator<U, UserAllocator, Mutex, NextSize>other;
		};
	public:
		fast_pool_allocator()
		{
			singleton_pool<fast_pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::is_from(0);
		}
		template<typename U>
		fast_pool_allocator(const fast_pool_allocator<U, UserAllocator, Mutex, NextSize>&)
		{
			singleton_pool<fast_pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::is_from(0);
		}
		static pointer address(reference r)
		{
			return &r;
		}
		static const_pointer address(const_reference s)
		{
			return &s;
		}
		static size_type max_size()
		{
			return (std::numeric_limits<size_type>::max)();
		}
		void construct(const pointer ptr, const value_type&t)
		{
			new(ptr)T(t);
		}
		void destroy(const pointer ptr)
		{
			ptr->~T();
			(void)ptr;
		}
		bool operator==(const fast_pool_allocator&)const
		{
			return true;
		}
		bool operator!=(const fast_pool_allocator&)const
		{
			return false;
		}
		static pointer allocate(const size_type n)
		{
			const pointer ret=(n==1)?static_cast<pointer>(singleton_pool<fast_pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::malloc()): static_cast<pointer>(singleton_pool<fast_pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::ordered_malloc(n));
			if(ret==0)boost::throw_exception(std::bad_alloc());
			return ret;
		}
		static pointer allocate(const size_type n, const void*const)
		{
			return allocate(n);
		}
		static pointer allocate()
		{
			const pointer ret=static_cast<pointer>(singleton_pool<fast_pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::malloc());
			if(ret==0)boost::throw_exception(std::bad_alloc());
			return ret;
		}
		static void deallocate(const pointer ptr, const size_type n)
		{
			if(n==1)singleton_pool<fast_pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::free(ptr);
			else singleton_pool<fast_pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::free(ptr, n);
		}
		static void deallocate(const pointer ptr)
		{
			singleton_pool<fast_pool_allocator_tag, sizeof(T), UserAllocator, Mutex, NextSize>::free(ptr);
		}
	};
	template<typename UserAllocator, typename Mutex, unsigned NextSize>
	class fast_pool_allocator<void, UserAllocator, Mutex, NextSize>
	{
	public:
		typedef void*pointer;
		typedef const void*const_pointer;
		typedef void value_type;
		template<class U>
		struct rebind
		{
			typedef fast_pool_allocator<U, UserAllocator, Mutex, NextSize>other;
		};
	};
}
namespace std
{
	template<class _Ty, class _Alloc>
	class _List_nod: public _Container_base
	{
		protected: struct _Node;
		friend struct _Node;
		typedef typename _Alloc::template rebind<_Node>::other::pointer _Genptr;
		struct _Node
		{
			_Genptr _Next;
			_Genptr _Prev;
			_Ty _Myval;
		};
		_List_nod(_Alloc _Al): _Alnod(_Al)
		{
		}
		typename _Alloc::template rebind<_Node>::other _Alnod;
	};
	template<class _Ty, class _Alloc>
	class _List_ptr: public _List_nod<_Ty, _Alloc>
	{
		protected: typedef typename _List_nod<_Ty, _Alloc>::_Node _Node;
		typedef typename _Alloc::template rebind<_Node>::other::pointer _Nodeptr;
		_List_ptr(_Alloc _Al): _List_nod<_Ty, _Alloc>(_Al), _Alptr(_Al)
		{
		}
		typename _Alloc::template rebind<_Nodeptr>::other _Alptr;
	};
	template<class _Ty, class _Alloc>
	class _List_val: public _List_ptr<_Ty, _Alloc>
	{
	public:
		typedef typename _Alloc::template rebind<_Ty>::other _Alty;
		_List_val(_Alloc _Al=_Alloc()): _List_ptr<_Ty, _Alloc>(_Al), _Alval(_Al)
		{
		}
		_Alty _Alval;
	};
	template<class _Ty, class _Ax=allocator<_Ty> >
	class list: public _List_val<_Ty, _Ax>
	{
	public:
		typedef list<_Ty, _Ax>_Myt;
		typedef _List_val<_Ty, _Ax>_Mybase;
		typedef typename _Mybase::_Alty _Alloc;
		protected: typedef typename _List_nod<_Ty, _Ax>::_Genptr _Genptr;
		typedef typename _List_nod<_Ty, _Ax>::_Node _Node;
		typedef typename _Alloc::template rebind<_Node>::other::pointer _Nodeptr;
		typedef typename _Alloc::template rebind<_Nodeptr>::other::reference _Nodepref;
		typedef typename _Alloc::reference _Vref;
		static _Nodepref _Nextnode(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Next);
		}
		static _Nodepref _Prevnode(_Nodeptr _Pnode)
		{
			return ((_Nodepref)(*_Pnode)._Prev);
		}
		static _Vref _Myval(_Nodeptr _Pnode)
		{
			return ((_Vref)(*_Pnode)._Myval);
		}
	public:
		typedef _Alloc allocator_type;
		typedef typename _Alloc::size_type size_type;
		typedef typename _Alloc::difference_type _Dift;
		typedef _Dift difference_type;
		typedef typename _Alloc::pointer _Tptr;
		typedef typename _Alloc::const_pointer _Ctptr;
		typedef _Tptr pointer;
		typedef _Ctptr const_pointer;
		typedef typename _Alloc::reference _Reft;
		typedef _Reft reference;
		typedef typename _Alloc::const_reference const_reference;
		typedef typename _Alloc::value_type value_type;
		template<bool _Secure_validation>
		class _Const_iterator;
		friend class _Const_iterator<true>;
		friend class _Const_iterator<false>;
		template<bool _Secure_validation>
		class _Const_iterator: public _Bidit<_Ty, _Dift, _Ctptr, const_reference>
		{
		public:
			typedef _Const_iterator<_Secure_validation>_Myt_iter;
			typedef bidirectional_iterator_tag iterator_category;
			typedef _Ty value_type;
			typedef _Dift difference_type;
			typedef _Ctptr pointer;
			typedef const_reference reference;
			_Const_iterator(): _Ptr(0)
			{
			}
			_Const_iterator(_Nodeptr _Pnode, const _Myt*_Plist=0): _Ptr(_Pnode)
			{
				this->_Adopt(_Plist);
			}
			typedef typename _Secure_validation_helper<_Secure_validation>::_Checked_iterator_category _Checked_iterator_category;
			typedef typename _If<_Secure_validation, _Const_iterator<false>, _Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
			friend _Const_iterator<false>;
			friend _Const_iterator<true>;
			_Const_iterator<false>_Checked_iterator_base()const
			{
				_Const_iterator<false>_Base(this->_Ptr, ((_Myt*)this->_Mycont));
				return _Base;
			}
			void _Checked_iterator_assign_from_base(_Const_iterator<false>_Base)
			{

				{
					if(!(this->_Mycont==_Base._Mycont))
					{
						(void)((!!((("this->_Mycont == _Base._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 201, 0, L"(\"this->_Mycont == _Base._Mycont\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 201, 0);
					};
				};
				this->_Ptr=_Base._Ptr;
			}
			const_reference operator*()const
			{
				if(this->_Mycont==0||_Ptr==((_Myt*)this->_Mycont)->_Myhead)
				{
					_Debug_message(L"list iterator not dereferencable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 213);

					{
						;
						;
						if(_Secure_validation)
						{

							{
								(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 214, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
								::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 214, 0);
							}
						};
					};
				}
				return (_Myval(_Ptr));
			}
			_Ctptr operator->()const
			{
				return (&**this);
			}
			_Myt_iter&operator++()
			{
				if(this->_Mycont==0||_Ptr==((_Myt*)this->_Mycont)->_Myhead)
				{
					_Debug_message(L"list iterator not incrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 236);

					{
						;
						;
						if(_Secure_validation)
						{

							{
								(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 237, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
								::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 237, 0);
							}
						};
					};
				}
				_Ptr=_Nextnode(_Ptr);
				return (*this);
			}
			_Myt_iter operator++(int)
			{
				_Myt_iter _Tmp=*this;
				++*this;
				return (_Tmp);
			}
			_Myt_iter&operator--()
			{
				if(this->_Mycont==0||(_Ptr=_Prevnode(_Ptr))==((_Myt*)this->_Mycont)->_Myhead)
				{
					_Debug_message(L"list iterator not decrementable", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 262);

					{
						;
						;
						if(_Secure_validation)
						{

							{
								(void)((!!((("Standard C++ Libraries Out of Range", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 263, 0, L"(\"Standard C++ Libraries Out of Range\", 0)"))||(__debugbreak(), 0));
								::_invalid_parameter(L"\"out of range\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 263, 0);
							}
						};
					};
				}
				return (*this);
			}
			_Myt_iter operator--(int)
			{
				_Myt_iter _Tmp=*this;
				--*this;
				return (_Tmp);
			}
			bool operator==(const _Myt_iter&_Right)const
			{
				_Compat(_Right);
				return (_Ptr==_Right._Ptr);
			}
			bool operator!=(const _Myt_iter&_Right)const
			{
				return (!(*this==_Right));
			}
			_Nodeptr _Mynode()const
			{
				return (_Ptr);
			}
			void _Compat(const _Myt_iter&_Right)const
			{
				if(this->_Mycont==0||this->_Mycont!=_Right._Mycont)
				{
					_Debug_message(L"list iterators incompatible", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 309);

					{
						;
						;
						if(_Secure_validation)
						{

							{
								(void)((!!((("Standard C++ Libraries Invalid Argument", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 310, 0, L"(\"Standard C++ Libraries Invalid Argument\", 0)"))||(__debugbreak(), 0));
								::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 310, 0);
							}
						};
					};
				}
			}
			_Nodeptr _Ptr;
		};
		typedef _Const_iterator<true>const_iterator;
		template<bool _Secure_validation>
		class _Iterator;
		friend class _Iterator<true>;
		friend class _Iterator<false>;
		template<bool _Secure_validation>
		class _Iterator: public _Const_iterator<_Secure_validation>
		{
		public:
			friend class list<_Ty, _Ax>;
			typedef _Iterator<_Secure_validation>_Myt_iter;
			typedef _Const_iterator<_Secure_validation>_Mybase_iter;
			typedef bidirectional_iterator_tag iterator_category;
			typedef _Ty value_type;
			typedef _Dift difference_type;
			typedef _Tptr pointer;
			typedef _Reft reference;
			_Iterator()
			{
			}
			_Iterator(_Nodeptr _Pnode, const _Myt*_Plist=0): _Mybase_iter(_Pnode, _Plist)
			{
			}
			typedef typename _If<_Secure_validation, _Iterator<false>, _Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
			friend _Iterator<false>;
			friend _Iterator<true>;
			_Iterator<false>_Checked_iterator_base()const
			{
				_Iterator<false>_Base(this->_Ptr, ((_Myt*)this->_Mycont));
				return _Base;
			}
			void _Checked_iterator_assign_from_base(_Iterator<false>_Base)
			{

				{
					if(!(this->_Mycont==_Base._Mycont))
					{
						(void)((!!((("this->_Mycont == _Base._Mycont", 0))))||(1!=_CrtDbgReportW(2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 381, 0, L"(\"this->_Mycont == _Base._Mycont\", 0)"))||(__debugbreak(), 0));
						::_invalid_parameter(L"\"invalid argument\"", L"<function-sig>", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 381, 0);
					};
				};
				this->_Ptr=_Base._Ptr;
			}
			reference operator*()const
			{
				return ((reference)**(_Mybase_iter*)this);
			}
			_Tptr operator->()const
			{
				return (&**this);
			}
			_Myt_iter&operator++()
			{
				++(*(_Mybase_iter*)this);
				return (*this);
			}
			_Myt_iter operator++(int)
			{
				_Myt_iter _Tmp=*this;
				++*this;
				return (_Tmp);
			}
			_Myt_iter&operator--()
			{
				--(*(_Mybase_iter*)this);
				return (*this);
			}
			_Myt_iter operator--(int)
			{
				_Myt_iter _Tmp=*this;
				--*this;
				return (_Tmp);
			}
		};
		typedef _Iterator<true>iterator;
		typedef std::reverse_iterator<iterator>reverse_iterator;
		typedef std::reverse_iterator<const_iterator>const_reverse_iterator;
		list(): _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
		}
		explicit list(const _Alloc&_Al): _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
		}
		explicit list(size_type _Count): _Mybase(), _Mysize(0)
		{
			_Ty _Val=_Ty();
			_Myhead=_Buynode();
			_Construct_n(_Count, _Val);
		}
		list(size_type _Count, const _Ty&_Val): _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
			_Construct_n(_Count, _Val);
		}
		list(size_type _Count, const _Ty&_Val, const _Alloc&_Al): _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
			_Construct_n(_Count, _Val);
		}
		list(const _Myt&_Right): _Mybase(_Right._Alval), _Myhead(_Buynode()), _Mysize(0)
		{
			try
			{
				insert(begin(), _Right.begin(), _Right.end());
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		template<class _Iter>
		list(_Iter _First, _Iter _Last): _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		list(_Iter _First, _Iter _Last, const _Alloc&_Al): _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{
			_Construct(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Construct_n((size_type)_Count, (_Ty)_Val);
		}
		template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			try
			{
				insert(begin(), _First, _Last);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		void _Construct_n(size_type _Count, const _Ty&_Val)
		{
			try
			{
				_Insert_n(begin(), _Count, _Val);
			}
			catch(...)
			{
				_Tidy();
				throw;
			}
		}
		~list()
		{
			_Tidy();
		}
		_Myt&operator=(const _Myt&_Right)
		{
			if(this!=&_Right)assign(_Right.begin(), _Right.end());
			return (*this);
		}
		iterator begin()
		{
			return (iterator(_Nextnode(_Myhead), this));
		}
		const_iterator begin()const
		{
			return (const_iterator(_Nextnode(_Myhead), this));
		}
		iterator end()
		{
			return (iterator(_Myhead, this));
		}
		const_iterator end()const
		{
			return (const_iterator(_Myhead, this));
		}
		reverse_iterator rbegin()
		{
			return (reverse_iterator(end()));
		}
		const_reverse_iterator rbegin()const
		{
			return (const_reverse_iterator(end()));
		}
		reverse_iterator rend()
		{
			return (reverse_iterator(begin()));
		}
		const_reverse_iterator rend()const
		{
			return (const_reverse_iterator(begin()));
		}
		void resize(size_type _Newsize)
		{
			resize(_Newsize, _Ty());
		}
		void resize(size_type _Newsize, _Ty _Val)
		{
			if(_Mysize<_Newsize)_Insert_n(end(), _Newsize-_Mysize, _Val);
			else while(_Newsize<_Mysize)pop_back();
		}
		size_type size()const
		{
			return (_Mysize);
		}
		size_type max_size()const
		{
			return (this->_Alval.max_size());
		}
		bool empty()const
		{
			return (_Mysize==0);
		}
		allocator_type get_allocator()const
		{
			return (this->_Alval);
		}
		reference front()
		{
			return (*begin());
		}
		const_reference front()const
		{
			return (*begin());
		}
		reference back()
		{
			return (*(--end()));
		}
		const_reference back()const
		{
			return (*(--end()));
		}
		void push_front(const _Ty&_Val)
		{
			_Insert(begin(), _Val);
		}
		void pop_front()
		{
			erase(begin());
		}
		void push_back(const _Ty&_Val)
		{
			_Insert(end(), _Val);
		}
		void pop_back()
		{
			erase(--end());
		}
		template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{
			_Assign(_First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Assign_n((size_type)_Count, (_Ty)_Val);
		}
		template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{
			clear();
			insert(begin(), _First, _Last);
		}
		void assign(size_type _Count, const _Ty&_Val)
		{
			_Assign_n(_Count, _Val);
		}
		iterator insert(iterator _Where, const _Ty&_Val)
		{
			_Insert(_Where, _Val);
			return (--_Where);
		}
		void _Insert(iterator _Where, const _Ty&_Val)
		{
			if(_Where._Mycont!=this)_Debug_message(L"list insert iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 698);
			_Nodeptr _Pnode=_Where._Mynode();
			_Nodeptr _Newnode=_Buynode(_Pnode, _Prevnode(_Pnode), _Val);
			_Incsize(1);
			_Prevnode(_Pnode)=_Newnode;
			_Nextnode(_Prevnode(_Newnode))=_Newnode;
		}
		void insert(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			_Insert_n(_Where, _Count, _Val);
		}
		template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{
			_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val, _Int_iterator_tag)
		{
			_Insert_n(_Where, (size_type)_Count, (_Ty)_Val);
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
		{
			size_type _Num=0;
			try
			{
				for(;
				_First!=_Last;
				++_First, ++_Num)_Insert(_Where, *_First);
			}
			catch(...)
			{
				for(;
				0<_Num;
				--_Num)
				{
					iterator _Before=_Where;
					erase(--_Before);
				}
				throw;
			}
		}
		template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
		{
			_Debug_range(_First, _Last, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 751);
			if(_Debug_get_cont(_First)==this)_Debug_message(L"list insertion overlaps range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 753);
			_Iter _Next=_First;
			try
			{
				for(;
				_First!=_Last;
				++_First)_Insert(_Where, *_First);
			}
			catch(...)
			{
				for(;
				_Next!=_First;
				++_Next)
				{
					iterator _Before=_Where;
					erase(--_Before);
				}
				throw;
			}
		}
		iterator erase(iterator _Where)
		{
			if(_Where._Mycont!=this||_Where._Ptr==_Myhead)_Debug_message(L"list erase iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 776);
			_Nodeptr _Pnode=(_Where++)._Mynode();
			_Orphan_ptr(*this, _Pnode);
			if(_Pnode!=_Myhead)
			{
				_Nextnode(_Prevnode(_Pnode))=_Nextnode(_Pnode);
				_Prevnode(_Nextnode(_Pnode))=_Prevnode(_Pnode);
				this->_Alnod.destroy(_Pnode);
				this->_Alnod.deallocate(_Pnode, 1);
				--_Mysize;
			}
			return (_Where);
		}
		iterator erase(iterator _First, iterator _Last)
		{
			if(_First==begin()&&_Last==end())
			{
				clear();
				return (end());
			}
			else
			{
				while(_First!=_Last)_First=erase(_First);
				return (_Last);
			}
		}
		void clear()
		{
			this->_Orphan_ptr(*this, 0);
			_Nodeptr _Pnext;
			_Nodeptr _Pnode=_Nextnode(_Myhead);
			_Nextnode(_Myhead)=_Myhead;
			_Prevnode(_Myhead)=_Myhead;
			_Mysize=0;
			for(;
			_Pnode!=_Myhead;
			_Pnode=_Pnext)
			{
				_Pnext=_Nextnode(_Pnode);
				this->_Alnod.destroy(_Pnode);
				this->_Alnod.deallocate(_Pnode, 1);
			}
		}
		void swap(_Myt&_Right)
		{
			if(this->_Alval==_Right._Alval)
			{
				this->_Swap_all(_Right);
				std::swap(_Myhead, _Right._Myhead);
				std::swap(_Mysize, _Right._Mysize);
			}
			else
			{
				iterator _Where=begin();
				splice(_Where, _Right);
				_Right.splice(_Right.begin(), *this, _Where, end());
			}
		}
		void splice(iterator _Where, _Myt&_Right)
		{
			if(this!=&_Right&&!_Right.empty())
			{
				_Splice(_Where, _Right, _Right.begin(), _Right.end(), _Right._Mysize);
			}
		}
		void splice(iterator _Where, _Myt&_Right, iterator _First)
		{
			if(_First==_Right.end())_Debug_message(L"list splice iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 865);
			else
			{
				iterator _Last=_First;
				++_Last;
				if(this!=&_Right||(_Where!=_First&&_Where!=_Last))_Splice(_Where, _Right, _First, _Last, 1);
			}
		}
		void splice(iterator _Where, _Myt&_Right, iterator _First, iterator _Last)
		{
			if(_First!=_Last&&(this!=&_Right||_Where!=_Last))
			{
				size_type _Count=0;
				if(this==&_Right);
				else if(_First==_Right.begin()&&_Last==_Right.end())_Count=_Right._Mysize;
				else _Distance(_First, _Last, _Count);
				_Splice(_Where, _Right, _First, _Last, _Count);
			}
		}
		void remove(const _Ty&_Val)
		{
			iterator _Last=end();
			for(iterator _First=begin();
			_First!=_Last;
			)if(*_First==_Val)_First=erase(_First);
			else++_First;
		}
		template<class _Pr1>
		void remove_if(_Pr1 _Pred)
		{
			iterator _Last=end();
			for(iterator _First=begin();
			_First!=_Last;
			)if(_Pred(*_First))_First=erase(_First);
			else++_First;
		}
		void unique()
		{
			if(2<=_Mysize)
			{
				iterator _First=begin();
				iterator _After=_First;
				for(++_After;
				_After!=end();
				)if(*_First==*_After)_After=erase(_After);
				else _First=_After++;
			}
		}
		template<class _Pr2>
		void unique(_Pr2 _Pred)
		{
			if(2<=_Mysize)
			{
				iterator _First=begin();
				iterator _After=_First;
				for(++_After;
				_After!=end();
				)if(_Pred(*_First, *_After))_After=erase(_After);
				else _First=_After++;
			}
		}
		void merge(_Myt&_Right)
		{
			if(&_Right!=this)
			{
				iterator _First1=begin(), _Last1=end();
				iterator _First2=_Right.begin(), _Last2=_Right.end();
				_Debug_order(_First1, _Last1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 953);
				_Debug_order(_First2, _Last2, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 954);
				while(_First1!=_Last1&&_First2!=_Last2)if(_Debug_lt(*_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 957))
				{
					iterator _Mid2=_First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2=_Mid2;
				}
				else++_First1;
				if(_First2!=_Last2)_Splice(_Last1, _Right, _First2, _Last2, _Right._Mysize);
			}
		}
		template<class _Pr3>
		void merge(_Myt&_Right, _Pr3 _Pred)
		{
			if(&_Right!=this)
			{
				iterator _First1=begin(), _Last1=end();
				iterator _First2=_Right.begin(), _Last2=_Right.end();
				_Debug_order(_First1, _Last1, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 979);
				_Debug_order(_First2, _Last2, _Pred, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 980);
				while(_First1!=_Last1&&_First2!=_Last2)if(_Debug_lt_pred(_Pred, *_First2, *_First1, L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 983))
				{
					iterator _Mid2=_First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2=_Mid2;
				}
				else++_First1;
				if(_First2!=_Last2)_Splice(_Last1, _Right, _First2, _Last2, _Right._Mysize);
			}
		}
		void sort()
		{
			if(2<=_Mysize)
			{
				const size_t _MAXBINS=25;
				_Myt _Templist(this->_Alval), _Binlist[_MAXBINS+1];
				size_t _Maxbin=0;
				while(!empty())
				{
					_Templist._Splice(_Templist.begin(), *this, begin(), ++begin(), 1, true);
					size_t _Bin;
					for(_Bin=0;
					_Bin<_Maxbin&&!_Binlist[_Bin].empty();
					++_Bin)
					{
						_Binlist[_Bin].merge(_Templist);
						_Binlist[_Bin].swap(_Templist);
					}
					if(_Bin==_MAXBINS)_Binlist[_Bin-1].merge(_Templist);
					else
					{
						_Binlist[_Bin].swap(_Templist);
						if(_Bin==_Maxbin)++_Maxbin;
					}
				}
				for(size_t _Bin=1;
				_Bin<_Maxbin;
				++_Bin)_Binlist[_Bin].merge(_Binlist[_Bin-1]);
				splice(begin(), _Binlist[_Maxbin-1]);
			}
		}
		template<class _Pr3>
		void sort(_Pr3 _Pred)
		{
			if(2<=_Mysize)
			{
				const size_t _MAXBINS=25;
				_Myt _Templist(this->_Alval), _Binlist[_MAXBINS+1];
				size_t _Maxbin=0;
				while(!empty())
				{
					_Templist._Splice(_Templist.begin(), *this, begin(), ++begin(), 1, true);
					size_t _Bin;
					for(_Bin=0;
					_Bin<_Maxbin&&!_Binlist[_Bin].empty();
					++_Bin)
					{
						_Binlist[_Bin].merge(_Templist, _Pred);
						_Binlist[_Bin].swap(_Templist);
					}
					if(_Bin==_MAXBINS)_Binlist[_Bin-1].merge(_Templist, _Pred);
					else
					{
						_Binlist[_Bin].swap(_Templist);
						if(_Bin==_Maxbin)++_Maxbin;
					}
				}
				for(size_t _Bin=1;
				_Bin<_Maxbin;
				++_Bin)_Binlist[_Bin].merge(_Binlist[_Bin-1], _Pred);
				splice(begin(), _Binlist[_Maxbin-1]);
			}
		}
		void reverse()
		{
			if(2<=_Mysize)
			{
				iterator _Last=end();
				for(iterator _Next=++begin();
				_Next!=_Last;
				)
				{
					iterator _Before=_Next;
					_Splice(begin(), *this, _Before, ++_Next, 1);
				}
			}
		}
		void _Splice(iterator _Where, _Myt&_Right, iterator _First, iterator _Last, size_type _Count, bool _Keep=false)
		{
			if(_Where._Mycont!=this)_Debug_message(L"list splice iterator outside range", L"D:\\dev\\cpparch\\cppparse\\msvc-8.0\\INCLUDE\\list", 1093);
			if(this->_Alval==_Right._Alval)
			{
				if(!_Keep&&this!=&_Right)for(iterator _Next=_First;
				_Next!=_Last;
				)_Orphan_ptr(_Right, (_Next++)._Ptr);
				if(this!=&_Right)
				{
					_Incsize(_Count);
					_Right._Mysize-=_Count;
				}
				_Nextnode(_Prevnode(_First._Mynode()))=_Last._Mynode();
				_Nextnode(_Prevnode(_Last._Mynode()))=_Where._Mynode();
				_Nextnode(_Prevnode(_Where._Mynode()))=_First._Mynode();
				_Nodeptr _Pnode=_Prevnode(_Where._Mynode());
				_Prevnode(_Where._Mynode())=_Prevnode(_Last._Mynode());
				_Prevnode(_Last._Mynode())=_Prevnode(_First._Mynode());
				_Prevnode(_First._Mynode())=_Pnode;
			}
			else
			{
				insert(_Where, _First, _Last);
				_Right.erase(_First, _Last);
			}
		}
		protected: void _Assign_n(size_type _Count, const _Ty&_Val)
		{
			_Ty _Tmp=_Val;
			clear();
			_Insert_n(begin(), _Count, _Tmp);
		}
		_Nodeptr _Buynode()
		{
			_Nodeptr _Pnode=this->_Alnod.allocate(1);
			int _Linkcnt=0;
			try
			{
				this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);
				++_Linkcnt;
				this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);
			}
			catch(...)
			{
				if(0<_Linkcnt)this->_Alptr.destroy(&_Nextnode(_Pnode));
				this->_Alnod.deallocate(_Pnode, 1);
				throw;
			}
			return (_Pnode);
		}
		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev, const _Ty&_Val)
		{
			_Nodeptr _Pnode=this->_Alnod.allocate(1);
			int _Linkcnt=0;
			try
			{
				this->_Alptr.construct(&_Nextnode(_Pnode), _Next);
				++_Linkcnt;
				this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);
				++_Linkcnt;
				this->_Alval.construct(&_Myval(_Pnode), _Val);
			}
			catch(...)
			{
				if(1<_Linkcnt)this->_Alptr.destroy(&_Prevnode(_Pnode));
				if(0<_Linkcnt)this->_Alptr.destroy(&_Nextnode(_Pnode));
				this->_Alnod.deallocate(_Pnode, 1);
				throw;
			}
			return (_Pnode);
		}
		void _Tidy()
		{
			clear();
			this->_Alptr.destroy(&_Nextnode(_Myhead));
			this->_Alptr.destroy(&_Prevnode(_Myhead));
			this->_Alnod.deallocate(_Myhead, 1);
			_Myhead=0;
		}
		void _Insert_n(iterator _Where, size_type _Count, const _Ty&_Val)
		{
			size_type _Countsave=_Count;
			try
			{
				for(;
				0<_Count;
				--_Count)_Insert(_Where, _Val);
			}
			catch(...)
			{
				for(;
				_Count<_Countsave;
				++_Count)
				{
					iterator _Before=_Where;
					erase(--_Before);
				}
				throw;
			}
		}
		void _Incsize(size_type _Count)
		{
			if(max_size()-_Mysize<_Count)throw length_error("list<T> too long");
			_Mysize+=_Count;
		}
		static void _Xran()
		{
			throw out_of_range("invalid list<T> subscript");
		}
		static void _Xinvarg()
		{
			throw invalid_argument("invalid list<T> argument");
		}
		void _Orphan_ptr(_Myt&_Cont, _Nodeptr _Ptr)const
		{
			_Lockit _Lock(3);
			const_iterator**_Pnext=(const_iterator**)&_Cont._Myfirstiter;
			while(*_Pnext!=0)if((*_Pnext)->_Ptr==_Myhead||_Ptr!=0&&(*_Pnext)->_Ptr!=_Ptr)_Pnext=(const_iterator**)&(*_Pnext)->_Mynextiter;
			else
			{
				(*_Pnext)->_Mycont=0;
				*_Pnext=(const_iterator*)(*_Pnext)->_Mynextiter;
			}
		}
		_Nodeptr _Myhead;
		size_type _Mysize;
	};
	template<class _Ty, class _Ax>
	class _Move_operation_category<list<_Ty, _Ax> >
	{
	public:
		typedef _Swap_move_tag _Move_cat;
	};
	template<class _Ty, class _Alloc>
	inline void swap(list<_Ty, _Alloc>&_Left, list<_Ty, _Alloc>&_Right)
	{
		_Left.swap(_Right);
	}
	template<class _Ty, class _Alloc>
	inline bool operator==(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (_Left.size()==_Right.size()&&equal(_Left.begin(), _Left.end(), _Right.begin()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator!=(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (!(_Left==_Right));
	}
	template<class _Ty, class _Alloc>
	inline bool operator<(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end()));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (_Right<_Left);
	}
	template<class _Ty, class _Alloc>
	inline bool operator<=(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (!(_Right<_Left));
	}
	template<class _Ty, class _Alloc>
	inline bool operator>=(const list<_Ty, _Alloc>&_Left, const list<_Ty, _Alloc>&_Right)
	{
		return (!(_Left<_Right));
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			template<typename IteratorT, typename TokenT, typename ContainerT>
			class unput_queue_iterator: public boost::iterator_adaptor<unput_queue_iterator<IteratorT, TokenT, ContainerT>, IteratorT, TokenT const, std::forward_iterator_tag>
			{
				typedef boost::iterator_adaptor<unput_queue_iterator<IteratorT, TokenT, ContainerT>, IteratorT, TokenT const, std::forward_iterator_tag>base_type;
			public:
				typedef ContainerT container_type;
				typedef IteratorT iterator_type;
				unput_queue_iterator(IteratorT const&it, ContainerT&queue): base_type(it), unput_queue(queue)
				{
				}
				ContainerT&get_unput_queue()
				{
					return unput_queue;
				}
				ContainerT const&get_unput_queue()const
				{
					return unput_queue;
				}
				IteratorT&get_base_iterator()
				{
					return base_type::base_reference();
				}
				IteratorT const&get_base_iterator()const
				{
					return base_type::base_reference();
				}
				unput_queue_iterator&operator=(unput_queue_iterator const&rhs)
				{
					if(this!=&rhs)
					{
						unput_queue=rhs.unput_queue;
						base_type::operator=(rhs);
					}
					return *this;
				}
				typename base_type::reference dereference()const
				{
					if(!unput_queue.empty())return unput_queue.front();
					return *base_type::base_reference();
				}
				void increment()
				{
					if(!unput_queue.empty())
					{
						unput_queue.pop_front();
					}
					else
					{
						++base_type::base_reference();
					}
				}
				template<typename OtherDerivedT, typename OtherIteratorT, typename V, typename C, typename R, typename D>
				bool equal(boost::iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D>const&x)const
				{
					OtherDerivedT const&rhs=static_cast<OtherDerivedT const&>(x);
					return ((unput_queue.empty()&&rhs.unput_queue.empty())||(&unput_queue==&rhs.unput_queue&&unput_queue.begin()==rhs.unput_queue.begin()))&&(get_base_iterator()==rhs.get_base_iterator());
				}
			private:
				ContainerT&unput_queue;
			};
			namespace impl
			{
				template<typename IteratorT, typename TokenT, typename ContainerT>
				struct gen_unput_queue_iterator
				{
					typedef ContainerT container_type;
					typedef IteratorT iterator_type;
					typedef unput_queue_iterator<IteratorT, TokenT, ContainerT>return_type;
					static container_type last;
					static return_type generate(iterator_type const&it)
					{
						return return_type(it, last);
					}
					static return_type generate(ContainerT&queue, iterator_type const&it)
					{
						return return_type(it, queue);
					}
				};
				template<typename IteratorT, typename TokenT, typename ContainerT>
				typename gen_unput_queue_iterator<IteratorT, TokenT, ContainerT>::container_type gen_unput_queue_iterator<IteratorT, TokenT, ContainerT>::last=typename gen_unput_queue_iterator<IteratorT, TokenT, ContainerT>::container_type();
				template<typename IteratorT, typename TokenT, typename ContainerT>
				struct gen_unput_queue_iterator<unput_queue_iterator<IteratorT, TokenT, ContainerT>, TokenT, ContainerT>
				{
					typedef ContainerT container_type;
					typedef unput_queue_iterator<IteratorT, TokenT, ContainerT>iterator_type;
					typedef unput_queue_iterator<IteratorT, TokenT, ContainerT>return_type;
					static container_type last;
					static return_type generate(iterator_type&it)
					{
						return return_type(it.base(), last);
					}
					static return_type generate(ContainerT&queue, iterator_type&it)
					{
						return return_type(it.base(), queue);
					}
				};
				template<typename IteratorT>
				struct assign_iterator
				{
					static void do_(IteratorT&dest, IteratorT const&src)
					{
						dest=src;
					}
				};
				template<typename IteratorT>
				struct next_token
				{
					static boost::wave::token_id peek(IteratorT it, IteratorT end, bool skip_whitespace=true)
					{
						using namespace boost::wave;
						if(skip_whitespace)
						{
							for(++it;
							it!=end;
							++it)
							{
								if(!((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&T_NEWLINE!=token_id(*it))
								{
									break;
								}
							}
						}
						else
						{
							++it;
						}
						if(it!=end)return token_id(*it);
						return T_EOI;
					}
				};
				template<typename IteratorT, typename TokenT, typename ContainerT>
				struct next_token<unput_queue_iterator<IteratorT, TokenT, ContainerT> >
				{
					typedef unput_queue_iterator<IteratorT, TokenT, ContainerT>iterator_type;
					static boost::wave::token_id peek(iterator_type it, iterator_type end, bool skip_whitespace=true)
					{
						using namespace boost::wave;
						typename iterator_type::container_type&queue=it.get_unput_queue();
						if(0!=queue.size())
						{
							typename iterator_type::container_type::iterator cit=queue.begin();
							typename iterator_type::container_type::iterator cend=queue.end();
							if(skip_whitespace)
							{
								for(++cit;
								cit!=cend;
								++cit)
								{
									if(!((((*cit)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&T_NEWLINE!=token_id(*cit))
									{
										break;
									}
								}
							}
							else
							{
								++cit;
							}
							if(cit!=cend)return token_id(*cit);
						}
						typename iterator_type::iterator_type base_it=it.get_base_iterator();
						typename iterator_type::iterator_type base_end=end.get_base_iterator();
						if(0==queue.size())++base_it;
						if(skip_whitespace)
						{
							for(;
							base_it!=base_end;
							++base_it)
							{
								if(!((((*base_it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&T_NEWLINE!=token_id(*base_it))
								{
									break;
								}
							}
						}
						if(base_it==base_end)return T_EOI;
						return token_id(*base_it);
					}
				};
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			class if_block
			{
			public:
				if_block(): status(true), some_part_status(true), enclosing_status(true), is_in_else(false)
				{
				}
				if_block(bool status_, bool enclosing_status_): status(status_), some_part_status(status_), enclosing_status(enclosing_status_), is_in_else(false)
				{
				}
				void set_status(bool status_)
				{
					status=status_;
					if(status_)some_part_status=true;
				}
				bool get_status()const
				{
					return status;
				}
				bool get_some_part_status()const
				{
					return some_part_status;
				}
				bool get_enclosing_status()const
				{
					return enclosing_status;
				}
				bool get_in_else()const
				{
					return is_in_else;
				}
				void set_in_else()
				{
					is_in_else=true;
				}
			private:
				bool status;
				bool some_part_status;
				bool enclosing_status;
				bool is_in_else;
			};
			class if_block_stack: private std::stack<if_block>
			{
			public:
				typedef std::stack<if_block>::size_type size_type;
				void enter_if_block(bool new_status)
				{
					bool enclosing_status=get_status();
					this->push(value_type(new_status&&enclosing_status, enclosing_status));
				}
				bool enter_elif_block(bool new_status)
				{
					if(!is_inside_ifpart())return false;
					if(get_enclosing_status())
					{
						if(get_status())
						{
							this->top().set_status(false);
						}
						else if(new_status&&!this->top().get_some_part_status())
						{
							this->top().set_status(new_status);
						}
					}
					return true;
				}
				bool enter_else_block()
				{
					if(!is_inside_ifpart())return false;
					if(get_enclosing_status())
					{
						if(!this->top().get_some_part_status())
						{
							this->top().set_status(true);
						}
						else if(get_status())
						{
							this->top().set_status(false);
						}
						this->top().set_in_else();
					}
					return true;
				}
				bool exit_if_block()
				{
					if(0==this->size())return false;
					this->pop();
					return true;
				}
				bool get_status()const
				{
					return 0==this->size()||this->top().get_status();
				}
				bool get_some_part_status()const
				{
					return 0==this->size()||this->top().get_some_part_status();
				}
				bool get_enclosing_status()const
				{
					return 0==this->size()||this->top().get_enclosing_status();
				}
				size_type get_if_block_depth()const
				{
					return this->size();
				}
				protected: bool is_inside_ifpart()const
				{
					return 0!=this->size()&&!this->top().get_in_else();
				}
				bool is_inside_elsepart()const
				{
					return 0!=this->size()&&this->top().get_in_else();
				}
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace filesystem
	{
		template<class Path>
		class basic_directory_iterator;
		typedef basic_directory_iterator<path>directory_iterator;
		template<class Path>
		class basic_directory_entry;
		enum file_type
		{
			status_unknown, file_not_found, regular_file, directory_file, symlink_file, block_file, character_file, fifo_file, socket_file, type_unknown
		};
		class file_status
		{
		public:
			explicit file_status(file_type v=status_unknown): m_value(v)
			{
			}
			void type(file_type v)
			{
				m_value=v;
			}
			file_type type()const
			{
				return m_value;
			}
		private:
			file_type m_value;
		};
		inline bool status_known(file_status f)
		{
			return f.type()!=status_unknown;
		}
		inline bool exists(file_status f)
		{
			return f.type()!=status_unknown&&f.type()!=file_not_found;
		}
		inline bool is_regular_file(file_status f)
		{
			return f.type()==regular_file;
		}
		inline bool is_directory(file_status f)
		{
			return f.type()==directory_file;
		}
		inline bool is_symlink(file_status f)
		{
			return f.type()==symlink_file;
		}
		inline bool is_other(file_status f)
		{
			return exists(f)&&!is_regular_file(f)&&!is_directory(f)&&!is_symlink(f);
		}
		inline bool is_regular(file_status f)
		{
			return f.type()==regular_file;
		}
		struct space_info
		{
			boost::uintmax_t capacity;
			boost::uintmax_t free;
			boost::uintmax_t available;
		};
		namespace detail
		{
			typedef std::pair<system::error_code, bool>query_pair;
			typedef std::pair<system::error_code, boost::uintmax_t>uintmax_pair;
			typedef std::pair<system::error_code, std::time_t>time_pair;
			typedef std::pair<system::error_code, space_info>space_pair;
			template<class Path>
			struct directory_pair
			{
				typedef std::pair<system::error_code, typename Path::external_string_type>type;
			};
			bool symbolic_link_exists_api(const std::string&);
			file_status status_api(const std::string&ph, system::error_code&ec);
			query_pair is_empty_api(const std::string&ph);
			query_pair equivalent_api(const std::string&ph1, const std::string&ph2);
			uintmax_pair file_size_api(const std::string&ph);
			space_pair space_api(const std::string&ph);
			time_pair last_write_time_api(const std::string&ph);
			system::error_code last_write_time_api(const std::string&ph, std::time_t new_value);
			system::error_code get_current_path_api(std::string&ph);
			system::error_code set_current_path_api(const std::string&ph);
			query_pair create_directory_api(const std::string&ph);
			system::error_code create_hard_link_api(const std::string&to_ph, const std::string&from_ph);
			system::error_code create_symlink_api(const std::string&to_ph, const std::string&from_ph);
			system::error_code remove_api(const std::string&ph);
			system::error_code rename_api(const std::string&from, const std::string&to);
			system::error_code copy_file_api(const std::string&from, const std::string&to, bool fail_if_exists);
			system::error_code get_full_path_name_api(const std::string&ph, std::string&target);
			boost::filesystem::file_status status_api(const std::wstring&ph, system::error_code&ec);
			query_pair is_empty_api(const std::wstring&ph);
			query_pair equivalent_api(const std::wstring&ph1, const std::wstring&ph2);
			uintmax_pair file_size_api(const std::wstring&ph);
			space_pair space_api(const std::wstring&ph);
			system::error_code get_full_path_name_api(const std::wstring&ph, std::wstring&target);
			time_pair last_write_time_api(const std::wstring&ph);
			system::error_code last_write_time_api(const std::wstring&ph, std::time_t new_value);
			system::error_code get_current_path_api(std::wstring&ph);
			system::error_code set_current_path_api(const std::wstring&ph);
			query_pair create_directory_api(const std::wstring&ph);
			system::error_code create_hard_link_api(const std::wstring&existing_ph, const std::wstring&new_ph);
			system::error_code create_symlink_api(const std::wstring&to_ph, const std::wstring&from_ph);
			system::error_code remove_api(const std::wstring&ph);
			system::error_code rename_api(const std::wstring&from, const std::wstring&to);
			system::error_code copy_file_api(const std::wstring&from, const std::wstring&to, bool fail_if_exists);
			template<class Path>
			bool remove_aux(const Path&ph, file_status f);
			template<class Path>
			unsigned long remove_all_aux(const Path&ph, file_status f);
		}
		template<class Path>
		inline typename boost::enable_if<is_basic_path<Path>, file_status>::type status(const Path&ph, system::error_code&ec)
		{
			return detail::status_api(ph.external_file_string(), ec);
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, file_status>::type status(const Path&ph)
		{
			system::error_code ec;
			file_status result(detail::status_api(ph.external_file_string(), ec));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::status", ph, ec));
			return result;
		}
		template<class Path>
		inline typename boost::enable_if<is_basic_path<Path>, file_status>::type symlink_status(const Path&ph, system::error_code&ec)
		{
			return detail::status_api(ph.external_file_string(), ec);
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, file_status>::type symlink_status(const Path&ph)
		{
			system::error_code ec;
			file_status result(symlink_status(ph, ec));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::symlink_status", ph, ec));
			return result;
		}
		inline bool symbolic_link_exists(const path&ph)
		{
			return is_symlink(symlink_status(ph));
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type exists(const Path&ph)
		{
			system::error_code ec;
			file_status result(detail::status_api(ph.external_file_string(), ec));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::exists", ph, ec));
			return exists(result);
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type is_directory(const Path&ph)
		{
			system::error_code ec;
			file_status result(detail::status_api(ph.external_file_string(), ec));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::is_directory", ph, ec));
			return is_directory(result);
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type is_regular_file(const Path&ph)
		{
			system::error_code ec;
			file_status result(detail::status_api(ph.external_file_string(), ec));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::is_regular_file", ph, ec));
			return is_regular_file(result);
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type is_regular(const Path&ph)
		{
			system::error_code ec;
			file_status result(detail::status_api(ph.external_file_string(), ec));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::is_regular", ph, ec));
			return is_regular(result);
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type is_other(const Path&ph)
		{
			system::error_code ec;
			file_status result(detail::status_api(ph.external_file_string(), ec));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::is_other", ph, ec));
			return is_other(result);
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type is_symlink(const Path&)
		{
			return false;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type is_empty(const Path&ph)
		{
			detail::query_pair result(detail::is_empty_api(ph.external_file_string()));
			if(result.first)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::is_empty", ph, result.first));
			return result.second;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type equivalent(const Path&ph1, const Path&ph2)
		{
			detail::query_pair result(detail::equivalent_api(ph1.external_file_string(), ph2.external_file_string()));
			if(result.first)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::equivalent", ph1, ph2, result.first));
			return result.second;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, boost::uintmax_t>::type file_size(const Path&ph)
		{
			detail::uintmax_pair result(detail::file_size_api(ph.external_file_string()));
			if(result.first)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::file_size", ph, result.first));
			return result.second;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, space_info>::type space(const Path&ph)
		{
			detail::space_pair result(detail::space_api(ph.external_file_string()));
			if(result.first)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::space", ph, result.first));
			return result.second;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, std::time_t>::type last_write_time(const Path&ph)
		{
			detail::time_pair result(detail::last_write_time_api(ph.external_file_string()));
			if(result.first)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::last_write_time", ph, result.first));
			return result.second;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type create_directory(const Path&dir_ph)
		{
			detail::query_pair result(detail::create_directory_api(dir_ph.external_directory_string()));
			if(result.first)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::create_directory", dir_ph, result.first));
			return result.second;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, void>::type create_hard_link(const Path&to_ph, const Path&from_ph)
		{
			system::error_code ec(detail::create_hard_link_api(to_ph.external_file_string(), from_ph.external_file_string()));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::create_hard_link", to_ph, from_ph, ec));
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, system::error_code>::type create_hard_link(const Path&to_ph, const Path&from_ph, system::error_code&ec)
		{
			ec=detail::create_hard_link_api(to_ph.external_file_string(), from_ph.external_file_string());
			return ec;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, void>::type create_symlink(const Path&to_ph, const Path&from_ph)
		{
			system::error_code ec(detail::create_symlink_api(to_ph.external_file_string(), from_ph.external_file_string()));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::create_symlink", to_ph, from_ph, ec));
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, system::error_code>::type create_symlink(const Path&to_ph, const Path&from_ph, system::error_code&ec)
		{
			ec=detail::create_symlink_api(to_ph.external_file_string(), from_ph.external_file_string());
			return ec;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, bool>::type remove(const Path&ph)
		{
			system::error_code ec;
			file_status f=symlink_status(ph, ec);
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::remove", ph, ec));
			return detail::remove_aux(ph, f);
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, unsigned long>::type remove_all(const Path&ph)
		{
			system::error_code ec;
			file_status f=symlink_status(ph, ec);
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::remove_all", ph, ec));
			return exists(f)?detail::remove_all_aux(ph, f): 0;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, void>::type rename(const Path&from_path, const Path&to_path)
		{
			system::error_code ec(detail::rename_api(from_path.external_directory_string(), to_path.external_directory_string()));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::rename", from_path, to_path, ec));
		}
		struct copy_option
		{
			enum enum_t
			{
				fail_if_exists, overwrite_if_exists
			};
		};
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, void>::type copy_file(const Path&from_path, const Path&to_path, copy_option::enum_t option=copy_option::fail_if_exists)
		{
			system::error_code ec(detail::copy_file_api(from_path.external_directory_string(), to_path.external_directory_string(), option==copy_option::fail_if_exists));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::copy_file", from_path, to_path, ec));
		}
		template<class Path>
		Path current_path()
		{
			typename Path::external_string_type ph;
			system::error_code ec(detail::get_current_path_api(ph));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::current_path", ec));
			return Path(Path::traits_type::to_internal(ph));
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, void>::type current_path(const Path&ph)
		{
			system::error_code ec(detail::set_current_path_api(ph.external_directory_string()));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::current_path", ph, ec));
		}
		template<class Path>
		const Path&initial_path()
		{
			static Path init_path;
			if(init_path.empty())init_path=current_path<Path>();
			return init_path;
		}
		inline path current_path()
		{
			return current_path<boost::filesystem::path>();
		}
		inline const path&initial_path()
		{
			return initial_path<boost::filesystem::path>();
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, Path>::type system_complete(const Path&ph)
		{
			if(ph.empty())return ph;
			typename Path::external_string_type sys_ph;
			system::error_code ec(detail::get_full_path_name_api(ph.external_file_string(), sys_ph));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::system_complete", ph, ec));
			return Path(Path::traits_type::to_internal(sys_ph));
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, Path>::type complete(const Path&ph, const Path&base)
		{
			(void)((!!(base.is_complete()&&(ph.is_complete()||!ph.has_root_name())&&"boost::filesystem::complete() precondition not met"))||(_wassert(L"base.is_complete() && (ph.is_complete() || !ph.has_root_name()) && \"boost::filesystem::complete() precondition not met\"", L"D:\\dev\\boost_1_41_0\\boost\\filesystem\\operations.hpp", 583), 0));
			if(ph.empty()||ph.is_complete())return ph;
			if(!ph.has_root_name())return ph.has_root_directory()?Path(base.root_name())/ph: base/ph;
			return base/ph;
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, Path>::type complete(const Path&ph)
		{
			return complete(ph, initial_path<Path>());
		}
		template<class Path>
		typename boost::enable_if<is_basic_path<Path>, void>::type last_write_time(const Path&ph, const std::time_t new_time)
		{
			system::error_code ec(detail::last_write_time_api(ph.external_file_string(), new_time));
			if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::last_write_time", ph, ec));
		}
		inline file_status status(const path&ph)
		{
			return status<path>(ph);
		}
		inline file_status status(const wpath&ph)
		{
			return status<wpath>(ph);
		}
		inline file_status status(const path&ph, system::error_code&ec)
		{
			return status<path>(ph, ec);
		}
		inline file_status status(const wpath&ph, system::error_code&ec)
		{
			return status<wpath>(ph, ec);
		}
		inline file_status symlink_status(const path&ph)
		{
			return symlink_status<path>(ph);
		}
		inline file_status symlink_status(const wpath&ph)
		{
			return symlink_status<wpath>(ph);
		}
		inline file_status symlink_status(const path&ph, system::error_code&ec)
		{
			return symlink_status<path>(ph, ec);
		}
		inline file_status symlink_status(const wpath&ph, system::error_code&ec)
		{
			return symlink_status<wpath>(ph, ec);
		}
		inline bool exists(const path&ph)
		{
			return exists<path>(ph);
		}
		inline bool exists(const wpath&ph)
		{
			return exists<wpath>(ph);
		}
		inline bool is_directory(const path&ph)
		{
			return is_directory<path>(ph);
		}
		inline bool is_directory(const wpath&ph)
		{
			return is_directory<wpath>(ph);
		}
		inline bool is_regular_file(const path&ph)
		{
			return is_regular_file<path>(ph);
		}
		inline bool is_regular_file(const wpath&ph)
		{
			return is_regular_file<wpath>(ph);
		}
		inline bool is_regular(const path&ph)
		{
			return is_regular<path>(ph);
		}
		inline bool is_regular(const wpath&ph)
		{
			return is_regular<wpath>(ph);
		}
		inline bool is_other(const path&ph)
		{
			return is_other<path>(ph);
		}
		inline bool is_other(const wpath&ph)
		{
			return is_other<wpath>(ph);
		}
		inline bool is_symlink(const path&ph)
		{
			return is_symlink<path>(ph);
		}
		inline bool is_symlink(const wpath&ph)
		{
			return is_symlink<wpath>(ph);
		}
		inline bool is_empty(const path&ph)
		{
			return boost::filesystem::is_empty<path>(ph);
		}
		inline bool is_empty(const wpath&ph)
		{
			return boost::filesystem::is_empty<wpath>(ph);
		}
		inline bool equivalent(const path&ph1, const path&ph2)
		{
			return equivalent<path>(ph1, ph2);
		}
		inline bool equivalent(const wpath&ph1, const wpath&ph2)
		{
			return equivalent<wpath>(ph1, ph2);
		}
		inline boost::uintmax_t file_size(const path&ph)
		{
			return file_size<path>(ph);
		}
		inline boost::uintmax_t file_size(const wpath&ph)
		{
			return file_size<wpath>(ph);
		}
		inline space_info space(const path&ph)
		{
			return space<path>(ph);
		}
		inline space_info space(const wpath&ph)
		{
			return space<wpath>(ph);
		}
		inline std::time_t last_write_time(const path&ph)
		{
			return last_write_time<path>(ph);
		}
		inline std::time_t last_write_time(const wpath&ph)
		{
			return last_write_time<wpath>(ph);
		}
		inline bool create_directory(const path&dir_ph)
		{
			return create_directory<path>(dir_ph);
		}
		inline bool create_directory(const wpath&dir_ph)
		{
			return create_directory<wpath>(dir_ph);
		}
		inline void create_hard_link(const path&to_ph, const path&from_ph)
		{
			return create_hard_link<path>(to_ph, from_ph);
		}
		inline void create_hard_link(const wpath&to_ph, const wpath&from_ph)
		{
			return create_hard_link<wpath>(to_ph, from_ph);
		}
		inline system::error_code create_hard_link(const path&to_ph, const path&from_ph, system::error_code&ec)
		{
			return create_hard_link<path>(to_ph, from_ph, ec);
		}
		inline system::error_code create_hard_link(const wpath&to_ph, const wpath&from_ph, system::error_code&ec)
		{
			return create_hard_link<wpath>(to_ph, from_ph, ec);
		}
		inline void create_symlink(const path&to_ph, const path&from_ph)
		{
			return create_symlink<path>(to_ph, from_ph);
		}
		inline void create_symlink(const wpath&to_ph, const wpath&from_ph)
		{
			return create_symlink<wpath>(to_ph, from_ph);
		}
		inline system::error_code create_symlink(const path&to_ph, const path&from_ph, system::error_code&ec)
		{
			return create_symlink<path>(to_ph, from_ph, ec);
		}
		inline system::error_code create_symlink(const wpath&to_ph, const wpath&from_ph, system::error_code&ec)
		{
			return create_symlink<wpath>(to_ph, from_ph, ec);
		}
		inline bool remove(const path&ph)
		{
			return remove<path>(ph);
		}
		inline bool remove(const wpath&ph)
		{
			return remove<wpath>(ph);
		}
		inline unsigned long remove_all(const path&ph)
		{
			return remove_all<path>(ph);
		}
		inline unsigned long remove_all(const wpath&ph)
		{
			return remove_all<wpath>(ph);
		}
		inline void rename(const path&from_path, const path&to_path)
		{
			return rename<path>(from_path, to_path);
		}
		inline void rename(const wpath&from_path, const wpath&to_path)
		{
			return rename<wpath>(from_path, to_path);
		}
		inline void copy_file(const path&from_path, const path&to_path)
		{
			return copy_file<path>(from_path, to_path);
		}
		inline void copy_file(const wpath&from_path, const wpath&to_path)
		{
			return copy_file<wpath>(from_path, to_path);
		}
		inline path system_complete(const path&ph)
		{
			return system_complete<path>(ph);
		}
		inline wpath system_complete(const wpath&ph)
		{
			return system_complete<wpath>(ph);
		}
		inline path complete(const path&ph, const path&base)
		{
			return complete<path>(ph, base);
		}
		inline wpath complete(const wpath&ph, const wpath&base)
		{
			return complete<wpath>(ph, base);
		}
		inline path complete(const path&ph)
		{
			return complete<path>(ph, initial_path<path>());
		}
		inline wpath complete(const wpath&ph)
		{
			return complete<wpath>(ph, initial_path<wpath>());
		}
		inline void last_write_time(const path&ph, const std::time_t new_time)
		{
			last_write_time<path>(ph, new_time);
		}
		inline void last_write_time(const wpath&ph, const std::time_t new_time)
		{
			last_write_time<wpath>(ph, new_time);
		}
		inline void current_path(const path&ph)
		{
			current_path<path>(ph);
		}
		inline void current_path(const wpath&ph)
		{
			current_path<wpath>(ph);
		}
		namespace detail
		{
			template<class Path>
			bool remove_aux(const Path&ph, file_status f)
			{
				if(exists(f))
				{
					system::error_code ec=remove_api(ph.external_file_string());
					if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::remove", ph, ec));
					return true;
				}
				return false;
			}
			template<class Path>
			unsigned long remove_all_aux(const Path&ph, file_status f)
			{
				static const boost::filesystem::basic_directory_iterator<Path>end_itr;
				unsigned long count=1;
				if(!boost::filesystem::is_symlink(f)&&boost::filesystem::is_directory(f))
				{
					for(boost::filesystem::basic_directory_iterator<Path>itr(ph);
					itr!=end_itr;
					++itr)
					{
						boost::system::error_code ec;
						boost::filesystem::file_status fn=boost::filesystem::symlink_status(itr->path(), ec);
						if(ec)boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem:remove_all", ph, ec));
						count+=remove_all_aux(itr->path(), fn);
					}
				}
				remove_aux(ph, f);
				return count;
			}
			bool possible_large_file_size_support();
			system::error_code dir_itr_first(void*&handle, const std::string&dir_path, std::string&target, file_status&fs, file_status&symlink_fs);
			system::error_code dir_itr_increment(void*&handle, std::string&target, file_status&fs, file_status&symlink_fs);
			system::error_code dir_itr_close(void*&handle);
			system::error_code dir_itr_first(void*&handle, const std::wstring&ph, std::wstring&target, file_status&fs, file_status&symlink_fs);
			system::error_code dir_itr_increment(void*&handle, std::wstring&target, file_status&fs, file_status&symlink_fs);
			template<class Path>
			class dir_itr_imp
			{
			public:
				basic_directory_entry<Path>m_directory_entry;
				void*m_handle;
				dir_itr_imp(): m_handle(0)
				{
				}
				~dir_itr_imp()
				{
					dir_itr_close(m_handle);
				}
			};
			system::error_code not_found_error();
		}
		template<class Path>
		class basic_directory_iterator: public boost::iterator_facade<basic_directory_iterator<Path>, basic_directory_entry<Path>, boost::single_pass_traversal_tag>
		{
		public:
			typedef Path path_type;
			basic_directory_iterator()
			{
			}
			explicit basic_directory_iterator(const Path&dir_path);
			basic_directory_iterator(const Path&dir_path, system::error_code&ec);
		private:
			boost::shared_ptr<detail::dir_itr_imp<Path> >m_imp;
			friend class boost::iterator_core_access;
			typename boost::iterator_facade<basic_directory_iterator<Path>, basic_directory_entry<Path>, boost::single_pass_traversal_tag>::reference dereference()const
			{
				(void)((!!(m_imp.get()&&"attempt to dereference end iterator"))||(_wassert(L"m_imp.get() && \"attempt to dereference end iterator\"", L"D:\\dev\\boost_1_41_0\\boost\\filesystem\\operations.hpp", 918), 0));
				return m_imp->m_directory_entry;
			}
			void increment();
			bool equal(const basic_directory_iterator&rhs)const
			{
				return m_imp==rhs.m_imp;
			}
			system::error_code m_init(const Path&dir_path);
		};
		typedef basic_directory_iterator<path>directory_iterator;
		typedef basic_directory_iterator<wpath>wdirectory_iterator;
		template<class Path>
		system::error_code basic_directory_iterator<Path>::m_init(const Path&dir_path)
		{
			if(dir_path.empty())
			{
				m_imp.reset();
				return detail::not_found_error();
			}
			typename Path::external_string_type name;
			file_status fs, symlink_fs;
			system::error_code ec(detail::dir_itr_first(m_imp->m_handle, dir_path.external_directory_string(), name, fs, symlink_fs));
			if(ec)
			{
				m_imp.reset();
				return ec;
			}
			if(m_imp->m_handle==0)m_imp.reset();
			else
			{
				m_imp->m_directory_entry.assign(dir_path/Path::traits_type::to_internal(name), fs, symlink_fs);
				if(name[0]==dot<Path>::value&&(name.size()==1||(name[1]==dot<Path>::value&&name.size()==2)))
				{
					increment();
				}
			}
			return boost::system::error_code();
		}
		template<class Path>
		basic_directory_iterator<Path>::basic_directory_iterator(const Path&dir_path): m_imp(new detail::dir_itr_imp<Path>)
		{
			system::error_code ec(m_init(dir_path));
			if(ec)
			{
				boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::basic_directory_iterator constructor", dir_path, ec));
			}
		}
		template<class Path>
		basic_directory_iterator<Path>::basic_directory_iterator(const Path&dir_path, system::error_code&ec): m_imp(new detail::dir_itr_imp<Path>)
		{
			ec=m_init(dir_path);
		}
		template<class Path>
		void basic_directory_iterator<Path>::increment()
		{
			(void)((!!(m_imp.get()&&"attempt to increment end iterator"))||(_wassert(L"m_imp.get() && \"attempt to increment end iterator\"", L"D:\\dev\\boost_1_41_0\\boost\\filesystem\\operations.hpp", 1000), 0));
			(void)((!!(m_imp->m_handle!=0&&"internal program error"))||(_wassert(L"m_imp->m_handle != 0 && \"internal program error\"", L"D:\\dev\\boost_1_41_0\\boost\\filesystem\\operations.hpp", 1001), 0));
			typename Path::external_string_type name;
			file_status fs, symlink_fs;
			system::error_code ec;
			for(;
			;
			)
			{
				ec=detail::dir_itr_increment(m_imp->m_handle, name, fs, symlink_fs);
				if(ec)
				{
					boost::throw_exception(basic_filesystem_error<Path>("boost::filesystem::basic_directory_iterator increment", m_imp->m_directory_entry.path().parent_path(), ec));
				}
				if(m_imp->m_handle==0)
				{
					m_imp.reset();
					return ;
				}
				if(!(name[0]==dot<Path>::value&&(name.size()==1||(name[1]==dot<Path>::value&&name.size()==2))))
				{
					m_imp->m_directory_entry.replace_filename(Path::traits_type::to_internal(name), fs, symlink_fs);
					return ;
				}
			}
		}
		template<class Path>
		class basic_directory_entry
		{
		public:
			typedef Path path_type;
			typedef typename Path::string_type string_type;
			basic_directory_entry()
			{
			}
			explicit basic_directory_entry(const path_type&p, file_status st=file_status(), file_status symlink_st=file_status()): m_path(p), m_status(st), m_symlink_status(symlink_st)
			{
			}
			void assign(const path_type&p, file_status st, file_status symlink_st)
			{
				m_path=p;
				m_status=st;
				m_symlink_status=symlink_st;
			}
			void replace_filename(const string_type&s, file_status st, file_status symlink_st)
			{
				m_path.remove_filename();
				m_path/=s;
				m_status=st;
				m_symlink_status=symlink_st;
			}
			void replace_leaf(const string_type&s, file_status st, file_status symlink_st)
			{
				replace_filename(s, st, symlink_st);
			}
			const Path&path()const
			{
				return m_path;
			}
			file_status status()const;
			file_status status(system::error_code&ec)const;
			file_status symlink_status()const;
			file_status symlink_status(system::error_code&ec)const;
			operator const path_type&()const
			{
				return m_path;
			}
			typename Path::string_type filename()const
			{
				return path().filename();
			}
			typename Path::string_type leaf()const
			{
				return path().filename();
			}
			typename Path::string_type string()const
			{
				return path().string();
			}
		private:
			path_type m_path;
			mutable file_status m_status;
			mutable file_status m_symlink_status;
		};
		typedef basic_directory_entry<path>directory_entry;
		typedef basic_directory_entry<wpath>wdirectory_entry;
		template<class Path>
		file_status basic_directory_entry<Path>::status()const
		{
			if(!status_known(m_status))
			{
				m_status=boost::filesystem::status(m_path);
			}
			return m_status;
		}
		template<class Path>
		file_status basic_directory_entry<Path>::status(system::error_code&ec)const
		{
			if(!status_known(m_status))
			{
				m_status=boost::filesystem::status(m_path, ec);
			}
			else ec=boost::system::error_code();
			;
			return m_status;
		}
		template<class Path>
		file_status basic_directory_entry<Path>::symlink_status()const
		{
			return status();
		}
		template<class Path>
		file_status basic_directory_entry<Path>::symlink_status(system::error_code&ec)const
		{
			return status(ec);
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			inline boost::filesystem::path initial_path()
			{
				return boost::filesystem::initial_path();
			}
			inline boost::filesystem::path current_path()
			{
				return boost::filesystem::current_path();
			}
			template<typename String>
			inline boost::filesystem::path create_path(String const&p)
			{
				return boost::filesystem::path(p, boost::filesystem::native);
			}
			inline std::string leaf(boost::filesystem::path const&p)
			{
				return p.leaf();
			}
			inline boost::filesystem::path branch_path(boost::filesystem::path const&p)
			{
				return p.branch_path();
			}
			inline boost::filesystem::path normalize(boost::filesystem::path&p)
			{
				return p.normalize();
			}
			inline std::string native_file_string(boost::filesystem::path const&p)
			{
				return p.native_file_string();
			}
		}
	}
}
namespace boost
{
	namespace detail
	{
		namespace allocator
		{
			template<typename Type>
			class partial_std_allocator_wrapper: public std::allocator<Type>
			{
			public:
				typedef Type value_type;
				partial_std_allocator_wrapper()
				{
				};
				template<typename Other>
				partial_std_allocator_wrapper(const partial_std_allocator_wrapper<Other>&)
				{
				}
				partial_std_allocator_wrapper(const std::allocator<Type>&x): std::allocator<Type>(x)
				{
				};
				Type*allocate(std::size_t n, const void*hint=0)
				{
					std::allocator<Type>&a=*this;
					return a.allocate(n, hint);
				}
			};
			template<typename Allocator>
			struct is_partial_std_allocator
			{
				static const bool value=false;
			};
			template<typename Allocator, typename Type>
			struct partial_std_allocator_rebind_to
			{
				typedef partial_std_allocator_wrapper<Type>type;
			};
			template<typename Allocator>
			struct rebinder
			{
				template<typename Type>
				struct result
				{
					typedef typename Allocator::template rebind<Type>::other other;
				};
			};
			template<typename Allocator, typename Type>
			struct compliant_allocator_rebind_to
			{
				typedef typename rebinder<Allocator>::template result<Type>::other type;
			};
			template<typename Allocator, typename Type>
			struct rebind_to: mpl::eval_if_c<is_partial_std_allocator<Allocator>::value, partial_std_allocator_rebind_to<Allocator, Type>, compliant_allocator_rebind_to<Allocator, Type> >
			{
			};
			template<typename Type>
			void construct(void*p, const Type&t)
			{
				new(p)Type(t);
			}
			template<typename Type>
			void destroy(const Type*p)
			{
				p->~Type();
			}
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct at_impl;
		template<typename Sequence, typename N>
		struct at;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct begin_impl;
		template<typename Tag>
		struct end_impl;
		template<typename Sequence>
		struct begin;
		template<typename Sequence>
		struct end;
	}
}
namespace boost
{
	namespace mpl
	{
		struct nested_begin_end_tag;
		struct non_sequence_tag;
		template<typename Sequence>
		struct sequence_tag;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct has_begin_msvc_sfinae_helper
			{
				typedef void type;
			};
			template<typename T, typename U=void>
			struct has_begin_impl_
			{
				static const bool value=false;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T>
			struct has_begin_impl_<T, typename has_begin_msvc_sfinae_helper<typename T::begin>::type>
			{
				static const bool value=true;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T, typename fallback_=boost::mpl::bool_<true> >
			struct has_begin: has_begin_impl_<T>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename Sequence>
			struct begin_type
			{
				typedef typename Sequence::begin type;
			};
			template<typename Sequence>
			struct end_type
			{
				typedef typename Sequence::end type;
			};
		}
		template<typename Tag>
		struct begin_impl
		{
			template<typename Sequence>
			struct apply
			{
				typedef typename eval_if<aux::has_begin<Sequence, true_>, aux::begin_type<Sequence>, void_>::type type;
			};
		};
		template<typename Tag>
		struct end_impl
		{
			template<typename Sequence>
			struct apply
			{
				typedef typename eval_if<aux::has_begin<Sequence, true_>, aux::end_type<Sequence>, void_>::type type;
			};
		};
		template<>
		struct begin_impl<nested_begin_end_tag>
		{
			template<typename Sequence>
			struct apply
			{
				typedef typename Sequence::begin type;
			};
		};
		template<>
		struct end_impl<nested_begin_end_tag>
		{
			template<typename Sequence>
			struct apply
			{
				typedef typename Sequence::end type;
			};
		};
		template<>
		struct begin_impl<non_sequence_tag>
		{
			template<typename Sequence>
			struct apply
			{
				typedef void_ type;
			};
		};
		template<>
		struct end_impl<non_sequence_tag>
		{
			template<typename Sequence>
			struct apply
			{
				typedef void_ type;
			};
		};
		template<>
		struct begin_impl<na>
		{
			template<typename Sequence>
			struct apply
			{
				typedef void_ type;
			};
		};
		template<>
		struct end_impl<na>
		{
			template<typename Sequence>
			struct apply
			{
				typedef void_ type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct has_tag_msvc_sfinae_helper
			{
				typedef void type;
			};
			template<typename T, typename U=void>
			struct has_tag_impl_
			{
				static const bool value=false;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T>
			struct has_tag_impl_<T, typename has_tag_msvc_sfinae_helper<typename T::tag>::type>
			{
				static const bool value=true;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T, typename fallback_=boost::mpl::bool_<false> >
			struct has_tag: has_tag_impl_<T>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<bool has_tag_, bool has_begin_>
			struct sequence_tag_impl
			{
				template<typename Sequence>
				struct result2_;
			};
			template<>
			struct sequence_tag_impl<true, true>
			{
				template<typename Sequence>
				struct result2_
				{
					typedef typename Sequence::tag type;
				};
			};
			template<>
			struct sequence_tag_impl<true, false>
			{
				template<typename Sequence>
				struct result2_
				{
					typedef typename Sequence::tag type;
				};
			};
			template<>
			struct sequence_tag_impl<false, true>
			{
				template<typename Sequence>
				struct result2_
				{
					typedef nested_begin_end_tag type;
				};
			};
			template<>
			struct sequence_tag_impl<false, false>
			{
				template<typename Sequence>
				struct result2_
				{
					typedef non_sequence_tag type;
				};
			};
		}
		template<typename Sequence=na>
		struct sequence_tag: aux::sequence_tag_impl< ::boost::mpl::aux::has_tag<Sequence>::value, ::boost::mpl::aux::has_begin<Sequence>::value>::template result2_<Sequence>
		{
		};
		template<>
		struct sequence_tag<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: sequence_tag<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<sequence_tag<na>, Tag>
		{
			typedef false_ is_le;
			typedef sequence_tag<na>result_;
			typedef sequence_tag<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na>
		struct begin
		{
			typedef typename sequence_tag<Sequence>::type tag_;
			typedef typename begin_impl<tag_>::template apply<Sequence>::type type;
		};
		template<typename Sequence=na>
		struct end
		{
			typedef typename sequence_tag<Sequence>::type tag_;
			typedef typename end_impl<tag_>::template apply<Sequence>::type type;
		};
		template<>
		struct begin<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: begin<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<begin<na>, Tag>
		{
			typedef false_ is_le;
			typedef begin<na>result_;
			typedef begin<na>type;
		};
		template<>
		struct end<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: end<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<end<na>, Tag>
		{
			typedef false_ is_le;
			typedef end<na>result_;
			typedef end<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct advance_impl;
		template<typename Iterator, typename N>
		struct advance;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename SourceTag, typename TargetTag>
		struct numeric_cast
		{
			template<typename N>
			struct apply;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct tag_impl
			{
				typedef typename T::tag type;
			};
		}
		template<typename T, typename Default=void_>
		struct tag: if_<aux::has_tag<T>, aux::tag_impl<T>, Default>::type
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename F, typename Tag1, typename Tag2>
			struct cast1st_impl
			{
				template<typename N1, typename N2>
				struct apply: apply_wrap2<F, typename apply_wrap1<numeric_cast<Tag1, Tag2>, N1>::type, N2>
				{
				};
			};
			template<typename F, typename Tag1, typename Tag2>
			struct cast2nd_impl
			{
				template<typename N1, typename N2>
				struct apply: apply_wrap2<F, N1, typename apply_wrap1<numeric_cast<Tag2, Tag1>, N2>::type>
				{
				};
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct msvc_eti_base: T
			{
				typedef T type;
			};
			template<>
			struct msvc_eti_base<int>
			{
				typedef msvc_eti_base type;
				typedef msvc_eti_base first;
				typedef msvc_eti_base second;
				typedef msvc_eti_base tag;
				enum
				{
					value=0
				};
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag1, typename Tag2>
		struct less_impl: if_c<(Tag1::value>Tag2::value), aux::cast2nd_impl<less_impl<Tag1, Tag1>, Tag1, Tag2>, aux::cast1st_impl<less_impl<Tag2, Tag2>, Tag1, Tag2> >::type
		{
		};
		template<>
		struct less_impl<na, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct less_impl<na, Tag>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct less_impl<Tag, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename T>
		struct less_tag
		{
			typedef typename T::tag type;
		};
		template<typename N1=na, typename N2=na>
		struct less: less_impl<typename less_tag<N1>::type, typename less_tag<N2>::type>::template apply<N1, N2>::type
		{
		};
		template<>
		struct less<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: less<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<less<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef less<na, na>result_;
			typedef less<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct less_impl<integral_c_tag, integral_c_tag>
		{
			template<typename N1, typename N2>
			struct apply: bool_<(N2::value>N1::value)>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct negate_impl;
		template<typename T>
		struct negate_tag
		{
			typedef typename T::tag type;
		};
		template<typename N=na>
		struct negate: negate_impl<typename negate_tag<N>::type>::template apply<N>::type
		{
		};
		template<>
		struct negate<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: negate<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<negate<na>, Tag>
		{
			typedef false_ is_le;
			typedef negate<na>result_;
			typedef negate<na>type;
		};
		template<>
		struct negate_impl<integral_c_tag>
		{
			template<typename N>
			struct apply: integral_c<typename N::value_type, (-N::value)>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<long N>
		struct long_;
	}
}
namespace boost
{
	namespace mpl
	{
		template<long N>
		struct long_
		{
			static const long value=N;
			typedef long_ type;
			typedef long value_type;
			typedef integral_c_tag tag;
			typedef boost::mpl::long_<static_cast<long>((value+1))>next;
			typedef boost::mpl::long_<static_cast<long>((value-1))>prior;
			operator long()const
			{
				return static_cast<long>(this->value);
			}
		};
		template<long N>
		long const boost::mpl::long_<N>::value;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<long N>
			struct advance_forward;
			template<>
			struct advance_forward<0>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef iter0 type;
				};
			};
			template<>
			struct advance_forward<1>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef typename next<iter0>::type iter1;
					typedef iter1 type;
				};
			};
			template<>
			struct advance_forward<2>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef typename next<iter0>::type iter1;
					typedef typename next<iter1>::type iter2;
					typedef iter2 type;
				};
			};
			template<>
			struct advance_forward<3>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef typename next<iter0>::type iter1;
					typedef typename next<iter1>::type iter2;
					typedef typename next<iter2>::type iter3;
					typedef iter3 type;
				};
			};
			template<>
			struct advance_forward<4>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef typename next<iter0>::type iter1;
					typedef typename next<iter1>::type iter2;
					typedef typename next<iter2>::type iter3;
					typedef typename next<iter3>::type iter4;
					typedef iter4 type;
				};
			};
			template<long N>
			struct advance_forward
			{
				template<typename Iterator>
				struct apply
				{
					typedef typename apply_wrap1<advance_forward<4>, Iterator>::type chunk_result_;
					typedef typename apply_wrap1<advance_forward<((N-4)<0?0: N-4)>, chunk_result_>::type type;
				};
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<long N>
			struct advance_backward;
			template<>
			struct advance_backward<0>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef iter0 type;
				};
			};
			template<>
			struct advance_backward<1>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef typename prior<iter0>::type iter1;
					typedef iter1 type;
				};
			};
			template<>
			struct advance_backward<2>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef typename prior<iter0>::type iter1;
					typedef typename prior<iter1>::type iter2;
					typedef iter2 type;
				};
			};
			template<>
			struct advance_backward<3>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef typename prior<iter0>::type iter1;
					typedef typename prior<iter1>::type iter2;
					typedef typename prior<iter2>::type iter3;
					typedef iter3 type;
				};
			};
			template<>
			struct advance_backward<4>
			{
				template<typename Iterator>
				struct apply
				{
					typedef Iterator iter0;
					typedef typename prior<iter0>::type iter1;
					typedef typename prior<iter1>::type iter2;
					typedef typename prior<iter2>::type iter3;
					typedef typename prior<iter3>::type iter4;
					typedef iter4 type;
				};
			};
			template<long N>
			struct advance_backward
			{
				template<typename Iterator>
				struct apply
				{
					typedef typename apply_wrap1<advance_backward<4>, Iterator>::type chunk_result_;
					typedef typename apply_wrap1<advance_backward<((N-4)<0?0: N-4)>, chunk_result_>::type type;
				};
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct advance_impl
		{
			template<typename Iterator, typename N>
			struct apply
			{
				typedef typename less<N, long_<0> >::type backward_;
				typedef typename if_<backward_, negate<N>, N>::type offset_;
				typedef typename if_<backward_, aux::advance_backward<offset_::value>, aux::advance_forward<offset_::value> >::type f_;
				typedef typename apply_wrap1<f_, Iterator>::type type;
			};
		};
		template<typename Iterator=na, typename N=na>
		struct advance: advance_impl<typename tag<Iterator>::type>::template apply<Iterator, N>
		{
		};
		template<typename Iterator, long N>
		struct advance_c: advance_impl<typename tag<Iterator>::type>::template apply<Iterator, long_<N> >
		{
		};
		template<>
		struct advance<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: advance<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<advance<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef advance<na, na>result_;
			typedef advance<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct msvc_type
			{
				typedef typename T::type type;
			};
			template<>
			struct msvc_type<int>
			{
				typedef int type;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Iterator=na>
		struct deref
		{
			typedef typename Iterator::type type;
		};
		template<>
		struct deref<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: deref<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<deref<na>, Tag>
		{
			typedef false_ is_le;
			typedef deref<na>result_;
			typedef deref<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct at_impl
		{
			template<typename Sequence, typename N>
			struct apply
			{
				typedef typename advance<typename begin<Sequence>::type, N>::type iter_;
				typedef typename deref<iter_>::type type;
			};
		};
		template<>
		struct at_impl<non_sequence_tag>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename N=na>
		struct at: at_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence, N>
		{
		};
		template<typename Sequence, long N>
		struct at_c: at_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence, mpl::long_<N> >
		{
		};
		template<>
		struct at<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: at<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<at<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef at<na, na>result_;
			typedef at<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct contains_impl;
		template<typename Sequence, typename T>
		struct contains;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename F, typename Iterator>
			struct iter_apply1: apply1<F, typename deref<Iterator>::type>
			{
			};
			template<typename F, typename Iterator1, typename Iterator2>
			struct iter_apply2: apply2<F, typename deref<Iterator1>::type, typename deref<Iterator2>::type>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename Predicate>
			struct find_if_pred
			{
				template<typename Iterator>
				struct apply
				{
					typedef not_<aux::iter_apply1<Predicate, Iterator> >type;
				};
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T1=na, typename T2=na>
		struct pair
		{
			typedef pair type;
			typedef T1 first;
			typedef T2 second;
		};
		template<typename P=na>
		struct first
		{
			typedef typename P::first type;
		};
		template<typename P=na>
		struct second
		{
			typedef typename P::second type;
		};
		template<>
		struct pair<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: pair<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<pair<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef pair<na, na>result_;
			typedef pair<na, na>type;
		};
		template<>
		struct first<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: first<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<first<na>, Tag>
		{
			typedef false_ is_le;
			typedef first<na>result_;
			typedef first<na>type;
		};
		template<>
		struct second<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: second<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<second<na>, Tag>
		{
			typedef false_ is_le;
			typedef second<na>result_;
			typedef second<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename Iterator, typename State>
			struct iter_fold_if_null_step
			{
				typedef State state;
				typedef Iterator iterator;
			};
			template<bool>
			struct iter_fold_if_step_impl
			{
				template<typename Iterator, typename State, typename StateOp, typename IteratorOp>
				struct result_
				{
					typedef typename apply2<StateOp, State, Iterator>::type state;
					typedef typename IteratorOp::type iterator;
				};
			};
			template<>
			struct iter_fold_if_step_impl<false>
			{
				template<typename Iterator, typename State, typename StateOp, typename IteratorOp>
				struct result_
				{
					typedef State state;
					typedef Iterator iterator;
				};
			};
			template<typename Iterator, typename State, typename ForwardOp, typename Predicate>
			struct iter_fold_if_forward_step
			{
				typedef typename apply2<Predicate, State, Iterator>::type not_last;
				typedef typename iter_fold_if_step_impl<not_last::value>::template result_<Iterator, State, ForwardOp, mpl::next<Iterator> >impl_;
				typedef typename impl_::state state;
				typedef typename impl_::iterator iterator;
			};
			template<typename Iterator, typename State, typename BackwardOp, typename Predicate>
			struct iter_fold_if_backward_step
			{
				typedef typename apply2<Predicate, State, Iterator>::type not_last;
				typedef typename iter_fold_if_step_impl<not_last::value>::template result_<Iterator, State, BackwardOp, identity<Iterator> >impl_;
				typedef typename impl_::state state;
				typedef typename impl_::iterator iterator;
			};
			template<typename Iterator, typename State, typename ForwardOp, typename ForwardPredicate, typename BackwardOp, typename BackwardPredicate>
			struct iter_fold_if_impl
			{
			private:
				typedef iter_fold_if_null_step<Iterator, State>forward_step0;
				typedef iter_fold_if_forward_step<typename forward_step0::iterator, typename forward_step0::state, ForwardOp, ForwardPredicate>forward_step1;
				typedef iter_fold_if_forward_step<typename forward_step1::iterator, typename forward_step1::state, ForwardOp, ForwardPredicate>forward_step2;
				typedef iter_fold_if_forward_step<typename forward_step2::iterator, typename forward_step2::state, ForwardOp, ForwardPredicate>forward_step3;
				typedef iter_fold_if_forward_step<typename forward_step3::iterator, typename forward_step3::state, ForwardOp, ForwardPredicate>forward_step4;
				typedef typename if_<typename forward_step4::not_last, iter_fold_if_impl<typename forward_step4::iterator, typename forward_step4::state, ForwardOp, ForwardPredicate, BackwardOp, BackwardPredicate>, iter_fold_if_null_step<typename forward_step4::iterator, typename forward_step4::state> >::type backward_step4;
				typedef iter_fold_if_backward_step<typename forward_step3::iterator, typename backward_step4::state, BackwardOp, BackwardPredicate>backward_step3;
				typedef iter_fold_if_backward_step<typename forward_step2::iterator, typename backward_step3::state, BackwardOp, BackwardPredicate>backward_step2;
				typedef iter_fold_if_backward_step<typename forward_step1::iterator, typename backward_step2::state, BackwardOp, BackwardPredicate>backward_step1;
				typedef iter_fold_if_backward_step<typename forward_step0::iterator, typename backward_step1::state, BackwardOp, BackwardPredicate>backward_step0;
			public:
				typedef typename backward_step0::state state;
				typedef typename backward_step4::iterator iterator;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename Predicate, typename LastIterator>
			struct iter_fold_if_pred
			{
				template<typename State, typename Iterator>
				struct apply: and_<not_<is_same<Iterator, LastIterator> >, apply1<Predicate, Iterator> >
				{
				};
			};
		}
		template<typename Sequence=na, typename State=na, typename ForwardOp=na, typename ForwardPredicate=na, typename BackwardOp=na, typename BackwardPredicate=na>
		struct iter_fold_if
		{
			typedef typename begin<Sequence>::type first_;
			typedef typename end<Sequence>::type last_;
			typedef typename eval_if<is_na<BackwardPredicate>, if_<is_na<BackwardOp>, always<false_>, always<true_> >, identity<BackwardPredicate> >::type backward_pred_;
			struct result_: aux::iter_fold_if_impl<first_, State, ForwardOp, protect<aux::iter_fold_if_pred<ForwardPredicate, last_> >, BackwardOp, backward_pred_>
			{
			};
		public:
			typedef pair<typename result_::state, typename result_::iterator>type;
		};
		template<>
		struct iter_fold_if<na, na, na, na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct apply: iter_fold_if<T1, T2, T3, T4, T5, T6>
			{
			};
		};
		template<typename Tag>
		struct lambda<iter_fold_if<na, na, na, na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef iter_fold_if<na, na, na, na, na, na>result_;
			typedef iter_fold_if<na, na, na, na, na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename Predicate=na>
		struct find_if
		{
			typedef typename iter_fold_if<Sequence, void, mpl::arg<1>, protect<aux::find_if_pred<Predicate> > >::type result_;
			typedef typename second<result_>::type type;
		};
		template<>
		struct find_if<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: find_if<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<find_if<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef find_if<na, na>result_;
			typedef find_if<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T1>
		struct same_as
		{
			template<typename T2>
			struct apply: is_same<T1, T2>
			{
			};
		};
		template<typename T1>
		struct not_same_as
		{
			template<typename T2>
			struct apply: not_<is_same<T1, T2> >
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename T=na>
		struct find: find_if<Sequence, same_as<T> >
		{
		};
		template<>
		struct find<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: find<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<find<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef find<na, na>result_;
			typedef find<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct contains_impl
		{
			template<typename Sequence, typename T>
			struct apply: not_<is_same<typename find<Sequence, T>::type, typename end<Sequence>::type> >
			{
			};
		};
		template<>
		struct contains_impl<non_sequence_tag>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename T=na>
		struct contains: contains_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence, T>
		{
		};
		template<>
		struct contains<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: contains<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<contains<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef contains<na, na>result_;
			typedef contains<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct size_impl;
		template<typename Sequence>
		struct size;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct distance_impl;
		template<typename First, typename Last>
		struct distance;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct O1_size_impl;
		template<typename Sequence>
		struct O1_size;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct has_size_msvc_sfinae_helper
			{
				typedef void type;
			};
			template<typename T, typename U=void>
			struct has_size_impl_
			{
				static const bool value=false;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T>
			struct has_size_impl_<T, typename has_size_msvc_sfinae_helper<typename T::size>::type>
			{
				static const bool value=true;
				typedef boost::mpl::bool_<value>type;
			};
			template<typename T, typename fallback_=boost::mpl::bool_<false> >
			struct has_size: has_size_impl_<T>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename Sequence>
			struct O1_size_impl: Sequence::size
			{
			};
		}
		template<typename Tag>
		struct O1_size_impl
		{
			template<typename Sequence>
			struct apply: if_<aux::has_size<Sequence>, aux::O1_size_impl<Sequence>, long_<-1> >::type
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na>
		struct O1_size: O1_size_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence>
		{
		};
		template<>
		struct O1_size<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: O1_size<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<O1_size<na>, Tag>
		{
			typedef false_ is_le;
			typedef O1_size<na>result_;
			typedef O1_size<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<int N, typename First, typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl;
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl<0, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef state0 state;
				typedef iter0 iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl<1, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef typename apply2<ForwardOp, state0, iter0>::type state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef state1 state;
				typedef iter1 iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl<2, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef typename apply2<ForwardOp, state0, iter0>::type state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, state1, iter1>::type state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef state2 state;
				typedef iter2 iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl<3, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef typename apply2<ForwardOp, state0, iter0>::type state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, state1, iter1>::type state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, state2, iter2>::type state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef state3 state;
				typedef iter3 iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl<4, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef typename apply2<ForwardOp, state0, iter0>::type state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, state1, iter1>::type state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, state2, iter2>::type state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef typename apply2<ForwardOp, state3, iter3>::type state4;
				typedef typename mpl::next<iter3>::type iter4;
				typedef state4 state;
				typedef iter4 iterator;
			};
			template<int N, typename First, typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl
			{
				typedef iter_fold_impl<4, First, Last, State, ForwardOp>chunk_;
				typedef iter_fold_impl<((N-4)<0?0: N-4), typename chunk_::iterator, Last, typename chunk_::state, ForwardOp>res_;
				typedef typename res_::state state;
				typedef typename res_::iterator iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl<-1, First, Last, State, ForwardOp>: iter_fold_impl<-1, typename mpl::next<First>::type, Last, typename apply2<ForwardOp, State, First>::type, ForwardOp>
			{
			};
			template<typename Last, typename State, typename ForwardOp>
			struct iter_fold_impl<-1, Last, Last, State, ForwardOp>
			{
				typedef State state;
				typedef Last iterator;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename State=na, typename ForwardOp=na>
		struct iter_fold
		{
			typedef typename aux::iter_fold_impl< ::boost::mpl::O1_size<Sequence>::value, typename begin<Sequence>::type, typename end<Sequence>::type, State, typename lambda<ForwardOp>::type>::state type;
		};
		template<>
		struct iter_fold<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: iter_fold<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<iter_fold<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef iter_fold<na, na, na>result_;
			typedef iter_fold<na, na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		struct iterator_range_tag;
		template<typename First=na, typename Last=na>
		struct iterator_range
		{
			typedef iterator_range_tag tag;
			typedef iterator_range type;
			typedef First begin;
			typedef Last end;
		};
		template<>
		struct iterator_range<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: iterator_range<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<iterator_range<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef iterator_range<na, na>result_;
			typedef iterator_range<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct distance_impl
		{
			template<typename First, typename Last>
			struct apply: aux::msvc_eti_base<typename iter_fold<iterator_range<First, Last>, mpl::long_<0>, next<> >::type>
			{
			};
		};
		template<typename First=na, typename Last=na>
		struct distance: distance_impl<typename tag<First>::type>::template apply<First, Last>
		{
		};
		template<>
		struct distance<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: distance<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<distance<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef distance<na, na>result_;
			typedef distance<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct size_impl
		{
			template<typename Sequence>
			struct apply: distance<typename begin<Sequence>::type, typename end<Sequence>::type>
			{
			};
		};
		template<>
		struct size_impl<non_sequence_tag>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na>
		struct size: aux::msvc_eti_base<typename size_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence>::type>::type
		{
		};
		template<>
		struct size<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: size<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<size<na>, Tag>
		{
			typedef false_ is_le;
			typedef size<na>result_;
			typedef size<na>type;
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		template<class Type>
		struct identity;
	}
}
namespace boost
{
	template<class Type>
	class reference_wrapper;
	namespace multi_index
	{
		namespace detail
		{
			template<typename Type>
			struct const_identity_base
			{
				typedef Type result_type;
				template<typename ChainedPtr>
				typename disable_if<is_convertible<const ChainedPtr&, Type&>, Type&>::type operator()(const ChainedPtr&x)const
				{
					return operator()(*x);
				}
				Type&operator()(Type&x)const
				{
					return x;
				}
				Type&operator()(const reference_wrapper<Type>&x)const
				{
					return x.get();
				}
				Type&operator()(const reference_wrapper<typename remove_const<Type>::type>&x, int=0)const
				{
					return x.get();
				}
			};
			template<typename Type>
			struct non_const_identity_base
			{
				typedef Type result_type;
				template<typename ChainedPtr>
				typename disable_if<is_convertible<const ChainedPtr&, const Type&>, Type&>::type operator()(const ChainedPtr&x)const
				{
					return operator()(*x);
				}
				const Type&operator()(const Type&x, int=0)const
				{
					return x;
				}
				Type&operator()(Type&x)const
				{
					return x;
				}
				const Type&operator()(const reference_wrapper<const Type>&x, int=0)const
				{
					return x.get();
				}
				Type&operator()(const reference_wrapper<Type>&x)const
				{
					return x.get();
				}
			};
		}
		template<class Type>
		struct identity: mpl::if_c<is_const<Type>::value, detail::const_identity_base<Type>, detail::non_const_identity_base<Type> >::type
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			struct v_iter_tag;
			template<long N>
			struct vector_tag;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Vector, long n_>
		struct v_at;
		template<long n_>
		struct at_impl<aux::vector_tag<n_> >
		{
			template<typename Vector, typename N>
			struct apply: v_at<Vector, N::value>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct front_impl;
		template<typename Sequence>
		struct front;
	}
}
namespace boost
{
	namespace mpl
	{
		template<long n_>
		struct front_impl<aux::vector_tag<n_> >
		{
			template<typename Vector>
			struct apply
			{
				typedef typename Vector::item0 type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct push_front_impl;
		template<typename Sequence, typename T>
		struct push_front;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct pop_front_impl;
		template<typename Sequence>
		struct pop_front;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct push_back_impl;
		template<typename Sequence, typename T>
		struct push_back;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct pop_back_impl;
		template<typename Sequence>
		struct pop_back;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct back_impl;
		template<typename Sequence>
		struct back;
	}
}
namespace boost
{
	namespace mpl
	{
		template<long n_>
		struct back_impl<aux::vector_tag<n_> >
		{
			template<typename Vector>
			struct apply
			{
				typedef typename Vector::back type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct clear_impl;
		template<typename Sequence>
		struct clear;
	}
}
namespace boost
{
	namespace mpl
	{
		struct forward_iterator_tag: int_<0>
		{
			typedef forward_iterator_tag type;
		};
		struct bidirectional_iterator_tag: int_<1>
		{
			typedef bidirectional_iterator_tag type;
		};
		struct random_access_iterator_tag: int_<2>
		{
			typedef random_access_iterator_tag type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			struct integral_rank;
			template<>
			struct integral_rank<bool>: int_<1>
			{
			};
			template<>
			struct integral_rank<signed char>: int_<2>
			{
			};
			template<>
			struct integral_rank<char>: int_<3>
			{
			};
			template<>
			struct integral_rank<unsigned char>: int_<4>
			{
			};
			template<>
			struct integral_rank<wchar_t>: int_<5>
			{
			};
			template<>
			struct integral_rank<short>: int_<6>
			{
			};
			template<>
			struct integral_rank<unsigned short>: int_<7>
			{
			};
			template<>
			struct integral_rank<int>: int_<8>
			{
			};
			template<>
			struct integral_rank<unsigned int>: int_<9>
			{
			};
			template<>
			struct integral_rank<long>: int_<10>
			{
			};
			template<>
			struct integral_rank<unsigned long>: int_<11>
			{
			};
			template<typename T1, typename T2>
			struct largest_int: if_c<(integral_rank<T1>::value>=integral_rank<T2>::value), T1, T2>
			{
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag1, typename Tag2>
		struct plus_impl: if_c<(Tag1::value>Tag2::value), aux::cast2nd_impl<plus_impl<Tag1, Tag1>, Tag1, Tag2>, aux::cast1st_impl<plus_impl<Tag2, Tag2>, Tag1, Tag2> >::type
		{
		};
		template<>
		struct plus_impl<na, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct plus_impl<na, Tag>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct plus_impl<Tag, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename T>
		struct plus_tag
		{
			typedef typename T::tag type;
		};
		template<typename N1=na, typename N2=na, typename N3=na, typename N4=na, typename N5=na>
		struct plus: plus<plus<plus<plus<N1, N2>, N3>, N4>, N5>
		{
		};
		template<typename N1, typename N2, typename N3, typename N4>
		struct plus<N1, N2, N3, N4, na>: plus<plus<plus<N1, N2>, N3>, N4>
		{
		};
		template<typename N1, typename N2, typename N3>
		struct plus<N1, N2, N3, na, na>: plus<plus<N1, N2>, N3>
		{
		};
		template<typename N1, typename N2>
		struct plus<N1, N2, na, na, na>: plus_impl<typename plus_tag<N1>::type, typename plus_tag<N2>::type>::template apply<N1, N2>::type
		{
		};
		template<>
		struct plus<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: plus<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<plus<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef plus<na, na>result_;
			typedef plus<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct plus_impl<integral_c_tag, integral_c_tag>
		{
			template<typename N1, typename N2>
			struct apply: integral_c<typename aux::largest_int<typename N1::value_type, typename N2::value_type>::type, (N1::value+N2::value)>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag1, typename Tag2>
		struct minus_impl: if_c<(Tag1::value>Tag2::value), aux::cast2nd_impl<minus_impl<Tag1, Tag1>, Tag1, Tag2>, aux::cast1st_impl<minus_impl<Tag2, Tag2>, Tag1, Tag2> >::type
		{
		};
		template<>
		struct minus_impl<na, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct minus_impl<na, Tag>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct minus_impl<Tag, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename T>
		struct minus_tag
		{
			typedef typename T::tag type;
		};
		template<typename N1=na, typename N2=na, typename N3=na, typename N4=na, typename N5=na>
		struct minus: minus<minus<minus<minus<N1, N2>, N3>, N4>, N5>
		{
		};
		template<typename N1, typename N2, typename N3, typename N4>
		struct minus<N1, N2, N3, N4, na>: minus<minus<minus<N1, N2>, N3>, N4>
		{
		};
		template<typename N1, typename N2, typename N3>
		struct minus<N1, N2, N3, na, na>: minus<minus<N1, N2>, N3>
		{
		};
		template<typename N1, typename N2>
		struct minus<N1, N2, na, na, na>: minus_impl<typename minus_tag<N1>::type, typename minus_tag<N2>::type>::template apply<N1, N2>::type
		{
		};
		template<>
		struct minus<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: minus<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<minus<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef minus<na, na>result_;
			typedef minus<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct minus_impl<integral_c_tag, integral_c_tag>
		{
			template<typename N1, typename N2>
			struct apply: integral_c<typename aux::largest_int<typename N1::value_type, typename N2::value_type>::type, (N1::value-N2::value)>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Vector, long n_>
		struct v_iter
		{
			typedef aux::v_iter_tag tag;
			typedef random_access_iterator_tag category;
			typedef typename v_at<Vector, n_>::type type;
			typedef Vector vector_;
			typedef mpl::long_<n_>pos;
		};
		template<typename Vector, long n_>
		struct next<v_iter<Vector, n_> >
		{
			typedef v_iter<Vector, (n_+1)>type;
		};
		template<typename Vector, long n_>
		struct prior<v_iter<Vector, n_> >
		{
			typedef v_iter<Vector, (n_-1)>type;
		};
		template<typename Vector, long n_, typename Distance>
		struct advance<v_iter<Vector, n_>, Distance>
		{
			typedef v_iter<Vector, (n_+Distance::value)>type;
		};
		template<typename Vector, long n_, long m_>
		struct distance<v_iter<Vector, n_>, v_iter<Vector, m_> >: mpl::long_<(m_-n_)>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Dummy=na>
		struct vector0;
		template<>
		struct vector0<na>
		{
			typedef aux::vector_tag<0>tag;
			typedef vector0 type;
			typedef void_ item0;
			typedef v_iter<vector0<>, 0>begin;
			typedef v_iter<vector0<>, 0>end;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<long N>
		struct clear_impl<aux::vector_tag<N> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector0<>type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<long N>
		struct O1_size_impl<aux::vector_tag<N> >
		{
			template<typename Vector>
			struct apply: mpl::long_<N>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<long N>
		struct size_impl<aux::vector_tag<N> >: O1_size_impl<aux::vector_tag<N> >
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct empty_impl;
		template<typename Sequence>
		struct empty;
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct empty_impl<aux::vector_tag<0> >
		{
			template<typename Vector>
			struct apply: true_
			{
			};
		};
		template<long N>
		struct empty_impl<aux::vector_tag<N> >
		{
			template<typename Vector>
			struct apply: false_
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename V>
		struct v_at<V, 0>
		{
			typedef typename V::item0 type;
		};
		template<typename T0>
		struct vector1
		{
			typedef aux::vector_tag<1>tag;
			typedef vector1 type;
			typedef T0 item0;
			typedef void_ item1;
			typedef T0 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 1>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<0> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector1<T>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<1> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector0<>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<0> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector1<T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<1> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector0<>type;
			};
		};
		template<typename V>
		struct v_at<V, 1>
		{
			typedef typename V::item1 type;
		};
		template<typename T0, typename T1>
		struct vector2
		{
			typedef aux::vector_tag<2>tag;
			typedef vector2 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef void_ item2;
			typedef T1 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 2>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<1> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector2<T, typename Vector::item0>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<2> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector1<typename Vector::item1>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<1> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector2<typename Vector::item0, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<2> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector1<typename Vector::item0>type;
			};
		};
		template<typename V>
		struct v_at<V, 2>
		{
			typedef typename V::item2 type;
		};
		template<typename T0, typename T1, typename T2>
		struct vector3
		{
			typedef aux::vector_tag<3>tag;
			typedef vector3 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef void_ item3;
			typedef T2 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 3>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<2> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector3<T, typename Vector::item0, typename Vector::item1>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<3> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector2<typename Vector::item1, typename Vector::item2>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<2> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector3<typename Vector::item0, typename Vector::item1, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<3> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector2<typename Vector::item0, typename Vector::item1>type;
			};
		};
		template<typename V>
		struct v_at<V, 3>
		{
			typedef typename V::item3 type;
		};
		template<typename T0, typename T1, typename T2, typename T3>
		struct vector4
		{
			typedef aux::vector_tag<4>tag;
			typedef vector4 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef void_ item4;
			typedef T3 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 4>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<3> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector4<T, typename Vector::item0, typename Vector::item1, typename Vector::item2>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<4> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector3<typename Vector::item1, typename Vector::item2, typename Vector::item3>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<3> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector4<typename Vector::item0, typename Vector::item1, typename Vector::item2, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<4> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector3<typename Vector::item0, typename Vector::item1, typename Vector::item2>type;
			};
		};
		template<typename V>
		struct v_at<V, 4>
		{
			typedef typename V::item4 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4>
		struct vector5
		{
			typedef aux::vector_tag<5>tag;
			typedef vector5 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef void_ item5;
			typedef T4 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 5>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<4> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector5<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<5> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector4<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<4> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector5<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<5> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector4<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3>type;
			};
		};
		template<typename V>
		struct v_at<V, 5>
		{
			typedef typename V::item5 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct vector6
		{
			typedef aux::vector_tag<6>tag;
			typedef vector6 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef void_ item6;
			typedef T5 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 6>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<5> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector6<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<6> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector5<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<5> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector6<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<6> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector5<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4>type;
			};
		};
		template<typename V>
		struct v_at<V, 6>
		{
			typedef typename V::item6 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
		struct vector7
		{
			typedef aux::vector_tag<7>tag;
			typedef vector7 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef void_ item7;
			typedef T6 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 7>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<6> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector7<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<7> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector6<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<6> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector7<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<7> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector6<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5>type;
			};
		};
		template<typename V>
		struct v_at<V, 7>
		{
			typedef typename V::item7 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
		struct vector8
		{
			typedef aux::vector_tag<8>tag;
			typedef vector8 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef void_ item8;
			typedef T7 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 8>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<7> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector8<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<8> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector7<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<7> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector8<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<8> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector7<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6>type;
			};
		};
		template<typename V>
		struct v_at<V, 8>
		{
			typedef typename V::item8 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
		struct vector9
		{
			typedef aux::vector_tag<9>tag;
			typedef vector9 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef void_ item9;
			typedef T8 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 9>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<8> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector9<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<9> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector8<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<8> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector9<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<9> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector8<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7>type;
			};
		};
		template<typename V>
		struct v_at<V, 9>
		{
			typedef typename V::item9 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
		struct vector10
		{
			typedef aux::vector_tag<10>tag;
			typedef vector10 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef void_ item10;
			typedef T9 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 10>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<9> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector10<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<10> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector9<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<9> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector10<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<10> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector9<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8>type;
			};
		};
		template<typename V>
		struct v_at<V, 10>
		{
			typedef typename V::item10 type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
		struct vector11
		{
			typedef aux::vector_tag<11>tag;
			typedef vector11 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef void_ item11;
			typedef T10 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 11>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<10> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector11<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<11> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector10<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<10> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector11<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<11> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector10<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9>type;
			};
		};
		template<typename V>
		struct v_at<V, 11>
		{
			typedef typename V::item11 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
		struct vector12
		{
			typedef aux::vector_tag<12>tag;
			typedef vector12 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef void_ item12;
			typedef T11 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 12>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<11> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector12<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<12> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector11<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<11> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector12<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<12> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector11<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10>type;
			};
		};
		template<typename V>
		struct v_at<V, 12>
		{
			typedef typename V::item12 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
		struct vector13
		{
			typedef aux::vector_tag<13>tag;
			typedef vector13 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef T12 item12;
			typedef void_ item13;
			typedef T12 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 13>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<12> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector13<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<13> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector12<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<12> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector13<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<13> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector12<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11>type;
			};
		};
		template<typename V>
		struct v_at<V, 13>
		{
			typedef typename V::item13 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
		struct vector14
		{
			typedef aux::vector_tag<14>tag;
			typedef vector14 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef T12 item12;
			typedef T13 item13;
			typedef void_ item14;
			typedef T13 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 14>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<13> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector14<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<14> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector13<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<13> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector14<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<14> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector13<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12>type;
			};
		};
		template<typename V>
		struct v_at<V, 14>
		{
			typedef typename V::item14 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
		struct vector15
		{
			typedef aux::vector_tag<15>tag;
			typedef vector15 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef T12 item12;
			typedef T13 item13;
			typedef T14 item14;
			typedef void_ item15;
			typedef T14 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 15>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<14> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector15<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<15> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector14<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<14> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector15<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<15> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector14<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13>type;
			};
		};
		template<typename V>
		struct v_at<V, 15>
		{
			typedef typename V::item15 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
		struct vector16
		{
			typedef aux::vector_tag<16>tag;
			typedef vector16 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef T12 item12;
			typedef T13 item13;
			typedef T14 item14;
			typedef T15 item15;
			typedef void_ item16;
			typedef T15 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 16>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<15> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector16<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<16> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector15<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<15> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector16<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<16> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector15<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14>type;
			};
		};
		template<typename V>
		struct v_at<V, 16>
		{
			typedef typename V::item16 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16>
		struct vector17
		{
			typedef aux::vector_tag<17>tag;
			typedef vector17 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef T12 item12;
			typedef T13 item13;
			typedef T14 item14;
			typedef T15 item15;
			typedef T16 item16;
			typedef void_ item17;
			typedef T16 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 17>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<16> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector17<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<17> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector16<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<16> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector17<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<17> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector16<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15>type;
			};
		};
		template<typename V>
		struct v_at<V, 17>
		{
			typedef typename V::item17 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17>
		struct vector18
		{
			typedef aux::vector_tag<18>tag;
			typedef vector18 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef T12 item12;
			typedef T13 item13;
			typedef T14 item14;
			typedef T15 item15;
			typedef T16 item16;
			typedef T17 item17;
			typedef void_ item18;
			typedef T17 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 18>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<17> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector18<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<18> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector17<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<17> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector18<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<18> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector17<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16>type;
			};
		};
		template<typename V>
		struct v_at<V, 18>
		{
			typedef typename V::item18 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18>
		struct vector19
		{
			typedef aux::vector_tag<19>tag;
			typedef vector19 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef T12 item12;
			typedef T13 item13;
			typedef T14 item14;
			typedef T15 item15;
			typedef T16 item16;
			typedef T17 item17;
			typedef T18 item18;
			typedef void_ item19;
			typedef T18 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 19>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<18> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector19<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<19> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector18<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17, typename Vector::item18>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<18> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector19<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<19> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector18<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17>type;
			};
		};
		template<typename V>
		struct v_at<V, 19>
		{
			typedef typename V::item19 type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19>
		struct vector20
		{
			typedef aux::vector_tag<20>tag;
			typedef vector20 type;
			typedef T0 item0;
			typedef T1 item1;
			typedef T2 item2;
			typedef T3 item3;
			typedef T4 item4;
			typedef T5 item5;
			typedef T6 item6;
			typedef T7 item7;
			typedef T8 item8;
			typedef T9 item9;
			typedef T10 item10;
			typedef T11 item11;
			typedef T12 item12;
			typedef T13 item13;
			typedef T14 item14;
			typedef T15 item15;
			typedef T16 item16;
			typedef T17 item17;
			typedef T18 item18;
			typedef T19 item19;
			typedef void_ item20;
			typedef T19 back;
			typedef v_iter<type, 0>begin;
			typedef v_iter<type, 20>end;
		};
		template<>
		struct push_front_impl<aux::vector_tag<19> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector20<T, typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17, typename Vector::item18>type;
			};
		};
		template<>
		struct pop_front_impl<aux::vector_tag<20> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector19<typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17, typename Vector::item18, typename Vector::item19>type;
			};
		};
		template<>
		struct push_back_impl<aux::vector_tag<19> >
		{
			template<typename Vector, typename T>
			struct apply
			{
				typedef vector20<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17, typename Vector::item18, T>type;
			};
		};
		template<>
		struct pop_back_impl<aux::vector_tag<20> >
		{
			template<typename Vector>
			struct apply
			{
				typedef vector19<typename Vector::item0, typename Vector::item1, typename Vector::item2, typename Vector::item3, typename Vector::item4, typename Vector::item5, typename Vector::item6, typename Vector::item7, typename Vector::item8, typename Vector::item9, typename Vector::item10, typename Vector::item11, typename Vector::item12, typename Vector::item13, typename Vector::item14, typename Vector::item15, typename Vector::item16, typename Vector::item17, typename Vector::item18>type;
			};
		};
		template<typename V>
		struct v_at<V, 20>
		{
			typedef typename V::item20 type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T0=na, typename T1=na, typename T2=na, typename T3=na, typename T4=na, typename T5=na, typename T6=na, typename T7=na, typename T8=na, typename T9=na, typename T10=na, typename T11=na, typename T12=na, typename T13=na, typename T14=na, typename T15=na, typename T16=na, typename T17=na, typename T18=na, typename T19=na>
		struct vector;
		template<>
		struct vector<na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>: vector0<>
		{
			typedef vector0<>::type type;
		};
		template<typename T0>
		struct vector<T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>: vector1<T0>
		{
			typedef typename vector1<T0>::type type;
		};
		template<typename T0, typename T1>
		struct vector<T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>: vector2<T0, T1>
		{
			typedef typename vector2<T0, T1>::type type;
		};
		template<typename T0, typename T1, typename T2>
		struct vector<T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>: vector3<T0, T1, T2>
		{
			typedef typename vector3<T0, T1, T2>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3>
		struct vector<T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>: vector4<T0, T1, T2, T3>
		{
			typedef typename vector4<T0, T1, T2, T3>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4>
		struct vector<T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>: vector5<T0, T1, T2, T3, T4>
		{
			typedef typename vector5<T0, T1, T2, T3, T4>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct vector<T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na, na, na, na>: vector6<T0, T1, T2, T3, T4, T5>
		{
			typedef typename vector6<T0, T1, T2, T3, T4, T5>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
		struct vector<T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na, na, na, na>: vector7<T0, T1, T2, T3, T4, T5, T6>
		{
			typedef typename vector7<T0, T1, T2, T3, T4, T5, T6>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na, na, na, na>: vector8<T0, T1, T2, T3, T4, T5, T6, T7>
		{
			typedef typename vector8<T0, T1, T2, T3, T4, T5, T6, T7>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na, na, na, na>: vector9<T0, T1, T2, T3, T4, T5, T6, T7, T8>
		{
			typedef typename vector9<T0, T1, T2, T3, T4, T5, T6, T7, T8>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na, na, na, na>: vector10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
		{
			typedef typename vector10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na, na, na, na>: vector11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
		{
			typedef typename vector11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na, na, na, na, na>: vector12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
		{
			typedef typename vector12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na, na, na, na, na>: vector13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
		{
			typedef typename vector13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na, na, na, na, na>: vector14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
		{
			typedef typename vector14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na, na, na, na, na>: vector15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
		{
			typedef typename vector15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, na, na, na, na>: vector16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
		{
			typedef typename vector16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, na, na, na>: vector17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
		{
			typedef typename vector17<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, na, na>: vector18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>
		{
			typedef typename vector18<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18>
		struct vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, na>: vector19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>
		{
			typedef typename vector19<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>::type type;
		};
		template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19>
		struct vector: vector20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>
		{
			typedef typename vector20<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>::type type;
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		template<typename T0, typename T1=mpl::na, typename T2=mpl::na, typename T3=mpl::na, typename T4=mpl::na, typename T5=mpl::na, typename T6=mpl::na, typename T7=mpl::na, typename T8=mpl::na, typename T9=mpl::na, typename T10=mpl::na, typename T11=mpl::na, typename T12=mpl::na, typename T13=mpl::na, typename T14=mpl::na, typename T15=mpl::na, typename T16=mpl::na, typename T17=mpl::na, typename T18=mpl::na, typename T19=mpl::na>
		struct indexed_by: mpl::vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<int N, typename First, typename Last, typename State, typename ForwardOp>
			struct fold_impl;
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct fold_impl<0, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef state0 state;
				typedef iter0 iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct fold_impl<1, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef typename apply2<ForwardOp, state0, typename deref<iter0>::type>::type state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef state1 state;
				typedef iter1 iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct fold_impl<2, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef typename apply2<ForwardOp, state0, typename deref<iter0>::type>::type state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, state1, typename deref<iter1>::type>::type state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef state2 state;
				typedef iter2 iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct fold_impl<3, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef typename apply2<ForwardOp, state0, typename deref<iter0>::type>::type state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, state1, typename deref<iter1>::type>::type state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, state2, typename deref<iter2>::type>::type state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef state3 state;
				typedef iter3 iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct fold_impl<4, First, Last, State, ForwardOp>
			{
				typedef First iter0;
				typedef State state0;
				typedef typename apply2<ForwardOp, state0, typename deref<iter0>::type>::type state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, state1, typename deref<iter1>::type>::type state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, state2, typename deref<iter2>::type>::type state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef typename apply2<ForwardOp, state3, typename deref<iter3>::type>::type state4;
				typedef typename mpl::next<iter3>::type iter4;
				typedef state4 state;
				typedef iter4 iterator;
			};
			template<int N, typename First, typename Last, typename State, typename ForwardOp>
			struct fold_impl
			{
				typedef fold_impl<4, First, Last, State, ForwardOp>chunk_;
				typedef fold_impl<((N-4)<0?0: N-4), typename chunk_::iterator, Last, typename chunk_::state, ForwardOp>res_;
				typedef typename res_::state state;
				typedef typename res_::iterator iterator;
			};
			template<typename First, typename Last, typename State, typename ForwardOp>
			struct fold_impl<-1, First, Last, State, ForwardOp>: fold_impl<-1, typename mpl::next<First>::type, Last, typename apply2<ForwardOp, State, typename deref<First>::type>::type, ForwardOp>
			{
			};
			template<typename Last, typename State, typename ForwardOp>
			struct fold_impl<-1, Last, Last, State, ForwardOp>
			{
				typedef State state;
				typedef Last iterator;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename State=na, typename ForwardOp=na>
		struct fold
		{
			typedef typename aux::fold_impl< ::boost::mpl::O1_size<Sequence>::value, typename begin<Sequence>::type, typename end<Sequence>::type, State, ForwardOp>::state type;
		};
		template<>
		struct fold<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: fold<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<fold<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef fold<na, na, na>result_;
			typedef fold<na, na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			struct set_tag;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct has_key_impl;
		template<typename AssociativeSequence, typename Key>
		struct has_key;
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename T>
			static T const&ptr_to_ref(T*);
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct has_key_impl<aux::set_tag>
		{
			template<typename Set, typename T>
			struct apply
			{
				static const bool value=(sizeof(Set::is_masked_(*static_cast<Set*>(0), static_cast<aux::type_wrapper<T>*>(0)))==sizeof(aux::no_tag));
				typedef bool_<value>type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct at_impl<aux::set_tag>
		{
			template<typename Set, typename T>
			struct apply
			{
				typedef typename if_<has_key_impl<aux::set_tag>::apply<Set, T>, T, void_>::type type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Dummy=na>
		struct set0
		{
			typedef set0<>item_;
			typedef item_ type;
			typedef aux::set_tag tag;
			typedef void_ last_masked_;
			typedef void_ item_type_;
			typedef long_<0>size;
			typedef long_<1>order;
			static aux::no_tag order_by_key_(set0<>const&, void const volatile*);
			static aux::yes_tag is_masked_(set0<>const&, void const volatile*);
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct clear_impl<aux::set_tag>
		{
			template<typename Set>
			struct apply
			{
				typedef set0<>type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct size_impl<aux::set_tag>
		{
			template<typename Set>
			struct apply: Set::size
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct empty_impl<aux::set_tag>
		{
			template<typename Set>
			struct apply: not_<typename Set::size>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct insert_impl;
		template<typename Sequence, typename Pos_or_T, typename T>
		struct insert;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T, typename Base>
		struct s_item: Base
		{
			typedef s_item<T, Base>item_;
			typedef void_ last_masked_;
			typedef T item_type_;
			typedef Base base;
			typedef typename next<typename Base::size>::type size;
			typedef typename next<typename Base::order>::type order;
			typedef char(&order_tag_)[order::value];
			static order_tag_ order_by_key_(s_item const&, aux::type_wrapper<T>*);
			using Base::order_by_key_;
			static aux::no_tag is_masked_(s_item const&, aux::type_wrapper<T>*);
			using Base::is_masked_;
		};
		template<typename T, typename Base>
		struct s_mask: Base
		{
			typedef s_mask<T, Base>item_;
			typedef T last_masked_;
			typedef void_ item_type_;
			typedef Base base;
			typedef typename prior<typename Base::size>::type size;
			static aux::yes_tag is_masked_(s_mask const&, aux::type_wrapper<T>*);
			using Base::is_masked_;
		};
		template<typename T, typename Base>
		struct s_unmask: Base
		{
			typedef s_unmask<T, Base>item_;
			typedef void_ last_masked_;
			typedef T item_type_;
			typedef Base base;
			typedef typename next<typename Base::size>::type size;
			static aux::no_tag is_masked_(s_unmask const&, aux::type_wrapper<T>*);
			using Base::is_masked_;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na>
		struct base
		{
			typedef typename T::base type;
		};
		template<>
		struct base<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: base<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<base<na>, Tag>
		{
			typedef false_ is_le;
			typedef base<na>result_;
			typedef base<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename Set, typename T>
			struct set_insert_impl: eval_if<has_key_impl<aux::set_tag>::apply<Set, T>, identity<Set>, eval_if<is_same<T, typename Set::last_masked_>, base<Set>, identity<s_item<T, typename Set::item_> > > >
			{
			};
		}
		template<>
		struct insert_impl<aux::set_tag>
		{
			template<typename Set, typename PosOrKey, typename KeyOrNA>
			struct apply: aux::set_insert_impl<Set, typename if_na<KeyOrNA, PosOrKey>::type>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct erase_impl;
		template<typename Sequence, typename First, typename Last>
		struct erase;
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct erase_key_impl;
		template<typename Sequence, typename Key>
		struct erase_key;
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct erase_key_impl<aux::set_tag>
		{
			template<typename Set, typename T>
			struct apply: eval_if<has_key_impl<aux::set_tag>::apply<Set, T>, eval_if<is_same<T, typename Set::item_type_>, base<Set>, identity<s_mask<T, typename Set::item_> > >, identity<Set> >
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct erase_impl<aux::set_tag>
		{
			template<typename Set, typename Pos, typename unused_>
			struct apply: erase_key_impl<aux::set_tag>::apply<Set, typename Pos::type>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct key_type_impl;
		template<typename AssociativeSequence, typename T>
		struct key_type;
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct key_type_impl<aux::set_tag>
		{
			template<typename Set, typename T>
			struct apply
			{
				typedef T type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct value_type_impl;
		template<typename AssociativeSequence, typename T>
		struct value_type;
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct value_type_impl<aux::set_tag>
		{
			template<typename Set, typename T>
			struct apply
			{
				typedef T type;
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct has_key_impl
		{
			template<typename AssociativeSequence, typename Key>
			struct apply;
		};
		template<>
		struct has_key_impl<non_sequence_tag>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename AssociativeSequence=na, typename Key=na>
		struct has_key: has_key_impl<typename sequence_tag<AssociativeSequence>::type>::template apply<AssociativeSequence, Key>
		{
		};
		template<>
		struct has_key<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: has_key<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<has_key<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef has_key<na, na>result_;
			typedef has_key<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Set, typename Tail>
		struct s_iter;
		template<typename Set, typename Tail>
		struct s_iter_get: eval_if<has_key<Set, typename Tail::item_type_>, identity<s_iter<Set, Tail> >, next<s_iter<Set, Tail> > >
		{
		};
		template<typename Set, typename Tail>
		struct s_iter_impl
		{
			typedef Tail tail_;
			typedef forward_iterator_tag category;
			typedef typename Tail::item_type_ type;
		};
		template<typename Set, typename Tail>
		struct next<s_iter<Set, Tail> >: s_iter_get<Set, typename Tail::base>
		{
		};
		template<typename Set>
		struct next<s_iter<Set, set0<> > >
		{
			typedef s_iter<Set, set0<> >type;
		};
		template<typename Set, typename Tail>
		struct s_iter: s_iter_impl<Set, Tail>
		{
		};
		template<typename Set>
		struct s_iter<Set, set0<> >
		{
			typedef forward_iterator_tag category;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct begin_impl<aux::set_tag>
		{
			template<typename Set>
			struct apply: s_iter_get<Set, typename Set::item_>
			{
			};
		};
		template<>
		struct end_impl<aux::set_tag>
		{
			template<typename Set>
			struct apply
			{
				typedef s_iter<Set, set0<> >type;
			};
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			struct duplicate_tag_mark
			{
			};
			struct duplicate_tag_marker
			{
				template<typename MplSet, typename Tag>
				struct apply
				{
					typedef mpl::s_item<typename mpl::if_<mpl::has_key<MplSet, Tag>, duplicate_tag_mark, Tag>::type, MplSet>type;
				};
			};
			template<typename TagList>
			struct no_duplicate_tags
			{
				typedef typename mpl::fold<TagList, mpl::set0<>, duplicate_tag_marker>::type aux;
				static const bool value=!(mpl::has_key<aux, duplicate_tag_mark>::value);
			};
			struct duplicate_tag_list_marker
			{
				template<typename MplSet, typename Index>
				struct apply: mpl::fold<typename Index::tag_list, MplSet, duplicate_tag_marker>
				{
				};
			};
			template<typename IndexList>
			struct no_duplicate_tags_in_index_list
			{
				typedef typename mpl::fold<IndexList, mpl::set0<>, duplicate_tag_list_marker>::type aux;
				static const bool value=!(mpl::has_key<aux, duplicate_tag_mark>::value);
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<long N, typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl;
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl<0, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef fwd_state0 bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter0 iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl<1, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, typename deref<iter0>::type>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef fwd_state1 bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, typename deref<iter0>::type>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter1 iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl<2, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, typename deref<iter0>::type>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, fwd_state1, typename deref<iter1>::type>::type fwd_state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef fwd_state2 bkwd_state2;
				typedef typename apply2<BackwardOp, bkwd_state2, typename deref<iter1>::type>::type bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, typename deref<iter0>::type>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter2 iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl<3, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, typename deref<iter0>::type>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, fwd_state1, typename deref<iter1>::type>::type fwd_state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, fwd_state2, typename deref<iter2>::type>::type fwd_state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef fwd_state3 bkwd_state3;
				typedef typename apply2<BackwardOp, bkwd_state3, typename deref<iter2>::type>::type bkwd_state2;
				typedef typename apply2<BackwardOp, bkwd_state2, typename deref<iter1>::type>::type bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, typename deref<iter0>::type>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter3 iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl<4, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, typename deref<iter0>::type>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, fwd_state1, typename deref<iter1>::type>::type fwd_state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, fwd_state2, typename deref<iter2>::type>::type fwd_state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef typename apply2<ForwardOp, fwd_state3, typename deref<iter3>::type>::type fwd_state4;
				typedef typename mpl::next<iter3>::type iter4;
				typedef fwd_state4 bkwd_state4;
				typedef typename apply2<BackwardOp, bkwd_state4, typename deref<iter3>::type>::type bkwd_state3;
				typedef typename apply2<BackwardOp, bkwd_state3, typename deref<iter2>::type>::type bkwd_state2;
				typedef typename apply2<BackwardOp, bkwd_state2, typename deref<iter1>::type>::type bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, typename deref<iter0>::type>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter4 iterator;
			};
			template<long N, typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, typename deref<iter0>::type>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, fwd_state1, typename deref<iter1>::type>::type fwd_state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, fwd_state2, typename deref<iter2>::type>::type fwd_state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef typename apply2<ForwardOp, fwd_state3, typename deref<iter3>::type>::type fwd_state4;
				typedef typename mpl::next<iter3>::type iter4;
				typedef reverse_fold_impl<((N-4)<0?0: N-4), iter4, Last, fwd_state4, BackwardOp, ForwardOp>nested_chunk;
				typedef typename nested_chunk::state bkwd_state4;
				typedef typename apply2<BackwardOp, bkwd_state4, typename deref<iter3>::type>::type bkwd_state3;
				typedef typename apply2<BackwardOp, bkwd_state3, typename deref<iter2>::type>::type bkwd_state2;
				typedef typename apply2<BackwardOp, bkwd_state2, typename deref<iter1>::type>::type bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, typename deref<iter0>::type>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef typename nested_chunk::iterator iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl<-1, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef reverse_fold_impl<-1, typename mpl::next<First>::type, Last, typename apply2<ForwardOp, State, typename deref<First>::type>::type, BackwardOp, ForwardOp>nested_step;
				typedef typename apply2<BackwardOp, typename nested_step::state, typename deref<First>::type>::type state;
				typedef typename nested_step::iterator iterator;
			};
			template<typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_fold_impl<-1, Last, Last, State, BackwardOp, ForwardOp>
			{
				typedef State state;
				typedef Last iterator;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename State=na, typename BackwardOp=na, typename ForwardOp=arg<1> >
		struct reverse_fold
		{
			typedef typename aux::reverse_fold_impl< ::boost::mpl::O1_size<Sequence>::value, typename begin<Sequence>::type, typename end<Sequence>::type, State, BackwardOp, ForwardOp>::state type;
		};
		template<>
		struct reverse_fold<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: reverse_fold<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<reverse_fold<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef reverse_fold<na, na, na>result_;
			typedef reverse_fold<na, na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Iterator=na>
		struct iterator_category
		{
			typedef typename Iterator::category type;
		};
		template<>
		struct iterator_category<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: iterator_category<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<iterator_category<na>, Tag>
		{
			typedef false_ is_le;
			typedef iterator_category<na>result_;
			typedef iterator_category<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename N1=na, typename N2=na>
		struct min: if_<less<N1, N2>, N1, N2>
		{
		};
		template<typename N1=na, typename N2=na>
		struct max: if_<less<N1, N2>, N2, N1>
		{
		};
		template<>
		struct min<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: min<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<min<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef min<na, na>result_;
			typedef min<na, na>type;
		};
		template<>
		struct max<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: max<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<max<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef max<na, na>result_;
			typedef max<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			struct pair_iter_tag;
		}
		template<typename Iter1, typename Iter2, typename Category>
		struct pair_iter
		{
			typedef aux::pair_iter_tag tag;
			typedef Category category;
			typedef Iter1 first;
			typedef Iter2 second;
		};
		template<typename Iter1, typename Iter2, typename C>
		struct deref<pair_iter<Iter1, Iter2, C> >
		{
			typedef pair<typename deref<Iter1>::type, typename deref<Iter2>::type>type;
		};
		template<typename Iter1, typename Iter2, typename C>
		struct next<pair_iter<Iter1, Iter2, C> >
		{
			typedef typename mpl::next<Iter1>::type i1_;
			typedef typename mpl::next<Iter2>::type i2_;
			typedef pair_iter<i1_, i2_, C>type;
		};
		template<typename Iter1, typename Iter2, typename C>
		struct prior<pair_iter<Iter1, Iter2, C> >
		{
			typedef typename mpl::prior<Iter1>::type i1_;
			typedef typename mpl::prior<Iter2>::type i2_;
			typedef pair_iter<i1_, i2_, C>type;
		};
		template<>
		struct advance_impl<aux::pair_iter_tag>
		{
			template<typename Iter, typename D>
			struct apply
			{
				typedef typename mpl::advance<typename Iter::first, D>::type i1_;
				typedef typename mpl::advance<typename Iter::second, D>::type i2_;
				typedef pair_iter<i1_, i2_, typename Iter::category>type;
			};
		};
		template<>
		struct distance_impl<aux::pair_iter_tag>
		{
			template<typename Iter1, typename Iter2>
			struct apply
			{
				typedef typename mpl::distance<typename first<Iter1>::type, typename first<Iter2>::type>::type type;
			};
		};
		template<typename Sequence1=na, typename Sequence2=na>
		struct pair_view
		{
			typedef nested_begin_end_tag tag;
			typedef typename begin<Sequence1>::type iter1_;
			typedef typename begin<Sequence2>::type iter2_;
			typedef typename min<typename iterator_category<iter1_>::type, typename iterator_category<iter2_>::type>::type category_;
			typedef pair_iter<iter1_, iter2_, category_>begin;
			typedef pair_iter<typename end<Sequence1>::type, typename end<Sequence2>::type, category_>end;
		};
		template<>
		struct pair_view<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: pair_view<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<pair_view<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef pair_view<na, na>result_;
			typedef pair_view<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename T=na>
		struct is_sequence: not_<is_same<typename begin<T>::type, void_> >
		{
		};
		template<>
		struct is_sequence<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: is_sequence<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<is_sequence<na>, Tag>
		{
			typedef false_ is_le;
			typedef is_sequence<na>result_;
			typedef is_sequence<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		struct has_push_back_arg
		{
		};
		template<typename Tag>
		struct push_back_impl
		{
			template<typename Sequence, typename T>
			struct apply
			{
				struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST;
				typedef struct REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST__COUNTER__: boost::mpl::assert_
				{
					static boost::mpl::failed************(REQUESTED_PUSH_BACK_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************assert_arg())(Sequence)
					{
						return 0;
					}
				}
				mpl_assert_arg__COUNTER__;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<((boost::is_same<T, has_push_back_arg>::value))>(mpl_assert_arg__COUNTER__::assert_arg()));
			};
		};
		template<typename Tag>
		struct has_push_back_impl
		{
			template<typename Seq>
			struct apply: aux::has_type<push_back<Seq, has_push_back_arg> >
			{
			};
		};
		template<>
		struct push_back_impl<non_sequence_tag>
		{
		};
		template<>
		struct has_push_back_impl<non_sequence_tag>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename T=na>
		struct push_back: push_back_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence, T>
		{
		};
		template<typename Sequence=na>
		struct has_push_back: has_push_back_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence>
		{
		};
		template<>
		struct push_back<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: push_back<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<push_back<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef push_back<na, na>result_;
			typedef push_back<na, na>type;
		};
		template<>
		struct has_push_back<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: has_push_back<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<has_push_back<na>, Tag>
		{
			typedef false_ is_le;
			typedef has_push_back<na>result_;
			typedef has_push_back<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence, typename Operation>
		struct inserter
		{
			typedef Sequence state;
			typedef Operation operation;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence>
		struct back_inserter: inserter<Sequence, push_back<> >
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		struct has_push_front_arg
		{
		};
		template<typename Tag>
		struct push_front_impl
		{
			template<typename Sequence, typename T>
			struct apply
			{
				struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST;
				typedef struct REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST__COUNTER__: boost::mpl::assert_
				{
					static boost::mpl::failed************(REQUESTED_PUSH_FRONT_SPECIALIZATION_FOR_SEQUENCE_DOES_NOT_EXIST::************assert_arg())(Sequence)
					{
						return 0;
					}
				}
				mpl_assert_arg__COUNTER__;
				static const std::size_t mpl_assertion_in_line___COUNTER__=sizeof(boost::mpl::assertion_failed<((boost::is_same<T, has_push_front_arg>::value))>(mpl_assert_arg__COUNTER__::assert_arg()));
			};
		};
		template<typename Tag>
		struct has_push_front_impl
		{
			template<typename Seq>
			struct apply: aux::has_type<push_front<Seq, has_push_front_arg> >
			{
			};
		};
		template<>
		struct push_front_impl<non_sequence_tag>
		{
		};
		template<>
		struct has_push_front_impl<non_sequence_tag>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename T=na>
		struct push_front: push_front_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence, T>
		{
		};
		template<typename Sequence=na>
		struct has_push_front: has_push_front_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence>
		{
		};
		template<>
		struct push_front<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: push_front<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<push_front<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef push_front<na, na>result_;
			typedef push_front<na, na>type;
		};
		template<>
		struct has_push_front<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: has_push_front<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<has_push_front<na>, Tag>
		{
			typedef false_ is_le;
			typedef has_push_front<na>result_;
			typedef has_push_front<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence>
		struct front_inserter: inserter<Sequence, push_front<> >
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct clear_impl
		{
			template<typename Sequence>
			struct apply;
		};
		template<>
		struct clear_impl<non_sequence_tag>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na>
		struct clear: clear_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence>
		{
		};
		template<>
		struct clear<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: clear<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<clear<na>, Tag>
		{
			typedef false_ is_le;
			typedef clear<na>result_;
			typedef clear<na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<typename Seq, typename Op, typename In>
			struct transform1_impl: fold<Seq, typename In::state, bind2<typename lambda<typename In::operation>::type, _1, bind1<typename lambda<Op>::type, _2> > >
			{
			};
			template<typename Seq, typename Op, typename In>
			struct reverse_transform1_impl: reverse_fold<Seq, typename In::state, bind2<typename lambda<typename In::operation>::type, _1, bind1<typename lambda<Op>::type, _2> > >
			{
			};
			template<typename Seq1, typename Seq2, typename Op, typename In>
			struct transform2_impl: fold<pair_view<Seq1, Seq2>, typename In::state, bind2<typename lambda<typename In::operation>::type, _1, bind2<typename lambda<Op>::type, bind1<first<>, _2>, bind1<second<>, _2> > > >
			{
			};
			template<typename Seq1, typename Seq2, typename Op, typename In>
			struct reverse_transform2_impl: reverse_fold<pair_view<Seq1, Seq2>, typename In::state, bind2<typename lambda<typename In::operation>::type, _1, bind2<typename lambda<Op>::type, bind1<first<>, _2>, bind1<second<>, _2> > > >
			{
			};
		}
		template<typename P1=na, typename P2=na, typename P3=na>
		struct transform1: aux::transform1_impl<P1, P2, P3>
		{
		};
		template<typename P1, typename P2>
		struct transform1<P1, P2, na>: if_<has_push_back<typename clear<P1>::type>, aux::transform1_impl<P1, P2, back_inserter<typename clear<P1>::type> >, aux::reverse_transform1_impl<P1, P2, front_inserter<typename clear<P1>::type> > >::type
		{
		};
		template<typename P1=na, typename P2=na, typename P3=na>
		struct reverse_transform1: aux::reverse_transform1_impl<P1, P2, P3>
		{
		};
		template<typename P1, typename P2>
		struct reverse_transform1<P1, P2, na>: if_<has_push_back<P1>, aux::reverse_transform1_impl<P1, P2, back_inserter<typename clear<P1>::type> >, aux::transform1_impl<P1, P2, front_inserter<typename clear<P1>::type> > >::type
		{
		};
		template<>
		struct transform1<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: transform1<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<transform1<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef transform1<na, na, na>result_;
			typedef transform1<na, na, na>type;
		};
		template<>
		struct reverse_transform1<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: reverse_transform1<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<reverse_transform1<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef reverse_transform1<na, na, na>result_;
			typedef reverse_transform1<na, na, na>type;
		};
		template<typename P1=na, typename P2=na, typename P3=na, typename P4=na>
		struct transform2: aux::transform2_impl<P1, P2, P3, P4>
		{
		};
		template<typename P1, typename P2, typename P3>
		struct transform2<P1, P2, P3, na>: if_<has_push_back<typename clear<P1>::type>, aux::transform2_impl<P1, P2, P3, back_inserter<typename clear<P1>::type> >, aux::reverse_transform2_impl<P1, P2, P3, front_inserter<typename clear<P1>::type> > >::type
		{
		};
		template<typename P1=na, typename P2=na, typename P3=na, typename P4=na>
		struct reverse_transform2: aux::reverse_transform2_impl<P1, P2, P3, P4>
		{
		};
		template<typename P1, typename P2, typename P3>
		struct reverse_transform2<P1, P2, P3, na>: if_<has_push_back<P1>, aux::reverse_transform2_impl<P1, P2, P3, back_inserter<typename clear<P1>::type> >, aux::transform2_impl<P1, P2, P3, front_inserter<typename clear<P1>::type> > >::type
		{
		};
		template<>
		struct transform2<na, na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4, typename T5=na>
			struct apply: transform2<T1, T2, T3, T4>
			{
			};
		};
		template<typename Tag>
		struct lambda<transform2<na, na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef transform2<na, na, na, na>result_;
			typedef transform2<na, na, na, na>type;
		};
		template<>
		struct reverse_transform2<na, na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4, typename T5=na>
			struct apply: reverse_transform2<T1, T2, T3, T4>
			{
			};
		};
		template<typename Tag>
		struct lambda<reverse_transform2<na, na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef reverse_transform2<na, na, na, na>result_;
			typedef reverse_transform2<na, na, na, na>type;
		};
		template<typename Seq1=na, typename Seq2OrOperation=na, typename OperationOrInserter=na, typename Inserter=na>
		struct transform
		{
			typedef typename eval_if<or_<is_na<OperationOrInserter>, is_lambda_expression<Seq2OrOperation>, not_<is_sequence<Seq2OrOperation> > >, transform1<Seq1, Seq2OrOperation, OperationOrInserter>, transform2<Seq1, Seq2OrOperation, OperationOrInserter, Inserter> >::type type;
		};
		template<>
		struct transform<na, na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4, typename T5=na>
			struct apply: transform<T1, T2, T3, T4>
			{
			};
		};
		template<typename Tag>
		struct lambda<transform<na, na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef transform<na, na, na, na>result_;
			typedef transform<na, na, na, na>type;
		};
		template<typename Seq1=na, typename Seq2OrOperation=na, typename OperationOrInserter=na, typename Inserter=na>
		struct reverse_transform
		{
			typedef typename eval_if<or_<is_na<OperationOrInserter>, is_lambda_expression<Seq2OrOperation>, not_<is_sequence<Seq2OrOperation> > >, reverse_transform1<Seq1, Seq2OrOperation, OperationOrInserter>, reverse_transform2<Seq1, Seq2OrOperation, OperationOrInserter, Inserter> >::type type;
		};
		template<>
		struct reverse_transform<na, na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4, typename T5=na>
			struct apply: reverse_transform<T1, T2, T3, T4>
			{
			};
		};
		template<typename Tag>
		struct lambda<reverse_transform<na, na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef reverse_transform<na, na, na, na>result_;
			typedef reverse_transform<na, na, na, na>type;
		};
	}
}
namespace boost
{
	namespace detail
	{
		template<typename B, typename D>
		struct is_base_and_derived_impl
		{
			typedef typename remove_cv<B>::type ncvB;
			typedef typename remove_cv<D>::type ncvD;
			static const bool value=((__is_base_of(B, D)&&!is_same<B, D>::value)&&!::boost::is_same<ncvB, ncvD>::value);
		};
	}
	template<typename Base, typename Derived>
	struct is_base_and_derived: ::boost::integral_constant<bool, (::boost::detail::is_base_and_derived_impl<Base, Derived>::value)>
	{
	};
	template<typename Base, typename Derived>
	struct is_base_and_derived<Base&, Derived>: ::boost::integral_constant<bool, false>
	{
	};
	template<typename Base, typename Derived>
	struct is_base_and_derived<Base, Derived&>: ::boost::integral_constant<bool, false>
	{
	};
	template<typename Base, typename Derived>
	struct is_base_and_derived<Base&, Derived&>: ::boost::integral_constant<bool, false>
	{
	};
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			struct tag_marker
			{
			};
			template<typename T>
			struct is_tag
			{
				static const bool value=(is_base_and_derived<tag_marker, T>::value);
			};
		}
		template<typename T0=mpl::na, typename T1=mpl::na, typename T2=mpl::na, typename T3=mpl::na, typename T4=mpl::na, typename T5=mpl::na, typename T6=mpl::na, typename T7=mpl::na, typename T8=mpl::na, typename T9=mpl::na, typename T10=mpl::na, typename T11=mpl::na, typename T12=mpl::na, typename T13=mpl::na, typename T14=mpl::na, typename T15=mpl::na, typename T16=mpl::na, typename T17=mpl::na, typename T18=mpl::na, typename T19=mpl::na>
		struct tag: private detail::tag_marker
		{
			typedef typename mpl::transform<mpl::vector<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>, mpl::identity<mpl::_1> >::type type;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(detail::no_duplicate_tags<type>::value)>)>boost_static_assert_typedef___COUNTER__;
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename KeyFromValue>
			struct index_args_default_compare
			{
				typedef std::less<typename KeyFromValue::result_type>type;
			};
			template<typename Arg1, typename Arg2, typename Arg3>
			struct ordered_index_args
			{
				typedef is_tag<Arg1>full_form;
				typedef typename mpl::if_<full_form, Arg1, tag<> >::type tag_list_type;
				typedef typename mpl::if_<full_form, Arg2, Arg1>::type key_from_value_type;
				typedef typename mpl::if_<full_form, Arg3, Arg2>::type supplied_compare_type;
				typedef typename mpl::eval_if<mpl::is_na<supplied_compare_type>, index_args_default_compare<key_from_value_type>, mpl::identity<supplied_compare_type> >::type compare_type;
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(is_tag<tag_list_type>::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(!mpl::is_na<key_from_value_type>::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(!mpl::is_na<compare_type>::value)>)>boost_static_assert_typedef___COUNTER__;
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename KeyFromValue, typename Compare, typename SuperMeta, typename TagList, typename Category>
			class ordered_index;
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator==(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y);
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator<(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y);
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator!=(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y);
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator>(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y);
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator>=(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y);
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator<=(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y);
			template<typename KeyFromValue, typename Compare, typename SuperMeta, typename TagList, typename Category>
			void swap(ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&x, ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&y);
		}
		template<typename Arg1, typename Arg2=mpl::na, typename Arg3=mpl::na>
		struct ordered_unique;
		template<typename Arg1, typename Arg2=mpl::na, typename Arg3=mpl::na>
		struct ordered_non_unique;
	}
}
namespace boost
{
	namespace multi_index
	{
		template<typename Value, typename IndexSpecifierList=indexed_by<ordered_unique<identity<Value> > >, typename Allocator=std::allocator<Value> >
		class multi_index_container;
		template<typename MultiIndexContainer, int N>
		struct nth_index;
		template<typename MultiIndexContainer, typename Tag>
		struct index;
		template<typename MultiIndexContainer, int N>
		struct nth_index_iterator;
		template<typename MultiIndexContainer, int N>
		struct nth_index_const_iterator;
		template<typename MultiIndexContainer, typename Tag>
		struct index_iterator;
		template<typename MultiIndexContainer, typename Tag>
		struct index_const_iterator;
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator==(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y);
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator<(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y);
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator!=(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y);
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator>(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y);
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator>=(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y);
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator<=(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y);
		template<typename Value, typename IndexSpecifierList, typename Allocator>
		void swap(multi_index_container<Value, IndexSpecifierList, Allocator>&x, multi_index_container<Value, IndexSpecifierList, Allocator>&y);
	}
	using multi_index::multi_index_container;
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename T>
			void adl_swap(T&x, T&y)
			{
				using std::swap;
				swap(x, y);
			}
		}
	}
}
namespace boost
{
	namespace detail
	{
		template<typename T, bool small_>
		struct ct_imp2
		{
			typedef const T&param_type;
		};
		template<typename T>
		struct ct_imp2<T, true>
		{
			typedef const T param_type;
		};
		template<typename T, bool isp, bool b1>
		struct ct_imp
		{
			typedef const T&param_type;
		};
		template<typename T, bool isp>
		struct ct_imp<T, isp, true>
		{
			typedef typename ct_imp2<T, sizeof(T)<=sizeof(void*)>::param_type param_type;
		};
		template<typename T, bool b1>
		struct ct_imp<T, true, b1>
		{
			typedef const T param_type;
		};
	}
	template<typename T>
	struct call_traits
	{
	public:
		typedef T value_type;
		typedef T&reference;
		typedef const T&const_reference;
		typedef typename boost::detail::ct_imp<T, ::boost::is_pointer<T>::value, ::boost::is_arithmetic<T>::value>::param_type param_type;
	};
	template<typename T>
	struct call_traits<T&>
	{
		typedef T&value_type;
		typedef T&reference;
		typedef const T&const_reference;
		typedef T&param_type;
	};
	template<typename T, std::size_t N>
	struct call_traits<T[N]>
	{
	private:
		typedef T array_type[N];
	public:
		typedef const T*value_type;
		typedef array_type&reference;
		typedef const array_type&const_reference;
		typedef const T*const param_type;
	};
	template<typename T, std::size_t N>
	struct call_traits<const T[N]>
	{
	private:
		typedef const T array_type[N];
	public:
		typedef const T*value_type;
		typedef array_type&reference;
		typedef const array_type&const_reference;
		typedef const T*const param_type;
	};
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Type, typename Construct>
			struct prevent_eti
			{
				typedef Construct type;
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename T, typename Allocator=std::allocator<T> >
			struct auto_space: private noncopyable
			{
				typedef typename prevent_eti<Allocator, typename boost::detail::allocator::rebind_to<Allocator, T>::type>::type::pointer pointer;
				explicit auto_space(const Allocator&al=Allocator(), std::size_t n=1): al_(al), n_(n), data_(n_?al_.allocate(n_): pointer(0))
				{
				}
				~auto_space()
				{
					if(n_)al_.deallocate(data_, n_);
				}
				Allocator get_allocator()const
				{
					return al_;
				}
				pointer data()const
				{
					return data_;
				}
				void swap(auto_space&x)
				{
					if(al_!=x.al_)adl_swap(al_, x.al_);
					std::swap(n_, x.n_);
					std::swap(data_, x.data_);
				}
			private:
				typename boost::detail::allocator::rebind_to<Allocator, T>::type al_;
				std::size_t n_;
				pointer data_;
			};
			template<typename T, typename Allocator>
			void swap(auto_space<T, Allocator>&x, auto_space<T, Allocator>&y)
			{
				x.swap(y);
			}
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Node>
			struct copy_map_entry
			{
				copy_map_entry(Node*f, Node*s): first(f), second(s)
				{
				}
				Node*first;
				Node*second;
				bool operator<(const copy_map_entry<Node>&x)const
				{
					return std::less<Node*>()(first, x.first);
				}
			};
			template<typename Node, typename Allocator>
			class copy_map: private noncopyable
			{
			public:
				typedef const copy_map_entry<Node>*const_iterator;
				copy_map(const Allocator&al, std::size_t size, Node*header_org, Node*header_cpy): al_(al), size_(size), spc(al_, size_), n(0), header_org_(header_org), header_cpy_(header_cpy), released(false)
				{
				}
				~copy_map()
				{
					if(!released)
					{
						for(std::size_t i=0;
						i<n;
						++i)
						{
							boost::detail::allocator::destroy(&(spc.data()+i)->second->value());
							deallocate((spc.data()+i)->second);
						}
					}
				}
				const_iterator begin()const
				{
					return &*spc.data();
				}
				const_iterator end()const
				{
					return &*(spc.data()+n);
				}
				void clone(Node*node)
				{
					(spc.data()+n)->first=node;
					(spc.data()+n)->second=&*al_.allocate(1);

					{
						if(true)
						{
							boost::detail::allocator::construct(&(spc.data()+n)->second->value(), node->value());
						}
						else if(false)
						{
							deallocate((spc.data()+n)->second);
							;
						}
					}
					++n;
					if(n==size_)std::sort(&*spc.data(), &*spc.data()+size_);
				}
				Node*find(Node*node)const
				{
					if(node==header_org_)return header_cpy_;
					return std::lower_bound(begin(), end(), copy_map_entry<Node>(node, 0))->second;
				}
				void release()
				{
					released=true;
				}
			private:
				typedef typename prevent_eti<Allocator, typename boost::detail::allocator::rebind_to<Allocator, Node>::type>::type allocator_type;
				typedef typename allocator_type::pointer allocator_pointer;
				allocator_type al_;
				std::size_t size_;
				auto_space<copy_map_entry<Node>, Allocator>spc;
				std::size_t n;
				Node*header_org_;
				Node*header_cpy_;
				bool released;
				void deallocate(Node*node)
				{
					al_.deallocate(static_cast<allocator_pointer>(node), 1);
				}
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		namespace aux
		{
			template<long N, typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl;
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl<0, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef fwd_state0 bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter0 iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl<1, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, iter0>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef fwd_state1 bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, iter0>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter1 iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl<2, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, iter0>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, fwd_state1, iter1>::type fwd_state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef fwd_state2 bkwd_state2;
				typedef typename apply2<BackwardOp, bkwd_state2, iter1>::type bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, iter0>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter2 iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl<3, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, iter0>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, fwd_state1, iter1>::type fwd_state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, fwd_state2, iter2>::type fwd_state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef fwd_state3 bkwd_state3;
				typedef typename apply2<BackwardOp, bkwd_state3, iter2>::type bkwd_state2;
				typedef typename apply2<BackwardOp, bkwd_state2, iter1>::type bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, iter0>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter3 iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl<4, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, iter0>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, fwd_state1, iter1>::type fwd_state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, fwd_state2, iter2>::type fwd_state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef typename apply2<ForwardOp, fwd_state3, iter3>::type fwd_state4;
				typedef typename mpl::next<iter3>::type iter4;
				typedef fwd_state4 bkwd_state4;
				typedef typename apply2<BackwardOp, bkwd_state4, iter3>::type bkwd_state3;
				typedef typename apply2<BackwardOp, bkwd_state3, iter2>::type bkwd_state2;
				typedef typename apply2<BackwardOp, bkwd_state2, iter1>::type bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, iter0>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef iter4 iterator;
			};
			template<long N, typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl
			{
				typedef First iter0;
				typedef State fwd_state0;
				typedef typename apply2<ForwardOp, fwd_state0, iter0>::type fwd_state1;
				typedef typename mpl::next<iter0>::type iter1;
				typedef typename apply2<ForwardOp, fwd_state1, iter1>::type fwd_state2;
				typedef typename mpl::next<iter1>::type iter2;
				typedef typename apply2<ForwardOp, fwd_state2, iter2>::type fwd_state3;
				typedef typename mpl::next<iter2>::type iter3;
				typedef typename apply2<ForwardOp, fwd_state3, iter3>::type fwd_state4;
				typedef typename mpl::next<iter3>::type iter4;
				typedef reverse_iter_fold_impl<((N-4)<0?0: N-4), iter4, Last, fwd_state4, BackwardOp, ForwardOp>nested_chunk;
				typedef typename nested_chunk::state bkwd_state4;
				typedef typename apply2<BackwardOp, bkwd_state4, iter3>::type bkwd_state3;
				typedef typename apply2<BackwardOp, bkwd_state3, iter2>::type bkwd_state2;
				typedef typename apply2<BackwardOp, bkwd_state2, iter1>::type bkwd_state1;
				typedef typename apply2<BackwardOp, bkwd_state1, iter0>::type bkwd_state0;
				typedef bkwd_state0 state;
				typedef typename nested_chunk::iterator iterator;
			};
			template<typename First, typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl<-1, First, Last, State, BackwardOp, ForwardOp>
			{
				typedef reverse_iter_fold_impl<-1, typename mpl::next<First>::type, Last, typename apply2<ForwardOp, State, First>::type, BackwardOp, ForwardOp>nested_step;
				typedef typename apply2<BackwardOp, typename nested_step::state, First>::type state;
				typedef typename nested_step::iterator iterator;
			};
			template<typename Last, typename State, typename BackwardOp, typename ForwardOp>
			struct reverse_iter_fold_impl<-1, Last, Last, State, BackwardOp, ForwardOp>
			{
				typedef State state;
				typedef Last iterator;
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na, typename State=na, typename BackwardOp=na, typename ForwardOp=arg<1> >
		struct reverse_iter_fold
		{
			typedef typename aux::reverse_iter_fold_impl< ::boost::mpl::O1_size<Sequence>::value, typename begin<Sequence>::type, typename end<Sequence>::type, State, typename lambda<BackwardOp>::type, typename lambda<ForwardOp>::type>::state type;
		};
		template<>
		struct reverse_iter_fold<na, na, na>
		{
			template<typename T1, typename T2, typename T3, typename T4=na, typename T5=na>
			struct apply: reverse_iter_fold<T1, T2, T3>
			{
			};
		};
		template<typename Tag>
		struct lambda<reverse_iter_fold<na, na, na>, Tag>
		{
			typedef false_ is_le;
			typedef reverse_iter_fold<na, na, na>result_;
			typedef reverse_iter_fold<na, na, na>type;
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename NodeTypePtr, typename Final>
			struct header_holder: private noncopyable
			{
				header_holder(): member(final().allocate_node())
				{
				}
				~header_holder()
				{
					final().deallocate_node(&*member);
				}
				NodeTypePtr member;
			private:
				Final&final()
				{
					return *static_cast<Final*>(this);
				}
			};
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<std::size_t N>
		struct size_t;
	}
}
namespace boost
{
	namespace mpl
	{
		template<std::size_t N>
		struct size_t
		{
			static const std::size_t value=N;
			typedef size_t type;
			typedef std::size_t value_type;
			typedef integral_c_tag tag;
			typedef boost::mpl::size_t<static_cast<std::size_t>((value+1))>next;
			typedef boost::mpl::size_t<static_cast<std::size_t>((value-1))>prior;
			operator std::size_t()const
			{
				return static_cast<std::size_t>(this->value);
			}
		};
		template<std::size_t N>
		std::size_t const boost::mpl::size_t<N>::value;
	}
}
namespace boost
{
	template<typename T>
	struct alignment_of;
	namespace detail
	{
		template<typename T>
		struct alignment_of_hack
		{
			char c;
			T t;
			alignment_of_hack();
		};
		template<unsigned A, unsigned S>
		struct alignment_logic
		{
			static const std::size_t value=A<S?A: S;
		};
		template<typename T>
		struct alignment_of_impl
		{
			static const std::size_t value=(::boost::detail::alignment_logic<sizeof(::boost::detail::alignment_of_hack<T>)-sizeof(T), 4>::value);
		};
	}
	template<typename T>
	struct alignment_of: ::boost::integral_constant<std::size_t, ::boost::detail::alignment_of_impl<T>::value>
	{
	};
	template<typename T>
	struct alignment_of<T&>: alignment_of<T*>
	{
	};
	template<>
	struct alignment_of<void>: ::boost::integral_constant<std::size_t, 0>
	{
	};
	template<>
	struct alignment_of<void const>: ::boost::integral_constant<std::size_t, 0>
	{
	};
	template<>
	struct alignment_of<void volatile>: ::boost::integral_constant<std::size_t, 0>
	{
	};
	template<>
	struct alignment_of<void const volatile>: ::boost::integral_constant<std::size_t, 0>
	{
	};
}
namespace boost
{
	namespace detail
	{
		class alignment_dummy;
		typedef void(*function_ptr)();
		typedef int(alignment_dummy::*member_ptr);
		typedef int(alignment_dummy::*member_function_ptr)();
		template<bool found, std::size_t target, class TestType>
		struct lower_alignment_helper
		{
			typedef char type;
			enum
			{
				value=true
			};
		};
		template<std::size_t target, class TestType>
		struct lower_alignment_helper<false, target, TestType>
		{
			enum
			{
				value=(alignment_of<TestType>::value==target)
			};
			typedef typename mpl::if_c<value, TestType, char>::type type;
		};
		template<typename T>
		struct has_one_T
		{
			T data;
		};
		template<std::size_t target>
		union lower_alignment
		{
			enum
			{
				found0=false
			};
			typename lower_alignment_helper<found0, target, char>::type t0;
			enum
			{
				found1=lower_alignment_helper<found0, target, char>::value
			};
			typename lower_alignment_helper<found1, target, short>::type t1;
			enum
			{
				found2=lower_alignment_helper<found1, target, short>::value
			};
			typename lower_alignment_helper<found2, target, int>::type t2;
			enum
			{
				found3=lower_alignment_helper<found2, target, int>::value
			};
			typename lower_alignment_helper<found3, target, long>::type t3;
			enum
			{
				found4=lower_alignment_helper<found3, target, long>::value
			};
			typename lower_alignment_helper<found4, target, float>::type t4;
			enum
			{
				found5=lower_alignment_helper<found4, target, float>::value
			};
			typename lower_alignment_helper<found5, target, double>::type t5;
			enum
			{
				found6=lower_alignment_helper<found5, target, double>::value
			};
			typename lower_alignment_helper<found6, target, long double>::type t6;
			enum
			{
				found7=lower_alignment_helper<found6, target, long double>::value
			};
			typename lower_alignment_helper<found7, target, void*>::type t7;
			enum
			{
				found8=lower_alignment_helper<found7, target, void*>::value
			};
			typename lower_alignment_helper<found8, target, function_ptr>::type t8;
			enum
			{
				found9=lower_alignment_helper<found8, target, function_ptr>::value
			};
			typename lower_alignment_helper<found9, target, member_ptr>::type t9;
			enum
			{
				found10=lower_alignment_helper<found9, target, member_ptr>::value
			};
			typename lower_alignment_helper<found10, target, member_function_ptr>::type t10;
			enum
			{
				found11=lower_alignment_helper<found10, target, member_function_ptr>::value
			};
			typename lower_alignment_helper<found11, target, boost::detail::has_one_T<char> >::type t11;
			enum
			{
				found12=lower_alignment_helper<found11, target, boost::detail::has_one_T<char> >::value
			};
			typename lower_alignment_helper<found12, target, boost::detail::has_one_T<short> >::type t12;
			enum
			{
				found13=lower_alignment_helper<found12, target, boost::detail::has_one_T<short> >::value
			};
			typename lower_alignment_helper<found13, target, boost::detail::has_one_T<int> >::type t13;
			enum
			{
				found14=lower_alignment_helper<found13, target, boost::detail::has_one_T<int> >::value
			};
			typename lower_alignment_helper<found14, target, boost::detail::has_one_T<long> >::type t14;
			enum
			{
				found15=lower_alignment_helper<found14, target, boost::detail::has_one_T<long> >::value
			};
			typename lower_alignment_helper<found15, target, boost::detail::has_one_T<float> >::type t15;
			enum
			{
				found16=lower_alignment_helper<found15, target, boost::detail::has_one_T<float> >::value
			};
			typename lower_alignment_helper<found16, target, boost::detail::has_one_T<double> >::type t16;
			enum
			{
				found17=lower_alignment_helper<found16, target, boost::detail::has_one_T<double> >::value
			};
			typename lower_alignment_helper<found17, target, boost::detail::has_one_T<long double> >::type t17;
			enum
			{
				found18=lower_alignment_helper<found17, target, boost::detail::has_one_T<long double> >::value
			};
			typename lower_alignment_helper<found18, target, boost::detail::has_one_T<void*> >::type t18;
			enum
			{
				found19=lower_alignment_helper<found18, target, boost::detail::has_one_T<void*> >::value
			};
			typename lower_alignment_helper<found19, target, boost::detail::has_one_T<function_ptr> >::type t19;
			enum
			{
				found20=lower_alignment_helper<found19, target, boost::detail::has_one_T<function_ptr> >::value
			};
			typename lower_alignment_helper<found20, target, boost::detail::has_one_T<member_ptr> >::type t20;
			enum
			{
				found21=lower_alignment_helper<found20, target, boost::detail::has_one_T<member_ptr> >::value
			};
			typename lower_alignment_helper<found21, target, boost::detail::has_one_T<member_function_ptr> >::type t21;
			enum
			{
				found22=lower_alignment_helper<found21, target, boost::detail::has_one_T<member_function_ptr> >::value
			};
		};
		union max_align
		{
			char t0;
			short t1;
			int t2;
			long t3;
			float t4;
			double t5;
			long double t6;
			void*t7;
			function_ptr t8;
			member_ptr t9;
			member_function_ptr t10;
			boost::detail::has_one_T<char>t11;
			boost::detail::has_one_T<short>t12;
			boost::detail::has_one_T<int>t13;
			boost::detail::has_one_T<long>t14;
			boost::detail::has_one_T<float>t15;
			boost::detail::has_one_T<double>t16;
			boost::detail::has_one_T<long double>t17;
			boost::detail::has_one_T<void*>t18;
			boost::detail::has_one_T<function_ptr>t19;
			boost::detail::has_one_T<member_ptr>t20;
			boost::detail::has_one_T<member_function_ptr>t21;
		};
		template<std::size_t TAlign, std::size_t Align>
		struct is_aligned
		{
			static const bool value=(TAlign>=Align)&(TAlign%Align==0);
		};
	}
	template<std::size_t Align>
	struct is_pod< ::boost::detail::lower_alignment<Align> >
	{
		static const std::size_t value=true;
	};
	namespace detail
	{
		template<std::size_t Align>
		class type_with_alignment_imp
		{
			typedef ::boost::detail::lower_alignment<Align>t1;
			typedef typename mpl::if_c< ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value, Align>::value, t1, ::boost::detail::max_align>::type align_t;
			static const std::size_t found=alignment_of<align_t>::value;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(found>=Align)>)>boost_static_assert_typedef___COUNTER__;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(found%Align==0)>)>boost_static_assert_typedef___COUNTER__;
		public:
			typedef align_t type;
		};
	}
	template<std::size_t Align>
	class type_with_alignment: public::boost::detail::type_with_alignment_imp<Align>
	{
	};
	namespace align
	{
		struct a8
		{
			char m[8];
			typedef a8 type;
		};
		struct a16
		{
			char m[16];
			typedef a16 type;
		};
		struct a32
		{
			char m[32];
			typedef a32 type;
		};
		struct a64
		{
			char m[64];
			typedef a64 type;
		};
		struct a128
		{
			char m[128];
			typedef a128 type;
		};
	}
	template<>
	class type_with_alignment<8>
	{
		typedef mpl::if_c< ::boost::alignment_of<detail::max_align>::value<8, align::a8, detail::type_with_alignment_imp<8> >::type t1;
	public:
		typedef t1::type type;
	};
	template<>
	class type_with_alignment<16>
	{
		typedef mpl::if_c< ::boost::alignment_of<detail::max_align>::value<16, align::a16, detail::type_with_alignment_imp<16> >::type t1;
	public:
		typedef t1::type type;
	};
	template<>
	class type_with_alignment<32>
	{
		typedef mpl::if_c< ::boost::alignment_of<detail::max_align>::value<32, align::a32, detail::type_with_alignment_imp<32> >::type t1;
	public:
		typedef t1::type type;
	};
	template<>
	class type_with_alignment<64>
	{
		typedef mpl::if_c< ::boost::alignment_of<detail::max_align>::value<64, align::a64, detail::type_with_alignment_imp<64> >::type t1;
	public:
		typedef t1::type type;
	};
	template<>
	class type_with_alignment<128>
	{
		typedef mpl::if_c< ::boost::alignment_of<detail::max_align>::value<128, align::a128, detail::type_with_alignment_imp<128> >::type t1;
	public:
		typedef t1::type type;
	};
	namespace detail
	{
		template<>
		struct is_pod_impl< ::boost::align::a8>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl< ::boost::align::a16>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl< ::boost::align::a32>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl< ::boost::align::a64>
		{
			static const bool value=(true);
		};
		template<>
		struct is_pod_impl< ::boost::align::a128>
		{
			static const bool value=(true);
		};
	}
}
namespace boost
{
	namespace detail
	{
		namespace aligned_storage
		{
			static const std::size_t alignment_of_max_align=::boost::alignment_of<max_align>::value;
			template<std::size_t size_, std::size_t alignment_>
			struct aligned_storage_imp
			{
				union data_t
				{
					char buf[size_];
					typename mpl::eval_if_c<alignment_==std::size_t(-1), mpl::identity<detail::max_align>, type_with_alignment<alignment_> >::type align_;
				}
				data_;
				void*address()const
				{
					return const_cast<aligned_storage_imp*>(this);
				}
			};
			template<std::size_t alignment_>
			struct aligned_storage_imp<0u, alignment_>
			{
				void*address()const
				{
					return 0;
				}
			};
		}
	}
	template<std::size_t size_, std::size_t alignment_=std::size_t(-1)>
	class aligned_storage: private detail::aligned_storage::aligned_storage_imp<size_, alignment_>
	{
	public:
		typedef detail::aligned_storage::aligned_storage_imp<size_, alignment_>type;
		static const std::size_t size=size_;
		static const std::size_t alignment=(alignment_==std::size_t(-1)?::boost::detail::aligned_storage::alignment_of_max_align: alignment_);
	public:
		aligned_storage(const aligned_storage&);
		aligned_storage&operator=(const aligned_storage&);
	public:
		aligned_storage()
		{
		}
		~aligned_storage()
		{
		}
	public:
		void*address()
		{
			return static_cast<type*>(this)->address();
		}
		const void*address()const
		{
			return static_cast<const type*>(this)->address();
		}
	};
	template<std::size_t size_, std::size_t alignment_>
	struct is_pod<boost::detail::aligned_storage::aligned_storage_imp<size_, alignment_> >: ::boost::integral_constant<bool, true>
	{
	};
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace archive
	{
		class archive_exception: public virtual std::exception
		{
		public:
			typedef enum
			{
				no_exception, other_exception, unregistered_class, invalid_signature, unsupported_version, pointer_conflict, incompatible_native_format, array_size_too_short, stream_error, invalid_class_name, unregistered_cast, unsupported_class_version, multiple_code_instantiation
			}
			exception_code;
			protected: std::string m_msg;
		public:
			exception_code code;
			archive_exception(exception_code c, const char*e1=0, const char*e2=0);
			~archive_exception()throw();
			virtual const char*what()const throw();
			protected: archive_exception();
		};
	}
}
namespace boost
{
	namespace serialization
	{
		template<class T>
		struct pfto_wrapper
		{
			const T&t;
			operator const T&()
			{
				return t;
			}
			pfto_wrapper(const T&rhs): t(rhs)
			{
			}
		};
		template<class T>
		pfto_wrapper<T>make_pfto_wrapper(const T&t, int)
		{
			return pfto_wrapper<T>(t);
		}
		template<class T>
		pfto_wrapper<T>make_pfto_wrapper(const pfto_wrapper<T>&t, int)
		{
			return t;
		}
	}
}
namespace boost
{
	namespace archive
	{
		namespace detail
		{
			template<class Archive, class T>
			class iserializer;
			template<class Archive, class T>
			class oserializer;
		}
	}
	namespace serialization
	{
		template<class Archive, class T>
		inline void serialize_adl(Archive&, T&, const unsigned int);
		namespace detail
		{
			template<class Archive, class T>
			struct member_saver;
			template<class Archive, class T>
			struct member_loader;
		}
		class access
		{
		public:
		public:
			template<class Archive, class T>
			static void member_save(Archive&ar, T&t, const unsigned int file_version)
			{
				t.save(ar, file_version);
			}
			template<class Archive, class T>
			static void member_load(Archive&ar, T&t, const unsigned int file_version)
			{
				t.load(ar, file_version);
			}
			template<class Archive, class T>
			static void serialize(Archive&ar, T&t, const unsigned int file_version)
			{
				t.serialize(ar, file_version);
			}
			template<class T>
			static void destroy(const T*t)
			{
				delete const_cast<T*>(t);
			}
			template<class T>
			static void construct(T*t)
			{
				::new(t)T;
			}
			template<class T, class U>
			static T&cast_reference(U&u)
			{
				return static_cast<T&>(u);
			}
			template<class T, class U>
			static T*cast_pointer(U*u)
			{
				return static_cast<T*>(u);
			}
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Value>
			struct pod_value_holder
			{
				typename aligned_storage<sizeof(Value), alignment_of<Value>::value>::type space;
			};
			template<typename Value, typename Allocator>
			struct index_node_base: private pod_value_holder<Value>
			{
				typedef index_node_base base_type;
				typedef Value value_type;
				typedef Allocator allocator_type;
				value_type&value()
				{
					return *static_cast<value_type*>(static_cast<void*>(&this->space));
				}
				const value_type&value()const
				{
					return *static_cast<const value_type*>(static_cast<const void*>(&this->space));
				}
				static index_node_base*from_value(const value_type*p)
				{
					return static_cast<index_node_base*>(reinterpret_cast<pod_value_holder<Value>*>(const_cast<value_type*>(p)));
				}
			private:
				friend class boost::serialization::access;
				template<class Archive>
				void serialize(Archive&, const unsigned int)
				{
				}
			};
			template<typename Node, typename Value>
			Node*node_from_value(const Value*p)
			{
				typedef typename Node::allocator_type allocator_type;
				return static_cast<Node*>(index_node_base<Value, allocator_type>::from_value(p));
			}
		}
	}
	namespace multi_index
	{
		namespace detail
		{
			template<class Archive, typename Value, typename Allocator>
			inline void load_construct_data(Archive&, boost::multi_index::detail::index_node_base<Value, Allocator>*, const unsigned int)
			{
				throw_exception(archive::archive_exception(archive::archive_exception::other_exception));
			}
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag>
		struct empty_impl
		{
			template<typename Sequence>
			struct apply: is_same<typename begin<Sequence>::type, typename end<Sequence>::type>
			{
			};
		};
		template<>
		struct empty_impl<non_sequence_tag>
		{
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Sequence=na>
		struct empty: empty_impl<typename sequence_tag<Sequence>::type>::template apply<Sequence>
		{
		};
		template<>
		struct empty<na>
		{
			template<typename T1, typename T2=na, typename T3=na, typename T4=na, typename T5=na>
			struct apply: empty<T1>
			{
			};
		};
		template<typename Tag>
		struct lambda<empty<na>, Tag>
		{
			typedef false_ is_le;
			typedef empty<na>result_;
			typedef empty<na>type;
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename T>
			struct is_index_list
			{
				static const bool mpl_sequence=mpl::is_sequence<T>::value;
				static const bool non_empty=!mpl::empty<T>::value;
				static const bool value=mpl_sequence&&non_empty;
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			struct index_node_applier
			{
				template<typename IndexSpecifierIterator, typename Super>
				struct apply
				{
					typedef typename mpl::deref<IndexSpecifierIterator>::type index_specifier;
					typedef typename index_specifier::template node_class<Super>::type type;
				};
			};
			template<typename Value, typename IndexSpecifierList, typename Allocator>
			struct multi_index_node_type
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(detail::is_index_list<IndexSpecifierList>::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef typename mpl::reverse_iter_fold<IndexSpecifierList, index_node_base<Value, Allocator>, mpl::bind2<index_node_applier, mpl::_2, mpl::_1> >::type type;
			};
		}
	}
}
namespace boost
{
	template<class T>
	class reference_wrapper
	{
	public:
		typedef T type;
		explicit reference_wrapper(T&t): t_(boost::addressof(t))
		{
		}
		operator T&()const
		{
			return *t_;
		}
		T&get()const
		{
			return *t_;
		}
		T*get_pointer()const
		{
			return t_;
		}
	private:
		T*t_;
	};
	template<class T>
	inline reference_wrapper<T>const ref(T&t)
	{
		return reference_wrapper<T>(t);
	}
	template<class T>
	inline reference_wrapper<T const>const cref(T const&t)
	{
		return reference_wrapper<T const>(t);
	}
	template<typename T>
	class is_reference_wrapper: public mpl::false_
	{
	};
	template<typename T>
	class unwrap_reference
	{
	public:
		typedef T type;
	};
	template<typename T>
	class is_reference_wrapper<reference_wrapper<T> >: public mpl::true_
	{
	};
	template<typename T>
	class unwrap_reference<reference_wrapper<T> >
	{
	public:
		typedef T type;
	};
	template<typename T>
	class is_reference_wrapper<reference_wrapper<T>const>: public mpl::true_
	{
	};
	template<typename T>
	class unwrap_reference<reference_wrapper<T>const>
	{
	public:
		typedef T type;
	};
	template<typename T>
	class is_reference_wrapper<reference_wrapper<T>volatile>: public mpl::true_
	{
	};
	template<typename T>
	class unwrap_reference<reference_wrapper<T>volatile>
	{
	public:
		typedef T type;
	};
	template<typename T>
	class is_reference_wrapper<reference_wrapper<T>const volatile>: public mpl::true_
	{
	};
	template<typename T>
	class unwrap_reference<reference_wrapper<T>const volatile>
	{
	public:
		typedef T type;
	};
	template<class T>
	inline typename unwrap_reference<T>::type&unwrap_ref(T&t)
	{
		return t;
	}
	template<class T>
	inline T*get_pointer(reference_wrapper<T>const&r)
	{
		return r.get_pointer();
	}
}
namespace boost
{
	template<typename T>
	struct add_volatile
	{
		typedef T volatile type;
	};
	template<typename T>
	struct add_volatile<T&>
	{
		typedef T&type;
	};
}
namespace boost
{
	template<typename T>
	struct add_cv
	{
		typedef T const volatile type;
	};
	template<typename T>
	struct add_cv<T&>
	{
		typedef T&type;
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T, bool is_const>
		struct remove_volatile_helper
		{
			typedef T type;
		};
		template<typename T>
		struct remove_volatile_helper<T, true>
		{
			typedef T const type;
		};
		template<typename T>
		struct remove_volatile_impl
		{
			typedef typename remove_volatile_helper<typename cv_traits_imp<T*>::unqualified_type, ::boost::is_const<T>::value>::type type;
		};
	}
	template<typename T>
	struct remove_volatile
	{
		typedef typename boost::detail::remove_volatile_impl<T>::type type;
	};
	template<typename T>
	struct remove_volatile<T&>
	{
		typedef T&type;
	};
	template<typename T, std::size_t N>
	struct remove_volatile<T volatile[N]>
	{
		typedef T type[N];
	};
	template<typename T, std::size_t N>
	struct remove_volatile<T const volatile[N]>
	{
		typedef T const type[N];
	};
}
namespace boost
{
	namespace detail
	{
		template<typename Function>
		struct function_traits_helper;
		template<typename R>
		struct function_traits_helper<R(*)(void)>
		{
			static const unsigned arity=0;
			typedef R result_type;
		};
		template<typename R, typename T1>
		struct function_traits_helper<R(*)(T1)>
		{
			static const unsigned arity=1;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T1 argument_type;
		};
		template<typename R, typename T1, typename T2>
		struct function_traits_helper<R(*)(T1, T2)>
		{
			static const unsigned arity=2;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T1 first_argument_type;
			typedef T2 second_argument_type;
		};
		template<typename R, typename T1, typename T2, typename T3>
		struct function_traits_helper<R(*)(T1, T2, T3)>
		{
			static const unsigned arity=3;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T3 arg3_type;
		};
		template<typename R, typename T1, typename T2, typename T3, typename T4>
		struct function_traits_helper<R(*)(T1, T2, T3, T4)>
		{
			static const unsigned arity=4;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T3 arg3_type;
			typedef T4 arg4_type;
		};
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
		struct function_traits_helper<R(*)(T1, T2, T3, T4, T5)>
		{
			static const unsigned arity=5;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T3 arg3_type;
			typedef T4 arg4_type;
			typedef T5 arg5_type;
		};
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
		struct function_traits_helper<R(*)(T1, T2, T3, T4, T5, T6)>
		{
			static const unsigned arity=6;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T3 arg3_type;
			typedef T4 arg4_type;
			typedef T5 arg5_type;
			typedef T6 arg6_type;
		};
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
		struct function_traits_helper<R(*)(T1, T2, T3, T4, T5, T6, T7)>
		{
			static const unsigned arity=7;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T3 arg3_type;
			typedef T4 arg4_type;
			typedef T5 arg5_type;
			typedef T6 arg6_type;
			typedef T7 arg7_type;
		};
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
		struct function_traits_helper<R(*)(T1, T2, T3, T4, T5, T6, T7, T8)>
		{
			static const unsigned arity=8;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T3 arg3_type;
			typedef T4 arg4_type;
			typedef T5 arg5_type;
			typedef T6 arg6_type;
			typedef T7 arg7_type;
			typedef T8 arg8_type;
		};
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
		struct function_traits_helper<R(*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
		{
			static const unsigned arity=9;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T3 arg3_type;
			typedef T4 arg4_type;
			typedef T5 arg5_type;
			typedef T6 arg6_type;
			typedef T7 arg7_type;
			typedef T8 arg8_type;
			typedef T9 arg9_type;
		};
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
		struct function_traits_helper<R(*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
		{
			static const unsigned arity=10;
			typedef R result_type;
			typedef T1 arg1_type;
			typedef T2 arg2_type;
			typedef T3 arg3_type;
			typedef T4 arg4_type;
			typedef T5 arg5_type;
			typedef T6 arg6_type;
			typedef T7 arg7_type;
			typedef T8 arg8_type;
			typedef T9 arg9_type;
			typedef T10 arg10_type;
		};
	}
	template<typename Function>
	struct function_traits: public detail::function_traits_helper<typename boost::add_pointer<Function>::type>
	{
	};
}
namespace boost
{
	namespace tuples
	{
		struct null_type
		{
		};
		namespace detail
		{
			inline const null_type cnull()
			{
				return null_type();
			}
			template<bool If, class Then, class Else>
			struct IF
			{
				typedef Then RET;
			};
			template<class Then, class Else>
			struct IF<false, Then, Else>
			{
				typedef Else RET;
			};
		}
		template<class HT, class TT>
		struct cons;
		template<class T0=null_type, class T1=null_type, class T2=null_type, class T3=null_type, class T4=null_type, class T5=null_type, class T6=null_type, class T7=null_type, class T8=null_type, class T9=null_type>
		class tuple;
		template<class T>
		struct length;
		namespace detail
		{
			template<class T>
			class generate_error;
			template<int N>
			struct get_class
			{
				template<class RET, class HT, class TT>
				inline static RET get(const cons<HT, TT>&t)
				{
					return get_class<N-1>::template get<RET>(t.tail);
				}
				template<class RET, class HT, class TT>
				inline static RET get(cons<HT, TT>&t)
				{
					return get_class<N-1>::template get<RET>(t.tail);
				}
			};
			template<>
			struct get_class<0>
			{
				template<class RET, class HT, class TT>
				inline static RET get(const cons<HT, TT>&t)
				{
					return t.head;
				}
				template<class RET, class HT, class TT>
				inline static RET get(cons<HT, TT>&t)
				{
					return t.head;
				}
			};
		}
		template<int N, class T>
		struct element
		{
		private:
			typedef typename T::tail_type Next;
		public:
			typedef typename element<N-1, Next>::type type;
		};
		template<class T>
		struct element<0, T>
		{
			typedef typename T::head_type type;
		};
		template<int N, class T>
		struct element<N, const T>
		{
		private:
			typedef typename T::tail_type Next;
			typedef typename element<N-1, Next>::type unqualified_type;
		public:
			typedef typename boost::add_const<unqualified_type>::type type;
		};
		template<class T>
		struct element<0, const T>
		{
			typedef typename boost::add_const<typename T::head_type>::type type;
		};
		template<class T>
		struct access_traits
		{
			typedef const T&const_type;
			typedef T&non_const_type;
			typedef const typename boost::remove_cv<T>::type&parameter_type;
		};
		template<class T>
		struct access_traits<T&>
		{
			typedef T&const_type;
			typedef T&non_const_type;
			typedef T&parameter_type;
		};
		template<int N, class HT, class TT>
		inline typename access_traits<typename element<N, cons<HT, TT> >::type>::non_const_type get(cons<HT, TT>&c)
		{
			return detail::get_class<N>::template get<typename access_traits<typename element<N, cons<HT, TT> >::type>::non_const_type, HT, TT>(c);
		}
		template<int N, class HT, class TT>
		inline typename access_traits<typename element<N, cons<HT, TT> >::type>::const_type get(const cons<HT, TT>&c)
		{
			return detail::get_class<N>::template get<typename access_traits<typename element<N, cons<HT, TT> >::type>::const_type, HT, TT>(c);
		}
		namespace detail
		{
			template<class T>
			class non_storeable_type
			{
				non_storeable_type();
			};
			template<class T>
			struct wrap_non_storeable_type
			{
				typedef typename IF< ::boost::is_function<T>::value, non_storeable_type<T>, T>::RET type;
			};
			template<>
			struct wrap_non_storeable_type<void>
			{
				typedef non_storeable_type<void>type;
			};
		}
		template<class HT, class TT>
		struct cons
		{
			typedef HT head_type;
			typedef TT tail_type;
			typedef typename detail::wrap_non_storeable_type<head_type>::type stored_head_type;
			stored_head_type head;
			tail_type tail;
			typename access_traits<stored_head_type>::non_const_type get_head()
			{
				return head;
			}
			typename access_traits<tail_type>::non_const_type get_tail()
			{
				return tail;
			}
			typename access_traits<stored_head_type>::const_type get_head()const
			{
				return head;
			}
			typename access_traits<tail_type>::const_type get_tail()const
			{
				return tail;
			}
			cons(): head(), tail()
			{
			}
			cons(typename access_traits<stored_head_type>::parameter_type h, const tail_type&t): head(h), tail(t)
			{
			}
			template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
			cons(T1&t1, T2&t2, T3&t3, T4&t4, T5&t5, T6&t6, T7&t7, T8&t8, T9&t9, T10&t10): head(t1), tail(t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
			{
			}
			template<class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
			cons(const null_type&, T2&t2, T3&t3, T4&t4, T5&t5, T6&t6, T7&t7, T8&t8, T9&t9, T10&t10): head(), tail(t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
			{
			}
			template<class HT2, class TT2>
			cons(const cons<HT2, TT2>&u): head(u.head), tail(u.tail)
			{
			}
			template<class HT2, class TT2>
			cons&operator=(const cons<HT2, TT2>&u)
			{
				head=u.head;
				tail=u.tail;
				return *this;
			}
			cons&operator=(const cons&u)
			{
				head=u.head;
				tail=u.tail;
				return *this;
			}
			template<class T1, class T2>
			cons&operator=(const std::pair<T1, T2>&u)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(length<cons>::value==2)>)>boost_static_assert_typedef___COUNTER__;
				head=u.first;
				tail.head=u.second;
				return *this;
			}
			template<int N>
			typename access_traits<typename element<N, cons<HT, TT> >::type>::non_const_type get()
			{
				return boost::tuples::get<N>(*this);
			}
			template<int N>
			typename access_traits<typename element<N, cons<HT, TT> >::type>::const_type get()const
			{
				return boost::tuples::get<N>(*this);
			}
		};
		template<class HT>
		struct cons<HT, null_type>
		{
			typedef HT head_type;
			typedef null_type tail_type;
			typedef cons<HT, null_type>self_type;
			typedef typename detail::wrap_non_storeable_type<head_type>::type stored_head_type;
			stored_head_type head;
			typename access_traits<stored_head_type>::non_const_type get_head()
			{
				return head;
			}
			null_type get_tail()
			{
				return null_type();
			}
			typename access_traits<stored_head_type>::const_type get_head()const
			{
				return head;
			}
			const null_type get_tail()const
			{
				return null_type();
			}
			cons(): head()
			{
			}
			cons(typename access_traits<stored_head_type>::parameter_type h, const null_type& =null_type()): head(h)
			{
			}
			template<class T1>
			cons(T1&t1, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&): head(t1)
			{
			}
			cons(const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&, const null_type&): head()
			{
			}
			template<class HT2>
			cons(const cons<HT2, null_type>&u): head(u.head)
			{
			}
			template<class HT2>
			cons&operator=(const cons<HT2, null_type>&u)
			{
				head=u.head;
				return *this;
			}
			cons&operator=(const cons&u)
			{
				head=u.head;
				return *this;
			}
			template<int N>
			typename access_traits<typename element<N, self_type>::type>::non_const_type get()
			{
				return boost::tuples::get<N>(*this);
			}
			template<int N>
			typename access_traits<typename element<N, self_type>::type>::const_type get()const
			{
				return boost::tuples::get<N>(*this);
			}
		};
		template<class T>
		struct length
		{
			static const int value=1+length<typename T::tail_type>::value;
		};
		template<>
		struct length<tuple<> >
		{
			static const int value=0;
		};
		template<>
		struct length<tuple<>const>
		{
			static const int value=0;
		};
		template<>
		struct length<null_type>
		{
			static const int value=0;
		};
		template<>
		struct length<null_type const>
		{
			static const int value=0;
		};
		namespace detail
		{
			template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
			struct map_tuple_to_cons
			{
				typedef cons<T0, typename map_tuple_to_cons<T1, T2, T3, T4, T5, T6, T7, T8, T9, null_type>::type>type;
			};
			template<>
			struct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>
			{
				typedef null_type type;
			};
		}
		template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		class tuple: public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
		{
		public:
			typedef typename detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;
			typedef typename inherited::head_type head_type;
			typedef typename inherited::tail_type tail_type;
			tuple()
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0): inherited(t0, detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1): inherited(t0, t1, detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1, typename access_traits<T2>::parameter_type t2): inherited(t0, t1, t2, detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1, typename access_traits<T2>::parameter_type t2, typename access_traits<T3>::parameter_type t3): inherited(t0, t1, t2, t3, detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1, typename access_traits<T2>::parameter_type t2, typename access_traits<T3>::parameter_type t3, typename access_traits<T4>::parameter_type t4): inherited(t0, t1, t2, t3, t4, detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1, typename access_traits<T2>::parameter_type t2, typename access_traits<T3>::parameter_type t3, typename access_traits<T4>::parameter_type t4, typename access_traits<T5>::parameter_type t5): inherited(t0, t1, t2, t3, t4, t5, detail::cnull(), detail::cnull(), detail::cnull(), detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1, typename access_traits<T2>::parameter_type t2, typename access_traits<T3>::parameter_type t3, typename access_traits<T4>::parameter_type t4, typename access_traits<T5>::parameter_type t5, typename access_traits<T6>::parameter_type t6): inherited(t0, t1, t2, t3, t4, t5, t6, detail::cnull(), detail::cnull(), detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1, typename access_traits<T2>::parameter_type t2, typename access_traits<T3>::parameter_type t3, typename access_traits<T4>::parameter_type t4, typename access_traits<T5>::parameter_type t5, typename access_traits<T6>::parameter_type t6, typename access_traits<T7>::parameter_type t7): inherited(t0, t1, t2, t3, t4, t5, t6, t7, detail::cnull(), detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1, typename access_traits<T2>::parameter_type t2, typename access_traits<T3>::parameter_type t3, typename access_traits<T4>::parameter_type t4, typename access_traits<T5>::parameter_type t5, typename access_traits<T6>::parameter_type t6, typename access_traits<T7>::parameter_type t7, typename access_traits<T8>::parameter_type t8): inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, detail::cnull())
			{
			}
			tuple(typename access_traits<T0>::parameter_type t0, typename access_traits<T1>::parameter_type t1, typename access_traits<T2>::parameter_type t2, typename access_traits<T3>::parameter_type t3, typename access_traits<T4>::parameter_type t4, typename access_traits<T5>::parameter_type t5, typename access_traits<T6>::parameter_type t6, typename access_traits<T7>::parameter_type t7, typename access_traits<T8>::parameter_type t8, typename access_traits<T9>::parameter_type t9): inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9)
			{
			}
			template<class U1, class U2>
			tuple(const cons<U1, U2>&p): inherited(p)
			{
			}
			template<class U1, class U2>
			tuple&operator=(const cons<U1, U2>&k)
			{
				inherited::operator=(k);
				return *this;
			}
			template<class U1, class U2>
			tuple&operator=(const std::pair<U1, U2>&k)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(length<tuple>::value==2)>)>boost_static_assert_typedef___COUNTER__;
				this->head=k.first;
				this->tail.head=k.second;
				return *this;
			}
		};
		template<>
		class tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>: public null_type
		{
		public:
			typedef null_type inherited;
		};
		namespace detail
		{
			struct swallow_assign
			{
				template<typename T>
				swallow_assign const&operator=(const T&)const
				{
					return *this;
				}
			};
		}
		detail::swallow_assign const ignore=detail::swallow_assign();
		template<class T>
		struct make_tuple_traits
		{
			typedef T type;
		};
		template<class T>
		struct make_tuple_traits<T&>
		{
			typedef typename detail::generate_error<T&>::do_not_use_with_reference_type error;
		};
		template<class T, int n>
		struct make_tuple_traits<T[n]>
		{
			typedef const T(&type)[n];
		};
		template<class T, int n>
		struct make_tuple_traits<const T[n]>
		{
			typedef const T(&type)[n];
		};
		template<class T, int n>
		struct make_tuple_traits<volatile T[n]>
		{
			typedef const volatile T(&type)[n];
		};
		template<class T, int n>
		struct make_tuple_traits<const volatile T[n]>
		{
			typedef const volatile T(&type)[n];
		};
		template<class T>
		struct make_tuple_traits<reference_wrapper<T> >
		{
			typedef T&type;
		};
		template<class T>
		struct make_tuple_traits<const reference_wrapper<T> >
		{
			typedef T&type;
		};
		namespace detail
		{
			template<class T0=null_type, class T1=null_type, class T2=null_type, class T3=null_type, class T4=null_type, class T5=null_type, class T6=null_type, class T7=null_type, class T8=null_type, class T9=null_type>
			struct make_tuple_mapper
			{
				typedef tuple<typename make_tuple_traits<T0>::type, typename make_tuple_traits<T1>::type, typename make_tuple_traits<T2>::type, typename make_tuple_traits<T3>::type, typename make_tuple_traits<T4>::type, typename make_tuple_traits<T5>::type, typename make_tuple_traits<T6>::type, typename make_tuple_traits<T7>::type, typename make_tuple_traits<T8>::type, typename make_tuple_traits<T9>::type>type;
			};
		}
		inline tuple<>make_tuple()
		{
			return tuple<>();
		}
		template<class T0>
		inline typename detail::make_tuple_mapper<T0>::type make_tuple(const T0&t0)
		{
			typedef typename detail::make_tuple_mapper<T0>::type t;
			return t(t0);
		}
		template<class T0, class T1>
		inline typename detail::make_tuple_mapper<T0, T1>::type make_tuple(const T0&t0, const T1&t1)
		{
			typedef typename detail::make_tuple_mapper<T0, T1>::type t;
			return t(t0, t1);
		}
		template<class T0, class T1, class T2>
		inline typename detail::make_tuple_mapper<T0, T1, T2>::type make_tuple(const T0&t0, const T1&t1, const T2&t2)
		{
			typedef typename detail::make_tuple_mapper<T0, T1, T2>::type t;
			return t(t0, t1, t2);
		}
		template<class T0, class T1, class T2, class T3>
		inline typename detail::make_tuple_mapper<T0, T1, T2, T3>::type make_tuple(const T0&t0, const T1&t1, const T2&t2, const T3&t3)
		{
			typedef typename detail::make_tuple_mapper<T0, T1, T2, T3>::type t;
			return t(t0, t1, t2, t3);
		}
		template<class T0, class T1, class T2, class T3, class T4>
		inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type make_tuple(const T0&t0, const T1&t1, const T2&t2, const T3&t3, const T4&t4)
		{
			typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type t;
			return t(t0, t1, t2, t3, t4);
		}
		template<class T0, class T1, class T2, class T3, class T4, class T5>
		inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type make_tuple(const T0&t0, const T1&t1, const T2&t2, const T3&t3, const T4&t4, const T5&t5)
		{
			typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type t;
			return t(t0, t1, t2, t3, t4, t5);
		}
		template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
		inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type make_tuple(const T0&t0, const T1&t1, const T2&t2, const T3&t3, const T4&t4, const T5&t5, const T6&t6)
		{
			typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type t;
			return t(t0, t1, t2, t3, t4, t5, t6);
		}
		template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type make_tuple(const T0&t0, const T1&t1, const T2&t2, const T3&t3, const T4&t4, const T5&t5, const T6&t6, const T7&t7)
		{
			typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type t;
			return t(t0, t1, t2, t3, t4, t5, t6, t7);
		}
		template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7, T8>::type make_tuple(const T0&t0, const T1&t1, const T2&t2, const T3&t3, const T4&t4, const T5&t5, const T6&t6, const T7&t7, const T8&t8)
		{
			typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
			return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
		}
		template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type make_tuple(const T0&t0, const T1&t1, const T2&t2, const T3&t3, const T4&t4, const T5&t5, const T6&t6, const T7&t7, const T8&t8, const T9&t9)
		{
			typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
			return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
		}
		template<class T1>
		inline tuple<T1&>tie(T1&t1)
		{
			return tuple<T1&>(t1);
		}
		template<class T1, class T2>
		inline tuple<T1&, T2&>tie(T1&t1, T2&t2)
		{
			return tuple<T1&, T2&>(t1, t2);
		}
		template<class T1, class T2, class T3>
		inline tuple<T1&, T2&, T3&>tie(T1&t1, T2&t2, T3&t3)
		{
			return tuple<T1&, T2&, T3&>(t1, t2, t3);
		}
		template<class T1, class T2, class T3, class T4>
		inline tuple<T1&, T2&, T3&, T4&>tie(T1&t1, T2&t2, T3&t3, T4&t4)
		{
			return tuple<T1&, T2&, T3&, T4&>(t1, t2, t3, t4);
		}
		template<class T1, class T2, class T3, class T4, class T5>
		inline tuple<T1&, T2&, T3&, T4&, T5&>tie(T1&t1, T2&t2, T3&t3, T4&t4, T5&t5)
		{
			return tuple<T1&, T2&, T3&, T4&, T5&>(t1, t2, t3, t4, t5);
		}
		template<class T1, class T2, class T3, class T4, class T5, class T6>
		inline tuple<T1&, T2&, T3&, T4&, T5&, T6&>tie(T1&t1, T2&t2, T3&t3, T4&t4, T5&t5, T6&t6)
		{
			return tuple<T1&, T2&, T3&, T4&, T5&, T6&>(t1, t2, t3, t4, t5, t6);
		}
		template<class T1, class T2, class T3, class T4, class T5, class T6, class T7>
		inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&>tie(T1&t1, T2&t2, T3&t3, T4&t4, T5&t5, T6&t6, T7&t7)
		{
			return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&>(t1, t2, t3, t4, t5, t6, t7);
		}
		template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8>
		inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&>tie(T1&t1, T2&t2, T3&t3, T4&t4, T5&t5, T6&t6, T7&t7, T8&t8)
		{
			return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&>(t1, t2, t3, t4, t5, t6, t7, t8);
		}
		template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>
		inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&>tie(T1&t1, T2&t2, T3&t3, T4&t4, T5&t5, T6&t6, T7&t7, T8&t8, T9&t9)
		{
			return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&>(t1, t2, t3, t4, t5, t6, t7, t8, t9);
		}
		template<class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10>
		inline tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&, T10&>tie(T1&t1, T2&t2, T3&t3, T4&t4, T5&t5, T6&t6, T7&t7, T8&t8, T9&t9, T10&t10)
		{
			return tuple<T1&, T2&, T3&, T4&, T5&, T6&, T7&, T8&, T9&, T10&>(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10);
		}
	}
}
namespace boost
{
	using tuples::tuple;
	using tuples::make_tuple;
	using tuples::tie;
	using tuples::get;
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_fundamental_impl: ::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_void<T>::value>
		{
		};
	}
	template<typename T>
	struct is_fundamental: ::boost::integral_constant<bool, ::boost::detail::is_fundamental_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace serialization
	{
		enum level_type
		{
			not_serializable=0, primitive_type=1, object_serializable=2, object_class_info=3
		};
	}
}
namespace boost
{
	namespace serialization
	{
		struct basic_traits;
		template<class T>
		struct implementation_level_impl
		{
			template<class U>
			struct traits_class_level
			{
				typedef typename U::level type;
			};
			typedef mpl::integral_c_tag tag;
			typedef typename mpl::eval_if<is_base_and_derived<boost::serialization::basic_traits, T>, traits_class_level<T>, typename mpl::eval_if<is_fundamental<T>, mpl::int_<primitive_type>, typename mpl::eval_if<is_class<T>, mpl::int_<object_class_info>, typename mpl::eval_if<is_array<T>, mpl::int_<object_serializable>, typename mpl::eval_if<is_enum<T>, mpl::int_<primitive_type>, mpl::int_<not_serializable> > > > > >::type type;
			static const int value=type::value;
		};
		template<class T>
		struct implementation_level: public implementation_level_impl<const T>
		{
		};
		template<class T, int L>
		inline bool operator>=(implementation_level<T>t, enum level_type l)
		{
			return t.value>=(int)l;
		}
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag1, typename Tag2>
		struct equal_to_impl: if_c<(Tag1::value>Tag2::value), aux::cast2nd_impl<equal_to_impl<Tag1, Tag1>, Tag1, Tag2>, aux::cast1st_impl<equal_to_impl<Tag2, Tag2>, Tag1, Tag2> >::type
		{
		};
		template<>
		struct equal_to_impl<na, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct equal_to_impl<na, Tag>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct equal_to_impl<Tag, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename T>
		struct equal_to_tag
		{
			typedef typename T::tag type;
		};
		template<typename N1=na, typename N2=na>
		struct equal_to: equal_to_impl<typename equal_to_tag<N1>::type, typename equal_to_tag<N2>::type>::template apply<N1, N2>::type
		{
		};
		template<>
		struct equal_to<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: equal_to<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<equal_to<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef equal_to<na, na>result_;
			typedef equal_to<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct equal_to_impl<integral_c_tag, integral_c_tag>
		{
			template<typename N1, typename N2>
			struct apply: bool_<(N1::value==N2::value)>
			{
			};
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<typename Tag1, typename Tag2>
		struct greater_impl: if_c<(Tag1::value>Tag2::value), aux::cast2nd_impl<greater_impl<Tag1, Tag1>, Tag1, Tag2>, aux::cast1st_impl<greater_impl<Tag2, Tag2>, Tag1, Tag2> >::type
		{
		};
		template<>
		struct greater_impl<na, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct greater_impl<na, Tag>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename Tag>
		struct greater_impl<Tag, na>
		{
			template<typename U1, typename U2>
			struct apply
			{
				typedef apply type;
				static const int value=0;
			};
		};
		template<typename T>
		struct greater_tag
		{
			typedef typename T::tag type;
		};
		template<typename N1=na, typename N2=na>
		struct greater: greater_impl<typename greater_tag<N1>::type, typename greater_tag<N2>::type>::template apply<N1, N2>::type
		{
		};
		template<>
		struct greater<na, na>
		{
			template<typename T1, typename T2, typename T3=na, typename T4=na, typename T5=na>
			struct apply: greater<T1, T2>
			{
			};
		};
		template<typename Tag>
		struct lambda<greater<na, na>, Tag>
		{
			typedef false_ is_le;
			typedef greater<na, na>result_;
			typedef greater<na, na>type;
		};
	}
}
namespace boost
{
	namespace mpl
	{
		template<>
		struct greater_impl<integral_c_tag, integral_c_tag>
		{
			template<typename N1, typename N2>
			struct apply: bool_<(N1::value>N2::value)>
			{
			};
		};
	}
}
namespace boost
{
	namespace serialization
	{
		enum tracking_type
		{
			track_never=0, track_selectively=1, track_always=2
		};
	}
}
namespace boost
{
	namespace serialization
	{
		struct basic_traits
		{
		};
		template<class T>
		struct extended_type_info_impl;
		template<class T, int Level, int Tracking, unsigned int Version=0, class ETII=extended_type_info_impl<T>, class Wrapper=mpl::false_>
		struct traits: public basic_traits
		{
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(Version==0||Level>=object_class_info)>)>boost_static_assert_typedef___COUNTER__;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(Tracking==track_never||Level>=object_serializable)>)>boost_static_assert_typedef___COUNTER__;
			typedef typename mpl::int_<Level>level;
			typedef typename mpl::int_<Tracking>tracking;
			typedef typename mpl::int_<Version>version;
			typedef ETII type_info_implementation;
			typedef Wrapper is_wrapper;
		};
	}
}
namespace boost
{
	namespace serialization
	{
		template<class T>
		struct type_info_implementation
		{
			template<class U>
			struct traits_class_typeinfo_implementation
			{
				typedef typename U::type_info_implementation::type type;
			};
			typedef typename mpl::eval_if<is_base_and_derived<boost::serialization::basic_traits, T>, traits_class_typeinfo_implementation<T>, mpl::identity<typename extended_type_info_impl<T>::type> >::type type;
		};
	}
}
namespace boost
{
	namespace serialization
	{
		struct basic_traits;
		template<class T>
		struct tracking_level_impl
		{
			template<class U>
			struct traits_class_tracking
			{
				typedef typename U::tracking type;
			};
			typedef mpl::integral_c_tag tag;
			typedef typename mpl::eval_if<is_base_and_derived<boost::serialization::basic_traits, T>, traits_class_tracking<T>, typename mpl::eval_if<is_pointer<T>, mpl::int_<track_never>, typename mpl::eval_if<typename mpl::equal_to<implementation_level<T>, mpl::int_<primitive_type> >, mpl::int_<track_never>, mpl::int_<track_selectively> > > >::type type;
			static const int value=type::value;
		};
		template<class T>
		struct tracking_level: public tracking_level_impl<const T>
		{
		};
		template<class T, enum tracking_type L>
		inline bool operator>=(tracking_level<T>t, enum tracking_type l)
		{
			return t.value>=(int)l;
		}
	}
}
namespace boost
{
	namespace archive
	{
		namespace detail
		{
			template<class Archive>
			class interface_oarchive;
			template<class Archive>
			class interface_iarchive;
		}
	}
	namespace serialization
	{
		namespace detail
		{
			template<class Archive, class T>
			struct member_saver
			{
				static void invoke(Archive&ar, const T&t, const unsigned int file_version)
				{
					access::member_save(ar, t, file_version);
				}
			};
			template<class Archive, class T>
			struct member_loader
			{
				static void invoke(Archive&ar, T&t, const unsigned int file_version)
				{
					access::member_load(ar, t, file_version);
				}
			};
		}
		template<class Archive, class T>
		inline void split_member(Archive&ar, T&t, const unsigned int file_version)
		{
			typedef typename mpl::eval_if<typename Archive::is_saving, mpl::identity<detail::member_saver<Archive, T> >, mpl::identity<detail::member_loader<Archive, T> > >::type typex;
			typex::invoke(ar, t, file_version);
		}
	}
}
namespace boost
{
	namespace detail
	{
		template<class T>
		struct is_polymorphic_imp1
		{
			typedef typename remove_cv<T>::type ncvT;
			struct d1: public ncvT
			{
				d1();
				~d1()throw();
				char padding[256];
			private:
				d1(const d1&);
				d1&operator=(const d1&);
			};
			struct d2: public ncvT
			{
				d2();
				virtual~d2()throw();
				char padding[256];
			private:
				d2(const d2&);
				d2&operator=(const d2&);
			};
			static const bool value=(sizeof(d2)==sizeof(d1));
		};
		template<class T>
		struct is_polymorphic_imp2
		{
			static const bool value=false;
		};
		template<bool is_class>
		struct is_polymorphic_selector
		{
			template<class T>
			struct rebind
			{
				typedef is_polymorphic_imp2<T>type;
			};
		};
		template<>
		struct is_polymorphic_selector<true>
		{
			template<class T>
			struct rebind
			{
				typedef is_polymorphic_imp1<T>type;
			};
		};
		template<class T>
		struct is_polymorphic_imp
		{
			typedef is_polymorphic_selector< ::boost::is_class<T>::value>selector;
			typedef typename selector::template rebind<T>binder;
			typedef typename binder::type imp_type;
			static const bool value=imp_type::value;
		};
	}
	template<typename T>
	struct is_polymorphic: ::boost::integral_constant<bool, ::boost::detail::is_polymorphic_imp<T>::value>
	{
	};
}
namespace boost
{
	namespace serialization
	{
		namespace void_cast_detail
		{
			class void_caster;
		}
		template<class Derived, class Base>
		inline const void_cast_detail::void_caster&void_cast_register(const Derived*dnull=0, const Base*bnull=0);
	}
}
namespace boost
{
	namespace serialization
	{
		namespace detail
		{
			template<class B, class D>
			struct base_cast
			{
				typedef typename mpl::if_<is_const<D>, const B, B>::type type;
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(is_const<type>::value==is_const<D>::value)>)>boost_static_assert_typedef___COUNTER__;
			};
			template<class Base, class Derived>
			struct base_register
			{
				struct polymorphic
				{
					static void const*invoke()
					{
						Base const*const b=0;
						Derived const*const d=0;
						return &void_cast_register(d, b);
					}
				};
				struct non_polymorphic
				{
					static void const*invoke()
					{
						return 0;
					}
				};
				static void const*invoke()
				{
					typedef typename mpl::eval_if<is_polymorphic<Base>, mpl::identity<polymorphic>, mpl::identity<non_polymorphic> >::type type;
					return type::invoke();
				}
			};
		}
		template<class Base, class Derived>
		typename detail::base_cast<Base, Derived>::type&base_object(Derived&d)
		{
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((is_base_and_derived<Base, Derived>::value))>)>boost_static_assert_typedef___COUNTER__;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(!is_pointer<Derived>::value)>)>boost_static_assert_typedef___COUNTER__;
			typedef typename detail::base_cast<Base, Derived>::type type;
			detail::base_register<type, Derived>::invoke();
			return access::cast_reference<type, Derived>(d);
		}
	}
}
namespace boost
{
	namespace serialization
	{
		template<class T, int Level=object_serializable, int Tracking=track_never, unsigned int Version=0, class ETII=extended_type_info_impl<T> >
		struct wrapper_traits: public traits<T, Level, Tracking, Version, ETII, mpl::true_>
		{
		};
		template<class T>
		struct is_wrapper_impl: boost::mpl::eval_if<boost::is_base_and_derived<basic_traits, T>, boost::mpl::true_, boost::mpl::false_>::type
		{
		};
		template<class T>
		struct is_wrapper
		{
			typedef typename is_wrapper_impl<const T>::type type;
		};
	}
}
namespace boost
{
	namespace serialization
	{
		template<class T>
		struct nvp: public std::pair<const char*, T*>, public wrapper_traits<const nvp<T> >
		{
			explicit nvp(const char*name_, T&t): std::pair<const char*, T*>(name_, (T*)(&t))
			{
			}
			nvp(const nvp&rhs): std::pair<const char*, T*>(rhs.first, (T*)rhs.second)
			{
			}
			const char*name()const
			{
				return this->first;
			}
			T&value()const
			{
				return *(this->second);
			}
			const T&const_value()const
			{
				return *(this->second);
			}
			template<class Archivex>
			void save(Archivex&ar, const unsigned int)const
			{
				ar.operator<<(const_value());
			}
			template<class Archivex>
			void load(Archivex&ar, const unsigned int)
			{
				ar.operator>>(value());
			}
			template<class Archive>
			void serialize(Archive&ar, const unsigned int file_version)
			{
				boost::serialization::split_member(ar, *this, file_version);
			}
		};
		template<class T>
		inline const nvp<T>make_nvp(const char*name, T&t)
		{
			return nvp<T>(name, t);
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Node, typename FinalNode, typename Allocator>
			class index_loader: private noncopyable
			{
			public:
				index_loader(const Allocator&al, std::size_t size): spc(al, size), size_(size), n(0), sorted(false)
				{
				}
				template<class Archive>
				void add(Node*node, Archive&ar, const unsigned int)
				{
					ar>>serialization::make_nvp("position", *node);
					entries()[n++]=node;
				}
				template<class Archive>
				void add_track(Node*node, Archive&ar, const unsigned int)
				{
					ar>>serialization::make_nvp("position", *node);
				}
				template<typename Rearranger, class Archive>
				void load(Rearranger r, Archive&ar, const unsigned int)const
				{
					FinalNode*prev=unchecked_load_node(ar);
					if(!prev)return ;
					if(!sorted)
					{
						std::sort(entries(), entries()+size_);
						sorted=true;
					}
					check_node(prev);
					for(;
					;
					)
					{
						for(;
						;
						)
						{
							FinalNode*node=load_node(ar);
							if(!node)break;
							if(node==prev)prev=0;
							r(prev, node);
							prev=node;
						}
						prev=load_node(ar);
						if(!prev)break;
					}
				}
			private:
				Node**entries()const
				{
					return &*spc.data();
				}
				template<class Archive>
				FinalNode*unchecked_load_node(Archive&ar)const
				{
					Node*node=0;
					ar>>serialization::make_nvp("pointer", node);
					return static_cast<FinalNode*>(node);
				}
				template<class Archive>
				FinalNode*load_node(Archive&ar)const
				{
					Node*node=0;
					ar>>serialization::make_nvp("pointer", node);
					check_node(node);
					return static_cast<FinalNode*>(node);
				}
				void check_node(Node*node)const
				{
					if(node!=0&&!std::binary_search(entries(), entries()+size_, node))
					{
						throw_exception(archive::archive_exception(archive::archive_exception::other_exception));
					}
				}
				auto_space<Node*, Allocator>spc;
				std::size_t size_;
				std::size_t n;
				mutable bool sorted;
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			namespace index_matcher
			{
				struct entry
				{
					entry(void*node_, std::size_t pos_=0): node(node_), pos(pos_)
					{
					}
					void*node;
					std::size_t pos;
					entry*previous;
					bool ordered;
					struct less_by_node
					{
						bool operator()(const entry&x, const entry&y)const
						{
							return std::less<void*>()(x.node, y.node);
						}
					};
					std::size_t pile_top;
					entry*pile_top_entry;
					struct less_by_pile_top
					{
						bool operator()(const entry&x, const entry&y)const
						{
							return x.pile_top<y.pile_top;
						}
					};
				};
				template<typename Allocator>
				class algorithm_base: private noncopyable
				{
					protected: algorithm_base(const Allocator&al, std::size_t size): spc(al, size), size_(size), n(0), sorted(false)
					{
					}
					void add(void*node)
					{
						entries()[n]=entry(node, n);
						++n;
					}
					void begin_algorithm()const
					{
						if(!sorted)
						{
							std::sort(entries(), entries()+size_, entry::less_by_node());
							sorted=true;
						}
						num_piles=0;
					}
					void add_node_to_algorithm(void*node)const
					{
						entry*ent=std::lower_bound(entries(), entries()+size_, entry(node), entry::less_by_node());
						ent->ordered=false;
						std::size_t n=ent->pos;
						entry dummy(0);
						dummy.pile_top=n;
						entry*pile_ent=std::lower_bound(entries(), entries()+num_piles, dummy, entry::less_by_pile_top());
						pile_ent->pile_top=n;
						pile_ent->pile_top_entry=ent;
						if(pile_ent>&entries()[0])
						{
							ent->previous=(pile_ent-1)->pile_top_entry;
						}
						if(pile_ent==&entries()[num_piles])
						{
							++num_piles;
						}
					}
					void finish_algorithm()const
					{
						if(num_piles>0)
						{
							entry*ent=entries()[num_piles-1].pile_top_entry;
							for(std::size_t n=num_piles;
							n--;
							)
							{
								ent->ordered=true;
								ent=ent->previous;
							}
						}
					}
					bool is_ordered(void*node)const
					{
						return std::lower_bound(entries(), entries()+size_, entry(node), entry::less_by_node())->ordered;
					}
				private:
					entry*entries()const
					{
						return &*spc.data();
					}
					auto_space<entry, Allocator>spc;
					std::size_t size_;
					std::size_t n;
					mutable bool sorted;
					mutable std::size_t num_piles;
				};
				template<typename Node, typename Allocator>
				class algorithm: private algorithm_base<Allocator>
				{
					typedef algorithm_base<Allocator>super;
				public:
					algorithm(const Allocator&al, std::size_t size): super(al, size)
					{
					}
					void add(Node*node)
					{
						super::add(node);
					}
					template<typename IndexIterator>
					void execute(IndexIterator first, IndexIterator last)const
					{
						super::begin_algorithm();
						for(IndexIterator it=first;
						it!=last;
						++it)
						{
							add_node_to_algorithm(get_node(it));
						}
						super::finish_algorithm();
					}
					bool is_ordered(Node*node)const
					{
						return super::is_ordered(node);
					}
				private:
					void add_node_to_algorithm(Node*node)const
					{
						super::add_node_to_algorithm(node);
					}
					template<typename IndexIterator>
					static Node*get_node(IndexIterator it)
					{
						return static_cast<Node*>(it.get_node());
					}
				};
			}
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Node, typename Allocator>
			class index_saver: private noncopyable
			{
			public:
				index_saver(const Allocator&al, std::size_t size): alg(al, size)
				{
				}
				template<class Archive>
				void add(Node*node, Archive&ar, const unsigned int)
				{
					ar<<serialization::make_nvp("position", *node);
					alg.add(node);
				}
				template<class Archive>
				void add_track(Node*node, Archive&ar, const unsigned int)
				{
					ar<<serialization::make_nvp("position", *node);
				}
				template<typename IndexIterator, class Archive>
				void save(IndexIterator first, IndexIterator last, Archive&ar, const unsigned int)const
				{
					alg.execute(first, last);
					std::size_t last_saved=3;
					for(IndexIterator it=first, prev=first;
					it!=last;
					prev=it++, ++last_saved)
					{
						if(!alg.is_ordered(get_node(it)))
						{
							if(last_saved>1)save_node(get_node(prev), ar);
							save_node(get_node(it), ar);
							last_saved=0;
						}
						else if(last_saved==2)save_node(null_node(), ar);
					}
					if(last_saved<=2)save_node(null_node(), ar);
					save_node(null_node(), ar);
				}
			private:
				template<typename IndexIterator>
				static Node*get_node(IndexIterator it)
				{
					return it.get_node();
				}
				static Node*null_node()
				{
					return 0;
				}
				template<typename Archive>
				static void save_node(Node*node, Archive&ar)
				{
					ar<<serialization::make_nvp("pointer", node);
				}
				index_matcher::algorithm<Node, Allocator>alg;
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Value, typename IndexSpecifierList, typename Allocator>
			class index_base
			{
				protected: typedef index_node_base<Value, Allocator>node_type;
				typedef typename multi_index_node_type<Value, IndexSpecifierList, Allocator>::type final_node_type;
				typedef multi_index_container<Value, IndexSpecifierList, Allocator>final_type;
				typedef tuples::null_type ctor_args_list;
				typedef typename boost::detail::allocator::rebind_to<Allocator, typename Allocator::value_type>::type final_allocator_type;
				typedef mpl::vector0<>index_type_list;
				typedef mpl::vector0<>iterator_type_list;
				typedef mpl::vector0<>const_iterator_type_list;
				typedef copy_map<final_node_type, final_allocator_type>copy_map_type;
				typedef index_saver<node_type, final_allocator_type>index_saver_type;
				typedef index_loader<node_type, final_node_type, final_allocator_type>index_loader_type;
			private:
				typedef typename call_traits<Value>::param_type value_param_type;
				protected: explicit index_base(const ctor_args_list&, const Allocator&)
				{
				}
				void copy_(const index_base<Value, IndexSpecifierList, Allocator>&, const copy_map_type&)
				{
				}
				node_type*insert_(value_param_type v, node_type*x)
				{
					boost::detail::allocator::construct(&x->value(), v);
					return x;
				}
				node_type*insert_(value_param_type v, node_type*, node_type*x)
				{
					boost::detail::allocator::construct(&x->value(), v);
					return x;
				}
				void erase_(node_type*x)
				{
					boost::detail::allocator::destroy(&x->value());
				}
				void delete_node_(node_type*x)
				{
					boost::detail::allocator::destroy(&x->value());
				}
				void clear_()
				{
				}
				void swap_(index_base<Value, IndexSpecifierList, Allocator>&)
				{
				}
				bool replace_(value_param_type v, node_type*x)
				{
					x->value()=v;
					return true;
				}
				bool modify_(node_type*)
				{
					return true;
				}
				bool modify_rollback_(node_type*)
				{
					return true;
				}
				template<typename Archive>
				void save_(Archive&, const unsigned int, const index_saver_type&)const
				{
				}
				template<typename Archive>
				void load_(Archive&, const unsigned int, const index_loader_type&)
				{
				}
				final_type&final()
				{
					return *static_cast<final_type*>(this);
				}
				const final_type&final()const
				{
					return *static_cast<const final_type*>(this);
				}
				final_node_type*final_header()const
				{
					return final().header();
				}
				bool final_empty_()const
				{
					return final().empty_();
				}
				std::size_t final_size_()const
				{
					return final().size_();
				}
				std::size_t final_max_size_()const
				{
					return final().max_size_();
				}
				std::pair<final_node_type*, bool>final_insert_(value_param_type x)
				{
					return final().insert_(x);
				}
				std::pair<final_node_type*, bool>final_insert_(value_param_type x, final_node_type*position)
				{
					return final().insert_(x, position);
				}
				void final_erase_(final_node_type*x)
				{
					final().erase_(x);
				}
				void final_delete_node_(final_node_type*x)
				{
					final().delete_node_(x);
				}
				void final_delete_all_nodes_()
				{
					final().delete_all_nodes_();
				}
				void final_clear_()
				{
					final().clear_();
				}
				void final_swap_(final_type&x)
				{
					final().swap_(x);
				}
				bool final_replace_(value_param_type k, final_node_type*x)
				{
					return final().replace_(k, x);
				}
				template<typename Modifier>
				bool final_modify_(Modifier&mod, final_node_type*x)
				{
					return final().modify_(mod, x);
				}
				template<typename Modifier, typename Rollback>
				bool final_modify_(Modifier&mod, Rollback&back, final_node_type*x)
				{
					return final().modify_(mod, back, x);
				}
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			struct index_applier
			{
				template<typename IndexSpecifierMeta, typename SuperMeta>
				struct apply
				{
					typedef typename IndexSpecifierMeta::type index_specifier;
					typedef typename index_specifier::template index_class<SuperMeta>::type type;
				};
			};
			template<int N, typename Value, typename IndexSpecifierList, typename Allocator>
			struct nth_layer
			{
				static const int length=mpl::size<IndexSpecifierList>::value;
				typedef typename mpl::eval_if_c<N==length, mpl::identity<index_base<Value, IndexSpecifierList, Allocator> >, mpl::apply2<index_applier, mpl::at_c<IndexSpecifierList, N>, nth_layer<N+1, Value, IndexSpecifierList, Allocator> > >::type type;
			};
			template<typename Value, typename IndexSpecifierList, typename Allocator>
			struct multi_index_base_type: nth_layer<0, Value, IndexSpecifierList, Allocator>
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(detail::is_index_list<IndexSpecifierList>::value)>)>boost_static_assert_typedef___COUNTER__;
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename MultiIndexContainer, typename Index>
			struct converter
			{
				static const Index&index(const MultiIndexContainer&x)
				{
					return x;
				}
				static Index&index(MultiIndexContainer&x)
				{
					return x;
				}
				static typename Index::const_iterator const_iterator(const MultiIndexContainer&x, typename MultiIndexContainer::node_type*node)
				{
					return x.Index::make_iterator(node);
				}
				static typename Index::iterator iterator(MultiIndexContainer&x, typename MultiIndexContainer::node_type*node)
				{
					return x.Index::make_iterator(node);
				}
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Tag>
			struct has_tag
			{
				template<typename Index>
				struct apply: mpl::contains<typename Index::tag_list, Tag>
				{
				};
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			class scope_guard_impl_base
			{
			public:
				scope_guard_impl_base(): dismissed_(false)
				{
				}
				void dismiss()const
				{
					dismissed_=true;
				}
				void touch()const
				{
				}
				protected: ~scope_guard_impl_base()
				{
				}
				scope_guard_impl_base(const scope_guard_impl_base&other): dismissed_(other.dismissed_)
				{
					other.dismiss();
				}
				template<typename J>
				static void safe_execute(J&j)
				{
					if(!j.dismissed_)j.execute();
				}
				mutable bool dismissed_;
			private:
				scope_guard_impl_base&operator=(const scope_guard_impl_base&);
			};
			typedef const scope_guard_impl_base&scope_guard;
			template<typename F>
			class scope_guard_impl0: public scope_guard_impl_base
			{
			public:
				scope_guard_impl0(F fun): fun_(fun)
				{
				}
				~scope_guard_impl0()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					fun_();
				}
				protected: F fun_;
			};
			template<typename F>
			inline scope_guard_impl0<F>make_guard(F fun)
			{
				return scope_guard_impl0<F>(fun);
			}
			template<typename F, typename P1>
			class scope_guard_impl1: public scope_guard_impl_base
			{
			public:
				scope_guard_impl1(F fun, P1 p1): fun_(fun), p1_(p1)
				{
				}
				~scope_guard_impl1()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					fun_(p1_);
				}
				protected: F fun_;
				const P1 p1_;
			};
			template<typename F, typename P1>
			inline scope_guard_impl1<F, P1>make_guard(F fun, P1 p1)
			{
				return scope_guard_impl1<F, P1>(fun, p1);
			}
			template<typename F, typename P1, typename P2>
			class scope_guard_impl2: public scope_guard_impl_base
			{
			public:
				scope_guard_impl2(F fun, P1 p1, P2 p2): fun_(fun), p1_(p1), p2_(p2)
				{
				}
				~scope_guard_impl2()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					fun_(p1_, p2_);
				}
				protected: F fun_;
				const P1 p1_;
				const P2 p2_;
			};
			template<typename F, typename P1, typename P2>
			inline scope_guard_impl2<F, P1, P2>make_guard(F fun, P1 p1, P2 p2)
			{
				return scope_guard_impl2<F, P1, P2>(fun, p1, p2);
			}
			template<typename F, typename P1, typename P2, typename P3>
			class scope_guard_impl3: public scope_guard_impl_base
			{
			public:
				scope_guard_impl3(F fun, P1 p1, P2 p2, P3 p3): fun_(fun), p1_(p1), p2_(p2), p3_(p3)
				{
				}
				~scope_guard_impl3()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					fun_(p1_, p2_, p3_);
				}
				protected: F fun_;
				const P1 p1_;
				const P2 p2_;
				const P3 p3_;
			};
			template<typename F, typename P1, typename P2, typename P3>
			inline scope_guard_impl3<F, P1, P2, P3>make_guard(F fun, P1 p1, P2 p2, P3 p3)
			{
				return scope_guard_impl3<F, P1, P2, P3>(fun, p1, p2, p3);
			}
			template<typename F, typename P1, typename P2, typename P3, typename P4>
			class scope_guard_impl4: public scope_guard_impl_base
			{
			public:
				scope_guard_impl4(F fun, P1 p1, P2 p2, P3 p3, P4 p4): fun_(fun), p1_(p1), p2_(p2), p3_(p3), p4_(p4)
				{
				}
				~scope_guard_impl4()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					fun_(p1_, p2_, p3_, p4_);
				}
				protected: F fun_;
				const P1 p1_;
				const P2 p2_;
				const P3 p3_;
				const P4 p4_;
			};
			template<typename F, typename P1, typename P2, typename P3, typename P4>
			inline scope_guard_impl4<F, P1, P2, P3, P4>make_guard(F fun, P1 p1, P2 p2, P3 p3, P4 p4)
			{
				return scope_guard_impl4<F, P1, P2, P3, P4>(fun, p1, p2, p3, p4);
			}
			template<class Obj, typename MemFun>
			class obj_scope_guard_impl0: public scope_guard_impl_base
			{
			public:
				obj_scope_guard_impl0(Obj&obj, MemFun mem_fun): obj_(obj), mem_fun_(mem_fun)
				{
				}
				~obj_scope_guard_impl0()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					(obj_.*mem_fun_)();
				}
				protected: Obj&obj_;
				MemFun mem_fun_;
			};
			template<class Obj, typename MemFun>
			inline obj_scope_guard_impl0<Obj, MemFun>make_obj_guard(Obj&obj, MemFun mem_fun)
			{
				return obj_scope_guard_impl0<Obj, MemFun>(obj, mem_fun);
			}
			template<class Obj, typename MemFun, typename P1>
			class obj_scope_guard_impl1: public scope_guard_impl_base
			{
			public:
				obj_scope_guard_impl1(Obj&obj, MemFun mem_fun, P1 p1): obj_(obj), mem_fun_(mem_fun), p1_(p1)
				{
				}
				~obj_scope_guard_impl1()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					(obj_.*mem_fun_)(p1_);
				}
				protected: Obj&obj_;
				MemFun mem_fun_;
				const P1 p1_;
			};
			template<class Obj, typename MemFun, typename P1>
			inline obj_scope_guard_impl1<Obj, MemFun, P1>make_obj_guard(Obj&obj, MemFun mem_fun, P1 p1)
			{
				return obj_scope_guard_impl1<Obj, MemFun, P1>(obj, mem_fun, p1);
			}
			template<class Obj, typename MemFun, typename P1, typename P2>
			class obj_scope_guard_impl2: public scope_guard_impl_base
			{
			public:
				obj_scope_guard_impl2(Obj&obj, MemFun mem_fun, P1 p1, P2 p2): obj_(obj), mem_fun_(mem_fun), p1_(p1), p2_(p2)
				{
				}
				~obj_scope_guard_impl2()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					(obj_.*mem_fun_)(p1_, p2_);
				}
				protected: Obj&obj_;
				MemFun mem_fun_;
				const P1 p1_;
				const P2 p2_;
			};
			template<class Obj, typename MemFun, typename P1, typename P2>
			inline obj_scope_guard_impl2<Obj, MemFun, P1, P2>make_obj_guard(Obj&obj, MemFun mem_fun, P1 p1, P2 p2)
			{
				return obj_scope_guard_impl2<Obj, MemFun, P1, P2>(obj, mem_fun, p1, p2);
			}
			template<class Obj, typename MemFun, typename P1, typename P2, typename P3>
			class obj_scope_guard_impl3: public scope_guard_impl_base
			{
			public:
				obj_scope_guard_impl3(Obj&obj, MemFun mem_fun, P1 p1, P2 p2, P3 p3): obj_(obj), mem_fun_(mem_fun), p1_(p1), p2_(p2), p3_(p3)
				{
				}
				~obj_scope_guard_impl3()
				{
					scope_guard_impl_base::safe_execute(*this);
				}
				void execute()
				{
					(obj_.*mem_fun_)(p1_, p2_, p3_);
				}
				protected: Obj&obj_;
				MemFun mem_fun_;
				const P1 p1_;
				const P2 p2_;
				const P3 p3_;
			};
			template<class Obj, typename MemFun, typename P1, typename P2, typename P3>
			inline obj_scope_guard_impl3<Obj, MemFun, P1, P2, P3>make_obj_guard(Obj&obj, MemFun mem_fun, P1 p1, P2 p2, P3 p3)
			{
				return obj_scope_guard_impl3<Obj, MemFun, P1, P2, P3>(obj, mem_fun, p1, p2, p3);
			}
		}
	}
}
namespace boost
{
	namespace serialization
	{
		void inline throw_exception(std::exception const&e)
		{
			::boost::throw_exception(e);
		}
	}
}
namespace boost
{
	namespace serialization
	{
		struct version_type: boost::totally_ordered1<version_type, boost::totally_ordered2<version_type, unsigned int> >
		{
			unsigned int t;
			explicit version_type(const unsigned int t_): t(t_)
			{
			};
			version_type()
			{
			};
			version_type(const version_type&t_): t(t_.t)
			{
			}
			version_type&operator=(const version_type&rhs)
			{
				t=rhs.t;
				return *this;
			}
			version_type&operator=(const unsigned int&rhs)
			{
				t=rhs;
				return *this;
			}
			operator const unsigned int&()const
			{
				return t;
			}
			operator unsigned int&()
			{
				return t;
			}
			bool operator==(const version_type&rhs)const
			{
				return t==rhs.t;
			}
			bool operator<(const version_type&rhs)const
			{
				return t<rhs.t;
			}
		};
		template<class Archive, class T>
		inline void serialize(Archive&ar, T&t, const unsigned int file_version)
		{
			access::serialize(ar, t, static_cast<unsigned int>(file_version));
		}
		template<class Archive, class T>
		inline void save_construct_data(Archive&, const T*, const unsigned int)
		{
		}
		template<class Archive, class T>
		inline void load_construct_data(Archive&, T*t, const unsigned int)
		{
			access::construct(t);
		}
		template<class Archive, class T>
		inline void serialize_adl(Archive&ar, T&t, const unsigned int file_version)
		{
			const version_type v(file_version);
			serialize(ar, t, v);
		}
		template<class Archive, class T>
		inline void save_construct_data_adl(Archive&ar, const T*t, const unsigned int file_version)
		{
			const version_type v(file_version);
			save_construct_data(ar, t, v);
		}
		template<class Archive, class T>
		inline void load_construct_data_adl(Archive&ar, T*t, const unsigned int file_version)
		{
			const version_type v(file_version);
			load_construct_data(ar, t, v);
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename T>
			struct archive_constructed: private noncopyable
			{
				template<class Archive>
				archive_constructed(Archive&ar, const unsigned int version)
				{
					serialization::load_construct_data_adl(ar, &get(), version);

					{
						if(true)
						{
							ar>>get();
						}
						else if(false)
						{
							(&get())->~T();
							;
						}
					}
				}
				template<class Archive>
				archive_constructed(const char*name, Archive&ar, const unsigned int version)
				{
					serialization::load_construct_data_adl(ar, &get(), version);

					{
						if(true)
						{
							ar>>serialization::make_nvp(name, get());
						}
						else if(false)
						{
							(&get())->~T();
							;
						}
					}
				}
				~archive_constructed()
				{
					(&get())->~T();
				}
				T&get()
				{
					return *static_cast<T*>(static_cast<void*>(&space));
				}
			private:
				typename aligned_storage<sizeof(T), alignment_of<T>::value>::type space;
			};
		}
	}
}
namespace boost
{
	namespace serialization
	{
		struct collection_size_type: boost::totally_ordered1<collection_size_type, boost::totally_ordered2<collection_size_type, std::size_t> >
		{
			std::size_t t;
			explicit collection_size_type(const std::size_t t_): t(t_)
			{
			};
			collection_size_type()
			{
			};
			collection_size_type(const collection_size_type&t_): t(t_.t)
			{
			}
			collection_size_type&operator=(const collection_size_type&rhs)
			{
				t=rhs.t;
				return *this;
			}
			collection_size_type&operator=(const std::size_t&rhs)
			{
				t=rhs;
				return *this;
			}
			operator const std::size_t&()const
			{
				return t;
			}
			operator std::size_t&()
			{
				return t;
			}
			bool operator==(const collection_size_type&rhs)const
			{
				return t==rhs.t;
			}
			bool operator<(const collection_size_type&rhs)const
			{
				return t<rhs.t;
			}
		};
	}
}
namespace boost
{
	namespace serialization
	{
		template<>
		struct implementation_level_impl<const boost::serialization::collection_size_type>
		{
			typedef mpl::integral_c_tag tag;
			typedef mpl::int_<primitive_type>type;
			static const int value=implementation_level_impl::type::value;
		};
	}
}
namespace boost
{
	namespace serialization
	{
		struct basic_traits;
		template<class T>
		struct version
		{
			template<class U>
			struct traits_class_version
			{
				typedef typename U::version type;
			};
			typedef mpl::integral_c_tag tag;
			typedef typename mpl::eval_if<is_base_and_derived<boost::serialization::basic_traits, T>, traits_class_version<T>, mpl::int_<0> >::type type;
			static const int value=version::type::value;
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		template<typename Value, typename IndexSpecifierList, typename Allocator>
		class multi_index_container: private::boost::base_from_member<typename boost::detail::allocator::rebind_to<Allocator, typename detail::multi_index_node_type<Value, IndexSpecifierList, Allocator>::type>::type>, public detail::header_holder<typename detail::prevent_eti<Allocator, typename boost::detail::allocator::rebind_to<Allocator, typename detail::multi_index_node_type<Value, IndexSpecifierList, Allocator>::type>::type>::type::pointer, multi_index_container<Value, IndexSpecifierList, Allocator> >, public detail::multi_index_base_type<Value, IndexSpecifierList, Allocator>::type
		{
		private:
			typedef typename detail::multi_index_base_type<Value, IndexSpecifierList, Allocator>::type super;
			typedef typename boost::detail::allocator::rebind_to<Allocator, typename super::node_type>::type node_allocator;
			typedef ::boost::base_from_member<node_allocator>bfm_allocator;
			typedef detail::header_holder<typename detail::prevent_eti<Allocator, node_allocator>::type::pointer, multi_index_container>bfm_header;
		public:
			typedef typename super::ctor_args_list ctor_args_list;
			typedef IndexSpecifierList index_specifier_type_list;
			typedef typename super::index_type_list index_type_list;
			typedef typename super::iterator_type_list iterator_type_list;
			typedef typename super::const_iterator_type_list const_iterator_type_list;
			typedef typename super::value_type value_type;
			typedef typename super::final_allocator_type allocator_type;
			typedef typename super::iterator iterator;
			typedef typename super::const_iterator const_iterator;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(detail::no_duplicate_tags_in_index_list<index_type_list>::value)>)>boost_static_assert_typedef___COUNTER__;
			typedef typename super::node_type node_type;
			explicit multi_index_container(const ctor_args_list&args_list=ctor_args_list(), const allocator_type&al=allocator_type()): bfm_allocator(al), super(args_list, bfm_allocator::member), node_count(0)
			{
				;
			}
			explicit multi_index_container(const allocator_type&al): bfm_allocator(al), super(ctor_args_list(), bfm_allocator::member), node_count(0)
			{
				;
			}
			template<typename InputIterator>
			multi_index_container(InputIterator first, InputIterator last, const ctor_args_list&args_list=ctor_args_list(), const allocator_type&al=allocator_type()): bfm_allocator(al), super(args_list, bfm_allocator::member), node_count(0)
			{
				;

				{
					if(true)
					{
						iterator hint=super::end();
						for(;
						first!=last;
						++first)
						{
							hint=super::make_iterator(insert_(*first, hint.get_node()).first);
						}
					}
					else if(false)
					{
						clear_();
						;
					}
				}
			}
			multi_index_container(const multi_index_container<Value, IndexSpecifierList, Allocator>&x): bfm_allocator(x.bfm_allocator::member), bfm_header(), super(x), node_count(0)
			{
				copy_map_type map(bfm_allocator::member, x.size(), x.header(), header());
				for(const_iterator it=x.begin(), it_end=x.end();
				it!=it_end;
				++it)
				{
					map.clone(it.get_node());
				}
				super::copy_(x, map);
				map.release();
				node_count=x.size();
				;
			}
			~multi_index_container()
			{
				delete_all_nodes_();
			}
			multi_index_container<Value, IndexSpecifierList, Allocator>&operator=(multi_index_container<Value, IndexSpecifierList, Allocator>x)
			{
				;
				this->swap(x);
				return *this;
			}
			allocator_type get_allocator()const
			{
				return allocator_type(bfm_allocator::member);
			}
			template<int N>
			struct nth_index
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(N>=0&&N<mpl::size<index_type_list>::type::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef typename mpl::at_c<index_type_list, N>::type type;
			};
			template<int N>
			typename nth_index<N>::type&get()
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(N>=0&&N<mpl::size<index_type_list>::type::value)>)>boost_static_assert_typedef___COUNTER__;
				return *this;
			}
			template<int N>
			const typename nth_index<N>::type&get()const
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(N>=0&&N<mpl::size<index_type_list>::type::value)>)>boost_static_assert_typedef___COUNTER__;
				return *this;
			}
			template<typename Tag>
			struct index
			{
				typedef typename mpl::find_if<index_type_list, detail::has_tag<Tag> >::type iter;
				static const bool index_found=!(is_same<iter, typename mpl::end<index_type_list>::type>::value);
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(index_found)>)>boost_static_assert_typedef___COUNTER__;
				typedef typename mpl::deref<iter>::type type;
			};
			template<typename Tag>
			typename index<Tag>::type&get()
			{
				return *this;
			}
			template<typename Tag>
			const typename index<Tag>::type&get()const
			{
				return *this;
			}
			template<int N>
			struct nth_index_iterator
			{
				typedef typename nth_index<N>::type::iterator type;
			};
			template<int N>
			struct nth_index_const_iterator
			{
				typedef typename nth_index<N>::type::const_iterator type;
			};
			template<int N, typename IteratorType>
			typename nth_index_iterator<N>::type project(IteratorType it)
			{
				typedef typename nth_index<N>::type index;
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((mpl::contains<iterator_type_list, IteratorType>::value))>)>boost_static_assert_typedef___COUNTER__;
				((void)0);
				;
				((void)0);
				;
				return index::make_iterator(static_cast<node_type*>(it.get_node()));
			}
			template<int N, typename IteratorType>
			typename nth_index_const_iterator<N>::type project(IteratorType it)const
			{
				typedef typename nth_index<N>::type index;
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((mpl::contains<iterator_type_list, IteratorType>::value||mpl::contains<const_iterator_type_list, IteratorType>::value))>)>boost_static_assert_typedef___COUNTER__;
				((void)0);
				;
				((void)0);
				;
				return index::make_iterator(static_cast<node_type*>(it.get_node()));
			}
			template<typename Tag>
			struct index_iterator
			{
				typedef typename index<Tag>::type::iterator type;
			};
			template<typename Tag>
			struct index_const_iterator
			{
				typedef typename index<Tag>::type::const_iterator type;
			};
			template<typename Tag, typename IteratorType>
			typename index_iterator<Tag>::type project(IteratorType it)
			{
				typedef typename index<Tag>::type index;
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((mpl::contains<iterator_type_list, IteratorType>::value))>)>boost_static_assert_typedef___COUNTER__;
				((void)0);
				;
				((void)0);
				;
				return index::make_iterator(static_cast<node_type*>(it.get_node()));
			}
			template<typename Tag, typename IteratorType>
			typename index_const_iterator<Tag>::type project(IteratorType it)const
			{
				typedef typename index<Tag>::type index;
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((mpl::contains<iterator_type_list, IteratorType>::value||mpl::contains<const_iterator_type_list, IteratorType>::value))>)>boost_static_assert_typedef___COUNTER__;
				((void)0);
				;
				((void)0);
				;
				return index::make_iterator(static_cast<node_type*>(it.get_node()));
			}
		public:
			typedef typename super::copy_map_type copy_map_type;
			node_type*header()const
			{
				return &*bfm_header::member;
			}
			node_type*allocate_node()
			{
				return &*bfm_allocator::member.allocate(1);
			}
			void deallocate_node(node_type*x)
			{
				typedef typename node_allocator::pointer node_pointer;
				bfm_allocator::member.deallocate(static_cast<node_pointer>(x), 1);
			}
			bool empty_()const
			{
				return node_count==0;
			}
			std::size_t size_()const
			{
				return node_count;
			}
			std::size_t max_size_()const
			{
				return static_cast<std::size_t>(-1);
			}
			std::pair<node_type*, bool>insert_(const Value&v)
			{
				node_type*x=allocate_node();

				{
					if(true)
					{
						node_type*res=super::insert_(v, x);
						if(res==x)
						{
							++node_count;
							return std::pair<node_type*, bool>(res, true);
						}
						else
						{
							deallocate_node(x);
							return std::pair<node_type*, bool>(res, false);
						}
					}
					else if(false)
					{
						deallocate_node(x);
						;
					}
				}
			}
			std::pair<node_type*, bool>insert_(const Value&v, node_type*position)
			{
				node_type*x=allocate_node();

				{
					if(true)
					{
						node_type*res=super::insert_(v, position, x);
						if(res==x)
						{
							++node_count;
							return std::pair<node_type*, bool>(res, true);
						}
						else
						{
							deallocate_node(x);
							return std::pair<node_type*, bool>(res, false);
						}
					}
					else if(false)
					{
						deallocate_node(x);
						;
					}
				}
			}
			void erase_(node_type*x)
			{
				--node_count;
				super::erase_(x);
				deallocate_node(x);
			}
			void delete_node_(node_type*x)
			{
				super::delete_node_(x);
				deallocate_node(x);
			}
			void delete_all_nodes_()
			{
				super::delete_all_nodes_();
			}
			void clear_()
			{
				delete_all_nodes_();
				super::clear_();
				node_count=0;
			}
			void swap_(multi_index_container<Value, IndexSpecifierList, Allocator>&x)
			{
				if(bfm_allocator::member!=x.bfm_allocator::member)
				{
					detail::adl_swap(bfm_allocator::member, x.bfm_allocator::member);
				}
				std::swap(bfm_header::member, x.bfm_header::member);
				super::swap_(x);
				std::swap(node_count, x.node_count);
			}
			bool replace_(const Value&k, node_type*x)
			{
				return super::replace_(k, x);
			}
			template<typename Modifier>
			bool modify_(Modifier&mod, node_type*x)
			{
				mod(const_cast<value_type&>(x->value()));

				{
					if(true)
					{
						if(!super::modify_(x))
						{
							deallocate_node(x);
							--node_count;
							return false;
						}
						else return true;
					}
					else if(false)
					{
						deallocate_node(x);
						--node_count;
						;
					}
				}
			}
			template<typename Modifier, typename Rollback>
			bool modify_(Modifier&mod, Rollback&back, node_type*x)
			{
				mod(const_cast<value_type&>(x->value()));
				bool b;

				{
					if(true)
					{
						b=super::modify_rollback_(x);
					}
					else if(false)
					{

						{
							if(true)
							{
								back(const_cast<value_type&>(x->value()));
								;
							}
							else if(false)
							{
								this->erase_(x);
								;
							}
						}
					}
				}

				{
					if(true)
					{
						if(!b)
						{
							back(const_cast<value_type&>(x->value()));
							return false;
						}
						else return true;
					}
					else if(false)
					{
						this->erase_(x);
						;
					}
				}
			}
			friend class boost::serialization::access;
			template<class Archive>
			void serialize(Archive&ar, const unsigned int file_version)
			{
				boost::serialization::split_member(ar, *this, file_version);
			}
			typedef typename super::index_saver_type index_saver_type;
			typedef typename super::index_loader_type index_loader_type;
			template<class Archive>
			void save(Archive&ar, const unsigned int version)const
			{
				const serialization::collection_size_type s(size_());
				ar<<serialization::make_nvp("count", s);
				index_saver_type sm(bfm_allocator::member, s);
				for(iterator it=super::begin(), it_end=super::end();
				it!=it_end;
				++it)
				{
					ar<<serialization::make_nvp("item", *it);
					sm.add(it.get_node(), ar, version);
				}
				sm.add_track(header(), ar, version);
				super::save_(ar, version, sm);
			}
			template<class Archive>
			void load(Archive&ar, const unsigned int version)
			{
				;
				clear_();
				serialization::collection_size_type s;
				if(version<1)
				{
					std::size_t sz;
					ar>>serialization::make_nvp("count", sz);
					s=sz;
				}
				else
				{
					ar>>serialization::make_nvp("count", s);
				}
				index_loader_type lm(bfm_allocator::member, s);
				for(std::size_t n=0;
				n<s;
				++n)
				{
					detail::archive_constructed<Value>value("item", ar, version);
					std::pair<node_type*, bool>p=insert_(value.get(), super::end().get_node());
					if(!p.second)throw_exception(archive::archive_exception(archive::archive_exception::other_exception));
					ar.reset_object_address(&p.first->value(), &value.get());
					lm.add(p.first, ar, version);
				}
				lm.add_track(header(), ar, version);
				super::load_(ar, version, lm);
			}
		private:
			std::size_t node_count;
		};
		template<typename MultiIndexContainer, int N>
		struct nth_index
		{
			static const int M=mpl::size<typename MultiIndexContainer::index_type_list>::type::value;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(N>=0&&N<M)>)>boost_static_assert_typedef___COUNTER__;
			typedef typename mpl::at_c<typename MultiIndexContainer::index_type_list, N>::type type;
		};
		template<int N, typename Value, typename IndexSpecifierList, typename Allocator>
		typename nth_index<multi_index_container<Value, IndexSpecifierList, Allocator>, N>::type&get(multi_index_container<Value, IndexSpecifierList, Allocator>&m)
		{
			typedef multi_index_container<Value, IndexSpecifierList, Allocator>multi_index_type;
			typedef typename nth_index<multi_index_container<Value, IndexSpecifierList, Allocator>, N>::type index;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(N>=0&&N<mpl::size<typename multi_index_type::index_type_list>::type::value)>)>boost_static_assert_typedef___COUNTER__;
			return detail::converter<multi_index_type, index>::index(m);
		}
		template<int N, typename Value, typename IndexSpecifierList, typename Allocator>
		const typename nth_index<multi_index_container<Value, IndexSpecifierList, Allocator>, N>::type&get(const multi_index_container<Value, IndexSpecifierList, Allocator>&m)
		{
			typedef multi_index_container<Value, IndexSpecifierList, Allocator>multi_index_type;
			typedef typename nth_index<multi_index_container<Value, IndexSpecifierList, Allocator>, N>::type index;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(N>=0&&N<mpl::size<typename multi_index_type::index_type_list>::type::value)>)>boost_static_assert_typedef___COUNTER__;
			return detail::converter<multi_index_type, index>::index(m);
		}
		template<typename MultiIndexContainer, typename Tag>
		struct index
		{
			typedef typename MultiIndexContainer::index_type_list index_type_list;
			typedef typename mpl::find_if<index_type_list, detail::has_tag<Tag> >::type iter;
			static const bool index_found=!(is_same<iter, typename mpl::end<index_type_list>::type>::value);
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(index_found)>)>boost_static_assert_typedef___COUNTER__;
			typedef typename mpl::deref<iter>::type type;
		};
		template<typename Tag, typename Value, typename IndexSpecifierList, typename Allocator>
		typename::boost::multi_index::index<multi_index_container<Value, IndexSpecifierList, Allocator>, Tag>::type&get(multi_index_container<Value, IndexSpecifierList, Allocator>&m)
		{
			typedef multi_index_container<Value, IndexSpecifierList, Allocator>multi_index_type;
			typedef typename::boost::multi_index::index<multi_index_container<Value, IndexSpecifierList, Allocator>, Tag>::type index;
			return detail::converter<multi_index_type, index>::index(m);
		}
		template<typename Tag, typename Value, typename IndexSpecifierList, typename Allocator>
		const typename::boost::multi_index::index<multi_index_container<Value, IndexSpecifierList, Allocator>, Tag>::type&get(const multi_index_container<Value, IndexSpecifierList, Allocator>&m)
		{
			typedef multi_index_container<Value, IndexSpecifierList, Allocator>multi_index_type;
			typedef typename::boost::multi_index::index<multi_index_container<Value, IndexSpecifierList, Allocator>, Tag>::type index;
			return detail::converter<multi_index_type, index>::index(m);
		}
		template<typename MultiIndexContainer, int N>
		struct nth_index_iterator
		{
			typedef typename detail::prevent_eti<nth_index<MultiIndexContainer, N>, typename nth_index<MultiIndexContainer, N>::type>::type::iterator type;
		};
		template<typename MultiIndexContainer, int N>
		struct nth_index_const_iterator
		{
			typedef typename detail::prevent_eti<nth_index<MultiIndexContainer, N>, typename nth_index<MultiIndexContainer, N>::type>::type::const_iterator type;
		};
		template<int N, typename IteratorType, typename Value, typename IndexSpecifierList, typename Allocator>
		typename nth_index_iterator<multi_index_container<Value, IndexSpecifierList, Allocator>, N>::type project(multi_index_container<Value, IndexSpecifierList, Allocator>&m, IteratorType it)
		{
			typedef multi_index_container<Value, IndexSpecifierList, Allocator>multi_index_type;
			typedef typename nth_index<multi_index_type, N>::type index;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((mpl::contains<typename multi_index_type::iterator_type_list, IteratorType>::value))>)>boost_static_assert_typedef___COUNTER__;
			((void)0);
			;
			return detail::converter<multi_index_type, index>::iterator(m, static_cast<typename multi_index_type::node_type*>(it.get_node()));
		}
		template<int N, typename IteratorType, typename Value, typename IndexSpecifierList, typename Allocator>
		typename nth_index_const_iterator<multi_index_container<Value, IndexSpecifierList, Allocator>, N>::type project(const multi_index_container<Value, IndexSpecifierList, Allocator>&m, IteratorType it)
		{
			typedef multi_index_container<Value, IndexSpecifierList, Allocator>multi_index_type;
			typedef typename nth_index<multi_index_type, N>::type index;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((mpl::contains<typename multi_index_type::iterator_type_list, IteratorType>::value||mpl::contains<typename multi_index_type::const_iterator_type_list, IteratorType>::value))>)>boost_static_assert_typedef___COUNTER__;
			((void)0);
			;
			return detail::converter<multi_index_type, index>::const_iterator(m, static_cast<typename multi_index_type::node_type*>(it.get_node()));
		}
		template<typename MultiIndexContainer, typename Tag>
		struct index_iterator
		{
			typedef typename::boost::multi_index::index<MultiIndexContainer, Tag>::type::iterator type;
		};
		template<typename MultiIndexContainer, typename Tag>
		struct index_const_iterator
		{
			typedef typename::boost::multi_index::index<MultiIndexContainer, Tag>::type::const_iterator type;
		};
		template<typename Tag, typename IteratorType, typename Value, typename IndexSpecifierList, typename Allocator>
		typename index_iterator<multi_index_container<Value, IndexSpecifierList, Allocator>, Tag>::type project(multi_index_container<Value, IndexSpecifierList, Allocator>&m, IteratorType it)
		{
			typedef multi_index_container<Value, IndexSpecifierList, Allocator>multi_index_type;
			typedef typename::boost::multi_index::index<multi_index_type, Tag>::type index;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((mpl::contains<typename multi_index_type::iterator_type_list, IteratorType>::value))>)>boost_static_assert_typedef___COUNTER__;
			((void)0);
			;
			return detail::converter<multi_index_type, index>::iterator(m, static_cast<typename multi_index_type::node_type*>(it.get_node()));
		}
		template<typename Tag, typename IteratorType, typename Value, typename IndexSpecifierList, typename Allocator>
		typename index_const_iterator<multi_index_container<Value, IndexSpecifierList, Allocator>, Tag>::type project(const multi_index_container<Value, IndexSpecifierList, Allocator>&m, IteratorType it)
		{
			typedef multi_index_container<Value, IndexSpecifierList, Allocator>multi_index_type;
			typedef typename::boost::multi_index::index<multi_index_type, Tag>::type index;
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((mpl::contains<typename multi_index_type::iterator_type_list, IteratorType>::value||mpl::contains<typename multi_index_type::const_iterator_type_list, IteratorType>::value))>)>boost_static_assert_typedef___COUNTER__;
			((void)0);
			;
			return detail::converter<multi_index_type, index>::const_iterator(m, static_cast<typename multi_index_type::node_type*>(it.get_node()));
		}
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator==(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y)
		{
			return get<0>(x)==get<0>(y);
		}
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator<(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y)
		{
			return get<0>(x)<get<0>(y);
		}
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator!=(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y)
		{
			return get<0>(x)!=get<0>(y);
		}
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator>(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y)
		{
			return get<0>(x)>get<0>(y);
		}
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator>=(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y)
		{
			return get<0>(x)>=get<0>(y);
		}
		template<typename Value1, typename IndexSpecifierList1, typename Allocator1, typename Value2, typename IndexSpecifierList2, typename Allocator2>
		bool operator<=(const multi_index_container<Value1, IndexSpecifierList1, Allocator1>&x, const multi_index_container<Value2, IndexSpecifierList2, Allocator2>&y)
		{
			return get<0>(x)<=get<0>(y);
		}
		template<typename Value, typename IndexSpecifierList, typename Allocator>
		void swap(multi_index_container<Value, IndexSpecifierList, Allocator>&x, multi_index_container<Value, IndexSpecifierList, Allocator>&y)
		{
			x.swap(y);
		}
	}
	namespace serialization
	{
		template<typename Value, typename IndexSpecifierList, typename Allocator>
		struct version<boost::multi_index_container<Value, IndexSpecifierList, Allocator> >
		{
			static const unsigned int value=1;
		};
	}
	using multi_index::get;
	using multi_index::project;
}
namespace boost
{
	template<class T>
	class reference_wrapper;
	namespace multi_index
	{
		namespace detail
		{
			template<class Class, typename Type, Type Class::*PtrToMember>
			struct const_member_base
			{
				typedef Type result_type;
				template<typename ChainedPtr>
				typename disable_if<is_convertible<const ChainedPtr&, const Class&>, Type&>::type operator()(const ChainedPtr&x)const
				{
					return operator()(*x);
				}
				Type&operator()(const Class&x)const
				{
					return x.*PtrToMember;
				}
				Type&operator()(const reference_wrapper<const Class>&x)const
				{
					return operator()(x.get());
				}
				Type&operator()(const reference_wrapper<Class>&x, int=0)const
				{
					return operator()(x.get());
				}
			};
			template<class Class, typename Type, Type Class::*PtrToMember>
			struct non_const_member_base
			{
				typedef Type result_type;
				template<typename ChainedPtr>
				typename disable_if<is_convertible<const ChainedPtr&, const Class&>, Type&>::type operator()(const ChainedPtr&x)const
				{
					return operator()(*x);
				}
				const Type&operator()(const Class&x, int=0)const
				{
					return x.*PtrToMember;
				}
				Type&operator()(Class&x)const
				{
					return x.*PtrToMember;
				}
				const Type&operator()(const reference_wrapper<const Class>&x, int=0)const
				{
					return operator()(x.get());
				}
				Type&operator()(const reference_wrapper<Class>&x)const
				{
					return operator()(x.get());
				}
			};
		}
		template<class Class, typename Type, Type Class::*PtrToMember>
		struct member: mpl::if_c<is_const<Type>::value, detail::const_member_base<Class, Type, PtrToMember>, detail::non_const_member_base<Class, Type, PtrToMember> >::type
		{
		};
		namespace detail
		{
			template<class Class, typename Type, std::size_t OffsetOfMember>
			struct const_member_offset_base
			{
				typedef Type result_type;
				template<typename ChainedPtr>
				typename disable_if<is_convertible<const ChainedPtr&, const Class&>, Type&>::type operator()(const ChainedPtr&x)const
				{
					return operator()(*x);
				}
				Type&operator()(const Class&x)const
				{
					return *static_cast<const Type*>(static_cast<const void*>(static_cast<const char*>(static_cast<const void*>(&x))+OffsetOfMember));
				}
				Type&operator()(const reference_wrapper<const Class>&x)const
				{
					return operator()(x.get());
				}
				Type&operator()(const reference_wrapper<Class>&x, int=0)const
				{
					return operator()(x.get());
				}
			};
			template<class Class, typename Type, std::size_t OffsetOfMember>
			struct non_const_member_offset_base
			{
				typedef Type result_type;
				template<typename ChainedPtr>
				typename disable_if<is_convertible<const ChainedPtr&, const Class&>, Type&>::type operator()(const ChainedPtr&x)const
				{
					return operator()(*x);
				}
				const Type&operator()(const Class&x, int=0)const
				{
					return *static_cast<const Type*>(static_cast<const void*>(static_cast<const char*>(static_cast<const void*>(&x))+OffsetOfMember));
				}
				Type&operator()(Class&x)const
				{
					return *static_cast<Type*>(static_cast<void*>(static_cast<char*>(static_cast<void*>(&x))+OffsetOfMember));
				}
				const Type&operator()(const reference_wrapper<const Class>&x, int=0)const
				{
					return operator()(x.get());
				}
				Type&operator()(const reference_wrapper<Class>&x)const
				{
					return operator()(x.get());
				}
			};
		}
		template<class Class, typename Type, std::size_t OffsetOfMember>
		struct member_offset: mpl::if_c<is_const<Type>::value, detail::const_member_offset_base<Class, Type, OffsetOfMember>, detail::non_const_member_offset_base<Class, Type, OffsetOfMember> >::type
		{
		};
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Node>
			class bidir_node_iterator: public bidirectional_iterator_helper<bidir_node_iterator<Node>, typename Node::value_type, std::ptrdiff_t, const typename Node::value_type*, const typename Node::value_type&>
			{
			public:
				bidir_node_iterator()
				{
				}
				explicit bidir_node_iterator(Node*node_): node(node_)
				{
				}
				const typename Node::value_type&operator*()const
				{
					return node->value();
				}
				bidir_node_iterator&operator++()
				{
					Node::increment(node);
					return *this;
				}
				bidir_node_iterator&operator--()
				{
					Node::decrement(node);
					return *this;
				}
				template<class Archive>
				void serialize(Archive&ar, const unsigned int file_version)
				{
					boost::serialization::split_member(ar, *this, file_version);
				}
				typedef typename Node::base_type node_base_type;
				template<class Archive>
				void save(Archive&ar, const unsigned int)const
				{
					node_base_type*bnode=node;
					ar<<serialization::make_nvp("pointer", bnode);
				}
				template<class Archive>
				void load(Archive&ar, const unsigned int)
				{
					node_base_type*bnode;
					ar>>serialization::make_nvp("pointer", bnode);
					node=static_cast<Node*>(bnode);
				}
				typedef Node node_type;
				Node*get_node()const
				{
					return node;
				}
			private:
				Node*node;
			};
			template<typename Node>
			bool operator==(const bidir_node_iterator<Node>&x, const bidir_node_iterator<Node>&y)
			{
				return x.get_node()==y.get_node();
			}
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Fun, typename Value, typename KeyFromValue>
			struct modify_key_adaptor
			{
				modify_key_adaptor(Fun f_, KeyFromValue kfv_): f(f_), kfv(kfv_)
				{
				}
				void operator()(Value&x)
				{
					f(kfv(x));
				}
			private:
				Fun f;
				KeyFromValue kfv;
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<int N>
			struct uintptr_candidates;
			template<>
			struct uintptr_candidates<-1>
			{
				typedef unsigned int type;
			};
			template<>
			struct uintptr_candidates<0>
			{
				typedef unsigned int type;
			};
			template<>
			struct uintptr_candidates<1>
			{
				typedef unsigned short type;
			};
			template<>
			struct uintptr_candidates<2>
			{
				typedef unsigned long type;
			};
			template<>
			struct uintptr_candidates<3>
			{
				typedef unsigned int type;
			};
			template<>
			struct uintptr_candidates<4>
			{
				typedef unsigned __int64 type;
			};
			struct uintptr_aux
			{
				static const int index=sizeof(void*)==sizeof(uintptr_candidates<0>::type)?0: sizeof(void*)==sizeof(uintptr_candidates<1>::type)?1: sizeof(void*)==sizeof(uintptr_candidates<2>::type)?2: sizeof(void*)==sizeof(uintptr_candidates<3>::type)?3: sizeof(void*)==sizeof(uintptr_candidates<4>::type)?4: -1;
				static const bool has_uintptr_type=(index>=0);
				typedef uintptr_candidates<index>::type type;
			};
			typedef mpl::bool_<uintptr_aux::has_uintptr_type>has_uintptr_type;
			typedef uintptr_aux::type uintptr_type;
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			enum ordered_index_color
			{
				red=false, black=true
			};
			enum ordered_index_side
			{
				to_left=false, to_right=true
			};
			template<typename Allocator>
			struct ordered_index_node_impl;
			template<typename Allocator>
			struct ordered_index_node_std_base
			{
				typedef typename prevent_eti<Allocator, typename boost::detail::allocator::rebind_to<Allocator, ordered_index_node_impl<Allocator> >::type>::type::pointer pointer;
				typedef typename prevent_eti<Allocator, typename boost::detail::allocator::rebind_to<Allocator, ordered_index_node_impl<Allocator> >::type>::type::const_pointer const_pointer;
				typedef ordered_index_color&color_ref;
				typedef pointer&parent_ref;
				ordered_index_color&color()
				{
					return color_;
				}
				ordered_index_color color()const
				{
					return color_;
				}
				pointer&parent()
				{
					return parent_;
				}
				pointer parent()const
				{
					return parent_;
				}
				pointer&left()
				{
					return left_;
				}
				pointer left()const
				{
					return left_;
				}
				pointer&right()
				{
					return right_;
				}
				pointer right()const
				{
					return right_;
				}
			private:
				ordered_index_color color_;
				pointer parent_;
				pointer left_;
				pointer right_;
			};
			template<typename Allocator>
			struct ordered_index_node_compressed_base
			{
				typedef ordered_index_node_impl<Allocator>*pointer;
				typedef const ordered_index_node_impl<Allocator>*const_pointer;
				struct color_ref
				{
					color_ref(uintptr_type*r_): r(r_)
					{
					}
					operator ordered_index_color()const
					{
						return ordered_index_color(*r&uintptr_type(1));
					}
					color_ref&operator=(ordered_index_color c)
					{
						*r&=~uintptr_type(1);
						*r|=uintptr_type(c);
						return *this;
					}
					color_ref&operator=(const color_ref&x)
					{
						return operator=(x.operator ordered_index_color());
					}
				private:
					uintptr_type*r;
				};
				struct parent_ref
				{
					parent_ref(uintptr_type*r_): r(r_)
					{
					}
					operator pointer()const
					{
						return (pointer)(void*)(*r&~uintptr_type(1));
					}
					parent_ref&operator=(pointer p)
					{
						*r=((uintptr_type)(void*)p)|(*r&uintptr_type(1));
						return *this;
					}
					parent_ref&operator=(const parent_ref&x)
					{
						return operator=(x.operator pointer());
					}
					pointer operator->()const
					{
						return operator pointer();
					}
				private:
					uintptr_type*r;
				};
				color_ref color()
				{
					return color_ref(&parentcolor_);
				}
				ordered_index_color color()const
				{
					return ordered_index_color(parentcolor_&std::size_t(1ul));
				}
				parent_ref parent()
				{
					return parent_ref(&parentcolor_);
				}
				pointer parent()const
				{
					return (pointer)(void*)(parentcolor_&~uintptr_type(1));
				}
				pointer&left()
				{
					return left_;
				}
				pointer left()const
				{
					return left_;
				}
				pointer&right()
				{
					return right_;
				}
				pointer right()const
				{
					return right_;
				}
			private:
				uintptr_type parentcolor_;
				pointer left_;
				pointer right_;
			};
			template<typename Allocator>
			struct ordered_index_node_impl_base: mpl::if_c<!(has_uintptr_type::value)||(alignment_of<ordered_index_node_compressed_base<Allocator> >::value%2)||!(is_same<typename prevent_eti<Allocator, typename boost::detail::allocator::rebind_to<Allocator, ordered_index_node_impl<Allocator> >::type>::type::pointer, ordered_index_node_impl<Allocator>*>::value), ordered_index_node_std_base<Allocator>, ordered_index_node_compressed_base<Allocator> >::type
			{
			};
			template<typename Allocator>
			struct ordered_index_node_impl: ordered_index_node_impl_base<Allocator>
			{
			private:
				typedef ordered_index_node_impl_base<Allocator>super;
			public:
				typedef typename super::color_ref color_ref;
				typedef typename super::parent_ref parent_ref;
				typedef typename super::pointer pointer;
				typedef typename super::const_pointer const_pointer;
				static void increment(pointer&x)
				{
					if(x->right()!=pointer(0))
					{
						x=x->right();
						while(x->left()!=pointer(0))x=x->left();
					}
					else
					{
						pointer y=x->parent();
						while(x==y->right())
						{
							x=y;
							y=y->parent();
						}
						if(x->right()!=y)x=y;
					}
				}
				static void decrement(pointer&x)
				{
					if(x->color()==red&&x->parent()->parent()==x)
					{
						x=x->right();
					}
					else if(x->left()!=pointer(0))
					{
						pointer y=x->left();
						while(y->right()!=pointer(0))y=y->right();
						x=y;
					}
					else
					{
						pointer y=x->parent();
						while(x==y->left())
						{
							x=y;
							y=y->parent();
						}
						x=y;
					}
				}
				static void rotate_left(pointer x, parent_ref root)
				{
					pointer y=x->right();
					x->right()=y->left();
					if(y->left()!=pointer(0))y->left()->parent()=x;
					y->parent()=x->parent();
					if(x==root)root=y;
					else if(x==x->parent()->left())x->parent()->left()=y;
					else x->parent()->right()=y;
					y->left()=x;
					x->parent()=y;
				}
				static pointer minimum(pointer x)
				{
					while(x->left()!=pointer(0))x=x->left();
					return x;
				}
				static pointer maximum(pointer x)
				{
					while(x->right()!=pointer(0))x=x->right();
					return x;
				}
				static void rotate_right(pointer x, parent_ref root)
				{
					pointer y=x->left();
					x->left()=y->right();
					if(y->right()!=pointer(0))y->right()->parent()=x;
					y->parent()=x->parent();
					if(x==root)root=y;
					else if(x==x->parent()->right())x->parent()->right()=y;
					else x->parent()->left()=y;
					y->right()=x;
					x->parent()=y;
				}
				static void rebalance(pointer x, parent_ref root)
				{
					x->color()=red;
					while(x!=root&&x->parent()->color()==red)
					{
						if(x->parent()==x->parent()->parent()->left())
						{
							pointer y=x->parent()->parent()->right();
							if(y!=pointer(0)&&y->color()==red)
							{
								x->parent()->color()=black;
								y->color()=black;
								x->parent()->parent()->color()=red;
								x=x->parent()->parent();
							}
							else
							{
								if(x==x->parent()->right())
								{
									x=x->parent();
									rotate_left(x, root);
								}
								x->parent()->color()=black;
								x->parent()->parent()->color()=red;
								rotate_right(x->parent()->parent(), root);
							}
						}
						else
						{
							pointer y=x->parent()->parent()->left();
							if(y!=pointer(0)&&y->color()==red)
							{
								x->parent()->color()=black;
								y->color()=black;
								x->parent()->parent()->color()=red;
								x=x->parent()->parent();
							}
							else
							{
								if(x==x->parent()->left())
								{
									x=x->parent();
									rotate_right(x, root);
								}
								x->parent()->color()=black;
								x->parent()->parent()->color()=red;
								rotate_left(x->parent()->parent(), root);
							}
						}
					}
					root->color()=black;
				}
				static void link(pointer x, ordered_index_side side, pointer position, pointer header)
				{
					if(side==to_left)
					{
						position->left()=x;
						if(position==header)
						{
							header->parent()=x;
							header->right()=x;
						}
						else if(position==header->left())
						{
							header->left()=x;
						}
					}
					else
					{
						position->right()=x;
						if(position==header->right())
						{
							header->right()=x;
						}
					}
					x->parent()=position;
					x->left()=pointer(0);
					x->right()=pointer(0);
					ordered_index_node_impl::rebalance(x, header->parent());
				}
				static pointer rebalance_for_erase(pointer z, parent_ref root, pointer&leftmost, pointer&rightmost)
				{
					pointer y=z;
					pointer x=pointer(0);
					pointer x_parent=pointer(0);
					if(y->left()==pointer(0))
					{
						x=y->right();
					}
					else
					{
						if(y->right()==pointer(0))
						{
							x=y->left();
						}
						else
						{
							y=y->right();
							while(y->left()!=pointer(0))y=y->left();
							x=y->right();
						}
					}
					if(y!=z)
					{
						z->left()->parent()=y;
						y->left()=z->left();
						if(y!=z->right())
						{
							x_parent=y->parent();
							if(x!=pointer(0))x->parent()=y->parent();
							y->parent()->left()=x;
							y->right()=z->right();
							z->right()->parent()=y;
						}
						else
						{
							x_parent=y;
						}
						if(root==z)root=y;
						else if(z->parent()->left()==z)z->parent()->left()=y;
						else z->parent()->right()=y;
						y->parent()=z->parent();
						ordered_index_color c=y->color();
						y->color()=z->color();
						z->color()=c;
						y=z;
					}
					else
					{
						x_parent=y->parent();
						if(x!=pointer(0))x->parent()=y->parent();
						if(root==z)
						{
							root=x;
						}
						else
						{
							if(z->parent()->left()==z)z->parent()->left()=x;
							else z->parent()->right()=x;
						}
						if(leftmost==z)
						{
							if(z->right()==pointer(0))
							{
								leftmost=z->parent();
							}
							else
							{
								leftmost=minimum(x);
							}
						}
						if(rightmost==z)
						{
							if(z->left()==pointer(0))
							{
								rightmost=z->parent();
							}
							else
							{
								rightmost=maximum(x);
							}
						}
					}
					if(y->color()!=red)
					{
						while(x!=root&&(x==pointer(0)||x->color()==black))
						{
							if(x==x_parent->left())
							{
								pointer w=x_parent->right();
								if(w->color()==red)
								{
									w->color()=black;
									x_parent->color()=red;
									rotate_left(x_parent, root);
									w=x_parent->right();
								}
								if((w->left()==pointer(0)||w->left()->color()==black)&&(w->right()==pointer(0)||w->right()->color()==black))
								{
									w->color()=red;
									x=x_parent;
									x_parent=x_parent->parent();
								}
								else
								{
									if(w->right()==pointer(0)||w->right()->color()==black)
									{
										if(w->left()!=pointer(0))w->left()->color()=black;
										w->color()=red;
										rotate_right(w, root);
										w=x_parent->right();
									}
									w->color()=x_parent->color();
									x_parent->color()=black;
									if(w->right()!=pointer(0))w->right()->color()=black;
									rotate_left(x_parent, root);
									break;
								}
							}
							else
							{
								pointer w=x_parent->left();
								if(w->color()==red)
								{
									w->color()=black;
									x_parent->color()=red;
									rotate_right(x_parent, root);
									w=x_parent->left();
								}
								if((w->right()==pointer(0)||w->right()->color()==black)&&(w->left()==pointer(0)||w->left()->color()==black))
								{
									w->color()=red;
									x=x_parent;
									x_parent=x_parent->parent();
								}
								else
								{
									if(w->left()==pointer(0)||w->left()->color()==black)
									{
										if(w->right()!=pointer(0))w->right()->color()=black;
										w->color()=red;
										rotate_left(w, root);
										w=x_parent->left();
									}
									w->color()=x_parent->color();
									x_parent->color()=black;
									if(w->left()!=pointer(0))w->left()->color()=black;
									rotate_right(x_parent, root);
									break;
								}
							}
						}
						if(x!=pointer(0))x->color()=black;
					}
					return y;
				}
				static void restore(pointer x, pointer position, pointer header)
				{
					if(position->left()==pointer(0)||position->left()==header)
					{
						link(x, to_left, position, header);
					}
					else
					{
						decrement(position);
						link(x, to_right, position, header);
					}
				}
			};
			template<typename Super>
			struct ordered_index_node_trampoline: prevent_eti<Super, ordered_index_node_impl<typename boost::detail::allocator::rebind_to<typename Super::allocator_type, char>::type> >::type
			{
				typedef typename prevent_eti<Super, ordered_index_node_impl<typename boost::detail::allocator::rebind_to<typename Super::allocator_type, char>::type> >::type impl_type;
			};
			template<typename Super>
			struct ordered_index_node: Super, ordered_index_node_trampoline<Super>
			{
			private:
				typedef ordered_index_node_trampoline<Super>trampoline;
			public:
				typedef typename trampoline::impl_type impl_type;
				typedef typename trampoline::color_ref impl_color_ref;
				typedef typename trampoline::parent_ref impl_parent_ref;
				typedef typename trampoline::pointer impl_pointer;
				typedef typename trampoline::const_pointer const_impl_pointer;
				impl_color_ref color()
				{
					return trampoline::color();
				}
				ordered_index_color color()const
				{
					return trampoline::color();
				}
				impl_parent_ref parent()
				{
					return trampoline::parent();
				}
				impl_pointer parent()const
				{
					return trampoline::parent();
				}
				impl_pointer&left()
				{
					return trampoline::left();
				}
				impl_pointer left()const
				{
					return trampoline::left();
				}
				impl_pointer&right()
				{
					return trampoline::right();
				}
				impl_pointer right()const
				{
					return trampoline::right();
				}
				impl_pointer impl()
				{
					return static_cast<impl_pointer>(static_cast<impl_type*>(static_cast<trampoline*>(this)));
				}
				const_impl_pointer impl()const
				{
					return static_cast<const_impl_pointer>(static_cast<const impl_type*>(static_cast<const trampoline*>(this)));
				}
				static ordered_index_node*from_impl(impl_pointer x)
				{
					return static_cast<ordered_index_node*>(static_cast<trampoline*>(&*x));
				}
				static const ordered_index_node*from_impl(const_impl_pointer x)
				{
					return static_cast<const ordered_index_node*>(static_cast<const trampoline*>(&*x));
				}
				static void increment(ordered_index_node*&x)
				{
					impl_pointer xi=x->impl();
					trampoline::increment(xi);
					x=from_impl(xi);
				}
				static void decrement(ordered_index_node*&x)
				{
					impl_pointer xi=x->impl();
					trampoline::decrement(xi);
					x=from_impl(xi);
				}
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Node, typename KeyFromValue, typename CompatibleKey, typename CompatibleCompare>
			inline Node*ordered_index_find(Node*top, Node*y, const KeyFromValue&key, const CompatibleKey&x, const CompatibleCompare&comp)
			{
				Node*y0=y;
				while(top)
				{
					if(!comp(key(top->value()), x))
					{
						y=top;
						top=Node::from_impl(top->left());
					}
					else top=Node::from_impl(top->right());
				}
				return (y==y0||comp(x, key(y->value())))?y0: y;
			}
			template<typename Node, typename KeyFromValue, typename CompatibleKey, typename CompatibleCompare>
			inline Node*ordered_index_lower_bound(Node*top, Node*y, const KeyFromValue&key, const CompatibleKey&x, const CompatibleCompare&comp)
			{
				while(top)
				{
					if(!comp(key(top->value()), x))
					{
						y=top;
						top=Node::from_impl(top->left());
					}
					else top=Node::from_impl(top->right());
				}
				return y;
			}
			template<typename Node, typename KeyFromValue, typename CompatibleKey, typename CompatibleCompare>
			inline Node*ordered_index_upper_bound(Node*top, Node*y, const KeyFromValue&key, const CompatibleKey&x, const CompatibleCompare&comp)
			{
				while(top)
				{
					if(comp(x, key(top->value())))
					{
						y=top;
						top=Node::from_impl(top->left());
					}
					else top=Node::from_impl(top->right());
				}
				return y;
			}
			template<typename Node, typename KeyFromValue, typename CompatibleKey, typename CompatibleCompare>
			inline std::pair<Node*, Node*>ordered_index_equal_range(Node*top, Node*y, const KeyFromValue&key, const CompatibleKey&x, const CompatibleCompare&comp)
			{
				while(top)
				{
					if(comp(key(top->value()), x))
					{
						top=Node::from_impl(top->right());
					}
					else if(comp(x, key(top->value())))
					{
						y=top;
						top=Node::from_impl(top->left());
					}
					else
					{
						return std::pair<Node*, Node*>(ordered_index_lower_bound(Node::from_impl(top->left()), top, key, x, comp), ordered_index_upper_bound(Node::from_impl(top->right()), y, key, x, comp));
					}
				}
				return std::pair<Node*, Node*>(y, y);
			}
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			class unbounded_helper;
		}
		detail::unbounded_helper unbounded(detail::unbounded_helper);
		namespace detail
		{
			class unbounded_helper
			{
				unbounded_helper()
				{
				}
				unbounded_helper(const unbounded_helper&)
				{
				}
				friend unbounded_helper multi_index::unbounded(unbounded_helper);
			};
			typedef unbounded_helper(*unbounded_type)(unbounded_helper);
		}
		inline detail::unbounded_helper unbounded(detail::unbounded_helper)
		{
			return detail::unbounded_helper();
		}
		namespace detail
		{
			struct none_unbounded_tag
			{
			};
			struct lower_unbounded_tag
			{
			};
			struct upper_unbounded_tag
			{
			};
			struct both_unbounded_tag
			{
			};
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Value, typename KeyFromValue, typename Compare>
			struct value_comparison: std::binary_function<Value, Value, bool>
			{
				value_comparison(const KeyFromValue&key_=KeyFromValue(), const Compare&comp_=Compare()): key(key_), comp(comp_)
				{
				}
				bool operator()(typename call_traits<Value>::param_type x, typename call_traits<Value>::param_type y)const
				{
					return comp(key(x), key(y));
				}
			private:
				KeyFromValue key;
				Compare comp;
			};
		}
	}
}
namespace boost
{
	template<class T>
	T*get_pointer(T*p)
	{
		return p;
	}
	template<class T>
	T*get_pointer(std::auto_ptr<T>const&p)
	{
		return p.get();
	}
}
namespace boost
{
	namespace _mfi
	{
		template<class R, class T>
		class mf0
		{
		public:
			typedef R result_type;
			typedef T*argument_type;
		private:
			typedef R(T::*F)();
			F f_;
			template<class U>
			R call(U&u, T const*)const
			{
				return (u.*f_)();
			}
			template<class U>
			R call(U&u, void const*)const
			{
				return (get_pointer(u)->*f_)();
			}
		public:
			explicit mf0(F f): f_(f)
			{
			}
			R operator()(T*p)const
			{
				return (p->*f_)();
			}
			template<class U>
			R operator()(U&u)const
			{
				return call(u, &u);
			}
			template<class U>
			R operator()(U const&u)const
			{
				return call(u, &u);
			}
			R operator()(T&t)const
			{
				return (t.*f_)();
			}
			bool operator==(mf0 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf0 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T>
		class cmf0
		{
		public:
			typedef R result_type;
			typedef T const*argument_type;
		private:
			typedef R(T::*F)()const;
			F f_;
			template<class U>
			R call(U&u, T const*)const
			{
				return (u.*f_)();
			}
			template<class U>
			R call(U&u, void const*)const
			{
				return (get_pointer(u)->*f_)();
			}
		public:
			explicit cmf0(F f): f_(f)
			{
			}
			template<class U>
			R operator()(U const&u)const
			{
				return call(u, &u);
			}
			R operator()(T const&t)const
			{
				return (t.*f_)();
			}
			bool operator==(cmf0 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf0 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1>
		class mf1
		{
		public:
			typedef R result_type;
			typedef T*first_argument_type;
			typedef A1 second_argument_type;
		private:
			typedef R(T::*F)(A1);
			F f_;
			template<class U, class B1>
			R call(U&u, T const*, B1&b1)const
			{
				return (u.*f_)(b1);
			}
			template<class U, class B1>
			R call(U&u, void const*, B1&b1)const
			{
				return (get_pointer(u)->*f_)(b1);
			}
		public:
			explicit mf1(F f): f_(f)
			{
			}
			R operator()(T*p, A1 a1)const
			{
				return (p->*f_)(a1);
			}
			template<class U>
			R operator()(U&u, A1 a1)const
			{
				return call(u, &u, a1);
			}
			template<class U>
			R operator()(U const&u, A1 a1)const
			{
				return call(u, &u, a1);
			}
			R operator()(T&t, A1 a1)const
			{
				return (t.*f_)(a1);
			}
			bool operator==(mf1 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf1 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1>
		class cmf1
		{
		public:
			typedef R result_type;
			typedef T const*first_argument_type;
			typedef A1 second_argument_type;
		private:
			typedef R(T::*F)(A1)const;
			F f_;
			template<class U, class B1>
			R call(U&u, T const*, B1&b1)const
			{
				return (u.*f_)(b1);
			}
			template<class U, class B1>
			R call(U&u, void const*, B1&b1)const
			{
				return (get_pointer(u)->*f_)(b1);
			}
		public:
			explicit cmf1(F f): f_(f)
			{
			}
			template<class U>
			R operator()(U const&u, A1 a1)const
			{
				return call(u, &u, a1);
			}
			R operator()(T const&t, A1 a1)const
			{
				return (t.*f_)(a1);
			}
			bool operator==(cmf1 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf1 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2>
		class mf2
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2);
			F f_;
			template<class U, class B1, class B2>
			R call(U&u, T const*, B1&b1, B2&b2)const
			{
				return (u.*f_)(b1, b2);
			}
			template<class U, class B1, class B2>
			R call(U&u, void const*, B1&b1, B2&b2)const
			{
				return (get_pointer(u)->*f_)(b1, b2);
			}
		public:
			explicit mf2(F f): f_(f)
			{
			}
			R operator()(T*p, A1 a1, A2 a2)const
			{
				return (p->*f_)(a1, a2);
			}
			template<class U>
			R operator()(U&u, A1 a1, A2 a2)const
			{
				return call(u, &u, a1, a2);
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2)const
			{
				return call(u, &u, a1, a2);
			}
			R operator()(T&t, A1 a1, A2 a2)const
			{
				return (t.*f_)(a1, a2);
			}
			bool operator==(mf2 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf2 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2>
		class cmf2
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2)const;
			F f_;
			template<class U, class B1, class B2>
			R call(U&u, T const*, B1&b1, B2&b2)const
			{
				return (u.*f_)(b1, b2);
			}
			template<class U, class B1, class B2>
			R call(U&u, void const*, B1&b1, B2&b2)const
			{
				return (get_pointer(u)->*f_)(b1, b2);
			}
		public:
			explicit cmf2(F f): f_(f)
			{
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2)const
			{
				return call(u, &u, a1, a2);
			}
			R operator()(T const&t, A1 a1, A2 a2)const
			{
				return (t.*f_)(a1, a2);
			}
			bool operator==(cmf2 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf2 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3>
		class mf3
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3);
			F f_;
			template<class U, class B1, class B2, class B3>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3)const
			{
				return (u.*f_)(b1, b2, b3);
			}
			template<class U, class B1, class B2, class B3>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3);
			}
		public:
			explicit mf3(F f): f_(f)
			{
			}
			R operator()(T*p, A1 a1, A2 a2, A3 a3)const
			{
				return (p->*f_)(a1, a2, a3);
			}
			template<class U>
			R operator()(U&u, A1 a1, A2 a2, A3 a3)const
			{
				return call(u, &u, a1, a2, a3);
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3)const
			{
				return call(u, &u, a1, a2, a3);
			}
			R operator()(T&t, A1 a1, A2 a2, A3 a3)const
			{
				return (t.*f_)(a1, a2, a3);
			}
			bool operator==(mf3 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf3 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3>
		class cmf3
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3)const;
			F f_;
			template<class U, class B1, class B2, class B3>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3)const
			{
				return (u.*f_)(b1, b2, b3);
			}
			template<class U, class B1, class B2, class B3>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3);
			}
		public:
			explicit cmf3(F f): f_(f)
			{
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3)const
			{
				return call(u, &u, a1, a2, a3);
			}
			R operator()(T const&t, A1 a1, A2 a2, A3 a3)const
			{
				return (t.*f_)(a1, a2, a3);
			}
			bool operator==(cmf3 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf3 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4>
		class mf4
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4);
			F f_;
			template<class U, class B1, class B2, class B3, class B4>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4)const
			{
				return (u.*f_)(b1, b2, b3, b4);
			}
			template<class U, class B1, class B2, class B3, class B4>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4);
			}
		public:
			explicit mf4(F f): f_(f)
			{
			}
			R operator()(T*p, A1 a1, A2 a2, A3 a3, A4 a4)const
			{
				return (p->*f_)(a1, a2, a3, a4);
			}
			template<class U>
			R operator()(U&u, A1 a1, A2 a2, A3 a3, A4 a4)const
			{
				return call(u, &u, a1, a2, a3, a4);
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4)const
			{
				return call(u, &u, a1, a2, a3, a4);
			}
			R operator()(T&t, A1 a1, A2 a2, A3 a3, A4 a4)const
			{
				return (t.*f_)(a1, a2, a3, a4);
			}
			bool operator==(mf4 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf4 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4>
		class cmf4
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4)const;
			F f_;
			template<class U, class B1, class B2, class B3, class B4>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4)const
			{
				return (u.*f_)(b1, b2, b3, b4);
			}
			template<class U, class B1, class B2, class B3, class B4>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4);
			}
		public:
			explicit cmf4(F f): f_(f)
			{
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4)const
			{
				return call(u, &u, a1, a2, a3, a4);
			}
			R operator()(T const&t, A1 a1, A2 a2, A3 a3, A4 a4)const
			{
				return (t.*f_)(a1, a2, a3, a4);
			}
			bool operator==(cmf4 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf4 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4, class A5>
		class mf5
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4, A5);
			F f_;
			template<class U, class B1, class B2, class B3, class B4, class B5>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5)const
			{
				return (u.*f_)(b1, b2, b3, b4, b5);
			}
			template<class U, class B1, class B2, class B3, class B4, class B5>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
			}
		public:
			explicit mf5(F f): f_(f)
			{
			}
			R operator()(T*p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)const
			{
				return (p->*f_)(a1, a2, a3, a4, a5);
			}
			template<class U>
			R operator()(U&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)const
			{
				return call(u, &u, a1, a2, a3, a4, a5);
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)const
			{
				return call(u, &u, a1, a2, a3, a4, a5);
			}
			R operator()(T&t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)const
			{
				return (t.*f_)(a1, a2, a3, a4, a5);
			}
			bool operator==(mf5 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf5 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4, class A5>
		class cmf5
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4, A5)const;
			F f_;
			template<class U, class B1, class B2, class B3, class B4, class B5>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5)const
			{
				return (u.*f_)(b1, b2, b3, b4, b5);
			}
			template<class U, class B1, class B2, class B3, class B4, class B5>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5);
			}
		public:
			explicit cmf5(F f): f_(f)
			{
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)const
			{
				return call(u, &u, a1, a2, a3, a4, a5);
			}
			R operator()(T const&t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)const
			{
				return (t.*f_)(a1, a2, a3, a4, a5);
			}
			bool operator==(cmf5 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf5 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6>
		class mf6
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4, A5, A6);
			F f_;
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6)const
			{
				return (u.*f_)(b1, b2, b3, b4, b5, b6);
			}
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
			}
		public:
			explicit mf6(F f): f_(f)
			{
			}
			R operator()(T*p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)const
			{
				return (p->*f_)(a1, a2, a3, a4, a5, a6);
			}
			template<class U>
			R operator()(U&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6);
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6);
			}
			R operator()(T&t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)const
			{
				return (t.*f_)(a1, a2, a3, a4, a5, a6);
			}
			bool operator==(mf6 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf6 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6>
		class cmf6
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4, A5, A6)const;
			F f_;
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6)const
			{
				return (u.*f_)(b1, b2, b3, b4, b5, b6);
			}
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6);
			}
		public:
			explicit cmf6(F f): f_(f)
			{
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6);
			}
			R operator()(T const&t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)const
			{
				return (t.*f_)(a1, a2, a3, a4, a5, a6);
			}
			bool operator==(cmf6 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf6 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
		class mf7
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4, A5, A6, A7);
			F f_;
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6, B7&b7)const
			{
				return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
			}
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6, B7&b7)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
			}
		public:
			explicit mf7(F f): f_(f)
			{
			}
			R operator()(T*p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)const
			{
				return (p->*f_)(a1, a2, a3, a4, a5, a6, a7);
			}
			template<class U>
			R operator()(U&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
			}
			R operator()(T&t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)const
			{
				return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
			}
			bool operator==(mf7 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf7 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
		class cmf7
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4, A5, A6, A7)const;
			F f_;
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6, B7&b7)const
			{
				return (u.*f_)(b1, b2, b3, b4, b5, b6, b7);
			}
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6, B7&b7)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7);
			}
		public:
			explicit cmf7(F f): f_(f)
			{
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6, a7);
			}
			R operator()(T const&t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)const
			{
				return (t.*f_)(a1, a2, a3, a4, a5, a6, a7);
			}
			bool operator==(cmf7 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf7 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
		class mf8
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4, A5, A6, A7, A8);
			F f_;
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6, B7&b7, B8&b8)const
			{
				return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
			}
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6, B7&b7, B8&b8)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
			}
		public:
			explicit mf8(F f): f_(f)
			{
			}
			R operator()(T*p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)const
			{
				return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
			}
			template<class U>
			R operator()(U&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
			}
			R operator()(T&t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)const
			{
				return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
			}
			bool operator==(mf8 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(mf8 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
		template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
		class cmf8
		{
		public:
			typedef R result_type;
		private:
			typedef R(T::*F)(A1, A2, A3, A4, A5, A6, A7, A8)const;
			F f_;
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8>
			R call(U&u, T const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6, B7&b7, B8&b8)const
			{
				return (u.*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
			}
			template<class U, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8>
			R call(U&u, void const*, B1&b1, B2&b2, B3&b3, B4&b4, B5&b5, B6&b6, B7&b7, B8&b8)const
			{
				return (get_pointer(u)->*f_)(b1, b2, b3, b4, b5, b6, b7, b8);
			}
		public:
			explicit cmf8(F f): f_(f)
			{
			}
			R operator()(T const*p, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)const
			{
				return (p->*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
			}
			template<class U>
			R operator()(U const&u, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)const
			{
				return call(u, &u, a1, a2, a3, a4, a5, a6, a7, a8);
			}
			R operator()(T const&t, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)const
			{
				return (t.*f_)(a1, a2, a3, a4, a5, a6, a7, a8);
			}
			bool operator==(cmf8 const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(cmf8 const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
	}
	template<class R, class T>
	_mfi::mf0<R, T>mem_fn(R(T::*f)())
	{
		return _mfi::mf0<R, T>(f);
	}
	template<class R, class T>
	_mfi::cmf0<R, T>mem_fn(R(T::*f)()const)
	{
		return _mfi::cmf0<R, T>(f);
	}
	template<class R, class T, class A1>
	_mfi::mf1<R, T, A1>mem_fn(R(T::*f)(A1))
	{
		return _mfi::mf1<R, T, A1>(f);
	}
	template<class R, class T, class A1>
	_mfi::cmf1<R, T, A1>mem_fn(R(T::*f)(A1)const)
	{
		return _mfi::cmf1<R, T, A1>(f);
	}
	template<class R, class T, class A1, class A2>
	_mfi::mf2<R, T, A1, A2>mem_fn(R(T::*f)(A1, A2))
	{
		return _mfi::mf2<R, T, A1, A2>(f);
	}
	template<class R, class T, class A1, class A2>
	_mfi::cmf2<R, T, A1, A2>mem_fn(R(T::*f)(A1, A2)const)
	{
		return _mfi::cmf2<R, T, A1, A2>(f);
	}
	template<class R, class T, class A1, class A2, class A3>
	_mfi::mf3<R, T, A1, A2, A3>mem_fn(R(T::*f)(A1, A2, A3))
	{
		return _mfi::mf3<R, T, A1, A2, A3>(f);
	}
	template<class R, class T, class A1, class A2, class A3>
	_mfi::cmf3<R, T, A1, A2, A3>mem_fn(R(T::*f)(A1, A2, A3)const)
	{
		return _mfi::cmf3<R, T, A1, A2, A3>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4>
	_mfi::mf4<R, T, A1, A2, A3, A4>mem_fn(R(T::*f)(A1, A2, A3, A4))
	{
		return _mfi::mf4<R, T, A1, A2, A3, A4>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4>
	_mfi::cmf4<R, T, A1, A2, A3, A4>mem_fn(R(T::*f)(A1, A2, A3, A4)const)
	{
		return _mfi::cmf4<R, T, A1, A2, A3, A4>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4, class A5>
	_mfi::mf5<R, T, A1, A2, A3, A4, A5>mem_fn(R(T::*f)(A1, A2, A3, A4, A5))
	{
		return _mfi::mf5<R, T, A1, A2, A3, A4, A5>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4, class A5>
	_mfi::cmf5<R, T, A1, A2, A3, A4, A5>mem_fn(R(T::*f)(A1, A2, A3, A4, A5)const)
	{
		return _mfi::cmf5<R, T, A1, A2, A3, A4, A5>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6>
	_mfi::mf6<R, T, A1, A2, A3, A4, A5, A6>mem_fn(R(T::*f)(A1, A2, A3, A4, A5, A6))
	{
		return _mfi::mf6<R, T, A1, A2, A3, A4, A5, A6>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6>
	_mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6>mem_fn(R(T::*f)(A1, A2, A3, A4, A5, A6)const)
	{
		return _mfi::cmf6<R, T, A1, A2, A3, A4, A5, A6>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7>mem_fn(R(T::*f)(A1, A2, A3, A4, A5, A6, A7))
	{
		return _mfi::mf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7>mem_fn(R(T::*f)(A1, A2, A3, A4, A5, A6, A7)const)
	{
		return _mfi::cmf7<R, T, A1, A2, A3, A4, A5, A6, A7>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>mem_fn(R(T::*f)(A1, A2, A3, A4, A5, A6, A7, A8))
	{
		return _mfi::mf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
	}
	template<class R, class T, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>mem_fn(R(T::*f)(A1, A2, A3, A4, A5, A6, A7, A8)const)
	{
		return _mfi::cmf8<R, T, A1, A2, A3, A4, A5, A6, A7, A8>(f);
	}
	namespace _mfi
	{
		template<class R, class T>
		class dm
		{
		public:
			typedef R const&result_type;
			typedef T const*argument_type;
		private:
			typedef R(T::*F);
			F f_;
			template<class U>
			R const&call(U&u, T const*)const
			{
				return (u.*f_);
			}
			template<class U>
			R const&call(U&u, void const*)const
			{
				return (get_pointer(u)->*f_);
			}
		public:
			explicit dm(F f): f_(f)
			{
			}
			R&operator()(T*p)const
			{
				return (p->*f_);
			}
			R const&operator()(T const*p)const
			{
				return (p->*f_);
			}
			template<class U>
			R const&operator()(U const&u)const
			{
				return call(u, &u);
			}
			R&operator()(T&t)const
			{
				return (t.*f_);
			}
			R const&operator()(T const&t)const
			{
				return (t.*f_);
			}
			bool operator==(dm const&rhs)const
			{
				return f_==rhs.f_;
			}
			bool operator!=(dm const&rhs)const
			{
				return f_!=rhs.f_;
			}
		};
	}
	template<class R, class T>
	_mfi::dm<R, T>mem_fn(R T::*f)
	{
		return _mfi::dm<R, T>(f);
	}
}
namespace boost
{
	template<class T>
	struct type
	{
	};
}
namespace boost
{
	template<class T>
	struct is_placeholder
	{
		enum _vt
		{
			value=0
		};
	};
}
namespace boost
{
	template<int I>
	struct arg
	{
		arg()
		{
		}
		template<class T>
		arg(T const&)
		{
			typedef char T_must_be_placeholder[I==is_placeholder<T>::value?1: -1];
		}
	};
	template<int I>
	bool operator==(arg<I>const&, arg<I>const&)
	{
		return true;
	}
	template<int I>
	struct is_placeholder<arg<I> >
	{
		enum _vt
		{
			value=I
		};
	};
	template<int I>
	struct is_placeholder<arg<I>(*)()>
	{
		enum _vt
		{
			value=I
		};
	};
}
namespace boost
{
	template<typename Visitor, typename T>
	inline void visit_each(Visitor&visitor, const T&t, long)
	{
		visitor(t);
	}
	template<typename Visitor, typename T>
	inline void visit_each(Visitor&visitor, const T&t)
	{
		visit_each(visitor, t, 0);
	}
}
namespace boost
{
	namespace _bi
	{
		template<class A1>
		struct storage1
		{
			explicit storage1(A1 a1): a1_(a1)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				visit_each(v, a1_, 0);
			}
			A1 a1_;
		};
		template<int I>
		struct storage1<boost::arg<I> >
		{
			explicit storage1(boost::arg<I>)
			{
			}
			template<class V>
			void accept(V&)const
			{
			}
			static boost::arg<I>a1_()
			{
				return boost::arg<I>();
			}
		};
		template<int I>
		struct storage1<boost::arg<I>(*)()>
		{
			explicit storage1(boost::arg<I>(*)())
			{
			}
			template<class V>
			void accept(V&)const
			{
			}
			static boost::arg<I>a1_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2>
		struct storage2: public storage1<A1>
		{
			typedef storage1<A1>inherited;
			storage2(A1 a1, A2 a2): storage1<A1>(a1), a2_(a2)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
				visit_each(v, a2_, 0);
			}
			A2 a2_;
		};
		template<class A1, int I>
		struct storage2<A1, boost::arg<I> >: public storage1<A1>
		{
			typedef storage1<A1>inherited;
			storage2(A1 a1, boost::arg<I>): storage1<A1>(a1)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a2_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, int I>
		struct storage2<A1, boost::arg<I>(*)()>: public storage1<A1>
		{
			typedef storage1<A1>inherited;
			storage2(A1 a1, boost::arg<I>(*)()): storage1<A1>(a1)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a2_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3>
		struct storage3: public storage2<A1, A2>
		{
			typedef storage2<A1, A2>inherited;
			storage3(A1 a1, A2 a2, A3 a3): storage2<A1, A2>(a1, a2), a3_(a3)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
				visit_each(v, a3_, 0);
			}
			A3 a3_;
		};
		template<class A1, class A2, int I>
		struct storage3<A1, A2, boost::arg<I> >: public storage2<A1, A2>
		{
			typedef storage2<A1, A2>inherited;
			storage3(A1 a1, A2 a2, boost::arg<I>): storage2<A1, A2>(a1, a2)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a3_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, int I>
		struct storage3<A1, A2, boost::arg<I>(*)()>: public storage2<A1, A2>
		{
			typedef storage2<A1, A2>inherited;
			storage3(A1 a1, A2 a2, boost::arg<I>(*)()): storage2<A1, A2>(a1, a2)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a3_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4>
		struct storage4: public storage3<A1, A2, A3>
		{
			typedef storage3<A1, A2, A3>inherited;
			storage4(A1 a1, A2 a2, A3 a3, A4 a4): storage3<A1, A2, A3>(a1, a2, a3), a4_(a4)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
				visit_each(v, a4_, 0);
			}
			A4 a4_;
		};
		template<class A1, class A2, class A3, int I>
		struct storage4<A1, A2, A3, boost::arg<I> >: public storage3<A1, A2, A3>
		{
			typedef storage3<A1, A2, A3>inherited;
			storage4(A1 a1, A2 a2, A3 a3, boost::arg<I>): storage3<A1, A2, A3>(a1, a2, a3)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a4_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, int I>
		struct storage4<A1, A2, A3, boost::arg<I>(*)()>: public storage3<A1, A2, A3>
		{
			typedef storage3<A1, A2, A3>inherited;
			storage4(A1 a1, A2 a2, A3 a3, boost::arg<I>(*)()): storage3<A1, A2, A3>(a1, a2, a3)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a4_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5>
		struct storage5: public storage4<A1, A2, A3, A4>
		{
			typedef storage4<A1, A2, A3, A4>inherited;
			storage5(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5): storage4<A1, A2, A3, A4>(a1, a2, a3, a4), a5_(a5)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
				visit_each(v, a5_, 0);
			}
			A5 a5_;
		};
		template<class A1, class A2, class A3, class A4, int I>
		struct storage5<A1, A2, A3, A4, boost::arg<I> >: public storage4<A1, A2, A3, A4>
		{
			typedef storage4<A1, A2, A3, A4>inherited;
			storage5(A1 a1, A2 a2, A3 a3, A4 a4, boost::arg<I>): storage4<A1, A2, A3, A4>(a1, a2, a3, a4)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a5_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, int I>
		struct storage5<A1, A2, A3, A4, boost::arg<I>(*)()>: public storage4<A1, A2, A3, A4>
		{
			typedef storage4<A1, A2, A3, A4>inherited;
			storage5(A1 a1, A2 a2, A3 a3, A4 a4, boost::arg<I>(*)()): storage4<A1, A2, A3, A4>(a1, a2, a3, a4)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a5_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6>
		struct storage6: public storage5<A1, A2, A3, A4, A5>
		{
			typedef storage5<A1, A2, A3, A4, A5>inherited;
			storage6(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6): storage5<A1, A2, A3, A4, A5>(a1, a2, a3, a4, a5), a6_(a6)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
				visit_each(v, a6_, 0);
			}
			A6 a6_;
		};
		template<class A1, class A2, class A3, class A4, class A5, int I>
		struct storage6<A1, A2, A3, A4, A5, boost::arg<I> >: public storage5<A1, A2, A3, A4, A5>
		{
			typedef storage5<A1, A2, A3, A4, A5>inherited;
			storage6(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, boost::arg<I>): storage5<A1, A2, A3, A4, A5>(a1, a2, a3, a4, a5)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a6_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, int I>
		struct storage6<A1, A2, A3, A4, A5, boost::arg<I>(*)()>: public storage5<A1, A2, A3, A4, A5>
		{
			typedef storage5<A1, A2, A3, A4, A5>inherited;
			storage6(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, boost::arg<I>(*)()): storage5<A1, A2, A3, A4, A5>(a1, a2, a3, a4, a5)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a6_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
		struct storage7: public storage6<A1, A2, A3, A4, A5, A6>
		{
			typedef storage6<A1, A2, A3, A4, A5, A6>inherited;
			storage7(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7): storage6<A1, A2, A3, A4, A5, A6>(a1, a2, a3, a4, a5, a6), a7_(a7)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
				visit_each(v, a7_, 0);
			}
			A7 a7_;
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, int I>
		struct storage7<A1, A2, A3, A4, A5, A6, boost::arg<I> >: public storage6<A1, A2, A3, A4, A5, A6>
		{
			typedef storage6<A1, A2, A3, A4, A5, A6>inherited;
			storage7(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, boost::arg<I>): storage6<A1, A2, A3, A4, A5, A6>(a1, a2, a3, a4, a5, a6)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a7_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, int I>
		struct storage7<A1, A2, A3, A4, A5, A6, boost::arg<I>(*)()>: public storage6<A1, A2, A3, A4, A5, A6>
		{
			typedef storage6<A1, A2, A3, A4, A5, A6>inherited;
			storage7(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, boost::arg<I>(*)()): storage6<A1, A2, A3, A4, A5, A6>(a1, a2, a3, a4, a5, a6)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a7_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
		struct storage8: public storage7<A1, A2, A3, A4, A5, A6, A7>
		{
			typedef storage7<A1, A2, A3, A4, A5, A6, A7>inherited;
			storage8(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8): storage7<A1, A2, A3, A4, A5, A6, A7>(a1, a2, a3, a4, a5, a6, a7), a8_(a8)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
				visit_each(v, a8_, 0);
			}
			A8 a8_;
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, int I>
		struct storage8<A1, A2, A3, A4, A5, A6, A7, boost::arg<I> >: public storage7<A1, A2, A3, A4, A5, A6, A7>
		{
			typedef storage7<A1, A2, A3, A4, A5, A6, A7>inherited;
			storage8(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, boost::arg<I>): storage7<A1, A2, A3, A4, A5, A6, A7>(a1, a2, a3, a4, a5, a6, a7)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a8_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, int I>
		struct storage8<A1, A2, A3, A4, A5, A6, A7, boost::arg<I>(*)()>: public storage7<A1, A2, A3, A4, A5, A6, A7>
		{
			typedef storage7<A1, A2, A3, A4, A5, A6, A7>inherited;
			storage8(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, boost::arg<I>(*)()): storage7<A1, A2, A3, A4, A5, A6, A7>(a1, a2, a3, a4, a5, a6, a7)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a8_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
		struct storage9: public storage8<A1, A2, A3, A4, A5, A6, A7, A8>
		{
			typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8>inherited;
			storage9(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9): storage8<A1, A2, A3, A4, A5, A6, A7, A8>(a1, a2, a3, a4, a5, a6, a7, a8), a9_(a9)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
				visit_each(v, a9_, 0);
			}
			A9 a9_;
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, int I>
		struct storage9<A1, A2, A3, A4, A5, A6, A7, A8, boost::arg<I> >: public storage8<A1, A2, A3, A4, A5, A6, A7, A8>
		{
			typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8>inherited;
			storage9(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, boost::arg<I>): storage8<A1, A2, A3, A4, A5, A6, A7, A8>(a1, a2, a3, a4, a5, a6, a7, a8)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a9_()
			{
				return boost::arg<I>();
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, int I>
		struct storage9<A1, A2, A3, A4, A5, A6, A7, A8, boost::arg<I>(*)()>: public storage8<A1, A2, A3, A4, A5, A6, A7, A8>
		{
			typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8>inherited;
			storage9(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, boost::arg<I>(*)()): storage8<A1, A2, A3, A4, A5, A6, A7, A8>(a1, a2, a3, a4, a5, a6, a7, a8)
			{
			}
			template<class V>
			void accept(V&v)const
			{
				inherited::accept(v);
			}
			static boost::arg<I>a9_()
			{
				return boost::arg<I>();
			}
		};
	}
}
namespace boost
{
	template<class T>
	class weak_ptr;
	namespace _bi
	{
		template<class R, class F>
		struct result_traits
		{
			typedef R type;
		};
		struct unspecified
		{
		};
		template<class F>
		struct result_traits<unspecified, F>
		{
			typedef typename F::result_type type;
		};
		template<class F>
		struct result_traits<unspecified, reference_wrapper<F> >
		{
			typedef typename F::result_type type;
		};
		template<class T>
		bool ref_compare(T const&a, T const&b, long)
		{
			return a==b;
		}
		template<int I>
		bool ref_compare(arg<I>const&, arg<I>const&, int)
		{
			return true;
		}
		template<int I>
		bool ref_compare(arg<I>(*)(), arg<I>(*)(), int)
		{
			return true;
		}
		template<class T>
		bool ref_compare(reference_wrapper<T>const&a, reference_wrapper<T>const&b, int)
		{
			return a.get_pointer()==b.get_pointer();
		}
		template<class R, class F, class L>
		class bind_t;
		template<class R, class F, class L>
		bool ref_compare(bind_t<R, F, L>const&a, bind_t<R, F, L>const&b, int)
		{
			return a.compare(b);
		}
		template<class T>
		class value
		{
		public:
			value(T const&t): t_(t)
			{
			}
			T&get()
			{
				return t_;
			}
			T const&get()const
			{
				return t_;
			}
			bool operator==(value const&rhs)const
			{
				return t_==rhs.t_;
			}
		private:
			T t_;
		};
		template<class T>
		bool ref_compare(value<weak_ptr<T> >const&a, value<weak_ptr<T> >const&b, int)
		{
			return !(a.get()<b.get())&&!(b.get()<a.get());
		}
		template<class T>
		class type
		{
		};
		template<class F>
		struct unwrapper
		{
			static inline F&unwrap(F&f, long)
			{
				return f;
			}
			template<class F2>
			static inline F2&unwrap(reference_wrapper<F2>rf, int)
			{
				return rf.get();
			}
			template<class R, class T>
			static inline _mfi::dm<R, T>unwrap(R T::*pm, int)
			{
				return _mfi::dm<R, T>(pm);
			}
		};
		class list0
		{
		public:
			list0()
			{
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&, long)
			{
				return unwrapper<F>::unwrap(f, 0)();
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)();
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&, int)
			{
				unwrapper<F>::unwrap(f, 0)();
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&, int)const
			{
				unwrapper<F const>::unwrap(f, 0)();
			}
			template<class V>
			void accept(V&)const
			{
			}
			bool operator==(list0 const&)const
			{
				return true;
			}
		};
		template<class A1>
		class list1: private storage1<A1>
		{
		private:
			typedef storage1<A1>base_type;
		public:
			explicit list1(A1 a1): base_type(a1)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_]);
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list1 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0);
			}
		};
		struct logical_and;
		struct logical_or;
		template<class A1, class A2>
		class list2: private storage2<A1, A2>
		{
		private:
			typedef storage2<A1, A2>base_type;
		public:
			list2(A1 a1, A2 a2): base_type(a1, a2)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>)const
			{
				return base_type::a2_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>(*)())const
			{
				return base_type::a2_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);
			}
			template<class A>
			bool operator()(type<bool>, logical_and&, A&a, int)
			{
				return a[base_type::a1_]&&a[base_type::a2_];
			}
			template<class A>
			bool operator()(type<bool>, logical_and const&, A&a, int)const
			{
				return a[base_type::a1_]&&a[base_type::a2_];
			}
			template<class A>
			bool operator()(type<bool>, logical_or&, A&a, int)
			{
				return a[base_type::a1_]||a[base_type::a2_];
			}
			template<class A>
			bool operator()(type<bool>, logical_or const&, A&a, int)const
			{
				return a[base_type::a1_]||a[base_type::a2_];
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list2 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0)&&ref_compare(base_type::a2_, rhs.a2_, 0);
			}
		};
		template<class A1, class A2, class A3>
		class list3: private storage3<A1, A2, A3>
		{
		private:
			typedef storage3<A1, A2, A3>base_type;
		public:
			list3(A1 a1, A2 a2, A3 a3): base_type(a1, a2, a3)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>)const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>)const
			{
				return base_type::a3_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>(*)())const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>(*)())const
			{
				return base_type::a3_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_]);
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list3 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0)&&ref_compare(base_type::a2_, rhs.a2_, 0)&&ref_compare(base_type::a3_, rhs.a3_, 0);
			}
		};
		template<class A1, class A2, class A3, class A4>
		class list4: private storage4<A1, A2, A3, A4>
		{
		private:
			typedef storage4<A1, A2, A3, A4>base_type;
		public:
			list4(A1 a1, A2 a2, A3 a3, A4 a4): base_type(a1, a2, a3, a4)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>)const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>)const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>)const
			{
				return base_type::a4_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>(*)())const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>(*)())const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>(*)())const
			{
				return base_type::a4_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_]);
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list4 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0)&&ref_compare(base_type::a2_, rhs.a2_, 0)&&ref_compare(base_type::a3_, rhs.a3_, 0)&&ref_compare(base_type::a4_, rhs.a4_, 0);
			}
		};
		template<class A1, class A2, class A3, class A4, class A5>
		class list5: private storage5<A1, A2, A3, A4, A5>
		{
		private:
			typedef storage5<A1, A2, A3, A4, A5>base_type;
		public:
			list5(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5): base_type(a1, a2, a3, a4, a5)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>)const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>)const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>)const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>)const
			{
				return base_type::a5_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>(*)())const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>(*)())const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>(*)())const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>(*)())const
			{
				return base_type::a5_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_]);
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list5 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0)&&ref_compare(base_type::a2_, rhs.a2_, 0)&&ref_compare(base_type::a3_, rhs.a3_, 0)&&ref_compare(base_type::a4_, rhs.a4_, 0)&&ref_compare(base_type::a5_, rhs.a5_, 0);
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6>
		class list6: private storage6<A1, A2, A3, A4, A5, A6>
		{
		private:
			typedef storage6<A1, A2, A3, A4, A5, A6>base_type;
		public:
			list6(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6): base_type(a1, a2, a3, a4, a5, a6)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>)const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>)const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>)const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>)const
			{
				return base_type::a5_;
			}
			A6 operator[](boost::arg<6>)const
			{
				return base_type::a6_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>(*)())const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>(*)())const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>(*)())const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>(*)())const
			{
				return base_type::a5_;
			}
			A6 operator[](boost::arg<6>(*)())const
			{
				return base_type::a6_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_]);
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list6 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0)&&ref_compare(base_type::a2_, rhs.a2_, 0)&&ref_compare(base_type::a3_, rhs.a3_, 0)&&ref_compare(base_type::a4_, rhs.a4_, 0)&&ref_compare(base_type::a5_, rhs.a5_, 0)&&ref_compare(base_type::a6_, rhs.a6_, 0);
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
		class list7: private storage7<A1, A2, A3, A4, A5, A6, A7>
		{
		private:
			typedef storage7<A1, A2, A3, A4, A5, A6, A7>base_type;
		public:
			list7(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7): base_type(a1, a2, a3, a4, a5, a6, a7)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>)const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>)const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>)const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>)const
			{
				return base_type::a5_;
			}
			A6 operator[](boost::arg<6>)const
			{
				return base_type::a6_;
			}
			A7 operator[](boost::arg<7>)const
			{
				return base_type::a7_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>(*)())const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>(*)())const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>(*)())const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>(*)())const
			{
				return base_type::a5_;
			}
			A6 operator[](boost::arg<6>(*)())const
			{
				return base_type::a6_;
			}
			A7 operator[](boost::arg<7>(*)())const
			{
				return base_type::a7_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_]);
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list7 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0)&&ref_compare(base_type::a2_, rhs.a2_, 0)&&ref_compare(base_type::a3_, rhs.a3_, 0)&&ref_compare(base_type::a4_, rhs.a4_, 0)&&ref_compare(base_type::a5_, rhs.a5_, 0)&&ref_compare(base_type::a6_, rhs.a6_, 0)&&ref_compare(base_type::a7_, rhs.a7_, 0);
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
		class list8: private storage8<A1, A2, A3, A4, A5, A6, A7, A8>
		{
		private:
			typedef storage8<A1, A2, A3, A4, A5, A6, A7, A8>base_type;
		public:
			list8(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8): base_type(a1, a2, a3, a4, a5, a6, a7, a8)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>)const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>)const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>)const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>)const
			{
				return base_type::a5_;
			}
			A6 operator[](boost::arg<6>)const
			{
				return base_type::a6_;
			}
			A7 operator[](boost::arg<7>)const
			{
				return base_type::a7_;
			}
			A8 operator[](boost::arg<8>)const
			{
				return base_type::a8_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>(*)())const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>(*)())const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>(*)())const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>(*)())const
			{
				return base_type::a5_;
			}
			A6 operator[](boost::arg<6>(*)())const
			{
				return base_type::a6_;
			}
			A7 operator[](boost::arg<7>(*)())const
			{
				return base_type::a7_;
			}
			A8 operator[](boost::arg<8>(*)())const
			{
				return base_type::a8_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_]);
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list8 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0)&&ref_compare(base_type::a2_, rhs.a2_, 0)&&ref_compare(base_type::a3_, rhs.a3_, 0)&&ref_compare(base_type::a4_, rhs.a4_, 0)&&ref_compare(base_type::a5_, rhs.a5_, 0)&&ref_compare(base_type::a6_, rhs.a6_, 0)&&ref_compare(base_type::a7_, rhs.a7_, 0)&&ref_compare(base_type::a8_, rhs.a8_, 0);
			}
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
		class list9: private storage9<A1, A2, A3, A4, A5, A6, A7, A8, A9>
		{
		private:
			typedef storage9<A1, A2, A3, A4, A5, A6, A7, A8, A9>base_type;
		public:
			list9(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9): base_type(a1, a2, a3, a4, a5, a6, a7, a8, a9)
			{
			}
			A1 operator[](boost::arg<1>)const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>)const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>)const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>)const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>)const
			{
				return base_type::a5_;
			}
			A6 operator[](boost::arg<6>)const
			{
				return base_type::a6_;
			}
			A7 operator[](boost::arg<7>)const
			{
				return base_type::a7_;
			}
			A8 operator[](boost::arg<8>)const
			{
				return base_type::a8_;
			}
			A9 operator[](boost::arg<9>)const
			{
				return base_type::a9_;
			}
			A1 operator[](boost::arg<1>(*)())const
			{
				return base_type::a1_;
			}
			A2 operator[](boost::arg<2>(*)())const
			{
				return base_type::a2_;
			}
			A3 operator[](boost::arg<3>(*)())const
			{
				return base_type::a3_;
			}
			A4 operator[](boost::arg<4>(*)())const
			{
				return base_type::a4_;
			}
			A5 operator[](boost::arg<5>(*)())const
			{
				return base_type::a5_;
			}
			A6 operator[](boost::arg<6>(*)())const
			{
				return base_type::a6_;
			}
			A7 operator[](boost::arg<7>(*)())const
			{
				return base_type::a7_;
			}
			A8 operator[](boost::arg<8>(*)())const
			{
				return base_type::a8_;
			}
			A9 operator[](boost::arg<9>(*)())const
			{
				return base_type::a9_;
			}
			template<class T>
			T&operator[](_bi::value<T>&v)const
			{
				return v.get();
			}
			template<class T>
			T const&operator[](_bi::value<T>const&v)const
			{
				return v.get();
			}
			template<class T>
			T&operator[](reference_wrapper<T>const&v)const
			{
				return v.get();
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class L>
			typename result_traits<R, F>::type operator[](bind_t<R, F, L>const&b)const
			{
				return b.eval(*this);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F&f, A&a, long)
			{
				return unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
			}
			template<class R, class F, class A>
			R operator()(type<R>, F const&f, A&a, long)const
			{
				return unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
			}
			template<class F, class A>
			void operator()(type<void>, F&f, A&a, int)
			{
				unwrapper<F>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
			}
			template<class F, class A>
			void operator()(type<void>, F const&f, A&a, int)const
			{
				unwrapper<F const>::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_], a[base_type::a3_], a[base_type::a4_], a[base_type::a5_], a[base_type::a6_], a[base_type::a7_], a[base_type::a8_], a[base_type::a9_]);
			}
			template<class V>
			void accept(V&v)const
			{
				base_type::accept(v);
			}
			bool operator==(list9 const&rhs)const
			{
				return ref_compare(base_type::a1_, rhs.a1_, 0)&&ref_compare(base_type::a2_, rhs.a2_, 0)&&ref_compare(base_type::a3_, rhs.a3_, 0)&&ref_compare(base_type::a4_, rhs.a4_, 0)&&ref_compare(base_type::a5_, rhs.a5_, 0)&&ref_compare(base_type::a6_, rhs.a6_, 0)&&ref_compare(base_type::a7_, rhs.a7_, 0)&&ref_compare(base_type::a8_, rhs.a8_, 0)&&ref_compare(base_type::a9_, rhs.a9_, 0);
			}
		};
		template<class R, class F, class L>
		class bind_t
		{
		public:
			typedef bind_t this_type;
			bind_t(F f, L const&l): f_(f), l_(l)
			{
			}
			typedef typename result_traits<R, F>::type result_type;
			result_type operator()()
			{
				list0 a;
				return l_(type<result_type>(), f_, a, 0);
			}
			result_type operator()()const
			{
				list0 a;
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1>
			result_type operator()(A1&a1)
			{
				list1<A1&>a(a1);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1>
			result_type operator()(A1&a1)const
			{
				list1<A1&>a(a1);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1>
			result_type operator()(A1 const&a1)
			{
				list1<A1 const&>a(a1);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1>
			result_type operator()(A1 const&a1)const
			{
				list1<A1 const&>a(a1);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2>
			result_type operator()(A1&a1, A2&a2)
			{
				list2<A1&, A2&>a(a1, a2);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2>
			result_type operator()(A1&a1, A2&a2)const
			{
				list2<A1&, A2&>a(a1, a2);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2>
			result_type operator()(A1 const&a1, A2&a2)
			{
				list2<A1 const&, A2&>a(a1, a2);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2>
			result_type operator()(A1 const&a1, A2&a2)const
			{
				list2<A1 const&, A2&>a(a1, a2);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2>
			result_type operator()(A1&a1, A2 const&a2)
			{
				list2<A1&, A2 const&>a(a1, a2);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2>
			result_type operator()(A1&a1, A2 const&a2)const
			{
				list2<A1&, A2 const&>a(a1, a2);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2>
			result_type operator()(A1 const&a1, A2 const&a2)
			{
				list2<A1 const&, A2 const&>a(a1, a2);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2>
			result_type operator()(A1 const&a1, A2 const&a2)const
			{
				list2<A1 const&, A2 const&>a(a1, a2);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3>
			result_type operator()(A1&a1, A2&a2, A3&a3)
			{
				list3<A1&, A2&, A3&>a(a1, a2, a3);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3>
			result_type operator()(A1&a1, A2&a2, A3&a3)const
			{
				list3<A1&, A2&, A3&>a(a1, a2, a3);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3)
			{
				list3<A1 const&, A2 const&, A3 const&>a(a1, a2, a3);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3)const
			{
				list3<A1 const&, A2 const&, A3 const&>a(a1, a2, a3);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4)
			{
				list4<A1&, A2&, A3&, A4&>a(a1, a2, a3, a4);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4)const
			{
				list4<A1&, A2&, A3&, A4&>a(a1, a2, a3, a4);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4)
			{
				list4<A1 const&, A2 const&, A3 const&, A4 const&>a(a1, a2, a3, a4);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4)const
			{
				list4<A1 const&, A2 const&, A3 const&, A4 const&>a(a1, a2, a3, a4);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5)
			{
				list5<A1&, A2&, A3&, A4&, A5&>a(a1, a2, a3, a4, a5);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5)const
			{
				list5<A1&, A2&, A3&, A4&, A5&>a(a1, a2, a3, a4, a5);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5)
			{
				list5<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&>a(a1, a2, a3, a4, a5);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5)const
			{
				list5<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&>a(a1, a2, a3, a4, a5);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5, A6&a6)
			{
				list6<A1&, A2&, A3&, A4&, A5&, A6&>a(a1, a2, a3, a4, a5, a6);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5, A6&a6)const
			{
				list6<A1&, A2&, A3&, A4&, A5&, A6&>a(a1, a2, a3, a4, a5, a6);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5, A6 const&a6)
			{
				list6<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&, A6 const&>a(a1, a2, a3, a4, a5, a6);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5, A6 const&a6)const
			{
				list6<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&, A6 const&>a(a1, a2, a3, a4, a5, a6);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5, A6&a6, A7&a7)
			{
				list7<A1&, A2&, A3&, A4&, A5&, A6&, A7&>a(a1, a2, a3, a4, a5, a6, a7);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5, A6&a6, A7&a7)const
			{
				list7<A1&, A2&, A3&, A4&, A5&, A6&, A7&>a(a1, a2, a3, a4, a5, a6, a7);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5, A6 const&a6, A7 const&a7)
			{
				list7<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&, A6 const&, A7 const&>a(a1, a2, a3, a4, a5, a6, a7);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5, A6 const&a6, A7 const&a7)const
			{
				list7<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&, A6 const&, A7 const&>a(a1, a2, a3, a4, a5, a6, a7);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5, A6&a6, A7&a7, A8&a8)
			{
				list8<A1&, A2&, A3&, A4&, A5&, A6&, A7&, A8&>a(a1, a2, a3, a4, a5, a6, a7, a8);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5, A6&a6, A7&a7, A8&a8)const
			{
				list8<A1&, A2&, A3&, A4&, A5&, A6&, A7&, A8&>a(a1, a2, a3, a4, a5, a6, a7, a8);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5, A6 const&a6, A7 const&a7, A8 const&a8)
			{
				list8<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&, A6 const&, A7 const&, A8 const&>a(a1, a2, a3, a4, a5, a6, a7, a8);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5, A6 const&a6, A7 const&a7, A8 const&a8)const
			{
				list8<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&, A6 const&, A7 const&, A8 const&>a(a1, a2, a3, a4, a5, a6, a7, a8);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5, A6&a6, A7&a7, A8&a8, A9&a9)
			{
				list9<A1&, A2&, A3&, A4&, A5&, A6&, A7&, A8&, A9&>a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
			result_type operator()(A1&a1, A2&a2, A3&a3, A4&a4, A5&a5, A6&a6, A7&a7, A8&a8, A9&a9)const
			{
				list9<A1&, A2&, A3&, A4&, A5&, A6&, A7&, A8&, A9&>a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5, A6 const&a6, A7 const&a7, A8 const&a8, A9 const&a9)
			{
				list9<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&, A6 const&, A7 const&, A8 const&, A9 const&>a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
			result_type operator()(A1 const&a1, A2 const&a2, A3 const&a3, A4 const&a4, A5 const&a5, A6 const&a6, A7 const&a7, A8 const&a8, A9 const&a9)const
			{
				list9<A1 const&, A2 const&, A3 const&, A4 const&, A5 const&, A6 const&, A7 const&, A8 const&, A9 const&>a(a1, a2, a3, a4, a5, a6, a7, a8, a9);
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A>
			result_type eval(A&a)
			{
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class A>
			result_type eval(A&a)const
			{
				return l_(type<result_type>(), f_, a, 0);
			}
			template<class V>
			void accept(V&v)const
			{
				using boost::visit_each;
				visit_each(v, f_, 0);
				l_.accept(v);
			}
			bool compare(this_type const&rhs)const
			{
				return ref_compare(f_, rhs.f_, 0)&&l_==rhs.l_;
			}
		private:
			F f_;
			L l_;
		};
		template<class R, class F, class L>
		bool function_equal(bind_t<R, F, L>const&a, bind_t<R, F, L>const&b)
		{
			return a.compare(b);
		}
		template<class T, int I>
		struct add_value_2
		{
			typedef boost::arg<I>type;
		};
		template<class T>
		struct add_value_2<T, 0>
		{
			typedef _bi::value<T>type;
		};
		template<class T>
		struct add_value
		{
			typedef typename add_value_2<T, boost::is_placeholder<T>::value>::type type;
		};
		template<class T>
		struct add_value<value<T> >
		{
			typedef _bi::value<T>type;
		};
		template<class T>
		struct add_value<reference_wrapper<T> >
		{
			typedef reference_wrapper<T>type;
		};
		template<int I>
		struct add_value<arg<I> >
		{
			typedef boost::arg<I>type;
		};
		template<int I>
		struct add_value<arg<I>(*)()>
		{
			typedef boost::arg<I>(*type)();
		};
		template<class R, class F, class L>
		struct add_value<bind_t<R, F, L> >
		{
			typedef bind_t<R, F, L>type;
		};
		template<class A1>
		struct list_av_1
		{
			typedef typename add_value<A1>::type B1;
			typedef list1<B1>type;
		};
		template<class A1, class A2>
		struct list_av_2
		{
			typedef typename add_value<A1>::type B1;
			typedef typename add_value<A2>::type B2;
			typedef list2<B1, B2>type;
		};
		template<class A1, class A2, class A3>
		struct list_av_3
		{
			typedef typename add_value<A1>::type B1;
			typedef typename add_value<A2>::type B2;
			typedef typename add_value<A3>::type B3;
			typedef list3<B1, B2, B3>type;
		};
		template<class A1, class A2, class A3, class A4>
		struct list_av_4
		{
			typedef typename add_value<A1>::type B1;
			typedef typename add_value<A2>::type B2;
			typedef typename add_value<A3>::type B3;
			typedef typename add_value<A4>::type B4;
			typedef list4<B1, B2, B3, B4>type;
		};
		template<class A1, class A2, class A3, class A4, class A5>
		struct list_av_5
		{
			typedef typename add_value<A1>::type B1;
			typedef typename add_value<A2>::type B2;
			typedef typename add_value<A3>::type B3;
			typedef typename add_value<A4>::type B4;
			typedef typename add_value<A5>::type B5;
			typedef list5<B1, B2, B3, B4, B5>type;
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6>
		struct list_av_6
		{
			typedef typename add_value<A1>::type B1;
			typedef typename add_value<A2>::type B2;
			typedef typename add_value<A3>::type B3;
			typedef typename add_value<A4>::type B4;
			typedef typename add_value<A5>::type B5;
			typedef typename add_value<A6>::type B6;
			typedef list6<B1, B2, B3, B4, B5, B6>type;
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7>
		struct list_av_7
		{
			typedef typename add_value<A1>::type B1;
			typedef typename add_value<A2>::type B2;
			typedef typename add_value<A3>::type B3;
			typedef typename add_value<A4>::type B4;
			typedef typename add_value<A5>::type B5;
			typedef typename add_value<A6>::type B6;
			typedef typename add_value<A7>::type B7;
			typedef list7<B1, B2, B3, B4, B5, B6, B7>type;
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
		struct list_av_8
		{
			typedef typename add_value<A1>::type B1;
			typedef typename add_value<A2>::type B2;
			typedef typename add_value<A3>::type B3;
			typedef typename add_value<A4>::type B4;
			typedef typename add_value<A5>::type B5;
			typedef typename add_value<A6>::type B6;
			typedef typename add_value<A7>::type B7;
			typedef typename add_value<A8>::type B8;
			typedef list8<B1, B2, B3, B4, B5, B6, B7, B8>type;
		};
		template<class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
		struct list_av_9
		{
			typedef typename add_value<A1>::type B1;
			typedef typename add_value<A2>::type B2;
			typedef typename add_value<A3>::type B3;
			typedef typename add_value<A4>::type B4;
			typedef typename add_value<A5>::type B5;
			typedef typename add_value<A6>::type B6;
			typedef typename add_value<A7>::type B7;
			typedef typename add_value<A8>::type B8;
			typedef typename add_value<A9>::type B9;
			typedef list9<B1, B2, B3, B4, B5, B6, B7, B8, B9>type;
		};
		struct logical_not
		{
			template<class V>
			bool operator()(V const&v)const
			{
				return !v;
			}
		};
		template<class R, class F, class L>
		bind_t<bool, logical_not, list1<bind_t<R, F, L> > >operator!(bind_t<R, F, L>const&f)
		{
			typedef list1<bind_t<R, F, L> >list_type;
			return bind_t<bool, logical_not, list_type>(logical_not(), list_type(f));
		}
		struct equal
		{
			template<class V, class W>
			bool operator()(V const&v, W const&w)const
			{
				return v==w;
			}
		};
		template<class R, class F, class L, class A2>
		bind_t<bool, equal, list2<bind_t<R, F, L>, typename add_value<A2>::type> >operator==(bind_t<R, F, L>const&f, A2 a2)
		{
			typedef typename add_value<A2>::type B2;
			typedef list2<bind_t<R, F, L>, B2>list_type;
			return bind_t<bool, equal, list_type>(equal(), list_type(f, a2));
		}
		struct not_equal
		{
			template<class V, class W>
			bool operator()(V const&v, W const&w)const
			{
				return v!=w;
			}
		};
		template<class R, class F, class L, class A2>
		bind_t<bool, not_equal, list2<bind_t<R, F, L>, typename add_value<A2>::type> >operator!=(bind_t<R, F, L>const&f, A2 a2)
		{
			typedef typename add_value<A2>::type B2;
			typedef list2<bind_t<R, F, L>, B2>list_type;
			return bind_t<bool, not_equal, list_type>(not_equal(), list_type(f, a2));
		}
		struct less
		{
			template<class V, class W>
			bool operator()(V const&v, W const&w)const
			{
				return v<w;
			}
		};
		template<class R, class F, class L, class A2>
		bind_t<bool, less, list2<bind_t<R, F, L>, typename add_value<A2>::type> >operator<(bind_t<R, F, L>const&f, A2 a2)
		{
			typedef typename add_value<A2>::type B2;
			typedef list2<bind_t<R, F, L>, B2>list_type;
			return bind_t<bool, less, list_type>(less(), list_type(f, a2));
		}
		struct less_equal
		{
			template<class V, class W>
			bool operator()(V const&v, W const&w)const
			{
				return v<=w;
			}
		};
		template<class R, class F, class L, class A2>
		bind_t<bool, less_equal, list2<bind_t<R, F, L>, typename add_value<A2>::type> >operator<=(bind_t<R, F, L>const&f, A2 a2)
		{
			typedef typename add_value<A2>::type B2;
			typedef list2<bind_t<R, F, L>, B2>list_type;
			return bind_t<bool, less_equal, list_type>(less_equal(), list_type(f, a2));
		}
		struct greater
		{
			template<class V, class W>
			bool operator()(V const&v, W const&w)const
			{
				return v>w;
			}
		};
		template<class R, class F, class L, class A2>
		bind_t<bool, greater, list2<bind_t<R, F, L>, typename add_value<A2>::type> >operator>(bind_t<R, F, L>const&f, A2 a2)
		{
			typedef typename add_value<A2>::type B2;
			typedef list2<bind_t<R, F, L>, B2>list_type;
			return bind_t<bool, greater, list_type>(greater(), list_type(f, a2));
		}
		struct greater_equal
		{
			template<class V, class W>
			bool operator()(V const&v, W const&w)const
			{
				return v>=w;
			}
		};
		template<class R, class F, class L, class A2>
		bind_t<bool, greater_equal, list2<bind_t<R, F, L>, typename add_value<A2>::type> >operator>=(bind_t<R, F, L>const&f, A2 a2)
		{
			typedef typename add_value<A2>::type B2;
			typedef list2<bind_t<R, F, L>, B2>list_type;
			return bind_t<bool, greater_equal, list_type>(greater_equal(), list_type(f, a2));
		}
		struct logical_and
		{
			template<class V, class W>
			bool operator()(V const&v, W const&w)const
			{
				return v&&w;
			}
		};
		template<class R, class F, class L, class A2>
		bind_t<bool, logical_and, list2<bind_t<R, F, L>, typename add_value<A2>::type> >operator&&(bind_t<R, F, L>const&f, A2 a2)
		{
			typedef typename add_value<A2>::type B2;
			typedef list2<bind_t<R, F, L>, B2>list_type;
			return bind_t<bool, logical_and, list_type>(logical_and(), list_type(f, a2));
		}
		struct logical_or
		{
			template<class V, class W>
			bool operator()(V const&v, W const&w)const
			{
				return v||w;
			}
		};
		template<class R, class F, class L, class A2>
		bind_t<bool, logical_or, list2<bind_t<R, F, L>, typename add_value<A2>::type> >operator||(bind_t<R, F, L>const&f, A2 a2)
		{
			typedef typename add_value<A2>::type B2;
			typedef list2<bind_t<R, F, L>, B2>list_type;
			return bind_t<bool, logical_or, list_type>(logical_or(), list_type(f, a2));
		}
		template<class V, class T>
		void visit_each(V&v, value<T>const&t, int)
		{
			using boost::visit_each;
			visit_each(v, t.get(), 0);
		}
		template<class V, class R, class F, class L>
		void visit_each(V&v, bind_t<R, F, L>const&t, int)
		{
			t.accept(v);
		}
	}
	template<class T>
	struct is_bind_expression
	{
		enum _vt
		{
			value=0
		};
	};
	template<class R, class F, class L>
	struct is_bind_expression<_bi::bind_t<R, F, L> >
	{
		enum _vt
		{
			value=1
		};
	};
	template<class R, class F>
	_bi::bind_t<R, F, _bi::list0>bind(F f)
	{
		typedef _bi::list0 list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type());
	}
	template<class R, class F, class A1>
	_bi::bind_t<R, F, typename _bi::list_av_1<A1>::type>bind(F f, A1 a1)
	{
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1));
	}
	template<class R, class F, class A1, class A2>
	_bi::bind_t<R, F, typename _bi::list_av_2<A1, A2>::type>bind(F f, A1 a1, A2 a2)
	{
		typedef typename _bi::list_av_2<A1, A2>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2));
	}
	template<class R, class F, class A1, class A2, class A3>
	_bi::bind_t<R, F, typename _bi::list_av_3<A1, A2, A3>::type>bind(F f, A1 a1, A2 a2, A3 a3)
	{
		typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
	}
	template<class R, class F, class A1, class A2, class A3, class A4>
	_bi::bind_t<R, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4)
	{
		typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5>
	_bi::bind_t<R, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6>
	_bi::bind_t<R, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
	{
		typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_bi::bind_t<R, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
	{
		typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_bi::bind_t<R, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
	{
		typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	_bi::bind_t<R, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
	{
		typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
	}
	template<class R, class F>
	_bi::bind_t<R, F, _bi::list0>bind(boost::type<R>, F f)
	{
		typedef _bi::list0 list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type());
	}
	template<class R, class F, class A1>
	_bi::bind_t<R, F, typename _bi::list_av_1<A1>::type>bind(boost::type<R>, F f, A1 a1)
	{
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1));
	}
	template<class R, class F, class A1, class A2>
	_bi::bind_t<R, F, typename _bi::list_av_2<A1, A2>::type>bind(boost::type<R>, F f, A1 a1, A2 a2)
	{
		typedef typename _bi::list_av_2<A1, A2>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2));
	}
	template<class R, class F, class A1, class A2, class A3>
	_bi::bind_t<R, F, typename _bi::list_av_3<A1, A2, A3>::type>bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3)
	{
		typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
	}
	template<class R, class F, class A1, class A2, class A3, class A4>
	_bi::bind_t<R, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4)
	{
		typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5>
	_bi::bind_t<R, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6>
	_bi::bind_t<R, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
	{
		typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_bi::bind_t<R, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
	{
		typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_bi::bind_t<R, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
	{
		typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
	}
	template<class R, class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	_bi::bind_t<R, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>bind(boost::type<R>, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
	{
		typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
	}
	template<class F>
	_bi::bind_t<_bi::unspecified, F, _bi::list0>bind(F f)
	{
		typedef _bi::list0 list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type());
	}
	template<class F, class A1>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_1<A1>::type>bind(F f, A1 a1)
	{
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1));
	}
	template<class F, class A1, class A2>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_2<A1, A2>::type>bind(F f, A1 a1, A2 a2)
	{
		typedef typename _bi::list_av_2<A1, A2>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2));
	}
	template<class F, class A1, class A2, class A3>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_3<A1, A2, A3>::type>bind(F f, A1 a1, A2 a2, A3 a3)
	{
		typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3));
	}
	template<class F, class A1, class A2, class A3, class A4>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_4<A1, A2, A3, A4>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4)
	{
		typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4));
	}
	template<class F, class A1, class A2, class A3, class A4, class A5>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
	}
	template<class F, class A1, class A2, class A3, class A4, class A5, class A6>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
	{
		typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
	}
	template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
	{
		typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
	}
	template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
	{
		typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
	}
	template<class F, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	_bi::bind_t<_bi::unspecified, F, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>bind(F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
	{
		typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
		return _bi::bind_t<_bi::unspecified, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
	}
	template<class R>
	_bi::bind_t<R, R(*)(), _bi::list0>bind(R(*f)())
	{
		typedef R(*F)();
		typedef _bi::list0 list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type());
	}
	template<class R, class B1, class A1>
	_bi::bind_t<R, R(*)(B1), typename _bi::list_av_1<A1>::type>bind(R(*f)(B1), A1 a1)
	{
		typedef R(*F)(B1);
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1));
	}
	template<class R, class B1, class B2, class A1, class A2>
	_bi::bind_t<R, R(*)(B1, B2), typename _bi::list_av_2<A1, A2>::type>bind(R(*f)(B1, B2), A1 a1, A2 a2)
	{
		typedef R(*F)(B1, B2);
		typedef typename _bi::list_av_2<A1, A2>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2));
	}
	template<class R, class B1, class B2, class B3, class A1, class A2, class A3>
	_bi::bind_t<R, R(*)(B1, B2, B3), typename _bi::list_av_3<A1, A2, A3>::type>bind(R(*f)(B1, B2, B3), A1 a1, A2 a2, A3 a3)
	{
		typedef R(*F)(B1, B2, B3);
		typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3));
	}
	template<class R, class B1, class B2, class B3, class B4, class A1, class A2, class A3, class A4>
	_bi::bind_t<R, R(*)(B1, B2, B3, B4), typename _bi::list_av_4<A1, A2, A3, A4>::type>bind(R(*f)(B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4)
	{
		typedef R(*F)(B1, B2, B3, B4);
		typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4));
	}
	template<class R, class B1, class B2, class B3, class B4, class B5, class A1, class A2, class A3, class A4, class A5>
	_bi::bind_t<R, R(*)(B1, B2, B3, B4, B5), typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>bind(R(*f)(B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		typedef R(*F)(B1, B2, B3, B4, B5);
		typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5));
	}
	template<class R, class B1, class B2, class B3, class B4, class B5, class B6, class A1, class A2, class A3, class A4, class A5, class A6>
	_bi::bind_t<R, R(*)(B1, B2, B3, B4, B5, B6), typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>bind(R(*f)(B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
	{
		typedef R(*F)(B1, B2, B3, B4, B5, B6);
		typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6));
	}
	template<class R, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_bi::bind_t<R, R(*)(B1, B2, B3, B4, B5, B6, B7), typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>bind(R(*f)(B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
	{
		typedef R(*F)(B1, B2, B3, B4, B5, B6, B7);
		typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7));
	}
	template<class R, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_bi::bind_t<R, R(*)(B1, B2, B3, B4, B5, B6, B7, B8), typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>bind(R(*f)(B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
	{
		typedef R(*F)(B1, B2, B3, B4, B5, B6, B7, B8);
		typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8));
	}
	template<class R, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class B9, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	_bi::bind_t<R, R(*)(B1, B2, B3, B4, B5, B6, B7, B8, B9), typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>bind(R(*f)(B1, B2, B3, B4, B5, B6, B7, B8, B9), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
	{
		typedef R(*F)(B1, B2, B3, B4, B5, B6, B7, B8, B9);
		typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
		return _bi::bind_t<R, F, list_type>(f, list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
	}
	template<class R, class T, class A1>
	_bi::bind_t<R, _mfi::mf0<R, T>, typename _bi::list_av_1<A1>::type>bind(R(T::*f)(), A1 a1)
	{
		typedef _mfi::mf0<R, T>F;
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1));
	}
	template<class R, class T, class A1>
	_bi::bind_t<R, _mfi::cmf0<R, T>, typename _bi::list_av_1<A1>::type>bind(R(T::*f)()const, A1 a1)
	{
		typedef _mfi::cmf0<R, T>F;
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1));
	}
	template<class R, class T, class B1, class A1, class A2>
	_bi::bind_t<R, _mfi::mf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>bind(R(T::*f)(B1), A1 a1, A2 a2)
	{
		typedef _mfi::mf1<R, T, B1>F;
		typedef typename _bi::list_av_2<A1, A2>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2));
	}
	template<class R, class T, class B1, class A1, class A2>
	_bi::bind_t<R, _mfi::cmf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>bind(R(T::*f)(B1)const, A1 a1, A2 a2)
	{
		typedef _mfi::cmf1<R, T, B1>F;
		typedef typename _bi::list_av_2<A1, A2>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2));
	}
	template<class R, class T, class B1, class B2, class A1, class A2, class A3>
	_bi::bind_t<R, _mfi::mf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>bind(R(T::*f)(B1, B2), A1 a1, A2 a2, A3 a3)
	{
		typedef _mfi::mf2<R, T, B1, B2>F;
		typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3));
	}
	template<class R, class T, class B1, class B2, class A1, class A2, class A3>
	_bi::bind_t<R, _mfi::cmf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>bind(R(T::*f)(B1, B2)const, A1 a1, A2 a2, A3 a3)
	{
		typedef _mfi::cmf2<R, T, B1, B2>F;
		typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3));
	}
	template<class R, class T, class B1, class B2, class B3, class A1, class A2, class A3, class A4>
	_bi::bind_t<R, _mfi::mf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>bind(R(T::*f)(B1, B2, B3), A1 a1, A2 a2, A3 a3, A4 a4)
	{
		typedef _mfi::mf3<R, T, B1, B2, B3>F;
		typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4));
	}
	template<class R, class T, class B1, class B2, class B3, class A1, class A2, class A3, class A4>
	_bi::bind_t<R, _mfi::cmf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>bind(R(T::*f)(B1, B2, B3)const, A1 a1, A2 a2, A3 a3, A4 a4)
	{
		typedef _mfi::cmf3<R, T, B1, B2, B3>F;
		typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class A1, class A2, class A3, class A4, class A5>
	_bi::bind_t<R, _mfi::mf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>bind(R(T::*f)(B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		typedef _mfi::mf4<R, T, B1, B2, B3, B4>F;
		typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class A1, class A2, class A3, class A4, class A5>
	_bi::bind_t<R, _mfi::cmf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>bind(R(T::*f)(B1, B2, B3, B4)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		typedef _mfi::cmf4<R, T, B1, B2, B3, B4>F;
		typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class B5, class A1, class A2, class A3, class A4, class A5, class A6>
	_bi::bind_t<R, _mfi::mf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>bind(R(T::*f)(B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
	{
		typedef _mfi::mf5<R, T, B1, B2, B3, B4, B5>F;
		typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class B5, class A1, class A2, class A3, class A4, class A5, class A6>
	_bi::bind_t<R, _mfi::cmf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>bind(R(T::*f)(B1, B2, B3, B4, B5)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
	{
		typedef _mfi::cmf5<R, T, B1, B2, B3, B4, B5>F;
		typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_bi::bind_t<R, _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>bind(R(T::*f)(B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
	{
		typedef _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>F;
		typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_bi::bind_t<R, _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>bind(R(T::*f)(B1, B2, B3, B4, B5, B6)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
	{
		typedef _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>F;
		typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_bi::bind_t<R, _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>bind(R(T::*f)(B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
	{
		typedef _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>F;
		typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_bi::bind_t<R, _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>bind(R(T::*f)(B1, B2, B3, B4, B5, B6, B7)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
	{
		typedef _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>F;
		typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	_bi::bind_t<R, _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>bind(R(T::*f)(B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
	{
		typedef _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>F;
		typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
	}
	template<class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	_bi::bind_t<R, _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>bind(R(T::*f)(B1, B2, B3, B4, B5, B6, B7, B8)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
	{
		typedef _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>F;
		typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
		return _bi::bind_t<R, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
	}
	template<class Rt2, class R, class T, class A1>
	_bi::bind_t<Rt2, _mfi::mf0<R, T>, typename _bi::list_av_1<A1>::type>bind(boost::type<Rt2>, R(T::*f)(), A1 a1)
	{
		typedef _mfi::mf0<R, T>F;
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1));
	}
	template<class Rt2, class R, class T, class A1>
	_bi::bind_t<Rt2, _mfi::cmf0<R, T>, typename _bi::list_av_1<A1>::type>bind(boost::type<Rt2>, R(T::*f)()const, A1 a1)
	{
		typedef _mfi::cmf0<R, T>F;
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1));
	}
	template<class Rt2, class R, class T, class B1, class A1, class A2>
	_bi::bind_t<Rt2, _mfi::mf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>bind(boost::type<Rt2>, R(T::*f)(B1), A1 a1, A2 a2)
	{
		typedef _mfi::mf1<R, T, B1>F;
		typedef typename _bi::list_av_2<A1, A2>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2));
	}
	template<class Rt2, class R, class T, class B1, class A1, class A2>
	_bi::bind_t<Rt2, _mfi::cmf1<R, T, B1>, typename _bi::list_av_2<A1, A2>::type>bind(boost::type<Rt2>, R(T::*f)(B1)const, A1 a1, A2 a2)
	{
		typedef _mfi::cmf1<R, T, B1>F;
		typedef typename _bi::list_av_2<A1, A2>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2));
	}
	template<class Rt2, class R, class T, class B1, class B2, class A1, class A2, class A3>
	_bi::bind_t<Rt2, _mfi::mf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2), A1 a1, A2 a2, A3 a3)
	{
		typedef _mfi::mf2<R, T, B1, B2>F;
		typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3));
	}
	template<class Rt2, class R, class T, class B1, class B2, class A1, class A2, class A3>
	_bi::bind_t<Rt2, _mfi::cmf2<R, T, B1, B2>, typename _bi::list_av_3<A1, A2, A3>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2)const, A1 a1, A2 a2, A3 a3)
	{
		typedef _mfi::cmf2<R, T, B1, B2>F;
		typedef typename _bi::list_av_3<A1, A2, A3>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class A1, class A2, class A3, class A4>
	_bi::bind_t<Rt2, _mfi::mf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3), A1 a1, A2 a2, A3 a3, A4 a4)
	{
		typedef _mfi::mf3<R, T, B1, B2, B3>F;
		typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class A1, class A2, class A3, class A4>
	_bi::bind_t<Rt2, _mfi::cmf3<R, T, B1, B2, B3>, typename _bi::list_av_4<A1, A2, A3, A4>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3)const, A1 a1, A2 a2, A3 a3, A4 a4)
	{
		typedef _mfi::cmf3<R, T, B1, B2, B3>F;
		typedef typename _bi::list_av_4<A1, A2, A3, A4>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class A1, class A2, class A3, class A4, class A5>
	_bi::bind_t<Rt2, _mfi::mf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		typedef _mfi::mf4<R, T, B1, B2, B3, B4>F;
		typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class A1, class A2, class A3, class A4, class A5>
	_bi::bind_t<Rt2, _mfi::cmf4<R, T, B1, B2, B3, B4>, typename _bi::list_av_5<A1, A2, A3, A4, A5>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
	{
		typedef _mfi::cmf4<R, T, B1, B2, B3, B4>F;
		typedef typename _bi::list_av_5<A1, A2, A3, A4, A5>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class B5, class A1, class A2, class A3, class A4, class A5, class A6>
	_bi::bind_t<Rt2, _mfi::mf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4, B5), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
	{
		typedef _mfi::mf5<R, T, B1, B2, B3, B4, B5>F;
		typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class B5, class A1, class A2, class A3, class A4, class A5, class A6>
	_bi::bind_t<Rt2, _mfi::cmf5<R, T, B1, B2, B3, B4, B5>, typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4, B5)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
	{
		typedef _mfi::cmf5<R, T, B1, B2, B3, B4, B5>F;
		typedef typename _bi::list_av_6<A1, A2, A3, A4, A5, A6>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_bi::bind_t<Rt2, _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4, B5, B6), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
	{
		typedef _mfi::mf6<R, T, B1, B2, B3, B4, B5, B6>F;
		typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	_bi::bind_t<Rt2, _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>, typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4, B5, B6)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
	{
		typedef _mfi::cmf6<R, T, B1, B2, B3, B4, B5, B6>F;
		typedef typename _bi::list_av_7<A1, A2, A3, A4, A5, A6, A7>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_bi::bind_t<Rt2, _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4, B5, B6, B7), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
	{
		typedef _mfi::mf7<R, T, B1, B2, B3, B4, B5, B6, B7>F;
		typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	_bi::bind_t<Rt2, _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>, typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4, B5, B6, B7)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
	{
		typedef _mfi::cmf7<R, T, B1, B2, B3, B4, B5, B6, B7>F;
		typedef typename _bi::list_av_8<A1, A2, A3, A4, A5, A6, A7, A8>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	_bi::bind_t<Rt2, _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4, B5, B6, B7, B8), A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
	{
		typedef _mfi::mf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>F;
		typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
	}
	template<class Rt2, class R, class T, class B1, class B2, class B3, class B4, class B5, class B6, class B7, class B8, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	_bi::bind_t<Rt2, _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>, typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type>bind(boost::type<Rt2>, R(T::*f)(B1, B2, B3, B4, B5, B6, B7, B8)const, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
	{
		typedef _mfi::cmf8<R, T, B1, B2, B3, B4, B5, B6, B7, B8>F;
		typedef typename _bi::list_av_9<A1, A2, A3, A4, A5, A6, A7, A8, A9>::type list_type;
		return _bi::bind_t<Rt2, F, list_type>(F(f), list_type(a1, a2, a3, a4, a5, a6, a7, a8, a9));
	}
	namespace _bi
	{
		template<class Pm, int I>
		struct add_cref;
		template<class M, class T>
		struct add_cref<M T::*, 0>
		{
			typedef M type;
		};
		template<class M, class T>
		struct add_cref<M T::*, 1>
		{
			typedef M const&type;
		};
		template<class R, class T>
		struct add_cref<R(T::*)(), 1>
		{
			typedef void type;
		};
		template<class R, class T>
		struct add_cref<R(T::*)()const, 1>
		{
			typedef void type;
		};
		template<class R>
		struct isref
		{
			enum value_type
			{
				value=0
			};
		};
		template<class R>
		struct isref<R&>
		{
			enum value_type
			{
				value=1
			};
		};
		template<class R>
		struct isref<R*>
		{
			enum value_type
			{
				value=1
			};
		};
		template<class Pm, class A1>
		struct dm_result
		{
			typedef typename add_cref<Pm, 1>::type type;
		};
		template<class Pm, class R, class F, class L>
		struct dm_result<Pm, bind_t<R, F, L> >
		{
			typedef typename bind_t<R, F, L>::result_type result_type;
			typedef typename add_cref<Pm, isref<result_type>::value>::type type;
		};
	}
	template<class A1, class M, class T>
	_bi::bind_t<typename _bi::dm_result<M T::*, A1>::type, _mfi::dm<M, T>, typename _bi::list_av_1<A1>::type>bind(M T::*f, A1 a1)
	{
		typedef typename _bi::dm_result<M T::*, A1>::type result_type;
		typedef _mfi::dm<M, T>F;
		typedef typename _bi::list_av_1<A1>::type list_type;
		return _bi::bind_t<result_type, F, list_type>(F(f), list_type(a1));
	}
}
namespace
{
	static boost::arg<1>_1;
	static boost::arg<2>_2;
	static boost::arg<3>_3;
	static boost::arg<4>_4;
	static boost::arg<5>_5;
	static boost::arg<6>_6;
	static boost::arg<7>_7;
	static boost::arg<8>_8;
	static boost::arg<9>_9;
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			template<typename Node, typename Predicate>
			class duplicates_iterator
			{
			public:
				typedef typename Node::value_type value_type;
				typedef std::ptrdiff_t difference_type;
				typedef const typename Node::value_type*pointer;
				typedef const typename Node::value_type&reference;
				typedef std::forward_iterator_tag iterator_category;
				duplicates_iterator(Node*node_, Node*end_, Predicate pred_): node(node_), begin_chunk(0), end(end_), pred(pred_)
				{
					advance();
				}
				duplicates_iterator(Node*end_, Predicate pred_): node(end_), begin_chunk(end_), end(end_), pred(pred_)
				{
				}
				reference operator*()const
				{
					return node->value();
				}
				pointer operator->()const
				{
					return &node->value();
				}
				duplicates_iterator&operator++()
				{
					Node::increment(node);
					sync();
					return *this;
				}
				duplicates_iterator operator++(int)
				{
					duplicates_iterator tmp(*this);
					++(*this);
					return tmp;
				}
				Node*get_node()const
				{
					return node;
				}
			private:
				void sync()
				{
					if(node!=end&&pred(begin_chunk->value(), node->value()))advance();
				}
				void advance()
				{
					for(Node*node2=node;
					node!=end;
					node=node2)
					{
						Node::increment(node2);
						if(node2!=end&&!pred(node->value(), node2->value()))break;
					}
					begin_chunk=node;
				}
				Node*node;
				Node*begin_chunk;
				Node*end;
				Predicate pred;
			};
			template<typename Node, typename Predicate>
			bool operator==(const duplicates_iterator<Node, Predicate>&x, const duplicates_iterator<Node, Predicate>&y)
			{
				return x.get_node()==y.get_node();
			}
			template<typename Node, typename Predicate>
			bool operator!=(const duplicates_iterator<Node, Predicate>&x, const duplicates_iterator<Node, Predicate>&y)
			{
				return !(x==y);
			}
		}
	}
}
namespace boost
{
	namespace multi_index
	{
		namespace detail
		{
			struct ordered_unique_tag
			{
			};
			struct ordered_non_unique_tag
			{
			};
			template<typename KeyFromValue, typename Compare, typename SuperMeta, typename TagList, typename Category>
			class ordered_index: public SuperMeta::type
			{
				typedef typename SuperMeta::type super;
				protected: typedef ordered_index_node<typename super::node_type>node_type;
			private:
				typedef typename node_type::impl_type node_impl_type;
				typedef typename node_impl_type::pointer node_impl_pointer;
			public:
				typedef typename KeyFromValue::result_type key_type;
				typedef typename node_type::value_type value_type;
				typedef KeyFromValue key_from_value;
				typedef Compare key_compare;
				typedef value_comparison<value_type, KeyFromValue, Compare>value_compare;
				typedef tuple<key_from_value, key_compare>ctor_args;
				typedef typename super::final_allocator_type allocator_type;
				typedef typename allocator_type::reference reference;
				typedef typename allocator_type::const_reference const_reference;
				typedef bidir_node_iterator<node_type>iterator;
				typedef iterator const_iterator;
				typedef std::size_t size_type;
				typedef std::ptrdiff_t difference_type;
				typedef typename allocator_type::pointer pointer;
				typedef typename allocator_type::const_pointer const_pointer;
				typedef typename boost::reverse_iterator<iterator>reverse_iterator;
				typedef typename boost::reverse_iterator<const_iterator>const_reverse_iterator;
				typedef TagList tag_list;
				protected: typedef typename super::final_node_type final_node_type;
				typedef tuples::cons<ctor_args, typename super::ctor_args_list>ctor_args_list;
				typedef typename mpl::push_front<typename super::index_type_list, ordered_index>::type index_type_list;
				typedef typename mpl::push_front<typename super::iterator_type_list, iterator>::type iterator_type_list;
				typedef typename mpl::push_front<typename super::const_iterator_type_list, const_iterator>::type const_iterator_type_list;
				typedef typename super::copy_map_type copy_map_type;
				typedef typename super::index_saver_type index_saver_type;
				typedef typename super::index_loader_type index_loader_type;
			private:
				typedef typename call_traits<value_type>::param_type value_param_type;
				typedef typename call_traits<key_type>::param_type key_param_type;
			public:
				ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&operator=(const ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&x)
				{
					this->final()=x.final();
					return *this;
				}
				allocator_type get_allocator()const
				{
					return this->final().get_allocator();
				}
				iterator begin()
				{
					return make_iterator(leftmost());
				}
				const_iterator begin()const
				{
					return make_iterator(leftmost());
				}
				iterator end()
				{
					return make_iterator(header());
				}
				const_iterator end()const
				{
					return make_iterator(header());
				}
				reverse_iterator rbegin()
				{
					return make_reverse_iterator(end());
				}
				const_reverse_iterator rbegin()const
				{
					return make_reverse_iterator(end());
				}
				reverse_iterator rend()
				{
					return make_reverse_iterator(begin());
				}
				const_reverse_iterator rend()const
				{
					return make_reverse_iterator(begin());
				}
				const_iterator cbegin()const
				{
					return begin();
				}
				const_iterator cend()const
				{
					return end();
				}
				const_reverse_iterator crbegin()const
				{
					return rbegin();
				}
				const_reverse_iterator crend()const
				{
					return rend();
				}
				iterator iterator_to(const value_type&x)
				{
					return make_iterator(node_from_value<node_type>(&x));
				}
				const_iterator iterator_to(const value_type&x)const
				{
					return make_iterator(node_from_value<node_type>(&x));
				}
				bool empty()const
				{
					return this->final_empty_();
				}
				size_type size()const
				{
					return this->final_size_();
				}
				size_type max_size()const
				{
					return this->final_max_size_();
				}
				std::pair<iterator, bool>insert(value_param_type x)
				{
					;
					std::pair<final_node_type*, bool>p=this->final_insert_(x);
					return std::pair<iterator, bool>(make_iterator(p.first), p.second);
				}
				iterator insert(iterator position, value_param_type x)
				{
					((void)0);
					;
					((void)0);
					;
					;
					std::pair<final_node_type*, bool>p=this->final_insert_(x, static_cast<final_node_type*>(position.get_node()));
					return make_iterator(p.first);
				}
				template<typename InputIterator>
				void insert(InputIterator first, InputIterator last)
				{
					;
					iterator hint=end();
					for(;
					first!=last;
					++first)hint=insert(hint, *first);
				}
				iterator erase(iterator position)
				{
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					;
					this->final_erase_(static_cast<final_node_type*>(position++.get_node()));
					return position;
				}
				size_type erase(key_param_type x)
				{
					;
					std::pair<iterator, iterator>p=equal_range(x);
					size_type s=0;
					while(p.first!=p.second)
					{
						p.first=erase(p.first);
						++s;
					}
					return s;
				}
				iterator erase(iterator first, iterator last)
				{
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					;
					while(first!=last)
					{
						first=erase(first);
					}
					return first;
				}
				bool replace(iterator position, value_param_type x)
				{
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					;
					return this->final_replace_(x, static_cast<final_node_type*>(position.get_node()));
				}
				template<typename Modifier>
				bool modify(iterator position, Modifier mod)
				{
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					;
					return this->final_modify_(mod, static_cast<final_node_type*>(position.get_node()));
				}
				template<typename Modifier, typename Rollback>
				bool modify(iterator position, Modifier mod, Rollback back)
				{
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					;
					return this->final_modify_(mod, back, static_cast<final_node_type*>(position.get_node()));
				}
				template<typename Modifier>
				bool modify_key(iterator position, Modifier mod)
				{
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					;
					return modify(position, modify_key_adaptor<Modifier, value_type, KeyFromValue>(mod, key));
				}
				template<typename Modifier, typename Rollback>
				bool modify_key(iterator position, Modifier mod, Rollback back)
				{
					((void)0);
					;
					((void)0);
					;
					((void)0);
					;
					;
					return modify(position, modify_key_adaptor<Modifier, value_type, KeyFromValue>(mod, key), modify_key_adaptor<Modifier, value_type, KeyFromValue>(back, key));
				}
				void swap(ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&x)
				{
					;
					this->final_swap_(x.final());
				}
				void clear()
				{
					;
					this->final_clear_();
				}
				key_from_value key_extractor()const
				{
					return key;
				}
				key_compare key_comp()const
				{
					return comp;
				}
				value_compare value_comp()const
				{
					return value_compare(key, comp);
				}
				template<typename CompatibleKey>
				iterator find(const CompatibleKey&x)const
				{
					return make_iterator(ordered_index_find(root(), header(), key, x, comp));
				}
				template<typename CompatibleKey, typename CompatibleCompare>
				iterator find(const CompatibleKey&x, const CompatibleCompare&comp)const
				{
					return make_iterator(ordered_index_find(root(), header(), key, x, comp));
				}
				template<typename CompatibleKey>
				size_type count(const CompatibleKey&x)const
				{
					return count(x, comp);
				}
				template<typename CompatibleKey, typename CompatibleCompare>
				size_type count(const CompatibleKey&x, const CompatibleCompare&comp)const
				{
					std::pair<iterator, iterator>p=equal_range(x, comp);
					size_type n=std::distance(p.first, p.second);
					return n;
				}
				template<typename CompatibleKey>
				iterator lower_bound(const CompatibleKey&x)const
				{
					return make_iterator(ordered_index_lower_bound(root(), header(), key, x, comp));
				}
				template<typename CompatibleKey, typename CompatibleCompare>
				iterator lower_bound(const CompatibleKey&x, const CompatibleCompare&comp)const
				{
					return make_iterator(ordered_index_lower_bound(root(), header(), key, x, comp));
				}
				template<typename CompatibleKey>
				iterator upper_bound(const CompatibleKey&x)const
				{
					return make_iterator(ordered_index_upper_bound(root(), header(), key, x, comp));
				}
				template<typename CompatibleKey, typename CompatibleCompare>
				iterator upper_bound(const CompatibleKey&x, const CompatibleCompare&comp)const
				{
					return make_iterator(ordered_index_upper_bound(root(), header(), key, x, comp));
				}
				template<typename CompatibleKey>
				std::pair<iterator, iterator>equal_range(const CompatibleKey&x)const
				{
					std::pair<node_type*, node_type*>p=ordered_index_equal_range(root(), header(), key, x, comp);
					return std::pair<iterator, iterator>(make_iterator(p.first), make_iterator(p.second));
				}
				template<typename CompatibleKey, typename CompatibleCompare>
				std::pair<iterator, iterator>equal_range(const CompatibleKey&x, const CompatibleCompare&comp)const
				{
					std::pair<node_type*, node_type*>p=ordered_index_equal_range(root(), header(), key, x, comp);
					return std::pair<iterator, iterator>(make_iterator(p.first), make_iterator(p.second));
				}
				template<typename LowerBounder, typename UpperBounder>
				std::pair<iterator, iterator>range(LowerBounder lower, UpperBounder upper)const
				{
					typedef typename mpl::if_<is_same<LowerBounder, unbounded_type>, typename mpl::if_<is_same<UpperBounder, unbounded_type>, both_unbounded_tag, lower_unbounded_tag>::type, typename mpl::if_<is_same<UpperBounder, unbounded_type>, upper_unbounded_tag, none_unbounded_tag>::type>::type dispatch;
					return range(lower, upper, dispatch());
				}
			public:
				ordered_index(const ctor_args_list&args_list, const allocator_type&al): super(args_list.get_tail(), al), key(tuples::get<0>(args_list.get_head())), comp(tuples::get<1>(args_list.get_head()))
				{
					empty_initialize();
				}
				ordered_index(const ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&x): super(x), key(x.key), comp(x.comp)
				{
				}
				~ordered_index()
				{
				}
				iterator make_iterator(node_type*node)
				{
					return iterator(node);
				}
				const_iterator make_iterator(node_type*node)const
				{
					return const_iterator(node);
				}
				void copy_(const ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&x, const copy_map_type&map)
				{
					if(!x.root())
					{
						empty_initialize();
					}
					else
					{
						header()->color()=x.header()->color();
						node_type*root_cpy=map.find(static_cast<final_node_type*>(x.root()));
						header()->parent()=root_cpy->impl();
						node_type*leftmost_cpy=map.find(static_cast<final_node_type*>(x.leftmost()));
						header()->left()=leftmost_cpy->impl();
						node_type*rightmost_cpy=map.find(static_cast<final_node_type*>(x.rightmost()));
						header()->right()=rightmost_cpy->impl();
						typedef typename copy_map_type::const_iterator copy_map_iterator;
						for(copy_map_iterator it=map.begin(), it_end=map.end();
						it!=it_end;
						++it)
						{
							node_type*org=it->first;
							node_type*cpy=it->second;
							cpy->color()=org->color();
							node_impl_pointer parent_org=org->parent();
							if(parent_org==node_impl_pointer(0))cpy->parent()=node_impl_pointer(0);
							else
							{
								node_type*parent_cpy=map.find(static_cast<final_node_type*>(node_type::from_impl(parent_org)));
								cpy->parent()=parent_cpy->impl();
								if(parent_org->left()==org->impl())
								{
									parent_cpy->left()=cpy->impl();
								}
								else if(parent_org->right()==org->impl())
								{
									parent_cpy->right()=cpy->impl();
								}
							}
							if(org->left()==node_impl_pointer(0))cpy->left()=node_impl_pointer(0);
							if(org->right()==node_impl_pointer(0))cpy->right()=node_impl_pointer(0);
						}
					}
					super::copy_(x, map);
				}
				node_type*insert_(value_param_type v, node_type*x)
				{
					link_info inf;
					if(!link_point(key(v), inf, Category()))
					{
						return node_type::from_impl(inf.pos);
					}
					node_type*res=static_cast<node_type*>(super::insert_(v, x));
					if(res==x)
					{
						node_impl_type::link(x->impl(), inf.side, inf.pos, header()->impl());
					}
					return res;
				}
				node_type*insert_(value_param_type v, node_type*position, node_type*x)
				{
					link_info inf;
					if(!hinted_link_point(key(v), position, inf, Category()))
					{
						return node_type::from_impl(inf.pos);
					}
					node_type*res=static_cast<node_type*>(super::insert_(v, position, x));
					if(res==x)
					{
						node_impl_type::link(x->impl(), inf.side, inf.pos, header()->impl());
					}
					return res;
				}
				void erase_(node_type*x)
				{
					node_impl_type::rebalance_for_erase(x->impl(), header()->parent(), header()->left(), header()->right());
					super::erase_(x);
				}
				void delete_all_nodes_()
				{
					delete_all_nodes(root());
				}
				void clear_()
				{
					super::clear_();
					empty_initialize();
				}
				void swap_(ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&x)
				{
					std::swap(key, x.key);
					std::swap(comp, x.comp);
					super::swap_(x);
				}
				bool replace_(value_param_type v, node_type*x)
				{
					if(in_place(v, x, Category()))
					{
						return super::replace_(v, x);
					}
					node_type*next=x;
					node_type::increment(next);
					node_impl_type::rebalance_for_erase(x->impl(), header()->parent(), header()->left(), header()->right());

					{
						if(true)
						{
							link_info inf;
							if(link_point(key(v), inf, Category())&&super::replace_(v, x))
							{
								node_impl_type::link(x->impl(), inf.side, inf.pos, header()->impl());
								return true;
							}
							node_impl_type::restore(x->impl(), next->impl(), header()->impl());
							return false;
						}
						else if(false)
						{
							node_impl_type::restore(x->impl(), next->impl(), header()->impl());
							;
						}
					}
				}
				bool modify_(node_type*x)
				{
					bool b;

					{
						if(true)
						{
							b=in_place(x->value(), x, Category());
						}
						else if(false)
						{
							erase_(x);
							;
						}
					}
					if(!b)
					{
						node_impl_type::rebalance_for_erase(x->impl(), header()->parent(), header()->left(), header()->right());

						{
							if(true)
							{
								link_info inf;
								if(!link_point(key(x->value()), inf, Category()))
								{
									super::erase_(x);
									return false;
								}
								node_impl_type::link(x->impl(), inf.side, inf.pos, header()->impl());
							}
							else if(false)
							{
								super::erase_(x);
								;
							}
						}
					}

					{
						if(true)
						{
							if(!super::modify_(x))
							{
								node_impl_type::rebalance_for_erase(x->impl(), header()->parent(), header()->left(), header()->right());
								return false;
							}
							else return true;
						}
						else if(false)
						{
							node_impl_type::rebalance_for_erase(x->impl(), header()->parent(), header()->left(), header()->right());
							;
						}
					}
				}
				bool modify_rollback_(node_type*x)
				{
					if(in_place(x->value(), x, Category()))
					{
						return super::modify_rollback_(x);
					}
					node_type*next=x;
					node_type::increment(next);
					node_impl_type::rebalance_for_erase(x->impl(), header()->parent(), header()->left(), header()->right());

					{
						if(true)
						{
							link_info inf;
							if(link_point(key(x->value()), inf, Category())&&super::modify_rollback_(x))
							{
								node_impl_type::link(x->impl(), inf.side, inf.pos, header()->impl());
								return true;
							}
							node_impl_type::restore(x->impl(), next->impl(), header()->impl());
							return false;
						}
						else if(false)
						{
							node_impl_type::restore(x->impl(), next->impl(), header()->impl());
							;
						}
					}
				}
				template<typename Archive>
				void save_(Archive&ar, const unsigned int version, const index_saver_type&sm)const
				{
					save_(ar, version, sm, Category());
				}
				template<typename Archive>
				void load_(Archive&ar, const unsigned int version, const index_loader_type&lm)
				{
					load_(ar, version, lm, Category());
				}
			private:
				node_type*header()const
				{
					return this->final_header();
				}
				node_type*root()const
				{
					return node_type::from_impl(header()->parent());
				}
				node_type*leftmost()const
				{
					return node_type::from_impl(header()->left());
				}
				node_type*rightmost()const
				{
					return node_type::from_impl(header()->right());
				}
				void empty_initialize()
				{
					header()->color()=red;
					header()->parent()=node_impl_pointer(0);
					header()->left()=header()->impl();
					header()->right()=header()->impl();
				}
				struct link_info
				{
					link_info(): side(to_left)
					{
					}
					ordered_index_side side;
					node_impl_pointer pos;
				};
				bool link_point(key_param_type k, link_info&inf, ordered_unique_tag)
				{
					node_type*y=header();
					node_type*x=root();
					bool c=true;
					while(x)
					{
						y=x;
						c=comp(k, key(x->value()));
						x=node_type::from_impl(c?x->left(): x->right());
					}
					node_type*yy=y;
					if(c)
					{
						if(yy==leftmost())
						{
							inf.side=to_left;
							inf.pos=y->impl();
							return true;
						}
						else node_type::decrement(yy);
					}
					if(comp(key(yy->value()), k))
					{
						inf.side=c?to_left: to_right;
						inf.pos=y->impl();
						return true;
					}
					else
					{
						inf.pos=yy->impl();
						return false;
					}
				}
				bool link_point(key_param_type k, link_info&inf, ordered_non_unique_tag)
				{
					node_type*y=header();
					node_type*x=root();
					bool c=true;
					while(x)
					{
						y=x;
						c=comp(k, key(x->value()));
						x=node_type::from_impl(c?x->left(): x->right());
					}
					inf.side=c?to_left: to_right;
					inf.pos=y->impl();
					return true;
				}
				bool lower_link_point(key_param_type k, link_info&inf, ordered_non_unique_tag)
				{
					node_type*y=header();
					node_type*x=root();
					bool c=false;
					while(x)
					{
						y=x;
						c=comp(key(x->value()), k);
						x=node_type::from_impl(c?x->right(): x->left());
					}
					inf.side=c?to_right: to_left;
					inf.pos=y->impl();
					return true;
				}
				bool hinted_link_point(key_param_type k, node_type*position, link_info&inf, ordered_unique_tag)
				{
					if(position->impl()==header()->left())
					{
						if(size()>0&&comp(k, key(position->value())))
						{
							inf.side=to_left;
							inf.pos=position->impl();
							return true;
						}
						else return link_point(k, inf, ordered_unique_tag());
					}
					else if(position==header())
					{
						if(comp(key(rightmost()->value()), k))
						{
							inf.side=to_right;
							inf.pos=rightmost()->impl();
							return true;
						}
						else return link_point(k, inf, ordered_unique_tag());
					}
					else
					{
						node_type*before=position;
						node_type::decrement(before);
						if(comp(key(before->value()), k)&&comp(k, key(position->value())))
						{
							if(before->right()==node_impl_pointer(0))
							{
								inf.side=to_right;
								inf.pos=before->impl();
								return true;
							}
							else
							{
								inf.side=to_left;
								inf.pos=position->impl();
								return true;
							}
						}
						else return link_point(k, inf, ordered_unique_tag());
					}
				}
				bool hinted_link_point(key_param_type k, node_type*position, link_info&inf, ordered_non_unique_tag)
				{
					if(position->impl()==header()->left())
					{
						if(size()>0&&!comp(key(position->value()), k))
						{
							inf.side=to_left;
							inf.pos=position->impl();
							return true;
						}
						else return lower_link_point(k, inf, ordered_non_unique_tag());
					}
					else if(position==header())
					{
						if(!comp(k, key(rightmost()->value())))
						{
							inf.side=to_right;
							inf.pos=rightmost()->impl();
							return true;
						}
						else return link_point(k, inf, ordered_non_unique_tag());
					}
					else
					{
						node_type*before=position;
						node_type::decrement(before);
						if(!comp(k, key(before->value())))
						{
							if(!comp(key(position->value()), k))
							{
								if(before->right()==node_impl_pointer(0))
								{
									inf.side=to_right;
									inf.pos=before->impl();
									return true;
								}
								else
								{
									inf.side=to_left;
									inf.pos=position->impl();
									return true;
								}
							}
							else return lower_link_point(k, inf, ordered_non_unique_tag());
						}
						else return link_point(k, inf, ordered_non_unique_tag());
					}
				}
				void delete_all_nodes(node_type*x)
				{
					if(!x)return ;
					delete_all_nodes(node_type::from_impl(x->left()));
					delete_all_nodes(node_type::from_impl(x->right()));
					this->final_delete_node_(static_cast<final_node_type*>(x));
				}
				bool in_place(value_param_type v, node_type*x, ordered_unique_tag)
				{
					node_type*y;
					if(x!=leftmost())
					{
						y=x;
						node_type::decrement(y);
						if(!comp(key(y->value()), key(v)))return false;
					}
					y=x;
					node_type::increment(y);
					return y==header()||comp(key(v), key(y->value()));
				}
				bool in_place(value_param_type v, node_type*x, ordered_non_unique_tag)
				{
					node_type*y;
					if(x!=leftmost())
					{
						y=x;
						node_type::decrement(y);
						if(comp(key(v), key(y->value())))return false;
					}
					y=x;
					node_type::increment(y);
					return y==header()||!comp(key(y->value()), key(v));
				}
				template<typename LowerBounder, typename UpperBounder>
				std::pair<iterator, iterator>range(LowerBounder lower, UpperBounder upper, none_unbounded_tag)const
				{
					node_type*y=header();
					node_type*z=root();
					while(z)
					{
						if(!lower(key(z->value())))
						{
							z=node_type::from_impl(z->right());
						}
						else if(!upper(key(z->value())))
						{
							y=z;
							z=node_type::from_impl(z->left());
						}
						else
						{
							return std::pair<iterator, iterator>(make_iterator(lower_range(node_type::from_impl(z->left()), z, lower)), make_iterator(upper_range(node_type::from_impl(z->right()), y, upper)));
						}
					}
					return std::pair<iterator, iterator>(make_iterator(y), make_iterator(y));
				}
				template<typename LowerBounder, typename UpperBounder>
				std::pair<iterator, iterator>range(LowerBounder, UpperBounder upper, lower_unbounded_tag)const
				{
					return std::pair<iterator, iterator>(begin(), make_iterator(upper_range(root(), header(), upper)));
				}
				template<typename LowerBounder, typename UpperBounder>
				std::pair<iterator, iterator>range(LowerBounder lower, UpperBounder, upper_unbounded_tag)const
				{
					return std::pair<iterator, iterator>(make_iterator(lower_range(root(), header(), lower)), end());
				}
				template<typename LowerBounder, typename UpperBounder>
				std::pair<iterator, iterator>range(LowerBounder, UpperBounder, both_unbounded_tag)const
				{
					return std::pair<iterator, iterator>(begin(), end());
				}
				template<typename LowerBounder>
				node_type*lower_range(node_type*top, node_type*y, LowerBounder lower)const
				{
					while(top)
					{
						if(lower(key(top->value())))
						{
							y=top;
							top=node_type::from_impl(top->left());
						}
						else top=node_type::from_impl(top->right());
					}
					return y;
				}
				template<typename UpperBounder>
				node_type*upper_range(node_type*top, node_type*y, UpperBounder upper)const
				{
					while(top)
					{
						if(!upper(key(top->value())))
						{
							y=top;
							top=node_type::from_impl(top->left());
						}
						else top=node_type::from_impl(top->right());
					}
					return y;
				}
				template<typename Archive>
				void save_(Archive&ar, const unsigned int version, const index_saver_type&sm, ordered_unique_tag)const
				{
					super::save_(ar, version, sm);
				}
				template<typename Archive>
				void load_(Archive&ar, const unsigned int version, const index_loader_type&lm, ordered_unique_tag)
				{
					super::load_(ar, version, lm);
				}
				template<typename Archive>
				void save_(Archive&ar, const unsigned int version, const index_saver_type&sm, ordered_non_unique_tag)const
				{
					typedef duplicates_iterator<node_type, value_compare>dup_iterator;
					sm.save(dup_iterator(begin().get_node(), end().get_node(), value_comp()), dup_iterator(end().get_node(), value_comp()), ar, version);
					super::save_(ar, version, sm);
				}
				template<typename Archive>
				void load_(Archive&ar, const unsigned int version, const index_loader_type&lm, ordered_non_unique_tag)
				{
					lm.load(::boost::bind(&ordered_index::rearranger, this, _1, _2), ar, version);
					super::load_(ar, version, lm);
				}
				void rearranger(node_type*position, node_type*x)
				{
					if(!position||comp(key(position->value()), key(x->value())))
					{
						position=lower_bound(key(x->value())).get_node();
					}
					else if(comp(key(x->value()), key(position->value())))
					{
						throw_exception(archive::archive_exception(archive::archive_exception::other_exception));
					}
					else node_type::increment(position);
					if(position!=x)
					{
						node_impl_type::rebalance_for_erase(x->impl(), header()->parent(), header()->left(), header()->right());
						node_impl_type::restore(x->impl(), position->impl(), header()->impl());
					}
				}
				key_from_value key;
				key_compare comp;
			};
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator==(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y)
			{
				return x.size()==y.size()&&std::equal(x.begin(), x.end(), y.begin());
			}
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator<(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y)
			{
				return std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
			}
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator!=(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y)
			{
				return !(x==y);
			}
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator>(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y)
			{
				return y<x;
			}
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator>=(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y)
			{
				return !(x<y);
			}
			template<typename KeyFromValue1, typename Compare1, typename SuperMeta1, typename TagList1, typename Category1, typename KeyFromValue2, typename Compare2, typename SuperMeta2, typename TagList2, typename Category2>
			bool operator<=(const ordered_index<KeyFromValue1, Compare1, SuperMeta1, TagList1, Category1>&x, const ordered_index<KeyFromValue2, Compare2, SuperMeta2, TagList2, Category2>&y)
			{
				return !(x>y);
			}
			template<typename KeyFromValue, typename Compare, typename SuperMeta, typename TagList, typename Category>
			void swap(ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&x, ordered_index<KeyFromValue, Compare, SuperMeta, TagList, Category>&y)
			{
				x.swap(y);
			}
		}
		template<typename Arg1, typename Arg2, typename Arg3>
		struct ordered_unique
		{
			typedef typename detail::ordered_index_args<Arg1, Arg2, Arg3>index_args;
			typedef typename index_args::tag_list_type::type tag_list_type;
			typedef typename index_args::key_from_value_type key_from_value_type;
			typedef typename index_args::compare_type compare_type;
			template<typename Super>
			struct node_class
			{
				typedef detail::ordered_index_node<Super>type;
			};
			template<typename SuperMeta>
			struct index_class
			{
				typedef detail::ordered_index<key_from_value_type, compare_type, SuperMeta, tag_list_type, detail::ordered_unique_tag>type;
			};
		};
		template<typename Arg1, typename Arg2, typename Arg3>
		struct ordered_non_unique
		{
			typedef detail::ordered_index_args<Arg1, Arg2, Arg3>index_args;
			typedef typename index_args::tag_list_type::type tag_list_type;
			typedef typename index_args::key_from_value_type key_from_value_type;
			typedef typename index_args::compare_type compare_type;
			template<typename Super>
			struct node_class
			{
				typedef detail::ordered_index_node<Super>type;
			};
			template<typename SuperMeta>
			struct index_class
			{
				typedef detail::ordered_index<key_from_value_type, compare_type, SuperMeta, tag_list_type, detail::ordered_non_unique_tag>type;
			};
		};
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			struct from
			{
			};
			struct to
			{
			};
			template<typename FromType, typename ToType>
			struct bidirectional_map
			{
				typedef std::pair<FromType, ToType>value_type;
				typedef boost::multi_index::multi_index_container<value_type, boost::multi_index::indexed_by<boost::multi_index::ordered_unique<boost::multi_index::tag<from>, boost::multi_index::member<value_type, FromType, &value_type::first> >, boost::multi_index::ordered_non_unique<boost::multi_index::tag<to>, boost::multi_index::member<value_type, ToType, &value_type::second> > > >type;
			};
			class include_paths
			{
			private:
				typedef std::list<std::pair<boost::filesystem::path, std::string> >include_list_type;
				typedef include_list_type::value_type include_value_type;
				typedef bidirectional_map<std::string, std::string>::type pragma_once_set_type;
			public:
				include_paths(): was_sys_include_path(false), current_dir(initial_path()), current_rel_dir(initial_path())
				{
				}
				bool add_include_path(char const*path_, bool is_system=false)
				{
					return add_include_path(path_, (is_system||was_sys_include_path)?system_include_paths: user_include_paths);
				}
				void set_sys_include_delimiter()
				{
					was_sys_include_path=true;
				}
				bool find_include_file(std::string&s, std::string&dir, bool is_system, char const*current_file)const;
				void set_current_directory(char const*path_);
				boost::filesystem::path get_current_directory()const
				{
					return current_dir;
				}
				protected: bool find_include_file(std::string&s, std::string&dir, include_list_type const&pathes, char const*)const;
				bool add_include_path(char const*path_, include_list_type&pathes_);
			private:
				include_list_type user_include_paths;
				include_list_type system_include_paths;
				bool was_sys_include_path;
				boost::filesystem::path current_dir;
				boost::filesystem::path current_rel_dir;
			public:
				bool has_pragma_once(std::string const&filename)
				{
					using namespace boost::multi_index;
					return get<from>(pragma_once_files).find(filename)!=pragma_once_files.end();
				}
				bool add_pragma_once_header(std::string const&filename, std::string const&guard_name)
				{
					typedef pragma_once_set_type::value_type value_type;
					return pragma_once_files.insert(value_type(filename, guard_name)).second;
				}
				bool remove_pragma_once_header(std::string const&guard_name)
				{
					typedef pragma_once_set_type::index_iterator<to>::type to_iterator;
					typedef std::pair<to_iterator, to_iterator>range_type;
					range_type r=pragma_once_files.get<to>().equal_range(guard_name);
					if(r.first!=r.second)
					{
						using namespace boost::multi_index;
						get<to>(pragma_once_files).erase(r.first, r.second);
						return true;
					}
					return false;
				}
			private:
				pragma_once_set_type pragma_once_files;
			};
			inline bool include_paths::add_include_path(char const*path_, include_list_type&pathes_)
			{
				namespace fs=boost::filesystem;
				if(path_)
				{
					fs::path newpath=fs::complete(create_path(path_), current_dir);
					if(!fs::exists(newpath)||!fs::is_directory(newpath))
					{
						return false;
					}
					pathes_.push_back(include_value_type(newpath, path_));
					return true;
				}
				return false;
			}
			inline bool include_paths::find_include_file(std::string&s, std::string&dir, include_list_type const&pathes, char const*current_file)const
			{
				namespace fs=boost::filesystem;
				typedef include_list_type::const_iterator const_include_list_iter_t;
				const_include_list_iter_t it=pathes.begin();
				const_include_list_iter_t include_paths_end=pathes.end();
				if(0!=current_file)
				{
					fs::path file_path(create_path(current_file));
					for(;
					it!=include_paths_end;
					++it)
					{
						fs::path currpath(create_path((*it).first.string()));
						if(std::equal(currpath.begin(), currpath.end(), file_path.begin()))
						{
							++it;
							break;
						}
					}
				}
				for(;
				it!=include_paths_end;
				++it)
				{
					fs::path currpath(create_path(s));
					if(!currpath.has_root_directory())
					{
						currpath=create_path((*it).first.string());
						currpath/=create_path(s);
					}
					if(fs::exists(currpath))
					{
						fs::path dirpath(create_path(s));
						if(!dirpath.has_root_directory())
						{
							dirpath=create_path((*it).second);
							dirpath/=create_path(s);
						}
						dir=dirpath.string();
						s=normalize(currpath).string();
						return true;
					}
				}
				return false;
			}
			inline bool include_paths::find_include_file(std::string&s, std::string&dir, bool is_system, char const*current_file)const
			{
				namespace fs=boost::filesystem;
				if(!is_system)
				{
					if(!was_sys_include_path)
					{
						fs::path currpath(create_path(s));
						if(!currpath.has_root_directory())
						{
							currpath=create_path(current_dir.string());
							currpath/=create_path(s);
						}
						if(fs::exists(currpath)&&0==current_file)
						{
							fs::path dirpath(create_path(s));
							if(!dirpath.has_root_directory())
							{
								dirpath=create_path(current_rel_dir.string());
								dirpath/=create_path(s);
							}
							dir=dirpath.string();
							s=normalize(currpath).string();
							return true;
						}
						if(find_include_file(s, dir, user_include_paths, current_file))return true;
					}
					else
					{
						return find_include_file(s, dir, user_include_paths, current_file);
					}
				}
				return find_include_file(s, dir, system_include_paths, current_file);
			}
			inline void include_paths::set_current_directory(char const*path_)
			{
				namespace fs=boost::filesystem;
				fs::path filepath(create_path(path_));
				fs::path filename=fs::complete(filepath, current_dir);
				if(fs::exists(filename)&&fs::is_directory(filename))
				{
					current_dir=filename;
					current_rel_dir=filepath;
				}
				else
				{
					current_dir=branch_path(filename);
					current_rel_dir=branch_path(filepath);
				}
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			template<typename IterationContextT>
			class iteration_context_stack
			{
				typedef std::stack<IterationContextT>base_type;
			public:
				typedef typename base_type::size_type size_type;
				iteration_context_stack(): max_include_nesting_depth(1024)
				{
				}
				void set_max_include_nesting_depth(size_type new_depth)
				{
					max_include_nesting_depth=new_depth;
				}
				size_type get_max_include_nesting_depth()const
				{
					return max_include_nesting_depth;
				}
				typename base_type::size_type size()const
				{
					return iter_ctx.size();
				}
				typename base_type::value_type&top()
				{
					return iter_ctx.top();
				}
				void pop()
				{
					iter_ctx.pop();
				}
				template<typename Context, typename PositionT>
				void push(Context&ctx, PositionT const&pos, typename base_type::value_type const&val)
				{
					if(iter_ctx.size()==max_include_nesting_depth)
					{
						char buffer[22];
						using namespace std;
						sprintf(buffer, "%d", (int)max_include_nesting_depth);

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::include_nesting_too_deep)<<": "<<preprocess_exception::error_text(preprocess_exception::include_nesting_too_deep);
							if((buffer)[0]!=0)stream<<": "<<(buffer);
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::include_nesting_too_deep, (pos).get_line(), (pos).get_column(), (pos).get_file().c_str()));
						};
					}
					iter_ctx.push(val);
				}
			private:
				size_type max_include_nesting_depth;
				base_type iter_ctx;
			};
		}
	}
}
namespace std
{
	using::isalnum;
	using::isalpha;
	using::iscntrl;
	using::isdigit;
	using::isgraph;
	using::islower;
	using::isprint;
	using::ispunct;
	using::isspace;
	using::isupper;
	using::isxdigit;
	using::tolower;
	using::toupper;
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename QueueT, typename T, typename PointerT>
				class fsq_iterator: public boost::iterator_adaptor<fsq_iterator<QueueT, T, PointerT>, PointerT, T, std::random_access_iterator_tag>
				{
				public:
					typedef typename QueueT::position_t position;
					typedef boost::iterator_adaptor<fsq_iterator<QueueT, T, PointerT>, PointerT, T, std::random_access_iterator_tag>base_t;
					fsq_iterator()
					{
					}
					fsq_iterator(position const&p_): p(p_)
					{
					}
					position const&get_position()const
					{
						return p;
					}
				private:
					friend class boost::iterator_core_access;
					typename base_t::reference dereference()const
					{
						return p.self->m_queue[p.pos];
					}
					void increment()
					{
						++p.pos;
						if(p.pos==QueueT::MAX_SIZE+1)p.pos=0;
					}
					void decrement()
					{
						if(p.pos==0)p.pos=QueueT::MAX_SIZE;
						else--p.pos;
					}
					template<typename OtherDerivedT, typename OtherIteratorT, typename V, typename C, typename R, typename D>
					bool equal(iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D>const&x)const
					{
						position const&rhs_pos=static_cast<OtherDerivedT const&>(x).get_position();
						return (p.self==rhs_pos.self)&&(p.pos==rhs_pos.pos);
					}
					template<typename OtherDerivedT, typename OtherIteratorT, typename V, typename C, typename R, typename D>
					typename base_t::difference_type distance_to(iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D>const&x)const
					{
						typedef typename base_t::difference_type diff_t;
						position const&p2=static_cast<OtherDerivedT const&>(x).get_position();
						std::size_t pos1=p.pos;
						std::size_t pos2=p2.pos;
						(void)((!!(p.self==p2.self))||(_wassert(L"p.self == p2.self", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 113), 0));
						if(pos1<p.self->m_head)pos1+=QueueT::MAX_SIZE;
						if(pos2<p2.self->m_head)pos2+=QueueT::MAX_SIZE;
						if(pos2>pos1)return diff_t(pos2-pos1);
						else return -diff_t(pos1-pos2);
					}
					void advance(typename base_t::difference_type n)
					{
						if(n<0)
						{
							n=-n;
							if(p.pos<(std::size_t)n)p.pos=QueueT::MAX_SIZE+1-(n-p.pos);
							else p.pos-=n;
						}
						else
						{
							p.pos+=n;
							if(p.pos>=QueueT::MAX_SIZE+1)p.pos-=QueueT::MAX_SIZE+1;
						}
					}
				private:
					position p;
				};
			}
			template<typename T, std::size_t N>
			class fixed_size_queue
			{
			private:
				struct position
				{
					fixed_size_queue*self;
					std::size_t pos;
					position(): self(0), pos(0)
					{
					}
					position(const fixed_size_queue*s, std::size_t p): self(const_cast<fixed_size_queue*>(s)), pos(p)
					{
					}
				};
			public:
				typedef impl::fsq_iterator<fixed_size_queue<T, N>, T, T*>iterator;
				typedef impl::fsq_iterator<fixed_size_queue<T, N>, T const, T const*>const_iterator;
				typedef position position_t;
				friend class impl::fsq_iterator<fixed_size_queue<T, N>, T, T*>;
				friend class impl::fsq_iterator<fixed_size_queue<T, N>, T const, T const*>;
				fixed_size_queue();
				fixed_size_queue(const fixed_size_queue&x);
				fixed_size_queue&operator=(const fixed_size_queue&x);
				~fixed_size_queue();
				void push_back(const T&e);
				void push_front(const T&e);
				void serve(T&e);
				void pop_front();
				bool empty()const
				{
					return m_size==0;
				}
				bool full()const
				{
					return m_size==N;
				}
				iterator begin()
				{
					return iterator(position(this, m_head));
				}
				const_iterator begin()const
				{
					return const_iterator(position(this, m_head));
				}
				iterator end()
				{
					return iterator(position(this, m_tail));
				}
				const_iterator end()const
				{
					return const_iterator(position(this, m_tail));
				}
				std::size_t size()const
				{
					return m_size;
				}
				T&front()
				{
					return m_queue[m_head];
				}
				const T&front()const
				{
					return m_queue[m_head];
				}
			private:
				static const std::size_t MAX_SIZE=N;
				std::size_t m_head;
				std::size_t m_tail;
				std::size_t m_size;
				T m_queue[N+1];
			};
			template<typename T, std::size_t N>
			inline fixed_size_queue<T, N>::fixed_size_queue(): m_head(0), m_tail(0), m_size(0)
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 261), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 262), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 263), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 264), 0));
			}
			template<typename T, std::size_t N>
			inline fixed_size_queue<T, N>::fixed_size_queue(const fixed_size_queue&x): m_head(x.m_head), m_tail(x.m_tail), m_size(x.m_size)
			{
				copy(x.begin(), x.end(), begin());
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 275), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 276), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 277), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 278), 0));
			}
			template<typename T, std::size_t N>
			inline fixed_size_queue<T, N>&fixed_size_queue<T, N>::operator=(const fixed_size_queue&x)
			{
				if(this!=&x)
				{
					m_head=x.m_head;
					m_tail=x.m_tail;
					m_size=x.m_size;
					copy(x.begin(), x.end(), begin());
				}
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 292), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 293), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 294), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 295), 0));
				return *this;
			}
			template<typename T, std::size_t N>
			inline fixed_size_queue<T, N>::~fixed_size_queue()
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 304), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 305), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 306), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 307), 0));
			}
			template<typename T, std::size_t N>
			inline void fixed_size_queue<T, N>::push_back(const T&e)
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 314), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 315), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 316), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 317), 0));
				(void)((!!(!full()))||(_wassert(L"!full()", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 319), 0));
				m_queue[m_tail]=e;
				++m_size;
				++m_tail;
				if(m_tail==N+1)m_tail=0;
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 328), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 329), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 330), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 331), 0));
			}
			template<typename T, std::size_t N>
			inline void fixed_size_queue<T, N>::push_front(const T&e)
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 338), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 339), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 340), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 341), 0));
				(void)((!!(!full()))||(_wassert(L"!full()", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 343), 0));
				if(m_head==0)m_head=N;
				else--m_head;
				m_queue[m_head]=e;
				++m_size;
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 353), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 354), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 355), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 356), 0));
			}
			template<typename T, std::size_t N>
			inline void fixed_size_queue<T, N>::serve(T&e)
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 364), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 365), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 366), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 367), 0));
				e=m_queue[m_head];
				pop_front();
			}
			template<typename T, std::size_t N>
			inline void fixed_size_queue<T, N>::pop_front()
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 379), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 380), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 381), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 382), 0));
				++m_head;
				if(m_head==N+1)m_head=0;
				--m_size;
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 389), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 390), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 391), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\fixed_size_queue.hpp", 392), 0));
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace multi_pass_policies
			{
				class ref_counted;
				class first_owner;
				class buf_id_check;
				class no_check;
				class std_deque;
				template<std::size_t N>
				class fixed_size_queue;
				class input_iterator;
				class lex_input;
				class functor_input;
			}
			template<typename InputT, typename InputPolicy=multi_pass_policies::input_iterator, typename OwnershipPolicy=multi_pass_policies::ref_counted, typename CheckingPolicy=multi_pass_policies::buf_id_check, typename StoragePolicy=multi_pass_policies::std_deque>
			class multi_pass;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename T>
				inline void mp_swap(T&t1, T&t2);
			}
			namespace multi_pass_policies
			{
				class ref_counted
				{
					protected: ref_counted(): count(new std::size_t(1))
					{
					}
					ref_counted(ref_counted const&x): count(x.count)
					{
					}
					void clone()
					{
						++*count;
					}
					bool release()
					{
						if(!--*count)
						{
							delete count;
							count=0;
							return true;
						}
						return false;
					}
					void swap(ref_counted&x)
					{
						impl::mp_swap(count, x.count);
					}
				public:
					bool unique()const
					{
						return *count==1;
					}
				private:
					std::size_t*count;
				};
				class first_owner
				{
					protected: first_owner(): first(true)
					{
					}
					first_owner(first_owner const&): first(false)
					{
					}
					void clone()
					{
					}
					bool release()
					{
						return first;
					}
					void swap(first_owner&)
					{
					}
				public:
					bool unique()const
					{
						return false;
					}
				private:
					bool first;
				};
				class illegal_backtracking: public std::exception
				{
				public:
					illegal_backtracking()throw()
					{
					}
					~illegal_backtracking()throw()
					{
					}
					virtual const char*what()const throw()
					{
						return "BOOST_SPIRIT_CLASSIC_NS::illegal_backtracking";
					}
				};
				class buf_id_check
				{
					protected: buf_id_check(): shared_buf_id(new unsigned long(0)), buf_id(0)
					{
					}
					buf_id_check(buf_id_check const&x): shared_buf_id(x.shared_buf_id), buf_id(x.buf_id)
					{
					}
					void destroy()
					{
						delete shared_buf_id;
						shared_buf_id=0;
					}
					void swap(buf_id_check&x)
					{
						impl::mp_swap(shared_buf_id, x.shared_buf_id);
						impl::mp_swap(buf_id, x.buf_id);
					}
					void check()const
					{
						if(buf_id!=*shared_buf_id)
						{
							boost::throw_exception(illegal_backtracking());
						}
					}
					void clear_queue()
					{
						++*shared_buf_id;
						++buf_id;
					}
				private:
					unsigned long*shared_buf_id;
					unsigned long buf_id;
				};
				class no_check
				{
					protected: no_check()
					{
					}
					no_check(no_check const&)
					{
					}
					void destroy()
					{
					}
					void swap(no_check&)
					{
					}
					void check()const
					{
					}
					void clear_queue()
					{
					}
				};
				class std_deque
				{
				public:
					template<typename ValueT>
					class inner
					{
					private:
						typedef std::deque<ValueT>queue_type;
						queue_type*queuedElements;
						mutable typename queue_type::size_type queuePosition;
						protected: inner(): queuedElements(new queue_type), queuePosition(0)
						{
						}
						inner(inner const&x): queuedElements(x.queuedElements), queuePosition(x.queuePosition)
						{
						}
						void destroy()
						{
							(void)((!!(0!=queuedElements))||(_wassert(L"0 != queuedElements", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\multi_pass.hpp", 269), 0));
							delete queuedElements;
							queuedElements=0;
						}
						void swap(inner&x)
						{
							impl::mp_swap(queuedElements, x.queuedElements);
							impl::mp_swap(queuePosition, x.queuePosition);
						}
						template<typename MultiPassT>
						static typename MultiPassT::reference dereference(MultiPassT const&mp)
						{
							if(mp.queuePosition==mp.queuedElements->size())
							{
								if(mp.unique())
								{
									if(mp.queuedElements->size()>0)
									{
										mp.queuedElements->clear();
										mp.queuePosition=0;
									}
								}
								return mp.get_input();
							}
							else
							{
								return (*mp.queuedElements)[mp.queuePosition];
							}
						}
						template<typename MultiPassT>
						static void increment(MultiPassT&mp)
						{
							if(mp.queuePosition==mp.queuedElements->size())
							{
								if(mp.unique())
								{
									if(mp.queuedElements->size()>0)
									{
										mp.queuedElements->clear();
										mp.queuePosition=0;
									}
								}
								else
								{
									mp.queuedElements->push_back(mp.get_input());
									++mp.queuePosition;
								}
								mp.advance_input();
							}
							else
							{
								++mp.queuePosition;
							}
						}
						void clear_queue()
						{
							queuedElements->clear();
							queuePosition=0;
						}
						template<typename MultiPassT>
						static bool is_eof(MultiPassT const&mp)
						{
							return mp.queuePosition==mp.queuedElements->size()&&mp.input_at_eof();
						}
						bool equal_to(inner const&x)const
						{
							return queuePosition==x.queuePosition;
						}
						bool less_than(inner const&x)const
						{
							return queuePosition<x.queuePosition;
						}
					};
				};
				template<std::size_t N>
				class fixed_size_queue
				{
				public:
					template<typename ValueT>
					class inner
					{
					private:
						typedef boost::spirit::classic::fixed_size_queue<ValueT, N>queue_type;
						queue_type*queuedElements;
						mutable typename queue_type::iterator queuePosition;
						protected: inner(): queuedElements(new queue_type), queuePosition(queuedElements->begin())
						{
						}
						inner(inner const&x): queuedElements(x.queuedElements), queuePosition(x.queuePosition)
						{
						}
						void destroy()
						{
							(void)((!!(0!=queuedElements))||(_wassert(L"0 != queuedElements", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\multi_pass.hpp", 408), 0));
							delete queuedElements;
							queuedElements=0;
						}
						void swap(inner&x)
						{
							impl::mp_swap(queuedElements, x.queuedElements);
							impl::mp_swap(queuePosition, x.queuePosition);
						}
						template<typename MultiPassT>
						static typename MultiPassT::reference dereference(MultiPassT const&mp)
						{
							if(mp.queuePosition==mp.queuedElements->end())
							{
								return mp.get_input();
							}
							else
							{
								return *mp.queuePosition;
							}
						}
						template<typename MultiPassT>
						static void increment(MultiPassT&mp)
						{
							if(mp.queuePosition==mp.queuedElements->end())
							{
								if(mp.queuedElements->size()>=N)mp.queuedElements->pop_front();
								mp.queuedElements->push_back(mp.get_input());
								mp.advance_input();
							}
							++mp.queuePosition;
						}
						void clear_queue()
						{
						}
						template<typename MultiPassT>
						static bool is_eof(MultiPassT const&mp)
						{
							return mp.queuePosition==mp.queuedElements->end()&&mp.input_at_eof();
						}
						bool equal_to(inner const&x)const
						{
							return queuePosition==x.queuePosition;
						}
						bool less_than(inner const&x)const
						{
							return queuePosition<x.queuePosition;
						}
					};
				};
				class input_iterator
				{
				public:
					template<typename InputT>
					class inner
					{
					private:
						typedef typename boost::detail::iterator_traits<InputT>::value_type result_type;
					public:
						typedef result_type value_type;
					private:
						struct Data
						{
							Data(InputT const&input_): input(input_), was_initialized(false)
							{
							}
							InputT input;
							value_type curtok;
							bool was_initialized;
						};
						friend struct Data;
					public:
						typedef typename boost::detail::iterator_traits<InputT>::difference_type difference_type;
						typedef typename boost::detail::iterator_traits<InputT>::pointer pointer;
						typedef typename boost::detail::iterator_traits<InputT>::reference reference;
						protected: inner(): data(0)
						{
						}
						inner(InputT x): data(new Data(x))
						{
						}
						inner(inner const&x): data(x.data)
						{
						}
						void destroy()
						{
							delete data;
							data=0;
						}
						bool same_input(inner const&x)const
						{
							return data==x.data;
						}
						typedef typename boost::detail::iterator_traits<InputT>::value_type value_t;
						void swap(inner&x)
						{
							impl::mp_swap(data, x.data);
						}
						void ensure_initialized()const
						{
							if(data&&!data->was_initialized)
							{
								data->curtok=*data->input;
								data->was_initialized=true;
							}
						}
					public:
						reference get_input()const
						{
							(void)((!!(0!=data))||(_wassert(L"0 != data", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\multi_pass.hpp", 572), 0));
							ensure_initialized();
							return data->curtok;
						}
						void advance_input()
						{
							(void)((!!(0!=data))||(_wassert(L"0 != data", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\iterator\\multi_pass.hpp", 579), 0));
							data->was_initialized=false;
							++data->input;
						}
						bool input_at_eof()const
						{
							return !data||data->input==InputT();
						}
					private:
						Data*data;
					};
				};
				class lex_input
				{
				public:
					template<typename InputT>
					class inner
					{
					public:
						typedef int value_type;
						typedef std::ptrdiff_t difference_type;
						typedef int*pointer;
						typedef int&reference;
						protected: inner(): curtok(new int(0))
						{
						}
						inner(InputT x): curtok(new int(x))
						{
						}
						inner(inner const&x): curtok(x.curtok)
						{
						}
						void destroy()
						{
							delete curtok;
							curtok=0;
						}
						bool same_input(inner const&x)const
						{
							return curtok==x.curtok;
						}
						void swap(inner&x)
						{
							impl::mp_swap(curtok, x.curtok);
						}
					public:
						reference get_input()const
						{
							return *curtok;
						}
						void advance_input()
						{
							extern int yylex();
							*curtok=yylex();
						}
						bool input_at_eof()const
						{
							return *curtok==0;
						}
					private:
						int*curtok;
					};
				};
				class functor_input
				{
				public:
					template<typename FunctorT>
					class inner
					{
						typedef typename FunctorT::result_type result_type;
					public:
						typedef result_type value_type;
						typedef std::ptrdiff_t difference_type;
						typedef result_type*pointer;
						typedef result_type&reference;
						protected: inner(): ftor(0), curtok(0)
						{
						}
						inner(FunctorT const&x): ftor(new FunctorT(x)), curtok(new result_type((*ftor)()))
						{
						}
						inner(inner const&x): ftor(x.ftor), curtok(x.curtok)
						{
						}
						void destroy()
						{
							delete ftor;
							ftor=0;
							delete curtok;
							curtok=0;
						}
						bool same_input(inner const&x)const
						{
							return ftor==x.ftor;
						}
						void swap(inner&x)
						{
							impl::mp_swap(curtok, x.curtok);
							impl::mp_swap(ftor, x.ftor);
						}
					public:
						reference get_input()const
						{
							return *curtok;
						}
						void advance_input()
						{
							if(curtok)
							{
								*curtok=(*ftor)();
							}
						}
						bool input_at_eof()const
						{
							return !curtok||*curtok==ftor->eof;
						}
						FunctorT&get_functor()const
						{
							return *ftor;
						}
					private:
						FunctorT*ftor;
						result_type*curtok;
					};
				};
			}
			namespace iterator_
			{
				namespace impl
				{
					template<typename InputPolicyT, typename InputT>
					struct iterator_base_creator
					{
						typedef typename InputPolicyT::template inner<InputT>input_t;
						typedef boost::iterator<std::forward_iterator_tag, typename input_t::value_type, typename input_t::difference_type, typename input_t::pointer, typename input_t::reference>type;
					};
				}
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			class multi_pass: public OwnershipPolicy, public CheckingPolicy, public StoragePolicy::template inner<typename InputPolicy::template inner<InputT>::value_type>, public InputPolicy::template inner<InputT>, public iterator_::impl::iterator_base_creator<InputPolicy, InputT>::type
			{
				typedef OwnershipPolicy OP;
				typedef CheckingPolicy CHP;
				typedef typename StoragePolicy::template inner<typename InputPolicy::template inner<InputT>::value_type>SP;
				typedef typename InputPolicy::template inner<InputT>IP;
				typedef typename iterator_::impl::iterator_base_creator<InputPolicy, InputT>::type IB;
			public:
				typedef typename IB::value_type value_type;
				typedef typename IB::difference_type difference_type;
				typedef typename IB::reference reference;
				typedef typename IB::pointer pointer;
				typedef InputT iterator_type;
				multi_pass();
				explicit multi_pass(InputT input);
				~multi_pass();
				multi_pass(multi_pass const&);
				multi_pass&operator=(multi_pass const&);
				void swap(multi_pass&x);
				reference operator*()const;
				pointer operator->()const;
				multi_pass&operator++();
				multi_pass operator++(int);
				void clear_queue();
				bool operator==(const multi_pass&y)const;
				bool operator<(const multi_pass&y)const;
			private:
				bool is_eof()const;
			};
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::multi_pass(): OP(), CHP(), SP(), IP()
			{
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::multi_pass(InputT input): OP(), CHP(), SP(), IP(input)
			{
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::~multi_pass()
			{
				if(OP::release())
				{
					CHP::destroy();
					SP::destroy();
					IP::destroy();
				}
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::multi_pass(multi_pass const&x): OP(x), CHP(x), SP(x), IP(x)
			{
				OP::clone();
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::operator=(multi_pass const&x)
			{
				multi_pass temp(x);
				temp.swap(*this);
				return *this;
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline void multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::swap(multi_pass&x)
			{
				OP::swap(x);
				CHP::swap(x);
				SP::swap(x);
				IP::swap(x);
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline typename multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::reference multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::operator*()const
			{
				CHP::check();
				return SP::dereference(*this);
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline typename multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::pointer multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::operator->()const
			{
				return &(operator*());
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::operator++()
			{
				CHP::check();
				SP::increment(*this);
				return *this;
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::operator++(int)
			{
				multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>tmp(*this);
				++*this;
				return tmp;
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline void multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::clear_queue()
			{
				SP::clear_queue();
				CHP::clear_queue();
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline bool multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::is_eof()const
			{
				return SP::is_eof(*this);
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline bool multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::operator==(const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&y)const
			{
				bool is_eof_=SP::is_eof(*this);
				bool y_is_eof_=SP::is_eof(y);
				if(is_eof_&&y_is_eof_)
				{
					return true;
				}
				else if(is_eof_^y_is_eof_)
				{
					return false;
				}
				else if(!IP::same_input(y))
				{
					return false;
				}
				else
				{
					return SP::equal_to(y);
				}
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline bool multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::operator<(const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&y)const
			{
				return SP::less_than(y);
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline bool operator!=(const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&x, const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&y)
			{
				return !(x==y);
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline bool operator>(const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&x, const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&y)
			{
				return y<x;
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline bool operator>=(const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&x, const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&y)
			{
				return !(x<y);
			}
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			inline bool operator<=(const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&x, const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&y)
			{
				return !(y<x);
			}
			template<typename InputT>
			inline multi_pass<InputT, multi_pass_policies::input_iterator, multi_pass_policies::ref_counted, multi_pass_policies::buf_id_check, multi_pass_policies::std_deque>make_multi_pass(InputT i)
			{
				return multi_pass<InputT, multi_pass_policies::input_iterator, multi_pass_policies::ref_counted, multi_pass_policies::buf_id_check, multi_pass_policies::std_deque>(i);
			}
			template<typename InputT, std::size_t N>
			class look_ahead: public multi_pass<InputT, multi_pass_policies::input_iterator, multi_pass_policies::first_owner, multi_pass_policies::no_check, multi_pass_policies::fixed_size_queue<N> >
			{
				typedef multi_pass<InputT, multi_pass_policies::input_iterator, multi_pass_policies::first_owner, multi_pass_policies::no_check, multi_pass_policies::fixed_size_queue<N> >base_t;
			public:
				look_ahead(): base_t()
				{
				}
				explicit look_ahead(InputT x): base_t(x)
				{
				}
				look_ahead(look_ahead const&x): base_t(x)
				{
				}
			};
			template<typename InputT, typename InputPolicy, typename OwnershipPolicy, typename CheckingPolicy, typename StoragePolicy>
			void swap(multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&x, multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&y)
			{
				x.swap(y);
			}
			namespace impl
			{
				template<typename T>
				inline void mp_swap(T&t1, T&t2)
				{
					using std::swap;
					using boost::spirit::classic::swap;
					swap(t1, t2);
				}
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct nil_t
			{
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct has_trivial_copy_impl
		{
			static const bool value=(::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_pod<T>::value, __has_trivial_copy(T)>::value, ::boost::type_traits::ice_not< ::boost::is_volatile<T>::value>::value>::value);
		};
	}
	template<typename T>
	struct has_trivial_copy: ::boost::integral_constant<bool, ::boost::detail::has_trivial_copy_impl<T>::value>
	{
	};
	template<typename T>
	struct has_trivial_copy_constructor: ::boost::integral_constant<bool, ::boost::detail::has_trivial_copy_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<class T>
		struct has_nothrow_copy_imp
		{
			static const bool value=(::boost::type_traits::ice_or< ::boost::has_trivial_copy<T>::value, __has_nothrow_copy(T)>::value);
		};
	}
	template<typename T>
	struct has_nothrow_copy: ::boost::integral_constant<bool, ::boost::detail::has_nothrow_copy_imp<T>::value>
	{
	};
	template<typename T>
	struct has_nothrow_copy_constructor: ::boost::integral_constant<bool, ::boost::detail::has_nothrow_copy_imp<T>::value>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename RefT>
		class reference_content
		{
		private:
			RefT content_;
		public:
			~reference_content()
			{
			}
			reference_content(RefT r): content_(r)
			{
			}
			reference_content(const reference_content&operand): content_(operand.content_)
			{
			}
		private:
			reference_content&operator=(const reference_content&);
		public:
			RefT get()const
			{
				return content_;
			}
		};
		template<typename T=mpl::void_>
		struct make_reference_content;
		template<typename T>
		struct make_reference_content
		{
			typedef T type;
		};
		template<typename T>
		struct make_reference_content<T&>
		{
			typedef reference_content<T&>type;
		};
		template<>
		struct make_reference_content<mpl::void_>
		{
			template<typename T>
			struct apply: make_reference_content<T>
			{
			};
			typedef mpl::void_ type;
		};
	}
	template<typename T>
	struct has_nothrow_copy< ::boost::detail::reference_content<T&> >: mpl::true_
	{
	};
}
namespace boost
{
	namespace detail
	{
		struct none_helper
		{
		};
	}
	typedef int detail::none_helper::*none_t;
}
namespace boost
{
	none_t const none=((none_t)0);
}
namespace boost
{
	template<class OptionalPointee>
	inline bool equal_pointees(OptionalPointee const&x, OptionalPointee const&y)
	{
		return (!x)!=(!y)?false: (!x?true: (*x)==(*y));
	}
	template<class OptionalPointee>
	struct equal_pointees_t: std::binary_function<OptionalPointee, OptionalPointee, bool>
	{
		bool operator()(OptionalPointee const&x, OptionalPointee const&y)const
		{
			return equal_pointees(x, y);
		}
	};
	template<class OptionalPointee>
	inline bool less_pointees(OptionalPointee const&x, OptionalPointee const&y)
	{
		return !y?false: (!x?true: (*x)<(*y));
	}
	template<class OptionalPointee>
	struct less_pointees_t: std::binary_function<OptionalPointee, OptionalPointee, bool>
	{
		bool operator()(OptionalPointee const&x, OptionalPointee const&y)const
		{
			return less_pointees(x, y);
		}
	};
}
namespace boost
{
	template<class T>
	class optional;
}
namespace boost_optional_detail
{
	template<class T, class Factory>
	void construct(Factory const&factory, void*address)
	{
		factory.template apply<T>(address);
	}
}
namespace boost
{
	class in_place_factory_base;
	class typed_in_place_factory_base;
	namespace optional_detail
	{
		template<class T>
		class aligned_storage
		{
			union dummy_u
			{
				char data[sizeof(T)];
				typename type_with_alignment< ::boost::alignment_of<T>::value>::type aligner_;
			}
			dummy_;
		public:
			void const*address()const
			{
				return &dummy_.data[0];
			}
			void*address()
			{
				return &dummy_.data[0];
			}
		};
		template<class T>
		struct types_when_isnt_ref
		{
			typedef T const&reference_const_type;
			typedef T&reference_type;
			typedef T const*pointer_const_type;
			typedef T*pointer_type;
			typedef T const&argument_type;
		};
		template<class T>
		struct types_when_is_ref
		{
			typedef typename remove_reference<T>::type raw_type;
			typedef raw_type&reference_const_type;
			typedef raw_type&reference_type;
			typedef raw_type*pointer_const_type;
			typedef raw_type*pointer_type;
			typedef raw_type&argument_type;
		};
		struct optional_tag
		{
		};
		template<class T>
		class optional_base: public optional_tag
		{
		private:
			typedef typename::boost::detail::make_reference_content<T>::type internal_type;
			typedef aligned_storage<internal_type>storage_type;
			typedef types_when_isnt_ref<T>types_when_not_ref;
			typedef types_when_is_ref<T>types_when_ref;
			typedef optional_base<T>this_type;
			protected: typedef T value_type;
			typedef mpl::true_ is_reference_tag;
			typedef mpl::false_ is_not_reference_tag;
			typedef typename is_reference<T>::type is_reference_predicate;
			typedef typename mpl::if_<is_reference_predicate, types_when_ref, types_when_not_ref>::type types;
			typedef bool(this_type::*unspecified_bool_type)()const;
			typedef typename types::reference_type reference_type;
			typedef typename types::reference_const_type reference_const_type;
			typedef typename types::pointer_type pointer_type;
			typedef typename types::pointer_const_type pointer_const_type;
			typedef typename types::argument_type argument_type;
			optional_base(): m_initialized(false)
			{
			}
			optional_base(none_t): m_initialized(false)
			{
			}
			optional_base(argument_type val): m_initialized(false)
			{
				construct(val);
			}
			optional_base(bool cond, argument_type val): m_initialized(false)
			{
				if(cond)construct(val);
			}
			optional_base(optional_base const&rhs): m_initialized(false)
			{
				if(rhs.is_initialized())construct(rhs.get_impl());
			}
			template<class Expr>
			explicit optional_base(Expr const&expr, Expr const*tag): m_initialized(false)
			{
				construct(expr, tag);
			}
			~optional_base()
			{
				destroy();
			}
			void assign(optional_base const&rhs)
			{
				if(is_initialized())
				{
					if(rhs.is_initialized())assign_value(rhs.get_impl(), is_reference_predicate());
					else destroy();
				}
				else
				{
					if(rhs.is_initialized())construct(rhs.get_impl());
				}
			}
			template<class U>
			void assign(optional<U>const&rhs)
			{
				if(is_initialized())
				{
					if(rhs.is_initialized())assign_value(static_cast<value_type>(rhs.get()), is_reference_predicate());
					else destroy();
				}
				else
				{
					if(rhs.is_initialized())construct(static_cast<value_type>(rhs.get()));
				}
			}
			void assign(argument_type val)
			{
				if(is_initialized())assign_value(val, is_reference_predicate());
				else construct(val);
			}
			void assign(none_t)
			{
				destroy();
			}
			template<class Expr>
			void assign_expr(Expr const&expr, Expr const*tag)
			{
				if(is_initialized())assign_expr_to_initialized(expr, tag);
				else construct(expr, tag);
			}
		public:
			void reset()
			{
				destroy();
			}
			void reset(argument_type val)
			{
				assign(val);
			}
			pointer_const_type get_ptr()const
			{
				return m_initialized?get_ptr_impl(): 0;
			}
			pointer_type get_ptr()
			{
				return m_initialized?get_ptr_impl(): 0;
			}
			bool is_initialized()const
			{
				return m_initialized;
			}
			protected: void construct(argument_type val)
			{
				new(m_storage.address())internal_type(val);
				m_initialized=true;
			}
			template<class Expr>
			void construct(Expr const&factory, in_place_factory_base const*)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::mpl::not_<is_reference_predicate>::value)>)>boost_static_assert_typedef___COUNTER__;
				boost_optional_detail::construct<value_type>(factory, m_storage.address());
				m_initialized=true;
			}
			template<class Expr>
			void construct(Expr const&factory, typed_in_place_factory_base const*)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::mpl::not_<is_reference_predicate>::value)>)>boost_static_assert_typedef___COUNTER__;
				factory.apply(m_storage.address());
				m_initialized=true;
			}
			template<class Expr>
			void assign_expr_to_initialized(Expr const&factory, in_place_factory_base const*tag)
			{
				destroy();
				construct(factory, tag);
			}
			template<class Expr>
			void assign_expr_to_initialized(Expr const&factory, typed_in_place_factory_base const*tag)
			{
				destroy();
				construct(factory, tag);
			}
			template<class Expr>
			void construct(Expr const&expr, void const*)
			{
				new(m_storage.address())internal_type(expr);
				m_initialized=true;
			}
			template<class Expr>
			void assign_expr_to_initialized(Expr const&expr, void const*)
			{
				assign_value(expr, is_reference_predicate());
			}
			void assign_value(argument_type val, is_not_reference_tag)
			{
				get_impl()=val;
			}
			void assign_value(argument_type val, is_reference_tag)
			{
				construct(val);
			}
			void destroy()
			{
				if(m_initialized)destroy_impl(is_reference_predicate());
			}
			unspecified_bool_type safe_bool()const
			{
				return m_initialized?&this_type::is_initialized: 0;
			}
			reference_const_type get_impl()const
			{
				return dereference(get_object(), is_reference_predicate());
			}
			reference_type get_impl()
			{
				return dereference(get_object(), is_reference_predicate());
			}
			pointer_const_type get_ptr_impl()const
			{
				return cast_ptr(get_object(), is_reference_predicate());
			}
			pointer_type get_ptr_impl()
			{
				return cast_ptr(get_object(), is_reference_predicate());
			}
		private:
			internal_type const*get_object()const
			{
				return static_cast<internal_type const*>(m_storage.address());
			}
			internal_type*get_object()
			{
				return static_cast<internal_type*>(m_storage.address());
			}
			reference_const_type dereference(internal_type const*p, is_not_reference_tag)const
			{
				return *p;
			}
			reference_type dereference(internal_type*p, is_not_reference_tag)
			{
				return *p;
			}
			reference_const_type dereference(internal_type const*p, is_reference_tag)const
			{
				return p->get();
			}
			reference_type dereference(internal_type*p, is_reference_tag)
			{
				return p->get();
			}
			void destroy_impl(is_not_reference_tag)
			{
				get_ptr_impl()->T::~T();
				m_initialized=false;
			}
			void destroy_impl(is_reference_tag)
			{
				m_initialized=false;
			}
			pointer_const_type cast_ptr(internal_type const*p, is_not_reference_tag)const
			{
				return p;
			}
			pointer_type cast_ptr(internal_type*p, is_not_reference_tag)
			{
				return p;
			}
			pointer_const_type cast_ptr(internal_type const*p, is_reference_tag)const
			{
				return &p->get();
			}
			pointer_type cast_ptr(internal_type*p, is_reference_tag)
			{
				return &p->get();
			}
			bool m_initialized;
			storage_type m_storage;
		};
	}
	template<class T>
	class optional: public optional_detail::optional_base<T>
	{
		typedef optional_detail::optional_base<T>base;
		typedef typename base::unspecified_bool_type unspecified_bool_type;
	public:
		typedef optional<T>this_type;
		typedef typename base::value_type value_type;
		typedef typename base::reference_type reference_type;
		typedef typename base::reference_const_type reference_const_type;
		typedef typename base::pointer_type pointer_type;
		typedef typename base::pointer_const_type pointer_const_type;
		typedef typename base::argument_type argument_type;
		optional(): base()
		{
		}
		optional(none_t none_): base(none_)
		{
		}
		optional(argument_type val): base(val)
		{
		}
		optional(bool cond, argument_type val): base(cond, val)
		{
		}
		template<class U>
		explicit optional(optional<U>const&rhs): base()
		{
			if(rhs.is_initialized())this->construct(rhs.get());
		}
		template<class Expr>
		explicit optional(Expr const&expr): base(expr, &expr)
		{
		}
		optional(optional const&rhs): base(rhs)
		{
		}
		~optional()
		{
		}
		template<class Expr>
		optional&operator=(Expr expr)
		{
			this->assign_expr(expr, &expr);
			return *this;
		}
		template<class U>
		optional&operator=(optional<U>const&rhs)
		{
			this->assign(rhs);
			return *this;
		}
		optional&operator=(optional const&rhs)
		{
			this->assign(rhs);
			return *this;
		}
		optional&operator=(argument_type val)
		{
			this->assign(val);
			return *this;
		}
		optional&operator=(none_t none_)
		{
			this->assign(none_);
			return *this;
		}
		reference_const_type get()const
		{
			(void)((!!(this->is_initialized()))||(_wassert(L"this->is_initialized()", L"D:\\dev\\boost_1_41_0\\boost\\optional\\optional.hpp", 577), 0));
			return this->get_impl();
		}
		reference_type get()
		{
			(void)((!!(this->is_initialized()))||(_wassert(L"this->is_initialized()", L"D:\\dev\\boost_1_41_0\\boost\\optional\\optional.hpp", 578), 0));
			return this->get_impl();
		}
		reference_const_type get_value_or(reference_const_type v)const
		{
			return this->is_initialized()?get(): v;
		}
		reference_type get_value_or(reference_type v)
		{
			return this->is_initialized()?get(): v;
		}
		pointer_const_type operator->()const
		{
			(void)((!!(this->is_initialized()))||(_wassert(L"this->is_initialized()", L"D:\\dev\\boost_1_41_0\\boost\\optional\\optional.hpp", 587), 0));
			return this->get_ptr_impl();
		}
		pointer_type operator->()
		{
			(void)((!!(this->is_initialized()))||(_wassert(L"this->is_initialized()", L"D:\\dev\\boost_1_41_0\\boost\\optional\\optional.hpp", 588), 0));
			return this->get_ptr_impl();
		}
		reference_const_type operator*()const
		{
			return this->get();
		}
		reference_type operator*()
		{
			return this->get();
		}
		operator unspecified_bool_type()const
		{
			return this->safe_bool();
		}
		bool operator!()const
		{
			return !this->is_initialized();
		}
	};
	template<class T>
	inline optional<T>make_optional(T const&v)
	{
		return optional<T>(v);
	}
	template<class T>
	inline optional<T>make_optional(bool cond, T const&v)
	{
		return optional<T>(cond, v);
	}
	template<class T>
	inline typename optional<T>::reference_const_type get(optional<T>const&opt)
	{
		return opt.get();
	}
	template<class T>
	inline typename optional<T>::reference_type get(optional<T>&opt)
	{
		return opt.get();
	}
	template<class T>
	inline typename optional<T>::pointer_const_type get(optional<T>const*opt)
	{
		return opt->get_ptr();
	}
	template<class T>
	inline typename optional<T>::pointer_type get(optional<T>*opt)
	{
		return opt->get_ptr();
	}
	template<class T>
	inline typename optional<T>::reference_const_type get_optional_value_or(optional<T>const&opt, typename optional<T>::reference_const_type v)
	{
		return opt.get_value_or(v);
	}
	template<class T>
	inline typename optional<T>::reference_type get_optional_value_or(optional<T>&opt, typename optional<T>::reference_type v)
	{
		return opt.get_value_or(v);
	}
	template<class T>
	inline typename optional<T>::pointer_const_type get_pointer(optional<T>const&opt)
	{
		return opt.get_ptr();
	}
	template<class T>
	inline typename optional<T>::pointer_type get_pointer(optional<T>&opt)
	{
		return opt.get_ptr();
	}
	template<class T>
	inline bool operator==(optional<T>const&x, optional<T>const&y)
	{
		return equal_pointees(x, y);
	}
	template<class T>
	inline bool operator<(optional<T>const&x, optional<T>const&y)
	{
		return less_pointees(x, y);
	}
	template<class T>
	inline bool operator!=(optional<T>const&x, optional<T>const&y)
	{
		return !(x==y);
	}
	template<class T>
	inline bool operator>(optional<T>const&x, optional<T>const&y)
	{
		return y<x;
	}
	template<class T>
	inline bool operator<=(optional<T>const&x, optional<T>const&y)
	{
		return !(y<x);
	}
	template<class T>
	inline bool operator>=(optional<T>const&x, optional<T>const&y)
	{
		return !(x<y);
	}
	template<class T>
	inline bool operator==(optional<T>const&x, T const&y)
	{
		return equal_pointees(x, optional<T>(y));
	}
	template<class T>
	inline bool operator<(optional<T>const&x, T const&y)
	{
		return less_pointees(x, optional<T>(y));
	}
	template<class T>
	inline bool operator!=(optional<T>const&x, T const&y)
	{
		return !(x==y);
	}
	template<class T>
	inline bool operator>(optional<T>const&x, T const&y)
	{
		return y<x;
	}
	template<class T>
	inline bool operator<=(optional<T>const&x, T const&y)
	{
		return !(y<x);
	}
	template<class T>
	inline bool operator>=(optional<T>const&x, T const&y)
	{
		return !(x<y);
	}
	template<class T>
	inline bool operator==(T const&x, optional<T>const&y)
	{
		return equal_pointees(optional<T>(x), y);
	}
	template<class T>
	inline bool operator<(T const&x, optional<T>const&y)
	{
		return less_pointees(optional<T>(x), y);
	}
	template<class T>
	inline bool operator!=(T const&x, optional<T>const&y)
	{
		return !(x==y);
	}
	template<class T>
	inline bool operator>(T const&x, optional<T>const&y)
	{
		return y<x;
	}
	template<class T>
	inline bool operator<=(T const&x, optional<T>const&y)
	{
		return !(y<x);
	}
	template<class T>
	inline bool operator>=(T const&x, optional<T>const&y)
	{
		return !(x<y);
	}
	template<class T>
	inline bool operator==(optional<T>const&x, none_t)
	{
		return equal_pointees(x, optional<T>());
	}
	template<class T>
	inline bool operator<(optional<T>const&x, none_t)
	{
		return less_pointees(x, optional<T>());
	}
	template<class T>
	inline bool operator!=(optional<T>const&x, none_t y)
	{
		return !(x==y);
	}
	template<class T>
	inline bool operator>(optional<T>const&x, none_t y)
	{
		return y<x;
	}
	template<class T>
	inline bool operator<=(optional<T>const&x, none_t y)
	{
		return !(y<x);
	}
	template<class T>
	inline bool operator>=(optional<T>const&x, none_t y)
	{
		return !(x<y);
	}
	template<class T>
	inline bool operator==(none_t x, optional<T>const&y)
	{
		return equal_pointees(optional<T>(), y);
	}
	template<class T>
	inline bool operator<(none_t x, optional<T>const&y)
	{
		return less_pointees(optional<T>(), y);
	}
	template<class T>
	inline bool operator!=(none_t x, optional<T>const&y)
	{
		return !(x==y);
	}
	template<class T>
	inline bool operator>(none_t x, optional<T>const&y)
	{
		return y<x;
	}
	template<class T>
	inline bool operator<=(none_t x, optional<T>const&y)
	{
		return !(y<x);
	}
	template<class T>
	inline bool operator>=(none_t x, optional<T>const&y)
	{
		return !(x<y);
	}
	namespace optional_detail
	{
		template<class T>
		inline void optional_swap(optional<T>&x, optional<T>&y)
		{
			if(!x&&!!y)
			{
				x.reset(*y);
				y.reset();
			}
			else if(!!x&&!y)
			{
				y.reset(*x);
				x.reset();
			}
			else if(!!x&&!!y)
			{
				using std::swap;
				swap(*x, *y);
			}
		}
	}
	template<class T>
	inline void swap(optional<T>&x, optional<T>&y)
	{
		optional_detail::optional_swap(x, y);
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename T>
				struct no_base
				{
				};
				template<typename T>
				struct safe_bool_impl
				{
					typedef T*TP;
					TP stub;
					typedef TP safe_bool_impl::*type;
				};
			}
			template<typename DerivedT, typename BaseT=impl::no_base<DerivedT> >
			struct safe_bool: BaseT
			{
			private:
				typedef impl::safe_bool_impl<DerivedT>impl_t;
				typedef typename impl_t::type bool_type;
			public:
				operator bool_type()const
				{
					return static_cast<const DerivedT*>(this)->operator_bool()?&impl_t::stub: 0;
				}
				operator bool_type()
				{
					return static_cast<DerivedT*>(this)->operator_bool()?&impl_t::stub: 0;
				}
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename T>
				struct match_attr_traits
				{
					typedef typename boost::optional<T>::reference_const_type const_reference;
					template<typename T2>
					static void convert(boost::optional<T>&dest, T2 const&src, mpl::true_)
					{
						dest.reset(src);
					}
					template<typename T2>
					static void convert(boost::optional<T>&dest, T2 const&, mpl::false_)
					{
						dest.reset();
					}
					static void convert(boost::optional<T>&dest, nil_t)
					{
						dest.reset();
					}
					template<typename T2>
					static void convert(boost::optional<T>&dest, T2 const&src)
					{
						convert(dest, src, is_convertible<T2, T>());
					}
					template<typename OtherMatchT>
					static void copy(boost::optional<T>&dest, OtherMatchT const&src)
					{
						if(src.has_valid_attribute())convert(dest, src.value());
					}
					template<typename OtherMatchT>
					static void assign(boost::optional<T>&dest, OtherMatchT const&src)
					{
						if(src.has_valid_attribute())convert(dest, src.value());
						else dest.reset();
					}
					template<typename ValueT>
					static void set_value(boost::optional<T>&dest, ValueT const&val, mpl::false_)
					{
						dest.reset(val);
					}
					template<typename ValueT>
					static void set_value(boost::optional<T>&dest, ValueT const&val, mpl::true_)
					{
						dest.get()=val;
					}
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T=nil_t>
			class match: public safe_bool<match<T> >
			{
			public:
				typedef typename boost::optional<T>optional_type;
				typedef typename optional_type::argument_type ctor_param_t;
				typedef typename optional_type::reference_const_type return_t;
				typedef T attr_t;
				match();
				explicit match(std::size_t length);
				match(std::size_t length, ctor_param_t val);
				bool operator!()const;
				std::ptrdiff_t length()const;
				bool has_valid_attribute()const;
				return_t value()const;
				void swap(match&other);
				template<typename T2>
				match(match<T2>const&other): len(other.length()), val()
				{
					impl::match_attr_traits<T>::copy(val, other);
				}
				template<typename T2>
				match&operator=(match<T2>const&other)
				{
					impl::match_attr_traits<T>::assign(val, other);
					len=other.length();
					return *this;
				}
				template<typename MatchT>
				void concat(MatchT const&other)
				{
					(void)((!!(*this&&other))||(_wassert(L"*this && other", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\core\\match.hpp", 103), 0));
					len+=other.length();
				}
				template<typename ValueT>
				void value(ValueT const&val_)
				{
					impl::match_attr_traits<T>::set_value(val, val_, is_reference<T>());
				}
				bool operator_bool()const
				{
					return len>=0;
				}
			private:
				std::ptrdiff_t len;
				optional_type val;
			};
			template<>
			class match<nil_t>: public safe_bool<match<nil_t> >
			{
			public:
				typedef nil_t attr_t;
				typedef nil_t return_t;
				match();
				explicit match(std::size_t length);
				match(std::size_t length, nil_t);
				bool operator!()const;
				bool has_valid_attribute()const;
				std::ptrdiff_t length()const;
				nil_t value()const;
				void value(nil_t);
				void swap(match&other);
				template<typename T>
				match(match<T>const&other): len(other.length())
				{
				}
				template<typename T>
				match<>&operator=(match<T>const&other)
				{
					len=other.length();
					return *this;
				}
				template<typename T>
				void concat(match<T>const&other)
				{
					(void)((!!(*this&&other))||(_wassert(L"*this && other", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\core\\match.hpp", 165), 0));
					len+=other.length();
				}
				bool operator_bool()const
				{
					return len>=0;
				}
			private:
				std::ptrdiff_t len;
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T>
			inline match<T>::match(): len(-1), val()
			{
			}
			template<typename T>
			inline match<T>::match(std::size_t length): len(length), val()
			{
			}
			template<typename T>
			inline match<T>::match(std::size_t length, ctor_param_t val_): len(length), val(val_)
			{
			}
			template<typename T>
			inline bool match<T>::operator!()const
			{
				return len<0;
			}
			template<typename T>
			inline std::ptrdiff_t match<T>::length()const
			{
				return len;
			}
			template<typename T>
			inline bool match<T>::has_valid_attribute()const
			{
				return val.is_initialized();
			}
			template<typename T>
			inline typename match<T>::return_t match<T>::value()const
			{
				(void)((!!(val.is_initialized()))||(_wassert(L"val.is_initialized()", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\core\\impl\\match.ipp", 54), 0));
				return *val;
			}
			template<typename T>
			inline void match<T>::swap(match&other)
			{
				std::swap(len, other.len);
				std::swap(val, other.val);
			}
			inline match<nil_t>::match(): len(-1)
			{
			}
			inline match<nil_t>::match(std::size_t length): len(length)
			{
			}
			inline match<nil_t>::match(std::size_t length, nil_t): len(length)
			{
			}
			inline bool match<nil_t>::operator!()const
			{
				return len<0;
			}
			inline bool match<nil_t>::has_valid_attribute()const
			{
				return false;
			}
			inline std::ptrdiff_t match<nil_t>::length()const
			{
				return len;
			}
			inline nil_t match<nil_t>::value()const
			{
				return nil_t();
			}
			inline void match<nil_t>::value(nil_t)
			{
			}
			inline void match<nil_t>::swap(match<nil_t>&other)
			{
				std::swap(len, other.len);
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			class parser_id
			{
			public:
				parser_id(): p(0)
				{
				}
				explicit parser_id(void const*prule): p(prule)
				{
				}
				parser_id(std::size_t l_): l(l_)
				{
				}
				bool operator==(parser_id const&x)const
				{
					return p==x.p;
				}
				bool operator!=(parser_id const&x)const
				{
					return !(*this==x);
				}
				bool operator<(parser_id const&x)const
				{
					return p<x.p;
				}
				std::size_t to_long()const
				{
					return l;
				}
			private:
				union
				{
					void const*p;
					std::size_t l;
				};
			};
			struct parser_tag_base
			{
			};
			struct parser_address_tag: parser_tag_base
			{
				parser_id id()const
				{
					return parser_id(reinterpret_cast<std::size_t>(this));
				}
			};
			template<int N>
			struct parser_tag: parser_tag_base
			{
				static parser_id id()
				{
					return parser_id(std::size_t(N));
				}
			};
			class dynamic_parser_tag: public parser_tag_base
			{
			public:
				dynamic_parser_tag(): tag(std::size_t(0))
				{
				}
				parser_id id()const
				{
					return tag.to_long()?tag: parser_id(reinterpret_cast<std::size_t>(this));
				}
				void set_id(parser_id id)
				{
					tag=id;
				}
			private:
				parser_id tag;
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct iteration_policy;
			struct action_policy;
			struct match_policy;
			template<typename IterationPolicyT=iteration_policy, typename MatchPolicyT=match_policy, typename ActionPolicyT=action_policy>
			struct scanner_policies;
			template<typename IteratorT=char const*, typename PoliciesT=scanner_policies<> >
			class scanner;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct iteration_policy
			{
				template<typename ScannerT>
				void advance(ScannerT const&scan)const
				{
					++scan.first;
				}
				template<typename ScannerT>
				bool at_end(ScannerT const&scan)const
				{
					return scan.first==scan.last;
				}
				template<typename T>
				T filter(T ch)const
				{
					return ch;
				}
				template<typename ScannerT>
				typename ScannerT::ref_t get(ScannerT const&scan)const
				{
					return *scan.first;
				}
			};
			struct match_policy
			{
				template<typename T>
				struct result
				{
					typedef match<T>type;
				};
				const match<nil_t>no_match()const
				{
					return match<nil_t>();
				}
				const match<nil_t>empty_match()const
				{
					return match<nil_t>(0, nil_t());
				}
				template<typename AttrT, typename IteratorT>
				match<AttrT>create_match(std::size_t length, AttrT const&val, IteratorT const&, IteratorT const&)const
				{
					return match<AttrT>(length, val);
				}
				template<typename MatchT, typename IteratorT>
				void group_match(MatchT&, parser_id const&, IteratorT const&, IteratorT const&)const
				{
				}
				template<typename Match1T, typename Match2T>
				void concat_match(Match1T&l, Match2T const&r)const
				{
					l.concat(r);
				}
			};
			template<typename MatchPolicyT, typename T>
			struct match_result
			{
				typedef typename MatchPolicyT::template result<T>::type type;
			};
			template<typename AttrT>
			struct attributed_action_policy
			{
				template<typename ActorT, typename IteratorT>
				static void call(ActorT const&actor, AttrT&val, IteratorT const&, IteratorT const&)
				{
					actor(val);
				}
			};
			template<>
			struct attributed_action_policy<nil_t>
			{
				template<typename ActorT, typename IteratorT>
				static void call(ActorT const&actor, nil_t, IteratorT const&first, IteratorT const&last)
				{
					actor(first, last);
				}
			};
			struct action_policy
			{
				template<typename ActorT, typename AttrT, typename IteratorT>
				void do_action(ActorT const&actor, AttrT&val, IteratorT const&first, IteratorT const&last)const
				{
					attributed_action_policy<AttrT>::call(actor, val, first, last);
				}
			};
			template<typename IterationPolicyT, typename MatchPolicyT, typename ActionPolicyT>
			struct scanner_policies: public IterationPolicyT, public MatchPolicyT, public ActionPolicyT
			{
				typedef IterationPolicyT iteration_policy_t;
				typedef MatchPolicyT match_policy_t;
				typedef ActionPolicyT action_policy_t;
				scanner_policies(IterationPolicyT const&i_policy=IterationPolicyT(), MatchPolicyT const&m_policy=MatchPolicyT(), ActionPolicyT const&a_policy=ActionPolicyT()): IterationPolicyT(i_policy), MatchPolicyT(m_policy), ActionPolicyT(a_policy)
				{
				}
				template<typename ScannerPoliciesT>
				scanner_policies(ScannerPoliciesT const&policies): IterationPolicyT(policies), MatchPolicyT(policies), ActionPolicyT(policies)
				{
				}
			};
			struct scanner_base
			{
			};
			template<typename IteratorT, typename PoliciesT>
			class scanner: public PoliciesT, public scanner_base
			{
			public:
				typedef IteratorT iterator_t;
				typedef PoliciesT policies_t;
				typedef typename boost::detail::iterator_traits<IteratorT>::value_type value_t;
				typedef typename boost::detail::iterator_traits<IteratorT>::reference ref_t;
				typedef typename boost::call_traits<IteratorT>::param_type iter_param_t;
				scanner(IteratorT&first_, iter_param_t last_, PoliciesT const&policies=PoliciesT()): PoliciesT(policies), first(first_), last(last_)
				{
					at_end();
				}
				scanner(scanner const&other): PoliciesT(other), first(other.first), last(other.last)
				{
				}
				scanner(scanner const&other, IteratorT&first_): PoliciesT(other), first(first_), last(other.last)
				{
				}
				template<typename PoliciesT1>
				scanner(scanner<IteratorT, PoliciesT1>const&other): PoliciesT(other), first(other.first), last(other.last)
				{
				}
				bool at_end()const
				{
					typedef typename PoliciesT::iteration_policy_t iteration_policy_type;
					return iteration_policy_type::at_end(*this);
				}
				value_t operator*()const
				{
					typedef typename PoliciesT::iteration_policy_t iteration_policy_type;
					return iteration_policy_type::filter(iteration_policy_type::get(*this));
				}
				scanner const&operator++()const
				{
					typedef typename PoliciesT::iteration_policy_t iteration_policy_type;
					iteration_policy_type::advance(*this);
					return *this;
				}
				template<typename PoliciesT2>
				struct rebind_policies
				{
					typedef scanner<IteratorT, PoliciesT2>type;
				};
				template<typename PoliciesT2>
				scanner<IteratorT, PoliciesT2>change_policies(PoliciesT2 const&policies)const
				{
					return scanner<IteratorT, PoliciesT2>(first, last, policies);
				}
				template<typename IteratorT2>
				struct rebind_iterator
				{
					typedef scanner<IteratorT2, PoliciesT>type;
				};
				template<typename IteratorT2>
				scanner<IteratorT2, PoliciesT>change_iterator(IteratorT2 const&first_, IteratorT2 const&last_)const
				{
					return scanner<IteratorT2, PoliciesT>(first_, last_, *this);
				}
				IteratorT&first;
				IteratorT const last;
			private:
				scanner&operator=(scanner const&other);
			};
			template<typename ScannerT, typename PoliciesT>
			struct rebind_scanner_policies
			{
				typedef typename ScannerT::template rebind_policies<PoliciesT>::type type;
			};
			template<typename ScannerT, typename IteratorT>
			struct rebind_scanner_iterator
			{
				typedef typename ScannerT::template rebind_iterator<IteratorT>::type type;
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename ParserT, typename ActionT>
			class action;
			struct plain_parser_category
			{
			};
			struct binary_parser_category: plain_parser_category
			{
			};
			struct unary_parser_category: plain_parser_category
			{
			};
			struct action_parser_category: unary_parser_category
			{
			};
			template<typename ParserT, typename ScannerT>
			struct parser_result
			{
				typedef typename boost::remove_reference<ParserT>::type parser_type;
				typedef typename parser_type::template result<ScannerT>::type type;
			};
			template<typename DerivedT>
			struct parser
			{
				typedef DerivedT embed_t;
				typedef DerivedT derived_t;
				typedef plain_parser_category parser_category_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, nil_t>::type type;
				};
				DerivedT&derived()
				{
					return *static_cast<DerivedT*>(this);
				}
				DerivedT const&derived()const
				{
					return *static_cast<DerivedT const*>(this);
				}
				template<typename ActionT>
				action<DerivedT, ActionT>operator[](ActionT const&actor)const
				{
					return action<DerivedT, ActionT>(derived(), actor);
				}
			};
			template<typename IteratorT=char const*>
			struct parse_info
			{
				IteratorT stop;
				bool hit;
				bool full;
				std::size_t length;
				parse_info(IteratorT const&stop_=IteratorT(), bool hit_=false, bool full_=false, std::size_t length_=0): stop(stop_), hit(hit_), full(full_), length(length_)
				{
				}
				template<typename ParseInfoT>
				parse_info(ParseInfoT const&pi): stop(pi.stop), hit(pi.hit), full(pi.full), length(pi.length)
				{
				}
			};
			template<typename IteratorT, typename DerivedT>
			parse_info<IteratorT>parse(IteratorT const&first, IteratorT const&last, parser<DerivedT>const&p);
			template<typename CharT, typename DerivedT>
			parse_info<CharT const*>parse(CharT const*str, parser<DerivedT>const&p);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename IteratorT, typename DerivedT>
			inline parse_info<IteratorT>parse(IteratorT const&first_, IteratorT const&last, parser<DerivedT>const&p)
			{
				IteratorT first=first_;
				scanner<IteratorT, scanner_policies<> >scan(first, last);
				match<nil_t>hit=p.derived().parse(scan);
				return parse_info<IteratorT>(first, hit, hit&&(first==last), hit.length());
			}
			template<typename CharT, typename DerivedT>
			inline parse_info<CharT const*>parse(CharT const*str, parser<DerivedT>const&p)
			{
				CharT const*last=str;
				while(*last)last++;
				return parse(str, last, p);
			}
		}
	}
}
extern "C"
{
	typedef wchar_t wctrans_t;
	wint_t towctrans(wint_t, wctrans_t);
	wctrans_t wctrans(const char*);
	wctype_t wctype(const char*);
}
namespace std
{
	using::wint_t;
	using::wctrans_t;
	using::wctype_t;
	using::iswalnum;
	using::iswalpha;
	using::iswcntrl;
	using::iswctype;
	using::iswdigit;
	using::iswgraph;
	using::iswlower;
	using::iswprint;
	using::iswpunct;
	using::iswspace;
	using::iswupper;
	using::iswxdigit;
	using::towctrans;
	using::towlower;
	using::towupper;
	using::wctrans;
	using::wctype;
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename DrivedT>
			struct char_parser;
			namespace impl
			{
				template<typename IteratorT>
				inline IteratorT get_last(IteratorT first)
				{
					while(*first)first++;
					return first;
				}
				template<typename RT, typename IteratorT, typename ScannerT>
				inline RT string_parser_parse(IteratorT str_first, IteratorT str_last, ScannerT&scan)
				{
					typedef typename ScannerT::iterator_t iterator_t;
					iterator_t saved=scan.first;
					std::size_t slen=str_last-str_first;
					while(str_first!=str_last)
					{
						if(scan.at_end()||(*str_first!=*scan))return scan.no_match();
						++str_first;
						++scan;
					}
					return scan.create_match(slen, nil_t(), saved, scan.first);
				}
				template<typename CharT>
				struct char_type_char_traits_helper
				{
					typedef CharT char_type;
					typedef typename std::char_traits<CharT>::int_type int_type;
					static int_type to_int_type(CharT c)
					{
						return std::char_traits<CharT>::to_int_type(c);
					}
					static char_type to_char_type(int_type i)
					{
						return std::char_traits<CharT>::to_char_type(i);
					}
				};
				template<typename CharT>
				struct char_traits_helper
				{
					typedef CharT char_type;
					typedef CharT int_type;
					static CharT&to_int_type(CharT&c)
					{
						return c;
					}
					static CharT&to_char_type(CharT&c)
					{
						return c;
					}
				};
				template<>
				struct char_traits_helper<char>: char_type_char_traits_helper<char>
				{
				};
				template<>
				struct char_traits_helper<wchar_t>: char_type_char_traits_helper<wchar_t>
				{
				};
				template<typename CharT>
				inline typename char_traits_helper<CharT>::int_type to_int_type(CharT c)
				{
					return char_traits_helper<CharT>::to_int_type(c);
				}
				template<typename CharT>
				inline CharT to_char_type(typename char_traits_helper<CharT>::int_type c)
				{
					return char_traits_helper<CharT>::to_char_type(c);
				}
				template<typename CharT>
				inline bool isalnum_(CharT c)
				{
					using namespace std;
					return isalnum(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool isalpha_(CharT c)
				{
					using namespace std;
					return isalpha(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool iscntrl_(CharT c)
				{
					using namespace std;
					return iscntrl(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool isdigit_(CharT c)
				{
					using namespace std;
					return isdigit(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool isgraph_(CharT c)
				{
					using namespace std;
					return isgraph(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool islower_(CharT c)
				{
					using namespace std;
					return islower(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool isprint_(CharT c)
				{
					using namespace std;
					return isprint(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool ispunct_(CharT c)
				{
					using namespace std;
					return ispunct(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool isspace_(CharT c)
				{
					using namespace std;
					return isspace(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool isupper_(CharT c)
				{
					using namespace std;
					return isupper(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool isxdigit_(CharT c)
				{
					using namespace std;
					return isxdigit(to_int_type(c))?true: false;
				}
				template<typename CharT>
				inline bool isblank_(CharT c)
				{
					return (c==' '||c=='\t');
				}
				template<typename CharT>
				inline CharT tolower_(CharT c)
				{
					using namespace std;
					return to_char_type<CharT>(tolower(to_int_type(c)));
				}
				template<typename CharT>
				inline CharT toupper_(CharT c)
				{
					using namespace std;
					return to_char_type<CharT>(toupper(to_int_type(c)));
				}
				inline bool isalnum_(wchar_t c)
				{
					using namespace std;
					return iswalnum(to_int_type(c))?true: false;
				}
				inline bool isalpha_(wchar_t c)
				{
					using namespace std;
					return iswalpha(to_int_type(c))?true: false;
				}
				inline bool iscntrl_(wchar_t c)
				{
					using namespace std;
					return iswcntrl(to_int_type(c))?true: false;
				}
				inline bool isdigit_(wchar_t c)
				{
					using namespace std;
					return iswdigit(to_int_type(c))?true: false;
				}
				inline bool isgraph_(wchar_t c)
				{
					using namespace std;
					return iswgraph(to_int_type(c))?true: false;
				}
				inline bool islower_(wchar_t c)
				{
					using namespace std;
					return iswlower(to_int_type(c))?true: false;
				}
				inline bool isprint_(wchar_t c)
				{
					using namespace std;
					return iswprint(to_int_type(c))?true: false;
				}
				inline bool ispunct_(wchar_t c)
				{
					using namespace std;
					return iswpunct(to_int_type(c))?true: false;
				}
				inline bool isspace_(wchar_t c)
				{
					using namespace std;
					return iswspace(to_int_type(c))?true: false;
				}
				inline bool isupper_(wchar_t c)
				{
					using namespace std;
					return iswupper(to_int_type(c))?true: false;
				}
				inline bool isxdigit_(wchar_t c)
				{
					using namespace std;
					return iswxdigit(to_int_type(c))?true: false;
				}
				inline bool isblank_(wchar_t c)
				{
					return (c==L' '||c==L'\t');
				}
				inline wchar_t tolower_(wchar_t c)
				{
					using namespace std;
					return to_char_type<wchar_t>(towlower(to_int_type(c)));
				}
				inline wchar_t toupper_(wchar_t c)
				{
					using namespace std;
					return to_char_type<wchar_t>(towupper(to_int_type(c)));
				}
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename BaseT=iteration_policy>
			struct skipper_iteration_policy;
			template<typename BaseT=iteration_policy>
			struct no_skipper_iteration_policy;
			template<typename ParserT, typename BaseT=iteration_policy>
			class skip_parser_iteration_policy;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename BaseT>
			struct skipper_iteration_policy: public BaseT
			{
				typedef BaseT base_t;
				skipper_iteration_policy(): BaseT()
				{
				}
				template<typename PolicyT>
				skipper_iteration_policy(PolicyT const&other): BaseT(other)
				{
				}
				template<typename ScannerT>
				void advance(ScannerT const&scan)const
				{
					BaseT::advance(scan);
					scan.skip(scan);
				}
				template<typename ScannerT>
				bool at_end(ScannerT const&scan)const
				{
					scan.skip(scan);
					return BaseT::at_end(scan);
				}
				template<typename ScannerT>
				void skip(ScannerT const&scan)const
				{
					while(!BaseT::at_end(scan)&&impl::isspace_(BaseT::get(scan)))BaseT::advance(scan);
				}
			};
			template<typename BaseT>
			struct no_skipper_iteration_policy: public BaseT
			{
				typedef BaseT base_t;
				no_skipper_iteration_policy(): BaseT()
				{
				}
				template<typename PolicyT>
				no_skipper_iteration_policy(PolicyT const&other): BaseT(other)
				{
				}
				template<typename ScannerT>
				void skip(ScannerT const&)const
				{
				}
			};
			namespace impl
			{
				template<typename ST, typename ScannerT, typename BaseT>
				void skipper_skip(ST const&s, ScannerT const&scan, skipper_iteration_policy<BaseT>const&);
				template<typename ST, typename ScannerT, typename BaseT>
				void skipper_skip(ST const&s, ScannerT const&scan, no_skipper_iteration_policy<BaseT>const&);
				template<typename ST, typename ScannerT>
				void skipper_skip(ST const&s, ScannerT const&scan, iteration_policy const&);
			}
			template<typename ParserT, typename BaseT>
			class skip_parser_iteration_policy: public skipper_iteration_policy<BaseT>
			{
			public:
				typedef skipper_iteration_policy<BaseT>base_t;
				skip_parser_iteration_policy(ParserT const&skip_parser, base_t const&base=base_t()): base_t(base), subject(skip_parser)
				{
				}
				template<typename PolicyT>
				skip_parser_iteration_policy(PolicyT const&other): base_t(other), subject(other.skipper())
				{
				}
				template<typename ScannerT>
				void skip(ScannerT const&scan)const
				{
					impl::skipper_skip(subject, scan, scan);
				}
				ParserT const&skipper()const
				{
					return subject;
				}
			private:
				ParserT const&subject;
			};
			template<typename IteratorT, typename ParserT, typename SkipT>
			parse_info<IteratorT>parse(IteratorT const&first, IteratorT const&last, parser<ParserT>const&p, parser<SkipT>const&skip);
			template<typename CharT, typename ParserT, typename SkipT>
			parse_info<CharT const*>parse(CharT const*str, parser<ParserT>const&p, parser<SkipT>const&skip);
			typedef skipper_iteration_policy<>iter_policy_t;
			typedef scanner_policies<iter_policy_t>scanner_policies_t;
			typedef scanner<char const*, scanner_policies_t>phrase_scanner_t;
			typedef scanner<wchar_t const*, scanner_policies_t>wide_phrase_scanner_t;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct space_parser;
			template<typename BaseT>
			struct no_skipper_iteration_policy;
			namespace impl
			{
				template<typename ST, typename ScannerT, typename BaseT>
				inline void skipper_skip(ST const&s, ScannerT const&scan, skipper_iteration_policy<BaseT>const&)
				{
					typedef scanner_policies<no_skipper_iteration_policy<typename ScannerT::iteration_policy_t>, typename ScannerT::match_policy_t, typename ScannerT::action_policy_t>policies_t;
					scanner<typename ScannerT::iterator_t, policies_t>scan2(scan.first, scan.last, policies_t(scan));
					typedef typename ScannerT::iterator_t iterator_t;
					for(;
					;
					)
					{
						iterator_t save=scan.first;
						if(!s.parse(scan2))
						{
							scan.first=save;
							break;
						}
					}
				}
				template<typename ST, typename ScannerT, typename BaseT>
				inline void skipper_skip(ST const&s, ScannerT const&scan, no_skipper_iteration_policy<BaseT>const&)
				{
					for(;
					;
					)
					{
						typedef typename ScannerT::iterator_t iterator_t;
						iterator_t save=scan.first;
						if(!s.parse(scan))
						{
							scan.first=save;
							break;
						}
					}
				}
				template<typename ST, typename ScannerT>
				inline void skipper_skip(ST const&s, ScannerT const&scan, iteration_policy const&)
				{
					for(;
					;
					)
					{
						typedef typename ScannerT::iterator_t iterator_t;
						iterator_t save=scan.first;
						if(!s.parse(scan))
						{
							scan.first=save;
							break;
						}
					}
				}
				template<typename SkipT>
				struct phrase_parser
				{
					template<typename IteratorT, typename ParserT>
					static parse_info<IteratorT>parse(IteratorT const&first_, IteratorT const&last, ParserT const&p, SkipT const&skip)
					{
						typedef skip_parser_iteration_policy<SkipT>iter_policy_t;
						typedef scanner_policies<iter_policy_t>scanner_policies_t;
						typedef scanner<IteratorT, scanner_policies_t>scanner_t;
						iter_policy_t iter_policy(skip);
						scanner_policies_t policies(iter_policy);
						IteratorT first=first_;
						scanner_t scan(first, last, policies);
						match<nil_t>hit=p.parse(scan);
						return parse_info<IteratorT>(first, hit, hit&&(first==last), hit.length());
					}
				};
				template<>
				struct phrase_parser<space_parser>
				{
					template<typename IteratorT, typename ParserT>
					static parse_info<IteratorT>parse(IteratorT const&first_, IteratorT const&last, ParserT const&p, space_parser const&)
					{
						typedef skipper_iteration_policy<>iter_policy_t;
						typedef scanner_policies<iter_policy_t>scanner_policies_t;
						typedef scanner<IteratorT, scanner_policies_t>scanner_t;
						IteratorT first=first_;
						scanner_t scan(first, last);
						match<nil_t>hit=p.parse(scan);
						return parse_info<IteratorT>(first, hit, hit&&(first==last), hit.length());
					}
				};
			}
			template<typename IteratorT, typename ParserT, typename SkipT>
			inline parse_info<IteratorT>parse(IteratorT const&first, IteratorT const&last, parser<ParserT>const&p, parser<SkipT>const&skip)
			{
				return impl::phrase_parser<SkipT>::parse(first, last, p.derived(), skip.derived());
			}
			template<typename CharT, typename ParserT, typename SkipT>
			inline parse_info<CharT const*>parse(CharT const*str, parser<ParserT>const&p, parser<SkipT>const&skip)
			{
				CharT const*last=str;
				while(*last)last++;
				return parse(str, last, p, skip);
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename BaseT>
			struct no_skipper_iteration_policy;
			template<typename BaseT>
			struct inhibit_case_iteration_policy;
			template<typename A, typename B>
			struct alternative;
			template<typename A, typename B>
			struct longest_alternative;
			template<typename A, typename B>
			struct shortest_alternative;
			namespace impl
			{
				template<typename RT, typename ST, typename ScannerT, typename BaseT>
				inline RT contiguous_parser_parse(ST const&s, ScannerT const&scan, skipper_iteration_policy<BaseT>const&)
				{
					typedef scanner_policies<no_skipper_iteration_policy<typename ScannerT::iteration_policy_t>, typename ScannerT::match_policy_t, typename ScannerT::action_policy_t>policies_t;
					scan.skip(scan);
					RT hit=s.parse(scan.change_policies(policies_t(scan)));
					return hit;
				}
				template<typename RT, typename ST, typename ScannerT, typename BaseT>
				inline RT contiguous_parser_parse(ST const&s, ScannerT const&scan, no_skipper_iteration_policy<BaseT>const&)
				{
					return s.parse(scan);
				}
				template<typename RT, typename ST, typename ScannerT>
				inline RT contiguous_parser_parse(ST const&s, ScannerT const&scan, iteration_policy const&)
				{
					return s.parse(scan);
				}
				template<typename RT, typename ParserT, typename ScannerT, typename BaseT>
				inline RT implicit_lexeme_parse(ParserT const&p, ScannerT const&scan, skipper_iteration_policy<BaseT>const&)
				{
					typedef scanner_policies<no_skipper_iteration_policy<typename ScannerT::iteration_policy_t>, typename ScannerT::match_policy_t, typename ScannerT::action_policy_t>policies_t;
					scan.skip(scan);
					RT hit=p.parse_main(scan.change_policies(policies_t(scan)));
					return hit;
				}
				template<typename RT, typename ParserT, typename ScannerT, typename BaseT>
				inline RT implicit_lexeme_parse(ParserT const&p, ScannerT const&scan, no_skipper_iteration_policy<BaseT>const&)
				{
					return p.parse_main(scan);
				}
				template<typename RT, typename ParserT, typename ScannerT>
				inline RT implicit_lexeme_parse(ParserT const&p, ScannerT const&scan, iteration_policy const&)
				{
					return p.parse_main(scan);
				}
				template<typename RT, typename ST, typename ScannerT>
				inline RT inhibit_case_parser_parse(ST const&s, ScannerT const&scan, iteration_policy const&)
				{
					typedef scanner_policies<inhibit_case_iteration_policy<typename ScannerT::iteration_policy_t>, typename ScannerT::match_policy_t, typename ScannerT::action_policy_t>policies_t;
					return s.parse(scan.change_policies(policies_t(scan)));
				}
				template<typename RT, typename ST, typename ScannerT, typename BaseT>
				inline RT inhibit_case_parser_parse(ST const&s, ScannerT const&scan, inhibit_case_iteration_policy<BaseT>const&)
				{
					return s.parse(scan);
				}
				template<typename T>
				struct to_longest_alternative
				{
					typedef T result_t;
					static result_t const&convert(T const&a)
					{
						return a;
					}
				};
				template<typename A, typename B>
				struct to_longest_alternative<alternative<A, B> >
				{
					typedef typename to_longest_alternative<A>::result_t a_t;
					typedef typename to_longest_alternative<B>::result_t b_t;
					typedef longest_alternative<a_t, b_t>result_t;
					static result_t convert(alternative<A, B>const&alt)
					{
						return result_t(to_longest_alternative<A>::convert(alt.left()), to_longest_alternative<B>::convert(alt.right()));
					}
				};
				template<typename T>
				struct to_shortest_alternative
				{
					typedef T result_t;
					static result_t const&convert(T const&a)
					{
						return a;
					}
				};
				template<typename A, typename B>
				struct to_shortest_alternative<alternative<A, B> >
				{
					typedef typename to_shortest_alternative<A>::result_t a_t;
					typedef typename to_shortest_alternative<B>::result_t b_t;
					typedef shortest_alternative<a_t, b_t>result_t;
					static result_t convert(alternative<A, B>const&alt)
					{
						return result_t(to_shortest_alternative<A>::convert(alt.left()), to_shortest_alternative<B>::convert(alt.right()));
					}
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename DerivedT>
			struct char_parser: public parser<DerivedT>
			{
				typedef DerivedT self_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, typename ScannerT::value_t>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::value_t value_t;
					typedef typename ScannerT::iterator_t iterator_t;
					if(!scan.at_end())
					{
						value_t ch=*scan;
						if(this->derived().test(ch))
						{
							iterator_t save(scan.first);
							++scan.first;
							return scan.create_match(1, ch, save, scan.first);
						}
					}
					return scan.no_match();
				}
			};
			template<typename PositiveT>
			struct negated_char_parser: public char_parser<negated_char_parser<PositiveT> >
			{
				typedef negated_char_parser<PositiveT>self_t;
				typedef PositiveT positive_t;
				negated_char_parser(positive_t const&p): positive(p.derived())
				{
				}
				template<typename T>
				bool test(T ch)const
				{
					return !positive.test(ch);
				}
				positive_t const positive;
			};
			template<typename ParserT>
			inline negated_char_parser<ParserT>operator~(char_parser<ParserT>const&p)
			{
				return negated_char_parser<ParserT>(p.derived());
			}
			template<typename ParserT>
			inline ParserT operator~(negated_char_parser<ParserT>const&n)
			{
				return n.positive;
			}
			template<typename CharT=char>
			struct chlit: public char_parser<chlit<CharT> >
			{
				chlit(CharT ch_): ch(ch_)
				{
				}
				template<typename T>
				bool test(T ch_)const
				{
					return ch_==ch;
				}
				CharT ch;
			};
			template<typename CharT>
			inline chlit<CharT>ch_p(CharT ch)
			{
				return chlit<CharT>(ch);
			}
			template<typename CharT, std::size_t N>
			inline chlit<CharT>ch_p(CharT const(&str)[N])
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(N<3)>)>boost_static_assert_typedef___COUNTER__;
				return chlit<CharT>(str[0]);
			}
			template<typename CharT=char>
			struct range: public char_parser<range<CharT> >
			{
				range(CharT first_, CharT last_): first(first_), last(last_)
				{
					(void)((!!(!(last<first)))||(_wassert(L"!(last < first)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\core\\primitives\\primitives.hpp", 155), 0));
				}
				template<typename T>
				bool test(T ch)const
				{
					return !(CharT(ch)<first)&&!(last<CharT(ch));
				}
				CharT first;
				CharT last;
			};
			template<typename CharT>
			inline range<CharT>range_p(CharT first, CharT last)
			{
				return range<CharT>(first, last);
			}
			template<typename IteratorT=char const*>
			class chseq: public parser<chseq<IteratorT> >
			{
			public:
				typedef chseq<IteratorT>self_t;
				chseq(IteratorT first_, IteratorT last_): first(first_), last(last_)
				{
				}
				chseq(IteratorT first_): first(first_), last(impl::get_last(first_))
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename boost::unwrap_reference<IteratorT>::type striter_t;
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					return impl::string_parser_parse<result_t>(striter_t(first), striter_t(last), scan);
				}
			private:
				IteratorT first;
				IteratorT last;
			};
			template<typename CharT>
			inline chseq<CharT const*>chseq_p(CharT const*str)
			{
				return chseq<CharT const*>(str);
			}
			template<typename IteratorT>
			inline chseq<IteratorT>chseq_p(IteratorT first, IteratorT last)
			{
				return chseq<IteratorT>(first, last);
			}
			template<typename IteratorT=char const*>
			class strlit: public parser<strlit<IteratorT> >
			{
			public:
				typedef strlit<IteratorT>self_t;
				strlit(IteratorT first, IteratorT last): seq(first, last)
				{
				}
				strlit(IteratorT first): seq(first)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					return impl::contiguous_parser_parse<result_t>(seq, scan, scan);
				}
			private:
				chseq<IteratorT>seq;
			};
			template<typename CharT>
			inline strlit<CharT const*>str_p(CharT const*str)
			{
				return strlit<CharT const*>(str);
			}
			template<typename CharT>
			inline strlit<CharT*>str_p(CharT*str)
			{
				return strlit<CharT*>(str);
			}
			template<typename IteratorT>
			inline strlit<IteratorT>str_p(IteratorT first, IteratorT last)
			{
				return strlit<IteratorT>(first, last);
			}
			template<typename CharT>
			inline chlit<CharT>str_p(CharT ch)
			{
				return chlit<CharT>(ch);
			}
			struct nothing_parser: public parser<nothing_parser>
			{
				typedef nothing_parser self_t;
				nothing_parser()
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					return scan.no_match();
				}
			};
			nothing_parser const nothing_p=nothing_parser();
			struct anychar_parser: public char_parser<anychar_parser>
			{
				typedef anychar_parser self_t;
				anychar_parser()
				{
				}
				template<typename CharT>
				bool test(CharT)const
				{
					return true;
				}
			};
			anychar_parser const anychar_p=anychar_parser();
			inline nothing_parser operator~(anychar_parser)
			{
				return nothing_p;
			}
			struct alnum_parser: public char_parser<alnum_parser>
			{
				typedef alnum_parser self_t;
				alnum_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isalnum_(ch);
				}
			};
			alnum_parser const alnum_p=alnum_parser();
			struct alpha_parser: public char_parser<alpha_parser>
			{
				typedef alpha_parser self_t;
				alpha_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isalpha_(ch);
				}
			};
			alpha_parser const alpha_p=alpha_parser();
			struct cntrl_parser: public char_parser<cntrl_parser>
			{
				typedef cntrl_parser self_t;
				cntrl_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::iscntrl_(ch);
				}
			};
			cntrl_parser const cntrl_p=cntrl_parser();
			struct digit_parser: public char_parser<digit_parser>
			{
				typedef digit_parser self_t;
				digit_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isdigit_(ch);
				}
			};
			digit_parser const digit_p=digit_parser();
			struct graph_parser: public char_parser<graph_parser>
			{
				typedef graph_parser self_t;
				graph_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isgraph_(ch);
				}
			};
			graph_parser const graph_p=graph_parser();
			struct lower_parser: public char_parser<lower_parser>
			{
				typedef lower_parser self_t;
				lower_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::islower_(ch);
				}
			};
			lower_parser const lower_p=lower_parser();
			struct print_parser: public char_parser<print_parser>
			{
				typedef print_parser self_t;
				print_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isprint_(ch);
				}
			};
			print_parser const print_p=print_parser();
			struct punct_parser: public char_parser<punct_parser>
			{
				typedef punct_parser self_t;
				punct_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::ispunct_(ch);
				}
			};
			punct_parser const punct_p=punct_parser();
			struct blank_parser: public char_parser<blank_parser>
			{
				typedef blank_parser self_t;
				blank_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isblank_(ch);
				}
			};
			blank_parser const blank_p=blank_parser();
			struct space_parser: public char_parser<space_parser>
			{
				typedef space_parser self_t;
				space_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isspace_(ch);
				}
			};
			space_parser const space_p=space_parser();
			struct upper_parser: public char_parser<upper_parser>
			{
				typedef upper_parser self_t;
				upper_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isupper_(ch);
				}
			};
			upper_parser const upper_p=upper_parser();
			struct xdigit_parser: public char_parser<xdigit_parser>
			{
				typedef xdigit_parser self_t;
				xdigit_parser()
				{
				}
				template<typename CharT>
				bool test(CharT ch)const
				{
					return impl::isxdigit_(ch);
				}
			};
			xdigit_parser const xdigit_p=xdigit_parser();
			struct eol_parser: public parser<eol_parser>
			{
				typedef eol_parser self_t;
				eol_parser()
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typename ScannerT::iterator_t save=scan.first;
					std::size_t len=0;
					if(!scan.at_end()&&*scan=='\r')
					{
						++scan.first;
						++len;
					}
					if(scan.first!=scan.last&&*scan=='\n')
					{
						++scan.first;
						++len;
					}
					if(len)return scan.create_match(len, nil_t(), save, scan.first);
					return scan.no_match();
				}
			};
			eol_parser const eol_p=eol_parser();
			struct end_parser: public parser<end_parser>
			{
				typedef end_parser self_t;
				end_parser()
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					if(scan.at_end())return scan.empty_match();
					return scan.no_match();
				}
			};
			end_parser const end_p=end_parser();
			inline strlit<char const*>const pizza_p(char const*your_favorite_pizza)
			{
				return your_favorite_pizza;
			}
		}
	}
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct empty_helper_t1: public T
		{
			empty_helper_t1();
			int i[256];
		private:
			empty_helper_t1(const empty_helper_t1&);
			empty_helper_t1&operator=(const empty_helper_t1&);
		};
		struct empty_helper_t2
		{
			int i[256];
		};
		template<typename T, bool is_a_class=false>
		struct empty_helper
		{
			static const bool value=false;
		};
		template<typename T>
		struct empty_helper<T, true>
		{
			static const bool value=(sizeof(empty_helper_t1<T>)==sizeof(empty_helper_t2));
		};
		template<typename T>
		struct is_empty_impl
		{
			typedef typename remove_cv<T>::type cvt;
			static const bool value=(::boost::type_traits::ice_or< ::boost::detail::empty_helper<cvt, ::boost::is_class<T>::value>::value, __is_empty(cvt)>::value);
		};
		template<>
		struct is_empty_impl<void>
		{
			static const bool value=(false);
		};
		template<>
		struct is_empty_impl<void const>
		{
			static const bool value=(false);
		};
		template<>
		struct is_empty_impl<void volatile>
		{
			static const bool value=(false);
		};
		template<>
		struct is_empty_impl<void const volatile>
		{
			static const bool value=(false);
		};
	}
	template<typename T>
	struct is_empty: ::boost::integral_constant<bool, ::boost::detail::is_empty_impl<T>::value>
	{
	};
}
namespace boost
{
	template<class T1, class T2>
	class compressed_pair;
	namespace details
	{
		template<class T1, class T2, bool IsSame, bool FirstEmpty, bool SecondEmpty>
		struct compressed_pair_switch;
		template<class T1, class T2>
		struct compressed_pair_switch<T1, T2, false, false, false>
		{
			static const int value=0;
		};
		template<class T1, class T2>
		struct compressed_pair_switch<T1, T2, false, true, true>
		{
			static const int value=3;
		};
		template<class T1, class T2>
		struct compressed_pair_switch<T1, T2, false, true, false>
		{
			static const int value=1;
		};
		template<class T1, class T2>
		struct compressed_pair_switch<T1, T2, false, false, true>
		{
			static const int value=2;
		};
		template<class T1, class T2>
		struct compressed_pair_switch<T1, T2, true, true, true>
		{
			static const int value=4;
		};
		template<class T1, class T2>
		struct compressed_pair_switch<T1, T2, true, false, false>
		{
			static const int value=5;
		};
		template<class T1, class T2, int Version>
		class compressed_pair_imp;
		template<typename T>
		inline void cp_swap(T&t1, T&t2)
		{
			using std::swap;
			swap(t1, t2);
		}
		template<class T1, class T2>
		class compressed_pair_imp<T1, T2, 0>
		{
		public:
			typedef T1 first_type;
			typedef T2 second_type;
			typedef typename call_traits<first_type>::param_type first_param_type;
			typedef typename call_traits<second_type>::param_type second_param_type;
			typedef typename call_traits<first_type>::reference first_reference;
			typedef typename call_traits<second_type>::reference second_reference;
			typedef typename call_traits<first_type>::const_reference first_const_reference;
			typedef typename call_traits<second_type>::const_reference second_const_reference;
			compressed_pair_imp()
			{
			}
			compressed_pair_imp(first_param_type x, second_param_type y): first_(x), second_(y)
			{
			}
			compressed_pair_imp(first_param_type x): first_(x)
			{
			}
			compressed_pair_imp(second_param_type y): second_(y)
			{
			}
			first_reference first()
			{
				return first_;
			}
			first_const_reference first()const
			{
				return first_;
			}
			second_reference second()
			{
				return second_;
			}
			second_const_reference second()const
			{
				return second_;
			}
			void swap(::boost::compressed_pair<T1, T2>&y)
			{
				cp_swap(first_, y.first());
				cp_swap(second_, y.second());
			}
		private:
			first_type first_;
			second_type second_;
		};
		template<class T1, class T2>
		class compressed_pair_imp<T1, T2, 1>: protected::boost::remove_cv<T1>::type
		{
		public:
			typedef T1 first_type;
			typedef T2 second_type;
			typedef typename call_traits<first_type>::param_type first_param_type;
			typedef typename call_traits<second_type>::param_type second_param_type;
			typedef typename call_traits<first_type>::reference first_reference;
			typedef typename call_traits<second_type>::reference second_reference;
			typedef typename call_traits<first_type>::const_reference first_const_reference;
			typedef typename call_traits<second_type>::const_reference second_const_reference;
			compressed_pair_imp()
			{
			}
			compressed_pair_imp(first_param_type x, second_param_type y): first_type(x), second_(y)
			{
			}
			compressed_pair_imp(first_param_type x): first_type(x)
			{
			}
			compressed_pair_imp(second_param_type y): second_(y)
			{
			}
			first_reference first()
			{
				return *this;
			}
			first_const_reference first()const
			{
				return *this;
			}
			second_reference second()
			{
				return second_;
			}
			second_const_reference second()const
			{
				return second_;
			}
			void swap(::boost::compressed_pair<T1, T2>&y)
			{
				cp_swap(second_, y.second());
			}
		private:
			second_type second_;
		};
		template<class T1, class T2>
		class compressed_pair_imp<T1, T2, 2>: protected::boost::remove_cv<T2>::type
		{
		public:
			typedef T1 first_type;
			typedef T2 second_type;
			typedef typename call_traits<first_type>::param_type first_param_type;
			typedef typename call_traits<second_type>::param_type second_param_type;
			typedef typename call_traits<first_type>::reference first_reference;
			typedef typename call_traits<second_type>::reference second_reference;
			typedef typename call_traits<first_type>::const_reference first_const_reference;
			typedef typename call_traits<second_type>::const_reference second_const_reference;
			compressed_pair_imp()
			{
			}
			compressed_pair_imp(first_param_type x, second_param_type y): second_type(y), first_(x)
			{
			}
			compressed_pair_imp(first_param_type x): first_(x)
			{
			}
			compressed_pair_imp(second_param_type y): second_type(y)
			{
			}
			first_reference first()
			{
				return first_;
			}
			first_const_reference first()const
			{
				return first_;
			}
			second_reference second()
			{
				return *this;
			}
			second_const_reference second()const
			{
				return *this;
			}
			void swap(::boost::compressed_pair<T1, T2>&y)
			{
				cp_swap(first_, y.first());
			}
		private:
			first_type first_;
		};
		template<class T1, class T2>
		class compressed_pair_imp<T1, T2, 3>: protected::boost::remove_cv<T1>::type, protected::boost::remove_cv<T2>::type
		{
		public:
			typedef T1 first_type;
			typedef T2 second_type;
			typedef typename call_traits<first_type>::param_type first_param_type;
			typedef typename call_traits<second_type>::param_type second_param_type;
			typedef typename call_traits<first_type>::reference first_reference;
			typedef typename call_traits<second_type>::reference second_reference;
			typedef typename call_traits<first_type>::const_reference first_const_reference;
			typedef typename call_traits<second_type>::const_reference second_const_reference;
			compressed_pair_imp()
			{
			}
			compressed_pair_imp(first_param_type x, second_param_type y): first_type(x), second_type(y)
			{
			}
			compressed_pair_imp(first_param_type x): first_type(x)
			{
			}
			compressed_pair_imp(second_param_type y): second_type(y)
			{
			}
			first_reference first()
			{
				return *this;
			}
			first_const_reference first()const
			{
				return *this;
			}
			second_reference second()
			{
				return *this;
			}
			second_const_reference second()const
			{
				return *this;
			}
			void swap(::boost::compressed_pair<T1, T2>&)
			{
			}
		};
		template<class T1, class T2>
		class compressed_pair_imp<T1, T2, 4>: protected::boost::remove_cv<T1>::type
		{
		public:
			typedef T1 first_type;
			typedef T2 second_type;
			typedef typename call_traits<first_type>::param_type first_param_type;
			typedef typename call_traits<second_type>::param_type second_param_type;
			typedef typename call_traits<first_type>::reference first_reference;
			typedef typename call_traits<second_type>::reference second_reference;
			typedef typename call_traits<first_type>::const_reference first_const_reference;
			typedef typename call_traits<second_type>::const_reference second_const_reference;
			compressed_pair_imp()
			{
			}
			compressed_pair_imp(first_param_type x, second_param_type y): first_type(x), m_second(y)
			{
			}
			compressed_pair_imp(first_param_type x): first_type(x), m_second(x)
			{
			}
			first_reference first()
			{
				return *this;
			}
			first_const_reference first()const
			{
				return *this;
			}
			second_reference second()
			{
				return m_second;
			}
			second_const_reference second()const
			{
				return m_second;
			}
			void swap(::boost::compressed_pair<T1, T2>&)
			{
			}
		private:
			T2 m_second;
		};
		template<class T1, class T2>
		class compressed_pair_imp<T1, T2, 5>
		{
		public:
			typedef T1 first_type;
			typedef T2 second_type;
			typedef typename call_traits<first_type>::param_type first_param_type;
			typedef typename call_traits<second_type>::param_type second_param_type;
			typedef typename call_traits<first_type>::reference first_reference;
			typedef typename call_traits<second_type>::reference second_reference;
			typedef typename call_traits<first_type>::const_reference first_const_reference;
			typedef typename call_traits<second_type>::const_reference second_const_reference;
			compressed_pair_imp()
			{
			}
			compressed_pair_imp(first_param_type x, second_param_type y): first_(x), second_(y)
			{
			}
			compressed_pair_imp(first_param_type x): first_(x), second_(x)
			{
			}
			first_reference first()
			{
				return first_;
			}
			first_const_reference first()const
			{
				return first_;
			}
			second_reference second()
			{
				return second_;
			}
			second_const_reference second()const
			{
				return second_;
			}
			void swap(::boost::compressed_pair<T1, T2>&y)
			{
				cp_swap(first_, y.first());
				cp_swap(second_, y.second());
			}
		private:
			first_type first_;
			second_type second_;
		};
	}
	template<class T1, class T2>
	class compressed_pair: private::boost::details::compressed_pair_imp<T1, T2, ::boost::details::compressed_pair_switch<T1, T2, ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value, ::boost::is_empty<T1>::value, ::boost::is_empty<T2>::value>::value>
	{
	private:
		typedef details::compressed_pair_imp<T1, T2, ::boost::details::compressed_pair_switch<T1, T2, ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value, ::boost::is_empty<T1>::value, ::boost::is_empty<T2>::value>::value>base;
	public:
		typedef T1 first_type;
		typedef T2 second_type;
		typedef typename call_traits<first_type>::param_type first_param_type;
		typedef typename call_traits<second_type>::param_type second_param_type;
		typedef typename call_traits<first_type>::reference first_reference;
		typedef typename call_traits<second_type>::reference second_reference;
		typedef typename call_traits<first_type>::const_reference first_const_reference;
		typedef typename call_traits<second_type>::const_reference second_const_reference;
		compressed_pair(): base()
		{
		}
		compressed_pair(first_param_type x, second_param_type y): base(x, y)
		{
		}
		explicit compressed_pair(first_param_type x): base(x)
		{
		}
		explicit compressed_pair(second_param_type y): base(y)
		{
		}
		first_reference first()
		{
			return base::first();
		}
		first_const_reference first()const
		{
			return base::first();
		}
		second_reference second()
		{
			return base::second();
		}
		second_const_reference second()const
		{
			return base::second();
		}
		void swap(compressed_pair&y)
		{
			base::swap(y);
		}
	};
	template<class T>
	class compressed_pair<T, T>: private details::compressed_pair_imp<T, T, ::boost::details::compressed_pair_switch<T, T, ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value, ::boost::is_empty<T>::value, ::boost::is_empty<T>::value>::value>
	{
	private:
		typedef details::compressed_pair_imp<T, T, ::boost::details::compressed_pair_switch<T, T, ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value, ::boost::is_empty<T>::value, ::boost::is_empty<T>::value>::value>base;
	public:
		typedef T first_type;
		typedef T second_type;
		typedef typename call_traits<first_type>::param_type first_param_type;
		typedef typename call_traits<second_type>::param_type second_param_type;
		typedef typename call_traits<first_type>::reference first_reference;
		typedef typename call_traits<second_type>::reference second_reference;
		typedef typename call_traits<first_type>::const_reference first_const_reference;
		typedef typename call_traits<second_type>::const_reference second_const_reference;
		compressed_pair(): base()
		{
		}
		compressed_pair(first_param_type x, second_param_type y): base(x, y)
		{
		}
		explicit compressed_pair(first_param_type x): base(x)
		{
		}
		first_reference first()
		{
			return base::first();
		}
		first_const_reference first()const
		{
			return base::first();
		}
		second_reference second()
		{
			return base::second();
		}
		second_const_reference second()const
		{
			return base::second();
		}
		void swap(::boost::compressed_pair<T, T>&y)
		{
			base::swap(y);
		}
	};
	template<class T1, class T2>
	inline void swap(compressed_pair<T1, T2>&x, compressed_pair<T1, T2>&y)
	{
		x.swap(y);
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename S, typename BaseT>
			class unary: public BaseT
			{
			public:
				typedef BaseT base_t;
				typedef typename boost::call_traits<S>::param_type param_t;
				typedef typename boost::call_traits<S>::const_reference return_t;
				typedef S subject_t;
				typedef typename S::embed_t subject_embed_t;
				unary(param_t subj_): base_t(), subj(subj_)
				{
				}
				unary(BaseT const&base, param_t subj_): base_t(base), subj(subj_)
				{
				}
				return_t subject()const
				{
					return subj;
				}
			private:
				subject_embed_t subj;
			};
			template<typename A, typename B, typename BaseT>
			class binary: public BaseT
			{
			public:
				typedef BaseT base_t;
				typedef typename boost::call_traits<A>::param_type left_param_t;
				typedef typename boost::call_traits<A>::const_reference left_return_t;
				typedef typename boost::call_traits<B>::param_type right_param_t;
				typedef typename boost::call_traits<B>::const_reference right_return_t;
				typedef A left_t;
				typedef typename A::embed_t left_embed_t;
				typedef B right_t;
				typedef typename B::embed_t right_embed_t;
				binary(left_param_t a, right_param_t b): base_t(), subj(a, b)
				{
				}
				left_return_t left()const
				{
					return subj.first();
				}
				right_return_t right()const
				{
					return subj.second();
				}
			private:
				boost::compressed_pair<left_embed_t, right_embed_t>subj;
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct lexeme_parser_gen;
			template<typename ParserT>
			struct contiguous: public unary<ParserT, parser<contiguous<ParserT> > >
			{
				typedef contiguous<ParserT>self_t;
				typedef unary_parser_category parser_category_t;
				typedef lexeme_parser_gen parser_generator_t;
				typedef unary<ParserT, parser<self_t> >base_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				contiguous(ParserT const&p): base_t(p)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					return impl::contiguous_parser_parse<result_t>(this->subject(), scan, scan);
				}
			};
			struct lexeme_parser_gen
			{
				template<typename ParserT>
				struct result
				{
					typedef contiguous<ParserT>type;
				};
				template<typename ParserT>
				static contiguous<ParserT>generate(parser<ParserT>const&subject)
				{
					return contiguous<ParserT>(subject.derived());
				}
				template<typename ParserT>
				contiguous<ParserT>operator[](parser<ParserT>const&subject)const
				{
					return contiguous<ParserT>(subject.derived());
				}
			};
			const lexeme_parser_gen lexeme_d=lexeme_parser_gen();
			template<typename ScannerT>
			struct lexeme_scanner
			{
				typedef scanner_policies<no_skipper_iteration_policy<typename ScannerT::iteration_policy_t>, typename ScannerT::match_policy_t, typename ScannerT::action_policy_t>policies_t;
				typedef typename rebind_scanner_policies<ScannerT, policies_t>::type type;
			};
			template<typename BaseT>
			struct inhibit_case_iteration_policy: public BaseT
			{
				typedef BaseT base_t;
				inhibit_case_iteration_policy(): BaseT()
				{
				}
				template<typename PolicyT>
				inhibit_case_iteration_policy(PolicyT const&other): BaseT(other)
				{
				}
				template<typename CharT>
				CharT filter(CharT ch)const
				{
					return impl::tolower_(ch);
				}
			};
			struct inhibit_case_parser_gen;
			template<typename ParserT>
			struct inhibit_case: public unary<ParserT, parser<inhibit_case<ParserT> > >
			{
				typedef inhibit_case<ParserT>self_t;
				typedef unary_parser_category parser_category_t;
				typedef inhibit_case_parser_gen parser_generator_t;
				typedef unary<ParserT, parser<self_t> >base_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				inhibit_case(ParserT const&p): base_t(p)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					return impl::inhibit_case_parser_parse<result_t>(this->subject(), scan, scan);
				}
			};
			template<int N>
			struct inhibit_case_parser_gen_base
			{
				static inhibit_case<strlit<char const*> >generate(char const*str)
				{
					return inhibit_case<strlit<char const*> >(str);
				}
				static inhibit_case<strlit<wchar_t const*> >generate(wchar_t const*str)
				{
					return inhibit_case<strlit<wchar_t const*> >(str);
				}
				static inhibit_case<chlit<char> >generate(char ch)
				{
					return inhibit_case<chlit<char> >(ch);
				}
				static inhibit_case<chlit<wchar_t> >generate(wchar_t ch)
				{
					return inhibit_case<chlit<wchar_t> >(ch);
				}
				template<typename ParserT>
				static inhibit_case<ParserT>generate(parser<ParserT>const&subject)
				{
					return inhibit_case<ParserT>(subject.derived());
				}
				inhibit_case<strlit<char const*> >operator[](char const*str)const
				{
					return inhibit_case<strlit<char const*> >(str);
				}
				inhibit_case<strlit<wchar_t const*> >operator[](wchar_t const*str)const
				{
					return inhibit_case<strlit<wchar_t const*> >(str);
				}
				inhibit_case<chlit<char> >operator[](char ch)const
				{
					return inhibit_case<chlit<char> >(ch);
				}
				inhibit_case<chlit<wchar_t> >operator[](wchar_t ch)const
				{
					return inhibit_case<chlit<wchar_t> >(ch);
				}
				template<typename ParserT>
				inhibit_case<ParserT>operator[](parser<ParserT>const&subject)const
				{
					return inhibit_case<ParserT>(subject.derived());
				}
			};
			struct inhibit_case_parser_gen: public inhibit_case_parser_gen_base<0>
			{
				inhibit_case_parser_gen()
				{
				}
			};
			const inhibit_case_parser_gen nocase_d=inhibit_case_parser_gen();
			const inhibit_case_parser_gen as_lower_d=inhibit_case_parser_gen();
			template<typename ScannerT>
			struct as_lower_scanner
			{
				typedef scanner_policies<inhibit_case_iteration_policy<typename ScannerT::iteration_policy_t>, typename ScannerT::match_policy_t, typename ScannerT::action_policy_t>policies_t;
				typedef typename rebind_scanner_policies<ScannerT, policies_t>::type type;
			};
			struct longest_parser_gen;
			template<typename A, typename B>
			struct longest_alternative: public binary<A, B, parser<longest_alternative<A, B> > >
			{
				typedef longest_alternative<A, B>self_t;
				typedef binary_parser_category parser_category_t;
				typedef longest_parser_gen parser_generator_t;
				typedef binary<A, B, parser<self_t> >base_t;
				longest_alternative(A const&a, B const&b): base_t(a, b)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typename ScannerT::iterator_t save=scan.first;
					result_t l=this->left().parse(scan);
					std::swap(scan.first, save);
					result_t r=this->right().parse(scan);
					if(l||r)
					{
						if(l.length()>r.length())
						{
							scan.first=save;
							return l;
						}
						return r;
					}
					return scan.no_match();
				}
			};
			struct longest_parser_gen
			{
				template<typename A, typename B>
				struct result
				{
					typedef typename impl::to_longest_alternative<alternative<A, B> >::result_t type;
				};
				template<typename A, typename B>
				static typename impl::to_longest_alternative<alternative<A, B> >::result_t generate(alternative<A, B>const&alt)
				{
					return impl::to_longest_alternative<alternative<A, B> >::convert(alt);
				}
				template<typename A, typename B>
				static longest_alternative<A, B>generate(A const&left, B const&right)
				{
					return longest_alternative<A, B>(left, right);
				}
				template<typename A, typename B>
				typename impl::to_longest_alternative<alternative<A, B> >::result_t operator[](alternative<A, B>const&alt)const
				{
					return impl::to_longest_alternative<alternative<A, B> >::convert(alt);
				}
			};
			const longest_parser_gen longest_d=longest_parser_gen();
			struct shortest_parser_gen;
			template<typename A, typename B>
			struct shortest_alternative: public binary<A, B, parser<shortest_alternative<A, B> > >
			{
				typedef shortest_alternative<A, B>self_t;
				typedef binary_parser_category parser_category_t;
				typedef shortest_parser_gen parser_generator_t;
				typedef binary<A, B, parser<self_t> >base_t;
				shortest_alternative(A const&a, B const&b): base_t(a, b)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typename ScannerT::iterator_t save=scan.first;
					result_t l=this->left().parse(scan);
					std::swap(scan.first, save);
					result_t r=this->right().parse(scan);
					if(l||r)
					{
						if(l.length()<r.length()&&l||!r)
						{
							scan.first=save;
							return l;
						}
						return r;
					}
					return scan.no_match();
				}
			};
			struct shortest_parser_gen
			{
				template<typename A, typename B>
				struct result
				{
					typedef typename impl::to_shortest_alternative<alternative<A, B> >::result_t type;
				};
				template<typename A, typename B>
				static typename impl::to_shortest_alternative<alternative<A, B> >::result_t generate(alternative<A, B>const&alt)
				{
					return impl::to_shortest_alternative<alternative<A, B> >::convert(alt);
				}
				template<typename A, typename B>
				static shortest_alternative<A, B>generate(A const&left, B const&right)
				{
					return shortest_alternative<A, B>(left, right);
				}
				template<typename A, typename B>
				typename impl::to_shortest_alternative<alternative<A, B> >::result_t operator[](alternative<A, B>const&alt)const
				{
					return impl::to_shortest_alternative<alternative<A, B> >::convert(alt);
				}
			};
			const shortest_parser_gen shortest_d=shortest_parser_gen();
			template<typename BoundsT>
			struct min_bounded_gen;
			template<typename ParserT, typename BoundsT>
			struct min_bounded: public unary<ParserT, parser<min_bounded<ParserT, BoundsT> > >
			{
				typedef min_bounded<ParserT, BoundsT>self_t;
				typedef unary_parser_category parser_category_t;
				typedef min_bounded_gen<BoundsT>parser_generator_t;
				typedef unary<ParserT, parser<self_t> >base_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				min_bounded(ParserT const&p, BoundsT const&min__): base_t(p), min_(min__)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					result_t hit=this->subject().parse(scan);
					if(hit.has_valid_attribute()&&hit.value()<min_)return scan.no_match();
					return hit;
				}
				BoundsT min_;
			};
			template<typename BoundsT>
			struct min_bounded_gen
			{
				min_bounded_gen(BoundsT const&min__): min_(min__)
				{
				}
				template<typename DerivedT>
				min_bounded<DerivedT, BoundsT>operator[](parser<DerivedT>const&p)const
				{
					return min_bounded<DerivedT, BoundsT>(p.derived(), min_);
				}
				BoundsT min_;
			};
			template<typename BoundsT>
			inline min_bounded_gen<BoundsT>min_limit_d(BoundsT const&min_)
			{
				return min_bounded_gen<BoundsT>(min_);
			}
			template<typename BoundsT>
			struct max_bounded_gen;
			template<typename ParserT, typename BoundsT>
			struct max_bounded: public unary<ParserT, parser<max_bounded<ParserT, BoundsT> > >
			{
				typedef max_bounded<ParserT, BoundsT>self_t;
				typedef unary_parser_category parser_category_t;
				typedef max_bounded_gen<BoundsT>parser_generator_t;
				typedef unary<ParserT, parser<self_t> >base_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				max_bounded(ParserT const&p, BoundsT const&max__): base_t(p), max_(max__)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					result_t hit=this->subject().parse(scan);
					if(hit.has_valid_attribute()&&hit.value()>max_)return scan.no_match();
					return hit;
				}
				BoundsT max_;
			};
			template<typename BoundsT>
			struct max_bounded_gen
			{
				max_bounded_gen(BoundsT const&max__): max_(max__)
				{
				}
				template<typename DerivedT>
				max_bounded<DerivedT, BoundsT>operator[](parser<DerivedT>const&p)const
				{
					return max_bounded<DerivedT, BoundsT>(p.derived(), max_);
				}
				BoundsT max_;
			};
			template<typename BoundsT>
			inline max_bounded_gen<BoundsT>max_limit_d(BoundsT const&max_)
			{
				return max_bounded_gen<BoundsT>(max_);
			}
			template<typename BoundsT>
			struct bounded_gen;
			template<typename ParserT, typename BoundsT>
			struct bounded: public unary<ParserT, parser<bounded<ParserT, BoundsT> > >
			{
				typedef bounded<ParserT, BoundsT>self_t;
				typedef unary_parser_category parser_category_t;
				typedef bounded_gen<BoundsT>parser_generator_t;
				typedef unary<ParserT, parser<self_t> >base_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				bounded(ParserT const&p, BoundsT const&min__, BoundsT const&max__): base_t(p), min_(min__), max_(max__)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					result_t hit=this->subject().parse(scan);
					if(hit.has_valid_attribute()&&(hit.value()<min_||hit.value()>max_))return scan.no_match();
					return hit;
				}
				BoundsT min_, max_;
			};
			template<typename BoundsT>
			struct bounded_gen
			{
				bounded_gen(BoundsT const&min__, BoundsT const&max__): min_(min__), max_(max__)
				{
				}
				template<typename DerivedT>
				bounded<DerivedT, BoundsT>operator[](parser<DerivedT>const&p)const
				{
					return bounded<DerivedT, BoundsT>(p.derived(), min_, max_);
				}
				BoundsT min_, max_;
			};
			template<typename BoundsT>
			inline bounded_gen<BoundsT>limit_d(BoundsT const&min_, BoundsT const&max_)
			{
				return bounded_gen<BoundsT>(min_, max_);
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T=unsigned, int Radix=10, unsigned MinDigits=1, int MaxDigits=-1>
			struct uint_parser;
			template<typename T=unsigned, int Radix=10, unsigned MinDigits=1, int MaxDigits=-1>
			struct int_parser;
			struct sign_parser;
			template<typename T>
			struct ureal_parser_policies;
			template<typename T>
			struct real_parser_policies;
			template<typename T=double, typename RealPoliciesT=ureal_parser_policies<T> >
			struct real_parser;
			template<typename T>
			struct strict_ureal_parser_policies;
			template<typename T>
			struct strict_real_parser_policies;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct sign_parser;
			namespace impl
			{
				template<typename ScannerT>
				bool extract_sign(ScannerT const&scan, std::size_t&count)
				{
					count=0;
					bool neg=*scan=='-';
					if(neg||(*scan=='+'))
					{
						++scan;
						++count;
						return neg;
					}
					return false;
				}
				template<const int Radix>
				struct radix_traits;
				template<>
				struct radix_traits<2>
				{
					template<typename CharT, typename T>
					static bool digit(CharT ch, T&val)
					{
						val=ch-'0';
						return ('0'==ch||'1'==ch);
					}
				};
				template<>
				struct radix_traits<8>
				{
					template<typename CharT, typename T>
					static bool digit(CharT ch, T&val)
					{
						val=ch-'0';
						return ('0'<=ch&&ch<='7');
					}
				};
				template<>
				struct radix_traits<10>
				{
					template<typename CharT, typename T>
					static bool digit(CharT ch, T&val)
					{
						val=ch-'0';
						return impl::isdigit_(ch);
					}
				};
				template<>
				struct radix_traits<16>
				{
					template<typename CharT, typename T>
					static bool digit(CharT ch, T&val)
					{
						if(radix_traits<10>::digit(ch, val))return true;
						CharT lc=impl::tolower_(ch);
						if('a'<=lc&&lc<='f')
						{
							val=lc-'a'+10;
							return true;
						}
						return false;
					}
				};
				template<typename T, int Radix>
				struct positive_accumulate
				{
					static bool add(T&n, T digit)
					{
						if(std::numeric_limits<T>::is_specialized)
						{
							static T const max=(std::numeric_limits<T>::max)();
							static T const max_div_radix=max/Radix;
							if(n>max_div_radix)return false;
							n*=Radix;
							if(n>max-digit)return false;
							n+=digit;
							return true;
						}
						else
						{
							n*=Radix;
							n+=digit;
							return true;
						}
					}
				};
				template<typename T, int Radix>
				struct negative_accumulate
				{
					static bool add(T&n, T digit)
					{
						if(std::numeric_limits<T>::is_specialized)
						{
							typedef std::numeric_limits<T>num_limits;
							static T const min=(!num_limits::is_integer&&num_limits::is_signed&&num_limits::has_denorm)?-(num_limits::max)(): (num_limits::min)();
							static T const min_div_radix=min/Radix;
							if(n<min_div_radix)return false;
							n*=Radix;
							if(n<min+digit)return false;
							n-=digit;
							return true;
						}
						else
						{
							n*=Radix;
							n-=digit;
							return true;
						}
					}
				};
				template<int MaxDigits>
				inline bool allow_more_digits(std::size_t i)
				{
					return i<MaxDigits;
				}
				template<>
				inline bool allow_more_digits<-1>(std::size_t)
				{
					return true;
				}
				template<int Radix, unsigned MinDigits, int MaxDigits, typename Accumulate>
				struct extract_int
				{
					template<typename ScannerT, typename T>
					static bool f(ScannerT&scan, T&n, std::size_t&count)
					{
						std::size_t i=0;
						T digit;
						while(allow_more_digits<MaxDigits>(i)&&!scan.at_end()&&radix_traits<Radix>::digit(*scan, digit))
						{
							if(!Accumulate::add(n, digit))return false;
							++i, ++scan, ++count;
						}
						return i>=MinDigits;
					}
				};
				template<typename T=unsigned, int Radix=10, unsigned MinDigits=1, int MaxDigits=-1>
				struct uint_parser_impl: parser<uint_parser_impl<T, Radix, MinDigits, MaxDigits> >
				{
					typedef uint_parser_impl<T, Radix, MinDigits, MaxDigits>self_t;
					template<typename ScannerT>
					struct result
					{
						typedef typename match_result<ScannerT, T>::type type;
					};
					template<typename ScannerT>
					typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
					{
						if(!scan.at_end())
						{
							T n=0;
							std::size_t count=0;
							typename ScannerT::iterator_t save=scan.first;
							if(extract_int<Radix, MinDigits, MaxDigits, positive_accumulate<T, Radix> >::f(scan, n, count))
							{
								return scan.create_match(count, n, save, scan.first);
							}
						}
						return scan.no_match();
					}
				};
				template<typename T=unsigned, int Radix=10, unsigned MinDigits=1, int MaxDigits=-1>
				struct int_parser_impl: parser<int_parser_impl<T, Radix, MinDigits, MaxDigits> >
				{
					typedef int_parser_impl<T, Radix, MinDigits, MaxDigits>self_t;
					template<typename ScannerT>
					struct result
					{
						typedef typename match_result<ScannerT, T>::type type;
					};
					template<typename ScannerT>
					typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
					{
						typedef extract_int<Radix, MinDigits, MaxDigits, negative_accumulate<T, Radix> >extract_int_neg_t;
						typedef extract_int<Radix, MinDigits, MaxDigits, positive_accumulate<T, Radix> >extract_int_pos_t;
						if(!scan.at_end())
						{
							T n=0;
							std::size_t count=0;
							typename ScannerT::iterator_t save=scan.first;
							bool hit=impl::extract_sign(scan, count);
							if(hit)hit=extract_int_neg_t::f(scan, n, count);
							else hit=extract_int_pos_t::f(scan, n, count);
							if(hit)return scan.create_match(count, n, save, scan.first);
							else scan.first=save;
						}
						return scan.no_match();
					}
				};
				template<typename RT, typename T, typename RealPoliciesT>
				struct real_parser_impl
				{
					typedef real_parser_impl<RT, T, RealPoliciesT>self_t;
					template<typename ScannerT>
					RT parse_main(ScannerT const&scan)const
					{
						if(scan.at_end())return scan.no_match();
						typename ScannerT::iterator_t save=scan.first;
						typedef typename parser_result<sign_parser, ScannerT>::type sign_match_t;
						typedef typename parser_result<chlit<>, ScannerT>::type exp_match_t;
						sign_match_t sign_match=RealPoliciesT::parse_sign(scan);
						std::size_t count=sign_match?sign_match.length(): 0;
						bool neg=sign_match.has_valid_attribute()?sign_match.value(): false;
						RT n_match=RealPoliciesT::parse_n(scan);
						T n=n_match.has_valid_attribute()?n_match.value(): T(0);
						bool got_a_number=n_match;
						exp_match_t e_hit;
						if(!got_a_number&&!RealPoliciesT::allow_leading_dot)return scan.no_match();
						else count+=n_match.length();
						if(neg)n=-n;
						if(RealPoliciesT::parse_dot(scan))
						{
							if(RT hit=RealPoliciesT::parse_frac_n(scan))
							{
								using namespace std;
								hit.value(hit.value()*pow(T(10), T(-hit.length())));
								if(neg)n-=hit.value();
								else n+=hit.value();
								count+=hit.length()+1;
							}
							else if(!got_a_number||!RealPoliciesT::allow_trailing_dot)return scan.no_match();
							e_hit=RealPoliciesT::parse_exp(scan);
						}
						else
						{
							if(!got_a_number)return scan.no_match();
							e_hit=RealPoliciesT::parse_exp(scan);
							if(RealPoliciesT::expect_dot&&!e_hit)return scan.no_match();
						}
						if(e_hit)
						{
							if(RT e_n_hit=RealPoliciesT::parse_exp_n(scan))
							{
								using namespace std;
								n*=pow(T(10), T(e_n_hit.value()));
								count+=e_n_hit.length()+e_hit.length();
							}
							else
							{
								return scan.no_match();
							}
						}
						return scan.create_match(count, n, save, scan.first);
					}
					template<typename ScannerT>
					static RT parse(ScannerT const&scan)
					{
						static self_t this_;
						return impl::implicit_lexeme_parse<RT>(this_, scan, scan);
					}
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T, int Radix, unsigned MinDigits, int MaxDigits>
			struct uint_parser: parser<uint_parser<T, Radix, MinDigits, MaxDigits> >
			{
				typedef uint_parser<T, Radix, MinDigits, MaxDigits>self_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, T>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef impl::uint_parser_impl<T, Radix, MinDigits, MaxDigits>impl_t;
					typedef typename parser_result<impl_t, ScannerT>::type result_t;
					return impl::contiguous_parser_parse<result_t>(impl_t(), scan, scan);
				}
			};
			template<typename T, int Radix, unsigned MinDigits, int MaxDigits>
			struct int_parser: parser<int_parser<T, Radix, MinDigits, MaxDigits> >
			{
				typedef int_parser<T, Radix, MinDigits, MaxDigits>self_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, T>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef impl::int_parser_impl<T, Radix, MinDigits, MaxDigits>impl_t;
					typedef typename parser_result<impl_t, ScannerT>::type result_t;
					return impl::contiguous_parser_parse<result_t>(impl_t(), scan, scan);
				}
			};
			int_parser<int>const int_p=int_parser<int>();
			uint_parser<unsigned>const uint_p=uint_parser<unsigned>();
			uint_parser<unsigned, 2>const bin_p=uint_parser<unsigned, 2>();
			uint_parser<unsigned, 8>const oct_p=uint_parser<unsigned, 8>();
			uint_parser<unsigned, 16>const hex_p=uint_parser<unsigned, 16>();
			namespace impl
			{
				template<typename ScannerT>
				bool extract_sign(ScannerT const&scan, std::size_t&count);
			}
			struct sign_parser: public parser<sign_parser>
			{
				typedef sign_parser self_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, bool>::type type;
				};
				sign_parser()
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					if(!scan.at_end())
					{
						std::size_t length;
						typename ScannerT::iterator_t save(scan.first);
						bool neg=impl::extract_sign(scan, length);
						if(length)return scan.create_match(1, neg, save, scan.first);
					}
					return scan.no_match();
				}
			};
			sign_parser const sign_p=sign_parser();
			template<typename T>
			struct ureal_parser_policies
			{
				static const bool allow_leading_dot=true;
				static const bool allow_trailing_dot=true;
				static const bool expect_dot=false;
				typedef uint_parser<T, 10, 1, -1>uint_parser_t;
				typedef int_parser<T, 10, 1, -1>int_parser_t;
				template<typename ScannerT>
				static typename match_result<ScannerT, nil_t>::type parse_sign(ScannerT&scan)
				{
					return scan.no_match();
				}
				template<typename ScannerT>
				static typename parser_result<uint_parser_t, ScannerT>::type parse_n(ScannerT&scan)
				{
					return uint_parser_t().parse(scan);
				}
				template<typename ScannerT>
				static typename parser_result<chlit<>, ScannerT>::type parse_dot(ScannerT&scan)
				{
					return ch_p('.').parse(scan);
				}
				template<typename ScannerT>
				static typename parser_result<uint_parser_t, ScannerT>::type parse_frac_n(ScannerT&scan)
				{
					return uint_parser_t().parse(scan);
				}
				template<typename ScannerT>
				static typename parser_result<chlit<>, ScannerT>::type parse_exp(ScannerT&scan)
				{
					return as_lower_d['e'].parse(scan);
				}
				template<typename ScannerT>
				static typename parser_result<int_parser_t, ScannerT>::type parse_exp_n(ScannerT&scan)
				{
					return int_parser_t().parse(scan);
				}
			};
			template<typename T>
			struct real_parser_policies: public ureal_parser_policies<T>
			{
				template<typename ScannerT>
				static typename parser_result<sign_parser, ScannerT>::type parse_sign(ScannerT&scan)
				{
					return sign_p.parse(scan);
				}
			};
			template<typename T, typename RealPoliciesT>
			struct real_parser: public parser<real_parser<T, RealPoliciesT> >
			{
				typedef real_parser<T, RealPoliciesT>self_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, T>::type type;
				};
				real_parser()
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					return impl::real_parser_impl<result_t, T, RealPoliciesT>::parse(scan);
				}
			};
			real_parser<double, ureal_parser_policies<double> >const ureal_p=real_parser<double, ureal_parser_policies<double> >();
			real_parser<double, real_parser_policies<double> >const real_p=real_parser<double, real_parser_policies<double> >();
			template<typename T>
			struct strict_ureal_parser_policies: public ureal_parser_policies<T>
			{
				static const bool expect_dot=true;
			};
			template<typename T>
			struct strict_real_parser_policies: public real_parser_policies<T>
			{
				static const bool expect_dot=true;
			};
			real_parser<double, strict_ureal_parser_policies<double> >const strict_ureal_p=real_parser<double, strict_ureal_parser_policies<double> >();
			real_parser<double, strict_real_parser_policies<double> >const strict_real_p=real_parser<double, strict_real_parser_policies<double> >();
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct default_parser_context_base
			{
				template<typename DerivedT>
				struct aux
				{
				};
			};
			struct parser_context_base
			{
			};
			struct nil_t;
			template<typename ContextT>
			struct parser_context_linker;
			template<typename AttrT=nil_t>
			struct parser_context: parser_context_base
			{
				typedef AttrT attr_t;
				typedef default_parser_context_base base_t;
				typedef parser_context_linker<parser_context<AttrT> >context_linker_t;
				template<typename ParserT>
				parser_context(ParserT const&)
				{
				}
				template<typename ParserT, typename ScannerT>
				void pre_parse(ParserT const&, ScannerT const&)
				{
				}
				template<typename ResultT, typename ParserT, typename ScannerT>
				ResultT&post_parse(ResultT&hit, ParserT const&, ScannerT const&)
				{
					return hit;
				}
			};
			template<typename ContextT, typename DerivedT>
			struct context_aux: public ContextT::base_t::template aux<DerivedT>
			{
			};
			template<typename ScannerT>
			struct parser_scanner_linker: public ScannerT
			{
				parser_scanner_linker(ScannerT const scan_): ScannerT(scan_)
				{
				}
			};
			template<typename ContextT>
			struct parser_context_linker: public ContextT
			{
				template<typename ParserT>
				parser_context_linker(ParserT const&p): ContextT(p)
				{
				}
				template<typename ParserT, typename ScannerT>
				void pre_parse(ParserT const&p, ScannerT const&scan)
				{
					ContextT::pre_parse(p, scan);
				}
				template<typename ResultT, typename ParserT, typename ScannerT>
				ResultT&post_parse(ResultT&hit, ParserT const&p, ScannerT const&scan)
				{
					return ContextT::post_parse(hit, p, scan);
				}
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<int ID, typename ContextT=parser_context<> >
			struct subrule;
			template<int ID, typename DefT, typename ContextT=parser_context<> >
			struct subrule_parser;
			template<typename ScannerT, typename ListT>
			struct subrules_scanner;
			template<typename FirstT, typename RestT>
			struct subrule_list;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename FirstT, typename RestT>
			struct subrule_list;
			template<int ID, typename DefT, typename ContextT>
			struct subrule_parser;
			namespace impl
			{
				template<int N, typename ListT>
				struct get_subrule
				{
					typedef typename get_subrule<N, typename ListT::rest_t>::type type;
				};
				template<int ID, typename DefT, typename ContextT, typename RestT>
				struct get_subrule<ID, subrule_list<subrule_parser<ID, DefT, ContextT>, RestT> >
				{
					typedef DefT type;
				};
				template<int ID>
				struct get_subrule<ID, nil_t>
				{
					typedef nil_t type;
				};
				template<typename T1, typename T2>
				struct get_result_t
				{
					typedef typename mpl::if_<boost::is_same<T1, nil_t>, T2, T1>::type type;
				};
				template<int ID, typename ScannerT, typename ContextResultT>
				struct get_subrule_result
				{
					typedef typename impl::get_subrule<ID, typename ScannerT::list_t>::type parser_t;
					typedef typename parser_result<parser_t, ScannerT>::type def_result_t;
					typedef typename match_result<ScannerT, ContextResultT>::type context_result_t;
					typedef typename get_result_t<context_result_t, def_result_t>::type type;
				};
				template<typename DefT, typename ScannerT, typename ContextResultT>
				struct get_subrule_parser_result
				{
					typedef typename parser_result<DefT, ScannerT>::type def_result_t;
					typedef typename match_result<ScannerT, ContextResultT>::type context_result_t;
					typedef typename get_result_t<context_result_t, def_result_t>::type type;
				};
				template<typename SubruleT, int ID>
				struct same_subrule_id
				{
					static const bool value=(SubruleT::id==ID);
				};
				template<typename RT, typename ScannerT, int ID>
				struct parse_subrule
				{
					template<typename ListT>
					static void do_parse(RT&r, ScannerT const&scan, ListT const&list, mpl::true_)
					{
						r=list.first.rhs.parse(scan);
					}
					template<typename ListT>
					static void do_parse(RT&r, ScannerT const&scan, ListT const&list, mpl::false_)
					{
						typedef typename ListT::rest_t::first_t subrule_t;
						mpl::bool_<same_subrule_id<subrule_t, ID>::value>same_id;
						do_parse(r, scan, list.rest, same_id);
					}
					static void do_(RT&r, ScannerT const&scan)
					{
						typedef typename ScannerT::list_t::first_t subrule_t;
						mpl::bool_<same_subrule_id<subrule_t, ID>::value>same_id;
						do_parse(r, scan, scan.list, same_id);
					}
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename ScannerT, typename ListT>
			struct subrules_scanner: public ScannerT
			{
				typedef ScannerT scanner_t;
				typedef ListT list_t;
				typedef subrules_scanner<ScannerT, ListT>self_t;
				subrules_scanner(ScannerT const&scan, ListT const&list_): ScannerT(scan), list(list_)
				{
				}
				template<typename PoliciesT>
				struct rebind_policies
				{
					typedef typename rebind_scanner_policies<ScannerT, PoliciesT>::type rebind_scanner;
					typedef subrules_scanner<rebind_scanner, ListT>type;
				};
				template<typename PoliciesT>
				subrules_scanner<typename rebind_scanner_policies<ScannerT, PoliciesT>::type, ListT>change_policies(PoliciesT const&policies)const
				{
					typedef subrules_scanner<typename rebind_scanner_policies<ScannerT, PoliciesT>::type, ListT>subrules_scanner_t;
					return subrules_scanner_t(ScannerT::change_policies(policies), list);
				}
				template<typename IteratorT>
				struct rebind_iterator
				{
					typedef typename rebind_scanner_iterator<ScannerT, IteratorT>::type rebind_scanner;
					typedef subrules_scanner<rebind_scanner, ListT>type;
				};
				template<typename IteratorT>
				subrules_scanner<typename rebind_scanner_iterator<ScannerT, IteratorT>::type, ListT>change_iterator(IteratorT const&first, IteratorT const&last)const
				{
					typedef subrules_scanner<typename rebind_scanner_iterator<ScannerT, IteratorT>::type, ListT>subrules_scanner_t;
					return subrules_scanner_t(ScannerT::change_iterator(first, last), list);
				}
				ListT const&list;
			};
			template<typename ScannerT, typename ListT>
			struct subrules_scanner_finder
			{
				typedef subrules_scanner<ScannerT, ListT>type;
			};
			template<typename ScannerT, typename ListT>
			struct subrules_scanner_finder<subrules_scanner<ScannerT, ListT>, ListT>
			{
				typedef subrules_scanner<ScannerT, ListT>type;
			};
			template<typename FirstT, typename RestT>
			struct subrule_list: public parser<subrule_list<FirstT, RestT> >
			{
				typedef subrule_list<FirstT, RestT>self_t;
				typedef FirstT first_t;
				typedef RestT rest_t;
				subrule_list(FirstT const&first_, RestT const&rest_): first(first_), rest(rest_)
				{
				}
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<FirstT, ScannerT>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename subrules_scanner_finder<ScannerT, self_t>::type subrules_scanner_t;
					subrules_scanner_t g_arg(scan, *this);
					return first.start.parse(g_arg);
				}
				template<int ID, typename DefT, typename ContextT>
				subrule_list<FirstT, subrule_list<subrule_parser<ID, DefT, ContextT>, RestT> >operator, (subrule_parser<ID, DefT, ContextT>const&rhs)
				{
					return subrule_list<FirstT, subrule_list<subrule_parser<ID, DefT, ContextT>, RestT> >(first, subrule_list<subrule_parser<ID, DefT, ContextT>, RestT>(rhs, rest));
				}
				FirstT first;
				RestT rest;
			};
			template<int ID, typename DefT, typename ContextT>
			struct subrule_parser: public parser<subrule_parser<ID, DefT, ContextT> >
			{
				typedef subrule_parser<ID, DefT, ContextT>self_t;
				typedef subrule<ID, ContextT>subrule_t;
				typedef DefT def_t;
				static const int id=ID;
				template<typename ScannerT>
				struct result
				{
					typedef typename impl::get_subrule_parser_result<DefT, ScannerT, typename subrule_t::attr_t>::type type;
				};
				subrule_parser(subrule_t const&start_, DefT const&rhs_): rhs(rhs_), start(start_)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef subrule_list<self_t, nil_t>list_t;
					typedef subrules_scanner<ScannerT, list_t>scanner_t;
					list_t list(*this, nil_t());
					scanner_t g_arg(scan, list);
					return start.parse(g_arg);
				}
				template<int ID2, typename DefT2, typename ContextT2>
				inline subrule_list<self_t, subrule_list<subrule_parser<ID2, DefT2, ContextT2>, nil_t> >operator, (subrule_parser<ID2, DefT2, ContextT2>const&rhs)const
				{
					return subrule_list<self_t, subrule_list<subrule_parser<ID2, DefT2, ContextT2>, nil_t> >(*this, subrule_list<subrule_parser<ID2, DefT2, ContextT2>, nil_t>(rhs, nil_t()));
				}
				typename DefT::embed_t rhs;
				subrule_t const&start;
			};
			template<int ID, typename ContextT>
			struct subrule: public parser<subrule<ID, ContextT> >, public ContextT::base_t, public context_aux<ContextT, subrule<ID, ContextT> >
			{
				typedef subrule<ID, ContextT>self_t;
				typedef subrule<ID, ContextT>const&embed_t;
				typedef typename ContextT::context_linker_t context_t;
				typedef typename context_t::attr_t attr_t;
				static const int id=ID;
				template<typename ScannerT>
				struct result
				{
					typedef typename impl::get_subrule_result<ID, ScannerT, attr_t>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse_main(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					result_t result;
					impl::parse_subrule<result_t, ScannerT, ID>::do_(result, scan);
					return result;
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef parser_scanner_linker<ScannerT>scanner_t;
					scanner_t scan_wrap(scan);
					context_t context_wrap(*this);
					context_wrap.pre_parse(*this, scan_wrap);
					result_t hit=parse_main(scan);
					return context_wrap.post_parse(hit, *this, scan_wrap);
					;
				}
				template<typename DefT>
				subrule_parser<ID, DefT, ContextT>operator=(parser<DefT>const&rhs)const
				{
					return subrule_parser<ID, DefT, ContextT>(*this, rhs.derived());
				}
			private:
				subrule&operator=(subrule const&);
				template<int ID2, typename ContextT2>
				subrule&operator=(subrule<ID2, ContextT2>const&);
			};
		}
	}
}
typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(1>0)>)>boost_static_assert_typedef___COUNTER__;
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	template<class T>
	class scoped_ptr
	{
	private:
		T*px;
		scoped_ptr(scoped_ptr const&);
		scoped_ptr&operator=(scoped_ptr const&);
		typedef scoped_ptr<T>this_type;
		void operator==(scoped_ptr const&)const;
		void operator!=(scoped_ptr const&)const;
	public:
		typedef T element_type;
		explicit scoped_ptr(T*p=0): px(p)
		{
		}
		explicit scoped_ptr(std::auto_ptr<T>p): px(p.release())
		{
		}
		~scoped_ptr()
		{
			boost::checked_delete(px);
		}
		void reset(T*p=0)
		{
			(void)((!!(p==0||p!=px))||(_wassert(L"p == 0 || p != px", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\scoped_ptr.hpp", 85), 0));
			this_type(p).swap(*this);
		}
		T&operator*()const
		{
			(void)((!!(px!=0))||(_wassert(L"px != 0", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\scoped_ptr.hpp", 91), 0));
			return *px;
		}
		T*operator->()const
		{
			(void)((!!(px!=0))||(_wassert(L"px != 0", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\scoped_ptr.hpp", 97), 0));
			return px;
		}
		T*get()const
		{
			return px;
		}
		typedef T*this_type::*unspecified_bool_type;
		operator unspecified_bool_type()const
		{
			return px==0?0: &this_type::px;
		}
		bool operator!()const
		{
			return px==0;
		}
		void swap(scoped_ptr&b)
		{
			T*tmp=b.px;
			b.px=px;
			px=tmp;
		}
	};
	template<class T>
	inline void swap(scoped_ptr<T>&a, scoped_ptr<T>&b)
	{
		a.swap(b);
	}
	template<class T>
	inline T*get_pointer(scoped_ptr<T>const&p)
	{
		return p.get();
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename BaseT, typename DefaultT, typename T0, typename T1, typename T2>
				struct get_param
				{
					typedef typename mpl::if_<is_base_and_derived<BaseT, T0>, T0, typename mpl::if_<is_base_and_derived<BaseT, T1>, T1, typename mpl::if_<is_base_and_derived<BaseT, T2>, T2, DefaultT>::type>::type>::type type;
				};
				template<typename T0, typename T1, typename T2>
				struct get_context
				{
					typedef typename get_param<parser_context_base, parser_context<>, T0, T1, T2>::type type;
				};
				template<typename T0, typename T1, typename T2>
				struct get_tag
				{
					typedef typename get_param<parser_tag_base, parser_address_tag, T0, T1, T2>::type type;
				};
				template<typename T0, typename T1, typename T2>
				struct get_scanner
				{
					typedef typename get_param<scanner_base, scanner<>, T0, T1, T2>::type type;
				};
				template<typename DerivedT, typename EmbedT, typename T0=nil_t, typename T1=nil_t, typename T2=nil_t>
				class rule_base;
				class rule_base_access
				{
				public:
					template<typename RuleT>
					static typename RuleT::abstract_parser_t*get(RuleT const&r)
					{
						return r.get();
					}
				};
				template<typename DerivedT, typename EmbedT, typename T0, typename T1, typename T2>
				class rule_base: public parser<DerivedT>, public impl::get_context<T0, T1, T2>::type::base_t, public context_aux<typename impl::get_context<T0, T1, T2>::type, DerivedT>, public impl::get_tag<T0, T1, T2>::type
				{
				public:
					typedef typename impl::get_scanner<T0, T1, T2>::type scanner_t;
					typedef typename impl::get_context<T0, T1, T2>::type context_t;
					typedef typename impl::get_tag<T0, T1, T2>::type tag_t;
					typedef EmbedT embed_t;
					typedef typename context_t::context_linker_t linked_context_t;
					typedef typename linked_context_t::attr_t attr_t;
					template<typename ScannerT>
					struct result
					{
						typedef typename match_result<ScannerT, attr_t>::type type;
					};
					template<typename ScannerT>
					typename parser_result<DerivedT, ScannerT>::type parse(ScannerT const&scan)const
					{
						typedef parser_scanner_linker<ScannerT>linked_scanner_t;
						typedef typename parser_result<DerivedT, ScannerT>::type result_t;
						linked_scanner_t scan_wrap(scan);
						linked_context_t context_wrap(*this);
						context_wrap.pre_parse(*this, scan_wrap);
						result_t hit=parse_main(scan);
						return context_wrap.post_parse(hit, *this, scan_wrap);
						;
					}
					template<typename ScannerT>
					typename parser_result<DerivedT, ScannerT>::type parse_main(ScannerT const&scan)const
					{
						typename parser_result<DerivedT, ScannerT>::type hit;
						DerivedT const*derived_this=static_cast<DerivedT const*>(this);
						if(rule_base_access::get(*derived_this))
						{
							typename ScannerT::iterator_t s(scan.first);
							hit=rule_base_access::get(*derived_this)->do_parse_virtual(scan);
							scan.group_match(hit, this->id(), s, scan.first);
						}
						else
						{
							hit=scan.no_match();
						}
						return hit;
					}
				};
				template<typename ScannerT, typename AttrT>
				struct abstract_parser
				{
					abstract_parser()
					{
					}
					virtual~abstract_parser()
					{
					}
					virtual typename match_result<ScannerT, AttrT>::type do_parse_virtual(ScannerT const&scan)const=0;
					virtual abstract_parser*clone()const=0;
				};
				template<typename ParserT, typename ScannerT, typename AttrT>
				struct concrete_parser: abstract_parser<ScannerT, AttrT>
				{
					concrete_parser(ParserT const&p): p(p)
					{
					}
					virtual~concrete_parser()
					{
					}
					virtual typename match_result<ScannerT, AttrT>::type do_parse_virtual(ScannerT const&scan)const
					{
						return p.parse(scan);
					}
					virtual abstract_parser<ScannerT, AttrT>*clone()const
					{
						return new concrete_parser(p);
					}
					typename ParserT::embed_t p;
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T0=nil_t, typename T1=nil_t, typename T2=nil_t>
			class rule: public impl::rule_base<rule<T0, T1, T2>, rule<T0, T1, T2>const&, T0, T1, T2>
			{
			public:
				typedef rule<T0, T1, T2>self_t;
				typedef impl::rule_base<self_t, self_t const&, T0, T1, T2>base_t;
				typedef typename base_t::scanner_t scanner_t;
				typedef typename base_t::attr_t attr_t;
				typedef impl::abstract_parser<scanner_t, attr_t>abstract_parser_t;
				rule(): ptr()
				{
				}
				~rule()
				{
				}
				rule(rule const&r): ptr(new impl::concrete_parser<rule, scanner_t, attr_t>(r))
				{
				}
				template<typename ParserT>
				rule(ParserT const&p): ptr(new impl::concrete_parser<ParserT, scanner_t, attr_t>(p))
				{
				}
				template<typename ParserT>
				rule&operator=(ParserT const&p)
				{
					ptr.reset(new impl::concrete_parser<ParserT, scanner_t, attr_t>(p));
					return *this;
				}
				rule&operator=(rule const&r)
				{
					ptr.reset(new impl::concrete_parser<rule, scanner_t, attr_t>(r));
					return *this;
				}
				rule<T0, T1, T2>copy()const
				{
					return rule<T0, T1, T2>(ptr.get()?ptr->clone(): 0);
				}
			private:
				friend class impl::rule_base_access;
				abstract_parser_t*get()const
				{
					return ptr.get();
				}
				rule(abstract_parser_t*ptr): ptr(ptr)
				{
				}
				rule(abstract_parser_t const*ptr): ptr(ptr)
				{
				}
				scoped_ptr<abstract_parser_t>ptr;
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename IdT=std::size_t>
				struct object_with_id_base_supply
				{
					typedef IdT object_id;
					typedef std::vector<object_id>id_vector;
					object_with_id_base_supply(): max_id(object_id())
					{
					}
					object_id max_id;
					id_vector free_ids;
					object_id acquire();
					void release(object_id);
				};
				template<typename TagT, typename IdT=std::size_t>
				struct object_with_id_base
				{
					typedef TagT tag_t;
					typedef IdT object_id;
					protected: object_id acquire_object_id();
					void release_object_id(object_id);
				private:
					boost::shared_ptr<object_with_id_base_supply<IdT> >id_supply;
				};
				template<class TagT, typename IdT=std::size_t>
				struct object_with_id: private object_with_id_base<TagT, IdT>
				{
					typedef object_with_id<TagT, IdT>self_t;
					typedef object_with_id_base<TagT, IdT>base_t;
					typedef IdT object_id;
					object_with_id(): id(base_t::acquire_object_id())
					{
					}
					object_with_id(self_t const&other): base_t(other), id(base_t::acquire_object_id())
					{
					}
					self_t&operator=(self_t const&other)
					{
						base_t::operator=(other);
						return *this;
					}
					~object_with_id()
					{
						base_t::release_object_id(id);
					}
					object_id get_object_id()const
					{
						return id;
					}
				private:
					object_id const id;
				};
				template<typename IdT>
				inline IdT object_with_id_base_supply<IdT>::acquire()
				{
					if(free_ids.size())
					{
						object_id id=*free_ids.rbegin();
						free_ids.pop_back();
						return id;
					}
					else
					{
						if(free_ids.capacity()<=max_id)free_ids.reserve(max_id*3/2+1);
						return ++max_id;
					}
				}
				template<typename IdT>
				inline void object_with_id_base_supply<IdT>::release(IdT id)
				{
					if(max_id==id)max_id--;
					else free_ids.push_back(id);
				}
				template<typename TagT, typename IdT>
				inline IdT object_with_id_base<TagT, IdT>::acquire_object_id()
				{

					{
						static boost::shared_ptr<object_with_id_base_supply<IdT> >static_supply;
						if(!static_supply.get())static_supply.reset(new object_with_id_base_supply<IdT>());
						id_supply=static_supply;
					}
					return id_supply->acquire();
				}
				template<typename TagT, typename IdT>
				inline void object_with_id_base<TagT, IdT>::release_object_id(IdT id)
				{
					id_supply->release(id);
				}
			}
		}
	}
}
namespace boost
{
	template<class T>
	class weak_ptr
	{
	private:
		typedef weak_ptr<T>this_type;
	public:
		typedef T element_type;
		weak_ptr(): px(0), pn()
		{
		}
		template<class Y>
		weak_ptr(weak_ptr<Y>const&r, typename detail::sp_enable_if_convertible<Y, T>::type=detail::sp_empty()): px(r.lock().get()), pn(r.pn)
		{
		}
		template<class Y>
		weak_ptr(shared_ptr<Y>const&r, typename detail::sp_enable_if_convertible<Y, T>::type=detail::sp_empty()): px(r.px), pn(r.pn)
		{
		}
		template<class Y>
		weak_ptr&operator=(weak_ptr<Y>const&r)
		{
			px=r.lock().get();
			pn=r.pn;
			return *this;
		}
		template<class Y>
		weak_ptr&operator=(shared_ptr<Y>const&r)
		{
			px=r.px;
			pn=r.pn;
			return *this;
		}
		shared_ptr<T>lock()const
		{
			return shared_ptr<element_type>(*this, boost::detail::sp_nothrow_tag());
		}
		long use_count()const
		{
			return pn.use_count();
		}
		bool expired()const
		{
			return pn.use_count()==0;
		}
		bool _empty()const
		{
			return pn.empty();
		}
		void reset()
		{
			this_type().swap(*this);
		}
		void swap(this_type&other)
		{
			std::swap(px, other.px);
			pn.swap(other.pn);
		}
		void _internal_assign(T*px2, boost::detail::shared_count const&pn2)
		{
			px=px2;
			pn=pn2;
		}
		template<class Y>
		bool _internal_less(weak_ptr<Y>const&rhs)const
		{
			return pn<rhs.pn;
		}
		T*px;
		boost::detail::weak_count pn;
	};
	template<class T, class U>
	inline bool operator<(weak_ptr<T>const&a, weak_ptr<U>const&b)
	{
		return a._internal_less(b);
	}
	template<class T>
	void swap(weak_ptr<T>&a, weak_ptr<T>&b)
	{
		a.swap(b);
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename DerivedT, typename ContextT>
			struct grammar;
			template<typename GrammarT, typename ScannerT>
			struct grammar_definition
			{
				typedef typename GrammarT::template definition<ScannerT>type;
			};
			namespace impl
			{
				struct grammar_tag
				{
				};
				template<typename GrammarT>
				struct grammar_helper_base
				{
					virtual int undefine(GrammarT*)=0;
					virtual~grammar_helper_base()
					{
					}
				};
				template<typename GrammarT>
				struct grammar_helper_list
				{
					typedef GrammarT grammar_t;
					typedef grammar_helper_base<GrammarT>helper_t;
					typedef std::vector<helper_t*>vector_t;
					grammar_helper_list()
					{
					}
					grammar_helper_list(grammar_helper_list const&)
					{
					}
					grammar_helper_list&operator=(grammar_helper_list const&x)
					{
						return *this;
					}
					void push_back(helper_t*helper)
					{
						helpers.push_back(helper);
					}
					void pop_back()
					{
						helpers.pop_back();
					}
					typename vector_t::size_type size()const
					{
						return helpers.size();
					}
					typename vector_t::reverse_iterator rbegin()
					{
						return helpers.rbegin();
					}
					typename vector_t::reverse_iterator rend()
					{
						return helpers.rend();
					}
				private:
					vector_t helpers;
				};
				struct grammartract_helper_list;
				struct grammartract_helper_list
				{
					template<typename GrammarT>
					static grammar_helper_list<GrammarT>&do_(GrammarT const*g)
					{
						return g->helpers;
					}
				};
				template<typename GrammarT, typename DerivedT, typename ScannerT>
				struct grammar_helper: private grammar_helper_base<GrammarT>
				{
					typedef GrammarT grammar_t;
					typedef ScannerT scanner_t;
					typedef DerivedT derived_t;
					typedef typename grammar_definition<DerivedT, ScannerT>::type definition_t;
					typedef grammar_helper<grammar_t, derived_t, scanner_t>helper_t;
					typedef boost::shared_ptr<helper_t>helper_ptr_t;
					typedef boost::weak_ptr<helper_t>helper_weak_ptr_t;
					grammar_helper*this_()
					{
						return this;
					}
					grammar_helper(helper_weak_ptr_t&p): definitions_cnt(0), self(this_())
					{
						p=self;
					}
					definition_t&define(grammar_t const*target_grammar)
					{
						grammar_helper_list<GrammarT>&helpers=grammartract_helper_list::do_(target_grammar);
						typename grammar_t::object_id id=target_grammar->get_object_id();
						if(definitions.size()<=id)definitions.resize(id*3/2+1);
						if(definitions[id]!=0)return *definitions[id];
						std::auto_ptr<definition_t>result(new definition_t(target_grammar->derived()));
						helpers.push_back(this);
						++definitions_cnt;
						definitions[id]=result.get();
						return *(result.release());
					}
					int undefine(grammar_t*target_grammar)
					{
						typename grammar_t::object_id id=target_grammar->get_object_id();
						if(definitions.size()<=id)return 0;
						delete definitions[id];
						definitions[id]=0;
						if(--definitions_cnt==0)self.reset();
						return 0;
					}
				private:
					std::vector<definition_t*>definitions;
					unsigned long definitions_cnt;
					helper_ptr_t self;
				};
				template<typename DerivedT, typename ContextT, typename ScannerT>
				inline typename DerivedT::template definition<ScannerT>&get_definition(grammar<DerivedT, ContextT>const*self)
				{
					typedef grammar<DerivedT, ContextT>self_t;
					typedef impl::grammar_helper<self_t, DerivedT, ScannerT>helper_t;
					typedef typename helper_t::helper_weak_ptr_t ptr_t;
					static ptr_t helper;
					if(helper.expired())new helper_t(helper);
					return helper.lock()->define(self);
				}
				template<int N>
				struct call_helper
				{
					template<typename RT, typename DefinitionT, typename ScannerT>
					static void do_(RT&result, DefinitionT&def, ScannerT const&scan)
					{
						result=def.template get_start_parser<N>()->parse(scan);
					}
				};
				template<>
				struct call_helper<0>
				{
					template<typename RT, typename DefinitionT, typename ScannerT>
					static void do_(RT&result, DefinitionT&def, ScannerT const&scan)
					{
						result=def.start().parse(scan);
					}
				};
				template<int N, typename DerivedT, typename ContextT, typename ScannerT>
				inline typename parser_result<grammar<DerivedT, ContextT>, ScannerT>::type grammar_parser_parse(grammar<DerivedT, ContextT>const*self, ScannerT const&scan)
				{
					typedef typename parser_result<grammar<DerivedT, ContextT>, ScannerT>::type result_t;
					typedef typename DerivedT::template definition<ScannerT>definition_t;
					result_t result;
					definition_t&def=get_definition<DerivedT, ContextT, ScannerT>(self);
					call_helper<N>::do_(result, def, scan);
					return result;
				}
				template<typename GrammarT>
				inline void grammar_destruct(GrammarT*self)
				{
					typedef impl::grammar_helper_base<GrammarT>helper_base_t;
					typedef grammar_helper_list<GrammarT>helper_list_t;
					typedef typename helper_list_t::vector_t::reverse_iterator iterator_t;
					helper_list_t&helpers=grammartract_helper_list::do_(self);
					std::for_each(helpers.rbegin(), helpers.rend(), std::bind2nd(std::mem_fun(&helper_base_t::undefine), self));
				}
				template<typename DerivedT, int N, typename ContextT>
				class entry_grammar: public parser<entry_grammar<DerivedT, N, ContextT> >
				{
				public:
					typedef entry_grammar<DerivedT, N, ContextT>self_t;
					typedef self_t embed_t;
					typedef typename ContextT::context_linker_t context_t;
					typedef typename context_t::attr_t attr_t;
					template<typename ScannerT>
					struct result
					{
						typedef typename match_result<ScannerT, attr_t>::type type;
					};
					entry_grammar(DerivedT const&p): target_grammar(p)
					{
					}
					template<typename ScannerT>
					typename parser_result<self_t, ScannerT>::type parse_main(ScannerT const&scan)const
					{
						return impl::grammar_parser_parse<N>(&target_grammar, scan);
					}
					template<typename ScannerT>
					typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
					{
						typedef typename parser_result<self_t, ScannerT>::type result_t;
						typedef parser_scanner_linker<ScannerT>scanner_t;
						scanner_t scan_wrap(scan);
						context_t context_wrap(target_grammar);
						context_wrap.pre_parse(target_grammar, scan_wrap);
						result_t hit=parse_main(scan);
						return context_wrap.post_parse(hit, target_grammar, scan_wrap);
					}
				private:
					DerivedT const&target_grammar;
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename DerivedT, typename ContextT=parser_context<> >
			struct grammar: public parser<DerivedT>, public ContextT::base_t, public context_aux<ContextT, DerivedT>, public impl::object_with_id<impl::grammar_tag>
			{
				typedef grammar<DerivedT, ContextT>self_t;
				typedef DerivedT const&embed_t;
				typedef typename ContextT::context_linker_t context_t;
				typedef typename context_t::attr_t attr_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, attr_t>::type type;
				};
				grammar()
				{
				}
				~grammar()
				{
					impl::grammar_destruct(this);
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse_main(ScannerT const&scan)const
				{
					return impl::grammar_parser_parse<0>(this, scan);
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef parser_scanner_linker<ScannerT>scanner_t;
					scanner_t scan_wrap(scan);
					context_t context_wrap(*this);
					context_wrap.pre_parse(*this, scan_wrap);
					result_t hit=parse_main(scan);
					return context_wrap.post_parse(hit, *this, scan_wrap);
				}
				template<int N>
				impl::entry_grammar<DerivedT, N, ContextT>use_parser()const
				{
					return impl::entry_grammar<DerivedT, N, ContextT>(this->derived());
				}
			private:
				friend struct impl::grammartract_helper_list;
				mutable impl::grammar_helper_list<self_t>helpers;
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename ParserT, typename ActionT>
			class action: public unary<ParserT, parser<action<ParserT, ActionT> > >
			{
			public:
				typedef action<ParserT, ActionT>self_t;
				typedef action_parser_category parser_category_t;
				typedef unary<ParserT, parser<self_t> >base_t;
				typedef ActionT predicate_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				action(ParserT const&p, ActionT const&a): base_t(p), actor(a)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename ScannerT::iterator_t iterator_t;
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					scan.at_end();
					iterator_t save=scan.first;
					result_t hit=this->subject().parse(scan);
					if(hit)
					{
						typename result_t::return_t val=hit.value();
						scan.do_action(actor, val, save, scan.first);
					}
					return hit;
				}
				ActionT const&predicate()const
				{
					return actor;
				}
			private:
				ActionT actor;
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename T>
				struct default_as_parser
				{
					typedef T type;
					static type const&convert(type const&p)
					{
						return p;
					}
				};
				struct char_as_parser
				{
					typedef chlit<char>type;
					static type convert(char ch)
					{
						return type(ch);
					}
				};
				struct wchar_as_parser
				{
					typedef chlit<wchar_t>type;
					static type convert(wchar_t ch)
					{
						return type(ch);
					}
				};
				struct string_as_parser
				{
					typedef strlit<char const*>type;
					static type convert(char const*str)
					{
						return type(str);
					}
				};
				struct wstring_as_parser
				{
					typedef strlit<wchar_t const*>type;
					static type convert(wchar_t const*str)
					{
						return type(str);
					}
				};
			}
			template<typename T>
			struct as_parser: impl::default_as_parser<T>
			{
			};
			template<>
			struct as_parser<char>: impl::char_as_parser
			{
			};
			template<>
			struct as_parser<wchar_t>: impl::wchar_as_parser
			{
			};
			template<>
			struct as_parser<char*>: impl::string_as_parser
			{
			};
			template<>
			struct as_parser<char const*>: impl::string_as_parser
			{
			};
			template<>
			struct as_parser<wchar_t*>: impl::wstring_as_parser
			{
			};
			template<>
			struct as_parser<wchar_t const*>: impl::wstring_as_parser
			{
			};
			template<int N>
			struct as_parser<char[N]>: impl::string_as_parser
			{
			};
			template<int N>
			struct as_parser<wchar_t[N]>: impl::wstring_as_parser
			{
			};
			template<int N>
			struct as_parser<char const[N]>: impl::string_as_parser
			{
			};
			template<int N>
			struct as_parser<wchar_t const[N]>: impl::wstring_as_parser
			{
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct sequence_parser_gen;
			template<typename A, typename B>
			struct sequence: public binary<A, B, parser<sequence<A, B> > >
			{
				typedef sequence<A, B>self_t;
				typedef binary_parser_category parser_category_t;
				typedef sequence_parser_gen parser_generator_t;
				typedef binary<A, B, parser<self_t> >base_t;
				sequence(A const&a, B const&b): base_t(a, b)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					if(result_t ma=this->left().parse(scan))if(result_t mb=this->right().parse(scan))
					{
						scan.concat_match(ma, mb);
						return ma;
					}
					return scan.no_match();
				}
			};
			struct sequence_parser_gen
			{
				template<typename A, typename B>
				struct result
				{
					typedef sequence<typename as_parser<A>::type, typename as_parser<B>::type>type;
				};
				template<typename A, typename B>
				static sequence<typename as_parser<A>::type, typename as_parser<B>::type>generate(A const&a, B const&b)
				{
					return sequence<typename as_parser<A>::type, typename as_parser<B>::type>(as_parser<A>::convert(a), as_parser<B>::convert(b));
				}
			};
			template<typename A, typename B>
			sequence<A, B>operator>>(parser<A>const&a, parser<B>const&b);
			template<typename A>
			sequence<A, chlit<char> >operator>>(parser<A>const&a, char b);
			template<typename B>
			sequence<chlit<char>, B>operator>>(char a, parser<B>const&b);
			template<typename A>
			sequence<A, strlit<char const*> >operator>>(parser<A>const&a, char const*b);
			template<typename B>
			sequence<strlit<char const*>, B>operator>>(char const*a, parser<B>const&b);
			template<typename A>
			sequence<A, chlit<wchar_t> >operator>>(parser<A>const&a, wchar_t b);
			template<typename B>
			sequence<chlit<wchar_t>, B>operator>>(wchar_t a, parser<B>const&b);
			template<typename A>
			sequence<A, strlit<wchar_t const*> >operator>>(parser<A>const&a, wchar_t const*b);
			template<typename B>
			sequence<strlit<wchar_t const*>, B>operator>>(wchar_t const*a, parser<B>const&b);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			inline sequence<A, B>operator>>(parser<A>const&a, parser<B>const&b)
			{
				return sequence<A, B>(a.derived(), b.derived());
			}
			template<typename A>
			inline sequence<A, chlit<char> >operator>>(parser<A>const&a, char b)
			{
				return sequence<A, chlit<char> >(a.derived(), b);
			}
			template<typename B>
			inline sequence<chlit<char>, B>operator>>(char a, parser<B>const&b)
			{
				return sequence<chlit<char>, B>(a, b.derived());
			}
			template<typename A>
			inline sequence<A, strlit<char const*> >operator>>(parser<A>const&a, char const*b)
			{
				return sequence<A, strlit<char const*> >(a.derived(), b);
			}
			template<typename B>
			inline sequence<strlit<char const*>, B>operator>>(char const*a, parser<B>const&b)
			{
				return sequence<strlit<char const*>, B>(a, b.derived());
			}
			template<typename A>
			inline sequence<A, chlit<wchar_t> >operator>>(parser<A>const&a, wchar_t b)
			{
				return sequence<A, chlit<wchar_t> >(a.derived(), b);
			}
			template<typename B>
			inline sequence<chlit<wchar_t>, B>operator>>(wchar_t a, parser<B>const&b)
			{
				return sequence<chlit<wchar_t>, B>(a, b.derived());
			}
			template<typename A>
			inline sequence<A, strlit<wchar_t const*> >operator>>(parser<A>const&a, wchar_t const*b)
			{
				return sequence<A, strlit<wchar_t const*> >(a.derived(), b);
			}
			template<typename B>
			inline sequence<strlit<wchar_t const*>, B>operator>>(wchar_t const*a, parser<B>const&b)
			{
				return sequence<strlit<wchar_t const*>, B>(a, b.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			sequence<A, B>operator&&(parser<A>const&a, parser<B>const&b);
			template<typename A>
			sequence<A, chlit<char> >operator&&(parser<A>const&a, char b);
			template<typename B>
			sequence<chlit<char>, B>operator&&(char a, parser<B>const&b);
			template<typename A>
			sequence<A, strlit<char const*> >operator&&(parser<A>const&a, char const*b);
			template<typename B>
			sequence<strlit<char const*>, B>operator&&(char const*a, parser<B>const&b);
			template<typename A>
			sequence<A, chlit<wchar_t> >operator&&(parser<A>const&a, wchar_t b);
			template<typename B>
			sequence<chlit<wchar_t>, B>operator&&(wchar_t a, parser<B>const&b);
			template<typename A>
			sequence<A, strlit<wchar_t const*> >operator&&(parser<A>const&a, wchar_t const*b);
			template<typename B>
			sequence<strlit<wchar_t const*>, B>operator&&(wchar_t const*a, parser<B>const&b);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			inline sequence<A, B>operator&&(parser<A>const&a, parser<B>const&b)
			{
				return sequence<A, B>(a.derived(), b.derived());
			}
			template<typename A>
			inline sequence<A, chlit<char> >operator&&(parser<A>const&a, char b)
			{
				return sequence<A, chlit<char> >(a.derived(), b);
			}
			template<typename B>
			inline sequence<chlit<char>, B>operator&&(char a, parser<B>const&b)
			{
				return sequence<chlit<char>, B>(a, b.derived());
			}
			template<typename A>
			inline sequence<A, strlit<char const*> >operator&&(parser<A>const&a, char const*b)
			{
				return sequence<A, strlit<char const*> >(a.derived(), b);
			}
			template<typename B>
			inline sequence<strlit<char const*>, B>operator&&(char const*a, parser<B>const&b)
			{
				return sequence<strlit<char const*>, B>(a, b.derived());
			}
			template<typename A>
			inline sequence<A, chlit<wchar_t> >operator&&(parser<A>const&a, wchar_t b)
			{
				return sequence<A, chlit<wchar_t> >(a.derived(), b);
			}
			template<typename B>
			inline sequence<chlit<wchar_t>, B>operator&&(wchar_t a, parser<B>const&b)
			{
				return sequence<chlit<wchar_t>, B>(a, b.derived());
			}
			template<typename A>
			inline sequence<A, strlit<wchar_t const*> >operator&&(parser<A>const&a, wchar_t const*b)
			{
				return sequence<A, strlit<wchar_t const*> >(a.derived(), b);
			}
			template<typename B>
			inline sequence<strlit<wchar_t const*>, B>operator&&(wchar_t const*a, parser<B>const&b)
			{
				return sequence<strlit<wchar_t const*>, B>(a, b.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct sequential_or_parser_gen;
			template<typename A, typename B>
			struct sequential_or: public binary<A, B, parser<sequential_or<A, B> > >
			{
				typedef sequential_or<A, B>self_t;
				typedef binary_parser_category parser_category_t;
				typedef sequential_or_parser_gen parser_generator_t;
				typedef binary<A, B, parser<self_t> >base_t;
				sequential_or(A const&a, B const&b): base_t(a, b)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::iterator_t iterator_t;

					{
						iterator_t save=scan.first;
						if(result_t ma=this->left().parse(scan))
						{
							save=scan.first;
							if(result_t mb=this->right().parse(scan))
							{
								scan.concat_match(ma, mb);
								return ma;
							}
							else
							{
								scan.first=save;
								return ma;
							}
						}
						scan.first=save;
					}
					return this->right().parse(scan);
				}
			};
			struct sequential_or_parser_gen
			{
				template<typename A, typename B>
				struct result
				{
					typedef sequential_or<typename as_parser<A>::type, typename as_parser<B>::type>type;
				};
				template<typename A, typename B>
				static sequential_or<typename as_parser<A>::type, typename as_parser<B>::type>generate(A const&a, B const&b)
				{
					return sequential_or<typename as_parser<A>::type, typename as_parser<B>::type>(as_parser<A>::convert(a), as_parser<B>::convert(b));
				}
			};
			template<typename A, typename B>
			sequential_or<A, B>operator||(parser<A>const&a, parser<B>const&b);
			template<typename A>
			sequential_or<A, chlit<char> >operator||(parser<A>const&a, char b);
			template<typename B>
			sequential_or<chlit<char>, B>operator||(char a, parser<B>const&b);
			template<typename A>
			sequential_or<A, strlit<char const*> >operator||(parser<A>const&a, char const*b);
			template<typename B>
			sequential_or<strlit<char const*>, B>operator||(char const*a, parser<B>const&b);
			template<typename A>
			sequential_or<A, chlit<wchar_t> >operator||(parser<A>const&a, wchar_t b);
			template<typename B>
			sequential_or<chlit<wchar_t>, B>operator||(wchar_t a, parser<B>const&b);
			template<typename A>
			sequential_or<A, strlit<wchar_t const*> >operator||(parser<A>const&a, wchar_t const*b);
			template<typename B>
			sequential_or<strlit<wchar_t const*>, B>operator||(wchar_t const*a, parser<B>const&b);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			inline sequential_or<A, B>operator||(parser<A>const&a, parser<B>const&b)
			{
				return sequential_or<A, B>(a.derived(), b.derived());
			}
			template<typename A>
			inline sequential_or<A, chlit<char> >operator||(parser<A>const&a, char b)
			{
				return sequential_or<A, chlit<char> >(a.derived(), b);
			}
			template<typename B>
			inline sequential_or<chlit<char>, B>operator||(char a, parser<B>const&b)
			{
				return sequential_or<chlit<char>, B>(a, b.derived());
			}
			template<typename A>
			inline sequential_or<A, strlit<char const*> >operator||(parser<A>const&a, char const*b)
			{
				return sequential_or<A, strlit<char const*> >(a.derived(), b);
			}
			template<typename B>
			inline sequential_or<strlit<char const*>, B>operator||(char const*a, parser<B>const&b)
			{
				return sequential_or<strlit<char const*>, B>(a, b.derived());
			}
			template<typename A>
			inline sequential_or<A, chlit<wchar_t> >operator||(parser<A>const&a, wchar_t b)
			{
				return sequential_or<A, chlit<wchar_t> >(a.derived(), b);
			}
			template<typename B>
			inline sequential_or<chlit<wchar_t>, B>operator||(wchar_t a, parser<B>const&b)
			{
				return sequential_or<chlit<wchar_t>, B>(a, b.derived());
			}
			template<typename A>
			inline sequential_or<A, strlit<wchar_t const*> >operator||(parser<A>const&a, wchar_t const*b)
			{
				return sequential_or<A, strlit<wchar_t const*> >(a.derived(), b);
			}
			template<typename B>
			inline sequential_or<strlit<wchar_t const*>, B>operator||(wchar_t const*a, parser<B>const&b)
			{
				return sequential_or<strlit<wchar_t const*>, B>(a, b.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct alternative_parser_gen;
			template<typename A, typename B>
			struct alternative: public binary<A, B, parser<alternative<A, B> > >
			{
				typedef alternative<A, B>self_t;
				typedef binary_parser_category parser_category_t;
				typedef alternative_parser_gen parser_generator_t;
				typedef binary<A, B, parser<self_t> >base_t;
				alternative(A const&a, B const&b): base_t(a, b)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::iterator_t iterator_t;

					{
						iterator_t save=scan.first;
						if(result_t hit=this->left().parse(scan))return hit;
						scan.first=save;
					}
					return this->right().parse(scan);
				}
			};
			struct alternative_parser_gen
			{
				template<typename A, typename B>
				struct result
				{
					typedef alternative<typename as_parser<A>::type, typename as_parser<B>::type>type;
				};
				template<typename A, typename B>
				static alternative<typename as_parser<A>::type, typename as_parser<B>::type>generate(A const&a, B const&b)
				{
					return alternative<typename as_parser<A>::type, typename as_parser<B>::type>(as_parser<A>::convert(a), as_parser<B>::convert(b));
				}
			};
			template<typename A, typename B>
			alternative<A, B>operator|(parser<A>const&a, parser<B>const&b);
			template<typename A>
			alternative<A, chlit<char> >operator|(parser<A>const&a, char b);
			template<typename B>
			alternative<chlit<char>, B>operator|(char a, parser<B>const&b);
			template<typename A>
			alternative<A, strlit<char const*> >operator|(parser<A>const&a, char const*b);
			template<typename B>
			alternative<strlit<char const*>, B>operator|(char const*a, parser<B>const&b);
			template<typename A>
			alternative<A, chlit<wchar_t> >operator|(parser<A>const&a, wchar_t b);
			template<typename B>
			alternative<chlit<wchar_t>, B>operator|(wchar_t a, parser<B>const&b);
			template<typename A>
			alternative<A, strlit<wchar_t const*> >operator|(parser<A>const&a, wchar_t const*b);
			template<typename B>
			alternative<strlit<wchar_t const*>, B>operator|(wchar_t const*a, parser<B>const&b);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			inline alternative<A, B>operator|(parser<A>const&a, parser<B>const&b)
			{
				return alternative<A, B>(a.derived(), b.derived());
			}
			template<typename A>
			inline alternative<A, chlit<char> >operator|(parser<A>const&a, char b)
			{
				return alternative<A, chlit<char> >(a.derived(), b);
			}
			template<typename B>
			inline alternative<chlit<char>, B>operator|(char a, parser<B>const&b)
			{
				return alternative<chlit<char>, B>(a, b.derived());
			}
			template<typename A>
			inline alternative<A, strlit<char const*> >operator|(parser<A>const&a, char const*b)
			{
				return alternative<A, strlit<char const*> >(a.derived(), b);
			}
			template<typename B>
			inline alternative<strlit<char const*>, B>operator|(char const*a, parser<B>const&b)
			{
				return alternative<strlit<char const*>, B>(a, b.derived());
			}
			template<typename A>
			inline alternative<A, chlit<wchar_t> >operator|(parser<A>const&a, wchar_t b)
			{
				return alternative<A, chlit<wchar_t> >(a.derived(), b);
			}
			template<typename B>
			inline alternative<chlit<wchar_t>, B>operator|(wchar_t a, parser<B>const&b)
			{
				return alternative<chlit<wchar_t>, B>(a, b.derived());
			}
			template<typename A>
			inline alternative<A, strlit<wchar_t const*> >operator|(parser<A>const&a, wchar_t const*b)
			{
				return alternative<A, strlit<wchar_t const*> >(a.derived(), b);
			}
			template<typename B>
			inline alternative<strlit<wchar_t const*>, B>operator|(wchar_t const*a, parser<B>const&b)
			{
				return alternative<strlit<wchar_t const*>, B>(a, b.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct difference_parser_gen;
			template<typename A, typename B>
			struct difference: public binary<A, B, parser<difference<A, B> > >
			{
				typedef difference<A, B>self_t;
				typedef binary_parser_category parser_category_t;
				typedef difference_parser_gen parser_generator_t;
				typedef binary<A, B, parser<self_t> >base_t;
				difference(A const&a, B const&b): base_t(a, b)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::iterator_t iterator_t;
					iterator_t save=scan.first;
					if(result_t hl=this->left().parse(scan))
					{
						std::swap(save, scan.first);
						result_t hr=this->right().parse(scan);
						if(!hr||(hr.length()<hl.length()))
						{
							scan.first=save;
							return hl;
						}
					}
					return scan.no_match();
				}
			};
			struct difference_parser_gen
			{
				template<typename A, typename B>
				struct result
				{
					typedef difference<typename as_parser<A>::type, typename as_parser<B>::type>type;
				};
				template<typename A, typename B>
				static difference<typename as_parser<A>::type, typename as_parser<B>::type>generate(A const&a, B const&b)
				{
					return difference<typename as_parser<A>::type, typename as_parser<B>::type>(as_parser<A>::convert(a), as_parser<B>::convert(b));
				}
			};
			template<typename A, typename B>
			difference<A, B>operator-(parser<A>const&a, parser<B>const&b);
			template<typename A>
			difference<A, chlit<char> >operator-(parser<A>const&a, char b);
			template<typename B>
			difference<chlit<char>, B>operator-(char a, parser<B>const&b);
			template<typename A>
			difference<A, strlit<char const*> >operator-(parser<A>const&a, char const*b);
			template<typename B>
			difference<strlit<char const*>, B>operator-(char const*a, parser<B>const&b);
			template<typename A>
			difference<A, chlit<wchar_t> >operator-(parser<A>const&a, wchar_t b);
			template<typename B>
			difference<chlit<wchar_t>, B>operator-(wchar_t a, parser<B>const&b);
			template<typename A>
			difference<A, strlit<wchar_t const*> >operator-(parser<A>const&a, wchar_t const*b);
			template<typename B>
			difference<strlit<wchar_t const*>, B>operator-(wchar_t const*a, parser<B>const&b);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			inline difference<A, B>operator-(parser<A>const&a, parser<B>const&b)
			{
				return difference<A, B>(a.derived(), b.derived());
			}
			template<typename A>
			inline difference<A, chlit<char> >operator-(parser<A>const&a, char b)
			{
				return difference<A, chlit<char> >(a.derived(), b);
			}
			template<typename B>
			inline difference<chlit<char>, B>operator-(char a, parser<B>const&b)
			{
				return difference<chlit<char>, B>(a, b.derived());
			}
			template<typename A>
			inline difference<A, strlit<char const*> >operator-(parser<A>const&a, char const*b)
			{
				return difference<A, strlit<char const*> >(a.derived(), b);
			}
			template<typename B>
			inline difference<strlit<char const*>, B>operator-(char const*a, parser<B>const&b)
			{
				return difference<strlit<char const*>, B>(a, b.derived());
			}
			template<typename A>
			inline difference<A, chlit<wchar_t> >operator-(parser<A>const&a, wchar_t b)
			{
				return difference<A, chlit<wchar_t> >(a.derived(), b);
			}
			template<typename B>
			inline difference<chlit<wchar_t>, B>operator-(wchar_t a, parser<B>const&b)
			{
				return difference<chlit<wchar_t>, B>(a, b.derived());
			}
			template<typename A>
			inline difference<A, strlit<wchar_t const*> >operator-(parser<A>const&a, wchar_t const*b)
			{
				return difference<A, strlit<wchar_t const*> >(a.derived(), b);
			}
			template<typename B>
			inline difference<strlit<wchar_t const*>, B>operator-(wchar_t const*a, parser<B>const&b)
			{
				return difference<strlit<wchar_t const*>, B>(a, b.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct intersection_parser_gen;
			template<typename A, typename B>
			struct intersection: public binary<A, B, parser<intersection<A, B> > >
			{
				typedef intersection<A, B>self_t;
				typedef binary_parser_category parser_category_t;
				typedef intersection_parser_gen parser_generator_t;
				typedef binary<A, B, parser<self_t> >base_t;
				intersection(A const&a, B const&b): base_t(a, b)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::iterator_t iterator_t;
					iterator_t save=scan.first;
					if(result_t hl=this->left().parse(scan))
					{
						ScannerT bscan(scan.first, scan.first, scan);
						scan.first=save;
						result_t hr=this->right().parse(bscan);
						if(hl.length()==hr.length())return hl;
					}
					return scan.no_match();
				}
			};
			struct intersection_parser_gen
			{
				template<typename A, typename B>
				struct result
				{
					typedef intersection<typename as_parser<A>::type, typename as_parser<B>::type>type;
				};
				template<typename A, typename B>
				static intersection<typename as_parser<A>::type, typename as_parser<B>::type>generate(A const&a, B const&b)
				{
					return intersection<typename as_parser<A>::type, typename as_parser<B>::type>(as_parser<A>::convert(a), as_parser<B>::convert(b));
				}
			};
			template<typename A, typename B>
			intersection<A, B>operator&(parser<A>const&a, parser<B>const&b);
			template<typename A>
			intersection<A, chlit<char> >operator&(parser<A>const&a, char b);
			template<typename B>
			intersection<chlit<char>, B>operator&(char a, parser<B>const&b);
			template<typename A>
			intersection<A, strlit<char const*> >operator&(parser<A>const&a, char const*b);
			template<typename B>
			intersection<strlit<char const*>, B>operator&(char const*a, parser<B>const&b);
			template<typename A>
			intersection<A, chlit<wchar_t> >operator&(parser<A>const&a, wchar_t b);
			template<typename B>
			intersection<chlit<wchar_t>, B>operator&(wchar_t a, parser<B>const&b);
			template<typename A>
			intersection<A, strlit<wchar_t const*> >operator&(parser<A>const&a, wchar_t const*b);
			template<typename B>
			intersection<strlit<wchar_t const*>, B>operator&(wchar_t const*a, parser<B>const&b);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			inline intersection<A, B>operator&(parser<A>const&a, parser<B>const&b)
			{
				return intersection<A, B>(a.derived(), b.derived());
			}
			template<typename A>
			inline intersection<A, chlit<char> >operator&(parser<A>const&a, char b)
			{
				return intersection<A, chlit<char> >(a.derived(), b);
			}
			template<typename B>
			inline intersection<chlit<char>, B>operator&(char a, parser<B>const&b)
			{
				return intersection<chlit<char>, B>(a, b.derived());
			}
			template<typename A>
			inline intersection<A, strlit<char const*> >operator&(parser<A>const&a, char const*b)
			{
				return intersection<A, strlit<char const*> >(a.derived(), b);
			}
			template<typename B>
			inline intersection<strlit<char const*>, B>operator&(char const*a, parser<B>const&b)
			{
				return intersection<strlit<char const*>, B>(a, b.derived());
			}
			template<typename A>
			inline intersection<A, chlit<wchar_t> >operator&(parser<A>const&a, wchar_t b)
			{
				return intersection<A, chlit<wchar_t> >(a.derived(), b);
			}
			template<typename B>
			inline intersection<chlit<wchar_t>, B>operator&(wchar_t a, parser<B>const&b)
			{
				return intersection<chlit<wchar_t>, B>(a, b.derived());
			}
			template<typename A>
			inline intersection<A, strlit<wchar_t const*> >operator&(parser<A>const&a, wchar_t const*b)
			{
				return intersection<A, strlit<wchar_t const*> >(a.derived(), b);
			}
			template<typename B>
			inline intersection<strlit<wchar_t const*>, B>operator&(wchar_t const*a, parser<B>const&b)
			{
				return intersection<strlit<wchar_t const*>, B>(a, b.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct exclusive_or_parser_gen;
			template<typename A, typename B>
			struct exclusive_or: public binary<A, B, parser<exclusive_or<A, B> > >
			{
				typedef exclusive_or<A, B>self_t;
				typedef binary_parser_category parser_category_t;
				typedef exclusive_or_parser_gen parser_generator_t;
				typedef binary<A, B, parser<self_t> >base_t;
				exclusive_or(A const&a, B const&b): base_t(a, b)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::iterator_t iterator_t;
					iterator_t save=scan.first;
					result_t l=this->left().parse(scan);
					std::swap(save, scan.first);
					result_t r=this->right().parse(scan);
					if(l?!bool(r): bool(r))
					{
						if(l)scan.first=save;
						return l?l: r;
					}
					return scan.no_match();
				}
			};
			struct exclusive_or_parser_gen
			{
				template<typename A, typename B>
				struct result
				{
					typedef exclusive_or<typename as_parser<A>::type, typename as_parser<B>::type>type;
				};
				template<typename A, typename B>
				static exclusive_or<typename as_parser<A>::type, typename as_parser<B>::type>generate(A const&a, B const&b)
				{
					return exclusive_or<typename as_parser<A>::type, typename as_parser<B>::type>(as_parser<A>::convert(a), as_parser<B>::convert(b));
				}
			};
			template<typename A, typename B>
			exclusive_or<A, B>operator^(parser<A>const&a, parser<B>const&b);
			template<typename A>
			exclusive_or<A, chlit<char> >operator^(parser<A>const&a, char b);
			template<typename B>
			exclusive_or<chlit<char>, B>operator^(char a, parser<B>const&b);
			template<typename A>
			exclusive_or<A, strlit<char const*> >operator^(parser<A>const&a, char const*b);
			template<typename B>
			exclusive_or<strlit<char const*>, B>operator^(char const*a, parser<B>const&b);
			template<typename A>
			exclusive_or<A, chlit<wchar_t> >operator^(parser<A>const&a, wchar_t b);
			template<typename B>
			exclusive_or<chlit<wchar_t>, B>operator^(wchar_t a, parser<B>const&b);
			template<typename A>
			exclusive_or<A, strlit<wchar_t const*> >operator^(parser<A>const&a, wchar_t const*b);
			template<typename B>
			exclusive_or<strlit<wchar_t const*>, B>operator^(wchar_t const*a, parser<B>const&b);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			inline exclusive_or<A, B>operator^(parser<A>const&a, parser<B>const&b)
			{
				return exclusive_or<A, B>(a.derived(), b.derived());
			}
			template<typename A>
			inline exclusive_or<A, chlit<char> >operator^(parser<A>const&a, char b)
			{
				return exclusive_or<A, chlit<char> >(a.derived(), b);
			}
			template<typename B>
			inline exclusive_or<chlit<char>, B>operator^(char a, parser<B>const&b)
			{
				return exclusive_or<chlit<char>, B>(a, b.derived());
			}
			template<typename A>
			inline exclusive_or<A, strlit<char const*> >operator^(parser<A>const&a, char const*b)
			{
				return exclusive_or<A, strlit<char const*> >(a.derived(), b);
			}
			template<typename B>
			inline exclusive_or<strlit<char const*>, B>operator^(char const*a, parser<B>const&b)
			{
				return exclusive_or<strlit<char const*>, B>(a, b.derived());
			}
			template<typename A>
			inline exclusive_or<A, chlit<wchar_t> >operator^(parser<A>const&a, wchar_t b)
			{
				return exclusive_or<A, chlit<wchar_t> >(a.derived(), b);
			}
			template<typename B>
			inline exclusive_or<chlit<wchar_t>, B>operator^(wchar_t a, parser<B>const&b)
			{
				return exclusive_or<chlit<wchar_t>, B>(a, b.derived());
			}
			template<typename A>
			inline exclusive_or<A, strlit<wchar_t const*> >operator^(parser<A>const&a, wchar_t const*b)
			{
				return exclusive_or<A, strlit<wchar_t const*> >(a.derived(), b);
			}
			template<typename B>
			inline exclusive_or<strlit<wchar_t const*>, B>operator^(wchar_t const*a, parser<B>const&b)
			{
				return exclusive_or<strlit<wchar_t const*>, B>(a, b.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct kleene_star_parser_gen;
			template<typename S>
			struct kleene_star: public unary<S, parser<kleene_star<S> > >
			{
				typedef kleene_star<S>self_t;
				typedef unary_parser_category parser_category_t;
				typedef kleene_star_parser_gen parser_generator_t;
				typedef unary<S, parser<self_t> >base_t;
				kleene_star(S const&a): base_t(a)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::iterator_t iterator_t;
					result_t hit=scan.empty_match();
					for(;
					;
					)
					{
						iterator_t save=scan.first;
						if(result_t next=this->subject().parse(scan))
						{
							scan.concat_match(hit, next);
						}
						else
						{
							scan.first=save;
							return hit;
						}
					}
				}
			};
			struct kleene_star_parser_gen
			{
				template<typename S>
				struct result
				{
					typedef kleene_star<S>type;
				};
				template<typename S>
				static kleene_star<S>generate(parser<S>const&a)
				{
					return kleene_star<S>(a.derived());
				}
			};
			template<typename S>
			kleene_star<S>operator*(parser<S>const&a);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename S>
			inline kleene_star<S>operator*(parser<S>const&a)
			{
				return kleene_star<S>(a.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct positive_parser_gen;
			template<typename S>
			struct positive: public unary<S, parser<positive<S> > >
			{
				typedef positive<S>self_t;
				typedef unary_parser_category parser_category_t;
				typedef positive_parser_gen parser_generator_t;
				typedef unary<S, parser<self_t> >base_t;
				positive(S const&a): base_t(a)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::iterator_t iterator_t;
					result_t hit=this->subject().parse(scan);
					if(hit)
					{
						for(;
						;
						)
						{
							iterator_t save=scan.first;
							if(result_t next=this->subject().parse(scan))
							{
								scan.concat_match(hit, next);
							}
							else
							{
								scan.first=save;
								break;
							}
						}
					}
					return hit;
				}
			};
			struct positive_parser_gen
			{
				template<typename S>
				struct result
				{
					typedef positive<S>type;
				};
				template<typename S>
				static positive<S>generate(parser<S>const&a)
				{
					return positive<S>(a.derived());
				}
			};
			template<typename S>
			inline positive<S>operator+(parser<S>const&a);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename S>
			inline positive<S>operator+(parser<S>const&a)
			{
				return positive<S>(a.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct optional_parser_gen;
			template<typename S>
			struct optional: public unary<S, parser<optional<S> > >
			{
				typedef optional<S>self_t;
				typedef unary_parser_category parser_category_t;
				typedef optional_parser_gen parser_generator_t;
				typedef unary<S, parser<self_t> >base_t;
				optional(S const&a): base_t(a)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename ScannerT::iterator_t iterator_t;
					iterator_t save=scan.first;
					if(result_t r=this->subject().parse(scan))
					{
						return r;
					}
					else
					{
						scan.first=save;
						return scan.empty_match();
					}
				}
			};
			struct optional_parser_gen
			{
				template<typename S>
				struct result
				{
					typedef optional<S>type;
				};
				template<typename S>
				static optional<S>generate(parser<S>const&a)
				{
					return optional<S>(a.derived());
				}
			};
			template<typename S>
			optional<S>operator!(parser<S>const&a);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename S>
			optional<S>operator!(parser<S>const&a)
			{
				return optional<S>(a.derived());
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			sequence<A, kleene_star<sequence<B, A> > >operator%(parser<A>const&a, parser<B>const&b);
			template<typename A>
			sequence<A, kleene_star<sequence<chlit<char>, A> > >operator%(parser<A>const&a, char b);
			template<typename B>
			sequence<chlit<char>, kleene_star<sequence<B, chlit<char> > > >operator%(char a, parser<B>const&b);
			template<typename A>
			sequence<A, kleene_star<sequence<strlit<char const*>, A> > >operator%(parser<A>const&a, char const*b);
			template<typename B>
			sequence<strlit<char const*>, kleene_star<sequence<B, strlit<char const*> > > >operator%(char const*a, parser<B>const&b);
			template<typename A>
			sequence<A, kleene_star<sequence<chlit<wchar_t>, A> > >operator%(parser<A>const&a, wchar_t b);
			template<typename B>
			sequence<chlit<wchar_t>, kleene_star<sequence<B, chlit<wchar_t> > > >operator%(wchar_t a, parser<B>const&b);
			template<typename A>
			sequence<A, kleene_star<sequence<strlit<wchar_t const*>, A> > >operator%(parser<A>const&a, wchar_t const*b);
			template<typename B>
			sequence<strlit<wchar_t const*>, kleene_star<sequence<B, strlit<wchar_t const*> > > >operator%(wchar_t const*a, parser<B>const&b);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename A, typename B>
			inline sequence<A, kleene_star<sequence<B, A> > >operator%(parser<A>const&a, parser<B>const&b)
			{
				return a.derived()>>*(b.derived()>>a.derived());
			}
			template<typename A>
			inline sequence<A, kleene_star<sequence<chlit<char>, A> > >operator%(parser<A>const&a, char b)
			{
				return a.derived()>>*(b>>a.derived());
			}
			template<typename B>
			inline sequence<chlit<char>, kleene_star<sequence<B, chlit<char> > > >operator%(char a, parser<B>const&b)
			{
				return a>>*(b.derived()>>a);
			}
			template<typename A>
			inline sequence<A, kleene_star<sequence<strlit<char const*>, A> > >operator%(parser<A>const&a, char const*b)
			{
				return a.derived()>>*(b>>a.derived());
			}
			template<typename B>
			inline sequence<strlit<char const*>, kleene_star<sequence<B, strlit<char const*> > > >operator%(char const*a, parser<B>const&b)
			{
				return a>>*(b.derived()>>a);
			}
			template<typename A>
			inline sequence<A, kleene_star<sequence<chlit<wchar_t>, A> > >operator%(parser<A>const&a, wchar_t b)
			{
				return a.derived()>>*(b>>a.derived());
			}
			template<typename B>
			inline sequence<chlit<wchar_t>, kleene_star<sequence<B, chlit<wchar_t> > > >operator%(wchar_t a, parser<B>const&b)
			{
				return a>>*(b.derived()>>a);
			}
			template<typename A>
			inline sequence<A, kleene_star<sequence<strlit<wchar_t const*>, A> > >operator%(parser<A>const&a, wchar_t const*b)
			{
				return a.derived()>>*(b>>a.derived());
			}
			template<typename B>
			inline sequence<strlit<wchar_t const*>, kleene_star<sequence<B, strlit<wchar_t const*> > > >operator%(wchar_t const*a, parser<B>const&b)
			{
				return a>>*(b.derived()>>a);
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				struct parser_type_traits_base
				{
					static const bool is_alternative=false;
					static const bool is_sequence=false;
					static const bool is_sequential_or=false;
					static const bool is_intersection=false;
					static const bool is_difference=false;
					static const bool is_exclusive_or=false;
					static const bool is_optional=false;
					static const bool is_kleene_star=false;
					static const bool is_positive=false;
				};
				template<typename ParserT>
				struct parser_type_traits: public parser_type_traits_base
				{
				};
				template<typename A, typename B>
				struct parser_type_traits<alternative<A, B> >: public parser_type_traits_base
				{
					static const bool is_alternative=true;
				};
				template<typename A, typename B>
				struct parser_type_traits<sequence<A, B> >: public parser_type_traits_base
				{
					static const bool is_sequence=true;
				};
				template<typename A, typename B>
				struct parser_type_traits<sequential_or<A, B> >: public parser_type_traits_base
				{
					static const bool is_sequential_or=true;
				};
				template<typename A, typename B>
				struct parser_type_traits<intersection<A, B> >: public parser_type_traits_base
				{
					static const bool is_intersection=true;
				};
				template<typename A, typename B>
				struct parser_type_traits<difference<A, B> >: public parser_type_traits_base
				{
					static const bool is_difference=true;
				};
				template<typename A, typename B>
				struct parser_type_traits<exclusive_or<A, B> >: public parser_type_traits_base
				{
					static const bool is_exclusive_or=true;
				};
				template<typename S>
				struct parser_type_traits<optional<S> >: public parser_type_traits_base
				{
					static const bool is_optional=true;
				};
				template<typename S>
				struct parser_type_traits<kleene_star<S> >: public parser_type_traits_base
				{
					static const bool is_kleene_star=true;
				};
				template<typename S>
				struct parser_type_traits<positive<S> >: public parser_type_traits_base
				{
					static const bool is_positive=true;
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T>
			struct is_parser
			{
				static const bool value=(::boost::is_base_and_derived<parser<T>, T>::value);
			};
			template<typename UnaryT>
			struct is_unary_composite
			{
				static const bool value=(::boost::is_convertible<typename UnaryT::parser_category_t, unary_parser_category>::value);
			};
			template<typename ActionT>
			struct is_action_parser
			{
				static const bool value=(::boost::is_convertible<typename ActionT::parser_category_t, action_parser_category>::value);
			};
			template<typename BinaryT>
			struct is_binary_composite
			{
				static const bool value=(::boost::is_convertible<typename BinaryT::parser_category_t, binary_parser_category>::value);
			};
			template<typename CompositeT>
			struct is_composite_parser
			{
				static const bool value=(::boost::spirit::classic::is_unary_composite<CompositeT>::value||::boost::spirit::classic::is_binary_composite<CompositeT>::value);
			};
			template<typename ParserT>
			struct is_alternative
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_alternative);
			};
			template<typename ParserT>
			struct is_sequence
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_sequence);
			};
			template<typename ParserT>
			struct is_sequential_or
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_sequential_or);
			};
			template<typename ParserT>
			struct is_intersection
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_intersection);
			};
			template<typename ParserT>
			struct is_difference
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_difference);
			};
			template<typename ParserT>
			struct is_exclusive_or
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_exclusive_or);
			};
			template<typename ParserT>
			struct is_optional
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_optional);
			};
			template<typename ParserT>
			struct is_kleene_star
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_kleene_star);
			};
			template<typename ParserT>
			struct is_positive
			{
				static const bool value=(::boost::spirit::classic::impl::parser_type_traits<ParserT>::is_positive);
			};
			template<typename UnaryT>
			struct unary_subject
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(boost::spirit::classic::is_unary_composite<UnaryT>::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef typename UnaryT::subject_t type;
			};
			template<typename UnaryT>
			inline typename unary_subject<UnaryT>::type const&get_unary_subject(UnaryT const&unary_)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_unary_composite<UnaryT>::value)>)>boost_static_assert_typedef___COUNTER__;
				return unary_.subject();
			}
			template<typename BinaryT>
			struct binary_left_subject
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_binary_composite<BinaryT>::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef typename BinaryT::left_t type;
			};
			template<typename BinaryT>
			struct binary_right_subject
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_binary_composite<BinaryT>::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef typename BinaryT::right_t type;
			};
			template<typename BinaryT>
			inline typename binary_left_subject<BinaryT>::type const&get_binary_left_subject(BinaryT const&binary_)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_binary_composite<BinaryT>::value)>)>boost_static_assert_typedef___COUNTER__;
				return binary_.left();
			}
			template<typename BinaryT>
			inline typename binary_right_subject<BinaryT>::type const&get_binary_right_subject(BinaryT const&binary_)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_binary_composite<BinaryT>::value)>)>boost_static_assert_typedef___COUNTER__;
				return binary_.right();
			}
			template<typename ActionT>
			struct action_subject
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_action_parser<ActionT>::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef typename ActionT::subject_t type;
			};
			template<typename ActionT>
			inline typename action_subject<ActionT>::type const&get_action_subject(ActionT const&action_)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_action_parser<ActionT>::value)>)>boost_static_assert_typedef___COUNTER__;
				return action_.subject();
			}
			template<typename ActionT>
			struct semantic_action
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_action_parser<ActionT>::value)>)>boost_static_assert_typedef___COUNTER__;
				typedef typename ActionT::predicate_t type;
			};
			template<typename ActionT>
			inline typename semantic_action<ActionT>::type const&get_semantic_action(ActionT const&action_)
			{
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(::boost::spirit::classic::is_action_parser<ActionT>::value)>)>boost_static_assert_typedef___COUNTER__;
				return action_.predicate();
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename BaseT=action_policy>
			struct no_actions_action_policy: public BaseT
			{
				typedef BaseT base_t;
				no_actions_action_policy(): BaseT()
				{
				}
				template<typename PolicyT>
				no_actions_action_policy(PolicyT const&other): BaseT(other)
				{
				}
				template<typename ActorT, typename AttrT, typename IteratorT>
				void do_action(ActorT const&actor, AttrT&val, IteratorT const&first, IteratorT const&last)const
				{
				}
			};
			namespace detail
			{
				template<typename ActionPolicy>
				struct compute_no_actions_action_policy
				{
					typedef no_actions_action_policy<ActionPolicy>type;
				};
				template<typename ActionPolicy>
				struct compute_no_actions_action_policy<no_actions_action_policy<ActionPolicy> >
				{
					typedef no_actions_action_policy<ActionPolicy>type;
				};
			}
			template<typename ScannerT=scanner<> >
			struct no_actions_scanner
			{
				typedef scanner_policies<typename ScannerT::iteration_policy_t, typename ScannerT::match_policy_t, typename detail::compute_no_actions_action_policy<typename ScannerT::action_policy_t>::type>policies_t;
				typedef typename rebind_scanner_policies<ScannerT, policies_t>::type type;
			};
			struct no_actions_parser_gen;
			template<typename ParserT>
			struct no_actions_parser: public unary<ParserT, parser<no_actions_parser<ParserT> > >
			{
				typedef no_actions_parser<ParserT>self_t;
				typedef unary_parser_category parser_category_t;
				typedef no_actions_parser_gen parser_generator_t;
				typedef unary<ParserT, parser<self_t> >base_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				no_actions_parser(ParserT const&p): base_t(p)
				{
				}
				template<typename ScannerT>
				typename result<ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename no_actions_scanner<ScannerT>::policies_t policies_t;
					return this->subject().parse(scan.change_policies(policies_t(scan)));
				}
			};
			struct no_actions_parser_gen
			{
				template<typename ParserT>
				struct result
				{
					typedef no_actions_parser<ParserT>type;
				};
				template<typename ParserT>
				static no_actions_parser<ParserT>generate(parser<ParserT>const&subject)
				{
					return no_actions_parser<ParserT>(subject.derived());
				}
				template<typename ParserT>
				no_actions_parser<ParserT>operator[](parser<ParserT>const&subject)const
				{
					return no_actions_parser<ParserT>(subject.derived());
				}
			};
			const no_actions_parser_gen no_actions_d=no_actions_parser_gen();
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename CondT, bool positive_=true>
			struct condition_parser: parser<condition_parser<CondT, positive_> >
			{
				typedef condition_parser<CondT, positive_>self_t;
				condition_parser(CondT const&cond_): cond(cond_)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					if(positive_==bool(cond()))return scan.empty_match();
					else return scan.no_match();
				}
				condition_parser<CondT, !positive_>negate()const
				{
					return condition_parser<CondT, !positive_>(cond);
				}
			private:
				CondT cond;
			};
			template<typename CondT>
			inline condition_parser<CondT, false>operator~(condition_parser<CondT, true>const&p)
			{
				return p.negate();
			}
			template<typename CondT>
			inline condition_parser<CondT, true>operator~(condition_parser<CondT, false>const&p)
			{
				return p.negate();
			}
			struct empty_match_parser_gen;
			struct negated_empty_match_parser_gen;
			template<typename SubjectT>
			struct negated_empty_match_parser;
			template<typename SubjectT>
			struct empty_match_parser: unary<SubjectT, parser<empty_match_parser<SubjectT> > >
			{
				typedef empty_match_parser<SubjectT>self_t;
				typedef unary<SubjectT, parser<self_t> >base_t;
				typedef unary_parser_category parser_category_t;
				typedef empty_match_parser_gen parser_genererator_t;
				typedef self_t embed_t;
				explicit empty_match_parser(SubjectT const&p): base_t(p)
				{
				}
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, nil_t>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typename ScannerT::iterator_t save(scan.first);
					typedef typename no_actions_scanner<ScannerT>::policies_t policies_t;
					bool matches=this->subject().parse(scan.change_policies(policies_t(scan)));
					if(matches)
					{
						scan.first=save;
						return scan.empty_match();
					}
					else
					{
						return scan.no_match();
					}
				}
				negated_empty_match_parser<SubjectT>negate()const
				{
					return negated_empty_match_parser<SubjectT>(this->subject());
				}
			};
			template<typename SubjectT>
			struct negated_empty_match_parser: public unary<SubjectT, parser<negated_empty_match_parser<SubjectT> > >
			{
				typedef negated_empty_match_parser<SubjectT>self_t;
				typedef unary<SubjectT, parser<self_t> >base_t;
				typedef unary_parser_category parser_category_t;
				typedef negated_empty_match_parser_gen parser_genererator_t;
				explicit negated_empty_match_parser(SubjectT const&p): base_t(p)
				{
				}
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, nil_t>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typename ScannerT::iterator_t save(scan.first);
					typedef typename no_actions_scanner<ScannerT>::policies_t policies_t;
					bool matches=this->subject().parse(scan.change_policies(policies_t(scan)));
					if(!matches)
					{
						scan.first=save;
						return scan.empty_match();
					}
					else
					{
						return scan.no_match();
					}
				}
				empty_match_parser<SubjectT>negate()const
				{
					return empty_match_parser<SubjectT>(this->subject());
				}
			};
			struct empty_match_parser_gen
			{
				template<typename SubjectT>
				struct result
				{
					typedef empty_match_parser<SubjectT>type;
				};
				template<typename SubjectT>
				static empty_match_parser<SubjectT>generate(parser<SubjectT>const&subject)
				{
					return empty_match_parser<SubjectT>(subject.derived());
				}
			};
			struct negated_empty_match_parser_gen
			{
				template<typename SubjectT>
				struct result
				{
					typedef negated_empty_match_parser<SubjectT>type;
				};
				template<typename SubjectT>
				static negated_empty_match_parser<SubjectT>generate(parser<SubjectT>const&subject)
				{
					return negated_empty_match_parser<SubjectT>(subject.derived());
				}
			};
			template<typename SubjectT>
			inline negated_empty_match_parser<SubjectT>operator~(empty_match_parser<SubjectT>const&p)
			{
				return p.negate();
			}
			template<typename SubjectT>
			inline empty_match_parser<SubjectT>operator~(negated_empty_match_parser<SubjectT>const&p)
			{
				return p.negate();
			}
			namespace impl
			{
				template<typename SubjectT>
				struct epsilon_selector
				{
					typedef typename as_parser<SubjectT>::type subject_t;
					typedef typename mpl::if_<is_parser<subject_t>, empty_match_parser<subject_t>, condition_parser<subject_t> >::type type;
				};
			}
			struct epsilon_parser: public parser<epsilon_parser>
			{
				typedef epsilon_parser self_t;
				epsilon_parser()
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					return scan.empty_match();
				}
				template<typename SubjectT>
				typename impl::epsilon_selector<SubjectT>::type operator()(SubjectT const&subject)const
				{
					typedef typename impl::epsilon_selector<SubjectT>::type result_t;
					return result_t(subject);
				}
			};
			epsilon_parser const epsilon_p=epsilon_parser();
			epsilon_parser const eps_p=epsilon_parser();
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T, typename ActionT>
			class ref_value_actor: public ActionT
			{
			private:
				T&ref;
			public:
				explicit ref_value_actor(T&ref_): ref(ref_)
				{
				}
				template<typename T2>
				void operator()(T2 const&val_)const
				{
					this->act(ref, val_);
				}
				template<typename IteratorT>
				void operator()(IteratorT const&first_, IteratorT const&last_)const
				{
					this->act(ref, first_, last_);
				}
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T, typename ValueT, typename ActionT>
			class ref_const_ref_actor: public ActionT
			{
			private:
				T&ref;
				ValueT const&value_ref;
			public:
				ref_const_ref_actor(T&ref_, ValueT const&value_ref_): ref(ref_), value_ref(value_ref_)
				{
				}
				template<typename T2>
				void operator()(T2 const&)const
				{
					this->act(ref, value_ref);
				}
				template<typename IteratorT>
				void operator()(IteratorT const&, IteratorT const&)const
				{
					this->act(ref, value_ref);
				}
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct assign_action
			{
				template<typename T, typename ValueT>
				void act(T&ref_, ValueT const&value_)const
				{
					ref_=value_;
				}
				template<typename T, typename IteratorT>
				void act(T&ref_, IteratorT const&first_, IteratorT const&last_)const
				{
					typedef T value_type;
					value_type value(first_, last_);
					ref_=value;
				}
			};
			template<typename T>
			inline ref_value_actor<T, assign_action>assign(T&ref_)
			{
				return ref_value_actor<T, assign_action>(ref_);
			}
			template<typename T>
			inline ref_value_actor<T, assign_action>assign_a(T&ref_)
			{
				return ref_value_actor<T, assign_action>(ref_);
			}
			template<typename T, typename ValueT>
			inline ref_const_ref_actor<T, ValueT, assign_action>assign_a(T&ref_, ValueT const&value_)
			{
				return ref_const_ref_actor<T, ValueT, assign_action>(ref_, value_);
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct push_back_action
			{
				template<typename T, typename ValueT>
				void act(T&ref_, ValueT const&value_)const
				{
					ref_.push_back(value_);
				}
				template<typename T, typename IteratorT>
				void act(T&ref_, IteratorT const&first_, IteratorT const&last_)const
				{
					typedef typename T::value_type value_type;
					value_type value(first_, last_);
					ref_.push_back(value);
				}
			};
			template<typename T>
			inline ref_value_actor<T, push_back_action>append(T&ref_)
			{
				return ref_value_actor<T, push_back_action>(ref_);
			}
			template<typename T>
			inline ref_value_actor<T, push_back_action>push_back_a(T&ref_)
			{
				return ref_value_actor<T, push_back_action>(ref_);
			}
			template<typename T, typename ValueT>
			inline ref_const_ref_actor<T, ValueT, push_back_action>push_back_a(T&ref_, ValueT const&value_)
			{
				return ref_const_ref_actor<T, ValueT, push_back_action>(ref_, value_);
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T>
			struct tree_node;
			template<typename IteratorT=char const*, typename ValueT=nil_t>
			struct node_iter_data;
			template<typename ValueT=nil_t>
			class node_iter_data_factory;
			template<typename ValueT=nil_t>
			class node_val_data_factory;
			template<typename ValueT=nil_t>
			class node_all_val_data_factory;
			template<typename IteratorT, typename NodeFactoryT=node_val_data_factory<nil_t>, typename T=nil_t>
			class tree_match;
			struct tree_policy;
			template<typename MatchPolicyT, typename IteratorT, typename NodeFactoryT, typename TreePolicyT, typename T=nil_t>
			struct common_tree_match_policy;
			template<typename MatchPolicyT, typename NodeFactoryT>
			struct common_tree_tree_policy;
			template<typename T>
			struct no_tree_gen_node_parser;
			template<typename T>
			struct leaf_node_parser;
			template<typename T, typename NodeParserT>
			struct node_parser;
			struct discard_node_op;
			struct reduced_node_op;
			struct infix_node_op;
			struct discard_first_node_op;
			struct discard_last_node_op;
			struct inner_node_op;
			template<typename T, typename ActionParserT>
			struct action_directive_parser;
			struct access_match_action
			{
				template<typename ParserT, typename ActionT>
				struct action;
			};
			struct access_node_action
			{
				template<typename ParserT, typename ActionT>
				struct action;
			};
			template<typename IteratorT=char const*, typename NodeFactoryT=node_val_data_factory<nil_t>, typename T=nil_t>
			struct tree_parse_info;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T>
			void swap(tree_node<T>&a, tree_node<T>&b);
			template<typename T, typename V>
			void swap(node_iter_data<T, V>&a, node_iter_data<T, V>&b);
			namespace impl
			{
				template<typename T>
				inline void cp_swap(T&t1, T&t2);
			}
			template<typename T>
			struct tree_node
			{
				typedef T parse_node_t;
				typedef std::allocator<tree_node<T> >allocator_type;
				typedef std::vector<tree_node<T>, allocator_type>children_t;
				typedef typename children_t::iterator tree_iterator;
				typedef typename children_t::const_iterator const_tree_iterator;
				T value;
				children_t children;
				tree_node(): value(), children()
				{
				}
				explicit tree_node(T const&v): value(v), children()
				{
				}
				tree_node(T const&v, children_t const&c): value(v), children(c)
				{
				}
				void swap(tree_node<T>&x)
				{
					impl::cp_swap(value, x.value);
					impl::cp_swap(children, x.children);
				}
				tree_node&operator=(tree_node const&rhs)
				{
					tree_node(rhs).swap(*this);
					return *this;
				}
			};
			template<typename IteratorT, typename ValueT>
			struct node_iter_data
			{
				typedef IteratorT iterator_t;
				typedef IteratorT const_iterator_t;
				node_iter_data(): first(), last(), is_root_(false), parser_id_(), value_()
				{
				}
				node_iter_data(IteratorT const&_first, IteratorT const&_last): first(_first), last(_last), is_root_(false), parser_id_(), value_()
				{
				}
				void swap(node_iter_data&x)
				{
					impl::cp_swap(first, x.first);
					impl::cp_swap(last, x.last);
					impl::cp_swap(parser_id_, x.parser_id_);
					impl::cp_swap(is_root_, x.is_root_);
					impl::cp_swap(value_, x.value_);
				}
				IteratorT begin()
				{
					return first;
				}
				IteratorT const&begin()const
				{
					return first;
				}
				IteratorT end()
				{
					return last;
				}
				IteratorT const&end()const
				{
					return last;
				}
				bool is_root()const
				{
					return is_root_;
				}
				void is_root(bool b)
				{
					is_root_=b;
				}
				parser_id id()const
				{
					return parser_id_;
				}
				void id(parser_id r)
				{
					parser_id_=r;
				}
				ValueT const&value()const
				{
					return value_;
				}
				void value(ValueT const&v)
				{
					value_=v;
				}
			private:
				IteratorT first, last;
				bool is_root_;
				parser_id parser_id_;
				ValueT value_;
			public:

			};
			template<typename IteratorT=char const*, typename ValueT=nil_t>
			struct node_val_data
			{
				typedef typename boost::detail::iterator_traits<IteratorT>::value_type value_type;
				typedef std::allocator<value_type>allocator_type;
				typedef std::vector<value_type, allocator_type>container_t;
				typedef typename container_t::iterator iterator_t;
				typedef typename container_t::const_iterator const_iterator_t;
				node_val_data(): text(), is_root_(false), parser_id_(), value_()
				{
				}
				node_val_data(IteratorT const&_first, IteratorT const&_last): text(_first, _last), is_root_(false), parser_id_(), value_()
				{
				}
				template<typename IteratorT2>
				node_val_data(IteratorT2 const&_first, IteratorT2 const&_last): text(_first, _last), is_root_(false), parser_id_(), value_()
				{
				}
				void swap(node_val_data&x)
				{
					impl::cp_swap(text, x.text);
					impl::cp_swap(is_root_, x.is_root_);
					impl::cp_swap(parser_id_, x.parser_id_);
					impl::cp_swap(value_, x.value_);
				}
				typename container_t::iterator begin()
				{
					return text.begin();
				}
				typename container_t::const_iterator begin()const
				{
					return text.begin();
				}
				typename container_t::iterator end()
				{
					return text.end();
				}
				typename container_t::const_iterator end()const
				{
					return text.end();
				}
				bool is_root()const
				{
					return is_root_;
				}
				void is_root(bool b)
				{
					is_root_=b;
				}
				parser_id id()const
				{
					return parser_id_;
				}
				void id(parser_id r)
				{
					parser_id_=r;
				}
				ValueT const&value()const
				{
					return value_;
				}
				void value(ValueT const&v)
				{
					value_=v;
				}
			private:
				container_t text;
				bool is_root_;
				parser_id parser_id_;
				ValueT value_;
			};
			template<typename T>
			inline void swap(tree_node<T>&a, tree_node<T>&b)
			{
				a.swap(b);
			}
			template<typename T, typename V>
			inline void swap(node_iter_data<T, V>&a, node_iter_data<T, V>&b)
			{
				a.swap(b);
			}
			template<typename ValueT>
			class node_iter_data_factory
			{
			public:
				template<typename IteratorT>
				class factory
				{
				public:
					typedef IteratorT iterator_t;
					typedef node_iter_data<iterator_t, ValueT>node_t;
					static node_t create_node(iterator_t const&first, iterator_t const&last, bool)
					{
						return node_t(first, last);
					}
					static node_t empty_node()
					{
						return node_t();
					}
					template<typename ContainerT>
					static node_t group_nodes(ContainerT const&nodes)
					{
						return node_t(nodes.begin()->value.begin(), nodes.back().value.end());
					}
				};
			};
			template<typename ValueT>
			class node_val_data_factory
			{
			public:
				template<typename IteratorT>
				class factory
				{
				public:
					typedef IteratorT iterator_t;
					typedef node_val_data<iterator_t, ValueT>node_t;
					static node_t create_node(iterator_t const&first, iterator_t const&last, bool is_leaf_node)
					{
						if(is_leaf_node)return node_t(first, last);
						else return node_t();
					}
					static node_t empty_node()
					{
						return node_t();
					}
					template<typename ContainerT>
					static node_t group_nodes(ContainerT const&nodes)
					{
						typename node_t::container_t c;
						typename ContainerT::const_iterator i_end=nodes.end();
						for(typename ContainerT::const_iterator i=nodes.begin();
						i!=i_end;
						++i)
						{
							(void)((!!(i->children.size()==0))||(_wassert(L"i->children.size() == 0", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\tree\\common.hpp", 465), 0));
							c.insert(c.end(), i->value.begin(), i->value.end());
						}
						return node_t(c.begin(), c.end());
					}
				};
			};
			template<typename ValueT>
			class node_all_val_data_factory
			{
			public:
				template<typename IteratorT>
				class factory
				{
				public:
					typedef IteratorT iterator_t;
					typedef node_val_data<iterator_t, ValueT>node_t;
					static node_t create_node(iterator_t const&first, iterator_t const&last, bool)
					{
						return node_t(first, last);
					}
					static node_t empty_node()
					{
						return node_t();
					}
					template<typename ContainerT>
					static node_t group_nodes(ContainerT const&nodes)
					{
						typename node_t::container_t c;
						typename ContainerT::const_iterator i_end=nodes.end();
						for(typename ContainerT::const_iterator i=nodes.begin();
						i!=i_end;
						++i)
						{
							(void)((!!(i->children.size()==0))||(_wassert(L"i->children.size() == 0", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\tree\\common.hpp", 507), 0));
							c.insert(c.end(), i->value.begin(), i->value.end());
						}
						return node_t(c.begin(), c.end());
					}
				};
			};
			namespace impl
			{
				template<typename T>
				inline void cp_swap(T&t1, T&t2)
				{
					using std::swap;
					using boost::spirit::classic::swap;
					using boost::swap;
					swap(t1, t2);
				}
			}
			template<typename IteratorT, typename NodeFactoryT, typename T>
			class tree_match: public match<T>
			{
			public:
				typedef typename NodeFactoryT::template factory<IteratorT>node_factory_t;
				typedef typename node_factory_t::node_t parse_node_t;
				typedef tree_node<parse_node_t>node_t;
				typedef typename node_t::children_t container_t;
				typedef typename container_t::iterator tree_iterator;
				typedef typename container_t::const_iterator const_tree_iterator;
				typedef T attr_t;
				typedef typename boost::call_traits<T>::param_type param_type;
				typedef typename boost::call_traits<T>::reference reference;
				typedef typename boost::call_traits<T>::const_reference const_reference;
				tree_match(): match<T>(), trees()
				{
				}
				explicit tree_match(std::size_t length): match<T>(length), trees()
				{
				}
				tree_match(std::size_t length, parse_node_t const&n): match<T>(length), trees()
				{
					trees.push_back(node_t(n));
				}
				tree_match(std::size_t length, param_type val, parse_node_t const&n): match<T>(length, val), trees()
				{
					trees.reserve(10);
					trees.push_back(node_t(n));
				}
				tree_match(std::size_t length, container_t&c): match<T>(length), trees()
				{
					impl::cp_swap(trees, c);
				}
				tree_match(std::size_t length, param_type val, container_t&c): match<T>(length, val), trees()
				{
					impl::cp_swap(trees, c);
				}
				template<typename T2>
				tree_match(match<T2>const&other): match<T>(other), trees()
				{
				}
				template<typename T2, typename T3, typename T4>
				tree_match(tree_match<T2, T3, T4>const&other): match<T>(other), trees()
				{
					impl::cp_swap(trees, other.trees);
				}
				template<typename T2>
				tree_match&operator=(match<T2>const&other)
				{
					match<T>::operator=(other);
					return *this;
				}
				template<typename T2, typename T3, typename T4>
				tree_match&operator=(tree_match<T2, T3, T4>const&other)
				{
					match<T>::operator=(other);
					impl::cp_swap(trees, other.trees);
					return *this;
				}
				tree_match(tree_match const&x): match<T>(x), trees()
				{
					impl::cp_swap(trees, x.trees);
				}
				tree_match&operator=(tree_match const&x)
				{
					tree_match tmp(x);
					this->swap(tmp);
					return *this;
				}
				void swap(tree_match&x)
				{
					match<T>::swap(x);
					impl::cp_swap(trees, x.trees);
				}
				mutable container_t trees;
			};
			struct tree_policy
			{
				template<typename FunctorT, typename MatchT>
				static void apply_op_to_match(FunctorT const&, MatchT&)
				{
				}
				template<typename MatchT, typename Iterator1T, typename Iterator2T>
				static void group_match(MatchT&, parser_id const&, Iterator1T const&, Iterator2T const&)
				{
				}
				template<typename MatchT>
				static void concat(MatchT&, MatchT const&)
				{
				}
			};
			template<typename MatchPolicyT, typename IteratorT, typename NodeFactoryT, typename TreePolicyT, typename T>
			struct common_tree_match_policy: public match_policy
			{
				common_tree_match_policy()
				{
				}
				template<typename PolicyT>
				common_tree_match_policy(PolicyT const&policies): match_policy((match_policy const&)policies)
				{
				}
				template<typename U>
				struct result
				{
					typedef tree_match<IteratorT, NodeFactoryT, U>type;
				};
				typedef tree_match<IteratorT, NodeFactoryT, T>match_t;
				typedef IteratorT iterator_t;
				typedef TreePolicyT tree_policy_t;
				typedef NodeFactoryT factory_t;
				static const match_t no_match()
				{
					return match_t();
				}
				static const match_t empty_match()
				{
					return match_t(0, tree_policy_t::empty_node());
				}
				template<typename AttrT, typename Iterator1T, typename Iterator2T>
				static tree_match<IteratorT, NodeFactoryT, AttrT>create_match(std::size_t length, AttrT const&val, Iterator1T const&first, Iterator2T const&last)
				{
					return tree_match<IteratorT, NodeFactoryT, AttrT>(length, val, tree_policy_t::create_node(length, first, last, true));
				}
				template<typename Match1T, typename Match2T>
				static void concat_match(Match1T&a, Match2T const&b)
				{
					(void)((!!(a&&b))||(_wassert(L"a && b", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\tree\\common.hpp", 742), 0));
					if(a.length()==0)
					{
						a=b;
						return ;
					}
					else if(b.length()==0)
					{
						return ;
					}
					a.concat(b);
					tree_policy_t::concat(a, b);
				}
				template<typename MatchT, typename IteratorT2>
				void group_match(MatchT&m, parser_id const&id, IteratorT2 const&first, IteratorT2 const&last)const
				{
					if(!m)return ;
					tree_policy_t::group_match(m, id, first, last);
				}
			};
			template<typename MatchPolicyT, typename NodeFactoryT>
			struct common_tree_tree_policy
			{
				typedef typename MatchPolicyT::iterator_t iterator_t;
				typedef typename MatchPolicyT::match_t match_t;
				typedef typename NodeFactoryT::template factory<iterator_t>factory_t;
				typedef typename factory_t::node_t node_t;
				template<typename Iterator1T, typename Iterator2T>
				static node_t create_node(std::size_t, Iterator1T const&first, Iterator2T const&last, bool leaf_node)
				{
					return factory_t::create_node(first, last, leaf_node);
				}
				static node_t empty_node()
				{
					return factory_t::empty_node();
				}
				template<typename FunctorT>
				static void apply_op_to_match(FunctorT const&op, match_t&m)
				{
					op(m);
				}
			};
			struct no_tree_gen_node_parser_gen;
			template<typename T>
			struct no_tree_gen_node_parser: public unary<T, parser<no_tree_gen_node_parser<T> > >
			{
				typedef no_tree_gen_node_parser<T>self_t;
				typedef no_tree_gen_node_parser_gen parser_generator_t;
				typedef unary_parser_category parser_category_t;
				no_tree_gen_node_parser(T const&a): unary<T, parser<no_tree_gen_node_parser<T> > >(a)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scanner)const
				{
					typedef typename ScannerT::iteration_policy_t iteration_policy_t;
					typedef match_policy match_policy_t;
					typedef typename ScannerT::action_policy_t action_policy_t;
					typedef scanner_policies<iteration_policy_t, match_policy_t, action_policy_t>policies_t;
					return this->subject().parse(scanner.change_policies(policies_t(scanner)));
				}
			};
			struct no_tree_gen_node_parser_gen
			{
				template<typename T>
				struct result
				{
					typedef no_tree_gen_node_parser<T>type;
				};
				template<typename T>
				static no_tree_gen_node_parser<T>generate(parser<T>const&s)
				{
					return no_tree_gen_node_parser<T>(s.derived());
				}
				template<typename T>
				no_tree_gen_node_parser<T>operator[](parser<T>const&s)const
				{
					return no_tree_gen_node_parser<T>(s.derived());
				}
			};
			const no_tree_gen_node_parser_gen no_node_d=no_tree_gen_node_parser_gen();
			struct leaf_node_parser_gen;
			template<typename T>
			struct leaf_node_parser: public unary<T, parser<leaf_node_parser<T> > >
			{
				typedef leaf_node_parser<T>self_t;
				typedef leaf_node_parser_gen parser_generator_t;
				typedef unary_parser_category parser_category_t;
				leaf_node_parser(T const&a): unary<T, parser<leaf_node_parser<T> > >(a)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scanner)const
				{
					typedef scanner_policies<typename ScannerT::iteration_policy_t, match_policy, typename ScannerT::action_policy_t>policies_t;
					typedef typename ScannerT::iterator_t iterator_t;
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					typedef typename result_t::node_factory_t factory_t;
					iterator_t from=scanner.first;
					result_t hit=impl::contiguous_parser_parse<result_t>(this->subject(), scanner.change_policies(policies_t(scanner, match_policy(), scanner)), scanner);
					if(hit)return result_t(hit.length(), factory_t::create_node(from, scanner.first, true));
					else return result_t(hit.length());
				}
			};
			struct leaf_node_parser_gen
			{
				template<typename T>
				struct result
				{
					typedef leaf_node_parser<T>type;
				};
				template<typename T>
				static leaf_node_parser<T>generate(parser<T>const&s)
				{
					return leaf_node_parser<T>(s.derived());
				}
				template<typename T>
				leaf_node_parser<T>operator[](parser<T>const&s)const
				{
					return leaf_node_parser<T>(s.derived());
				}
			};
			const leaf_node_parser_gen leaf_node_d=leaf_node_parser_gen();
			const leaf_node_parser_gen token_node_d=leaf_node_parser_gen();
			namespace impl
			{
				template<typename MatchPolicyT>
				struct tree_policy_selector
				{
					typedef tree_policy type;
				};
			}
			template<typename NodeParserT>
			struct node_parser_gen;
			template<typename T, typename NodeParserT>
			struct node_parser: public unary<T, parser<node_parser<T, NodeParserT> > >
			{
				typedef node_parser<T, NodeParserT>self_t;
				typedef node_parser_gen<NodeParserT>parser_generator_t;
				typedef unary_parser_category parser_category_t;
				node_parser(T const&a): unary<T, parser<node_parser<T, NodeParserT> > >(a)
				{
				}
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<T, ScannerT>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scanner)const
				{
					typename parser_result<self_t, ScannerT>::type hit=this->subject().parse(scanner);
					if(hit)
					{
						impl::tree_policy_selector<typename ScannerT::match_policy_t>::type::apply_op_to_match(NodeParserT(), hit);
					}
					return hit;
				}
			};
			template<typename NodeParserT>
			struct node_parser_gen
			{
				template<typename T>
				struct result
				{
					typedef node_parser<T, NodeParserT>type;
				};
				template<typename T>
				static node_parser<T, NodeParserT>generate(parser<T>const&s)
				{
					return node_parser<T, NodeParserT>(s.derived());
				}
				template<typename T>
				node_parser<T, NodeParserT>operator[](parser<T>const&s)const
				{
					return node_parser<T, NodeParserT>(s.derived());
				}
			};
			struct reduced_node_op
			{
				template<typename MatchT>
				void operator()(MatchT&m)const
				{
					if(m.trees.size()==1)
					{
						m.trees.begin()->children.clear();
					}
					else if(m.trees.size()>1)
					{
						typedef typename MatchT::node_factory_t node_factory_t;
						m=MatchT(m.length(), node_factory_t::group_nodes(m.trees));
					}
				}
			};
			const node_parser_gen<reduced_node_op>reduced_node_d=node_parser_gen<reduced_node_op>();
			struct discard_node_op
			{
				template<typename MatchT>
				void operator()(MatchT&m)const
				{
					m.trees.clear();
				}
			};
			const node_parser_gen<discard_node_op>discard_node_d=node_parser_gen<discard_node_op>();
			struct infix_node_op
			{
				template<typename MatchT>
				void operator()(MatchT&m)const
				{
					typedef typename MatchT::container_t container_t;
					typedef typename MatchT::container_t::iterator iter_t;
					typedef typename MatchT::container_t::value_type value_t;
					using std::swap;
					using boost::swap;
					using boost::spirit::classic::swap;
					container_t new_children;
					std::size_t length=0;
					std::size_t tree_size=m.trees.size();
					(void)((!!(tree_size>=1))||(_wassert(L"tree_size >= 1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\tree\\common.hpp", 1066), 0));
					bool keep=true;
					new_children.reserve((tree_size+1)/2);
					iter_t i_end=m.trees.end();
					for(iter_t i=m.trees.begin();
					i!=i_end;
					++i)
					{
						if(keep)
						{
							length+=std::distance((*i).value.begin(), (*i).value.end());
							new_children.push_back(value_t());
							swap(new_children.back(), *i);
							keep=false;
						}
						else
						{
							keep=true;
						}
					}
					m=MatchT(length, new_children);
				}
			};
			const node_parser_gen<infix_node_op>infix_node_d=node_parser_gen<infix_node_op>();
			struct discard_first_node_op
			{
				template<typename MatchT>
				void operator()(MatchT&m)const
				{
					typedef typename MatchT::container_t container_t;
					typedef typename MatchT::container_t::iterator iter_t;
					typedef typename MatchT::container_t::value_type value_t;
					using std::swap;
					using boost::swap;
					using boost::spirit::classic::swap;
					container_t new_children;
					std::size_t length=0;
					std::size_t tree_size=m.trees.size();
					(void)((!!(tree_size>=1))||(_wassert(L"tree_size >= 1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\tree\\common.hpp", 1121), 0));
					if(tree_size>1)
					{
						new_children.reserve(tree_size-1);
						iter_t i=m.trees.begin(), i_end=m.trees.end();
						for(++i;
						i!=i_end;
						++i)
						{
							length+=std::distance((*i).value.begin(), (*i).value.end());
							new_children.push_back(value_t());
							swap(new_children.back(), *i);
						}
					}
					else
					{
						iter_t i=m.trees.begin();
						typedef typename value_t::parse_node_t::iterator_t iterator_type;
						iterator_type it=(*i).value.end();
						new_children.push_back(value_t(typename value_t::parse_node_t(it, it)));
					}
					m=MatchT(length, new_children);
				}
			};
			const node_parser_gen<discard_first_node_op>discard_first_node_d=node_parser_gen<discard_first_node_op>();
			struct discard_last_node_op
			{
				template<typename MatchT>
				void operator()(MatchT&m)const
				{
					typedef typename MatchT::container_t container_t;
					typedef typename MatchT::container_t::iterator iter_t;
					typedef typename MatchT::container_t::value_type value_t;
					using std::swap;
					using boost::swap;
					using boost::spirit::classic::swap;
					container_t new_children;
					std::size_t length=0;
					std::size_t tree_size=m.trees.size();
					(void)((!!(tree_size>=1))||(_wassert(L"tree_size >= 1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\tree\\common.hpp", 1185), 0));
					if(tree_size>1)
					{
						m.trees.pop_back();
						new_children.reserve(tree_size-1);
						iter_t i_end=m.trees.end();
						for(iter_t i=m.trees.begin();
						i!=i_end;
						++i)
						{
							length+=std::distance((*i).value.begin(), (*i).value.end());
							new_children.push_back(value_t());
							swap(new_children.back(), *i);
						}
					}
					else
					{
						iter_t i=m.trees.begin();
						typedef typename value_t::parse_node_t::iterator_t iterator_type;
						iterator_type it=(*i).value.begin();
						new_children.push_back(value_t(typename value_t::parse_node_t(it, it)));
					}
					m=MatchT(length, new_children);
				}
			};
			const node_parser_gen<discard_last_node_op>discard_last_node_d=node_parser_gen<discard_last_node_op>();
			struct inner_node_op
			{
				template<typename MatchT>
				void operator()(MatchT&m)const
				{
					typedef typename MatchT::container_t container_t;
					typedef typename MatchT::container_t::iterator iter_t;
					typedef typename MatchT::container_t::value_type value_t;
					using std::swap;
					using boost::swap;
					using boost::spirit::classic::swap;
					container_t new_children;
					std::size_t length=0;
					std::size_t tree_size=m.trees.size();
					(void)((!!(tree_size>=2))||(_wassert(L"tree_size >= 2", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\tree\\common.hpp", 1245), 0));
					if(tree_size>2)
					{
						m.trees.pop_back();
						new_children.reserve(tree_size-1);
						iter_t i=m.trees.begin();
						iter_t i_end=m.trees.end();
						for(++i;
						i!=i_end;
						++i)
						{
							length+=std::distance((*i).value.begin(), (*i).value.end());
							new_children.push_back(value_t());
							swap(new_children.back(), *i);
						}
					}
					else
					{
						iter_t i=m.trees.begin();
						typedef typename value_t::parse_node_t::iterator_t iterator_type;
						iterator_type it=(*++i).value.begin();
						new_children.push_back(value_t(typename value_t::parse_node_t(it, it)));
					}
					m=MatchT(length, new_children);
				}
			};
			const node_parser_gen<inner_node_op>inner_node_d=node_parser_gen<inner_node_op>();
			template<typename ActionParserT>
			struct action_directive_parser_gen;
			template<typename T, typename ActionParserT>
			struct action_directive_parser: public unary<T, parser<action_directive_parser<T, ActionParserT> > >
			{
				typedef action_directive_parser<T, ActionParserT>self_t;
				typedef action_directive_parser_gen<ActionParserT>parser_generator_t;
				typedef unary_parser_category parser_category_t;
				action_directive_parser(T const&a): unary<T, parser<action_directive_parser<T, ActionParserT> > >(a)
				{
				}
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<T, ScannerT>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scanner)const
				{
					return this->subject().parse(scanner);
				}
				template<typename ActionT>
				typename ActionParserT::template action<action_directive_parser<T, ActionParserT>, ActionT>operator[](ActionT const&actor)const
				{
					typedef typename ActionParserT::template action<action_directive_parser, ActionT>action_t;
					return action_t(*this, actor);
				}
			};
			template<typename ActionParserT>
			struct action_directive_parser_gen
			{
				template<typename T>
				struct result
				{
					typedef action_directive_parser<T, ActionParserT>type;
				};
				template<typename T>
				static action_directive_parser<T, ActionParserT>generate(parser<T>const&s)
				{
					return action_directive_parser<T, ActionParserT>(s.derived());
				}
				template<typename T>
				action_directive_parser<T, ActionParserT>operator[](parser<T>const&s)const
				{
					return action_directive_parser<T, ActionParserT>(s.derived());
				}
			};
			template<typename ParserT, typename ActionT>
			struct access_match_action::action: public unary<ParserT, parser<access_match_action::action<ParserT, ActionT> > >
			{
				typedef action_parser_category parser_category;
				typedef action<ParserT, ActionT>self_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				action(ParserT const&subject, ActionT const&actor_);
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scanner)const;
				ActionT const&predicate()const;
			private:
				ActionT actor;
			};
			template<typename ParserT, typename ActionT>
			access_match_action::action<ParserT, ActionT>::action(ParserT const&subject, ActionT const&actor_): unary<ParserT, parser<access_match_action::action<ParserT, ActionT> > >(subject), actor(actor_)
			{
			}
			template<typename ParserT, typename ActionT>
			template<typename ScannerT>
			typename parser_result<access_match_action::action<ParserT, ActionT>, ScannerT>::type access_match_action::action<ParserT, ActionT>::parse(ScannerT const&scan)const
			{
				typedef typename ScannerT::iterator_t iterator_t;
				typedef typename parser_result<self_t, ScannerT>::type result_t;
				if(!scan.at_end())
				{
					iterator_t save=scan.first;
					result_t hit=this->subject().parse(scan);
					actor(hit, save, scan.first);
					return hit;
				}
				return scan.no_match();
			}
			template<typename ParserT, typename ActionT>
			ActionT const&access_match_action::action<ParserT, ActionT>::predicate()const
			{
				return actor;
			}
			const action_directive_parser_gen<access_match_action>access_match_d=action_directive_parser_gen<access_match_action>();
			template<typename ParserT, typename ActionT>
			struct access_node_action::action: public unary<ParserT, parser<access_node_action::action<ParserT, ActionT> > >
			{
				typedef action_parser_category parser_category;
				typedef action<ParserT, ActionT>self_t;
				template<typename ScannerT>
				struct result
				{
					typedef typename parser_result<ParserT, ScannerT>::type type;
				};
				action(ParserT const&subject, ActionT const&actor_);
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scanner)const;
				ActionT const&predicate()const;
			private:
				ActionT actor;
			};
			template<typename ParserT, typename ActionT>
			access_node_action::action<ParserT, ActionT>::action(ParserT const&subject, ActionT const&actor_): unary<ParserT, parser<access_node_action::action<ParserT, ActionT> > >(subject), actor(actor_)
			{
			}
			template<typename ParserT, typename ActionT>
			template<typename ScannerT>
			typename parser_result<access_node_action::action<ParserT, ActionT>, ScannerT>::type access_node_action::action<ParserT, ActionT>::parse(ScannerT const&scan)const
			{
				typedef typename ScannerT::iterator_t iterator_t;
				typedef typename parser_result<self_t, ScannerT>::type result_t;
				if(!scan.at_end())
				{
					iterator_t save=scan.first;
					result_t hit=this->subject().parse(scan);
					if(hit&&hit.trees.size()>0)actor(*hit.trees.begin(), save, scan.first);
					return hit;
				}
				return scan.no_match();
			}
			template<typename ParserT, typename ActionT>
			ActionT const&access_node_action::action<ParserT, ActionT>::predicate()const
			{
				return actor;
			}
			const action_directive_parser_gen<access_node_action>access_node_d=action_directive_parser_gen<access_node_action>();
			template<typename IteratorT, typename NodeFactoryT, typename T>
			struct tree_parse_info
			{
				IteratorT stop;
				bool match;
				bool full;
				std::size_t length;
				typename tree_match<IteratorT, NodeFactoryT, T>::container_t trees;
				tree_parse_info(): stop(), match(false), full(false), length(0), trees()
				{
				}
				template<typename IteratorT2>
				tree_parse_info(tree_parse_info<IteratorT2>const&pi): stop(pi.stop), match(pi.match), full(pi.full), length(pi.length), trees()
				{
					using std::swap;
					using boost::swap;
					using boost::spirit::classic::swap;
					swap(trees, pi.trees);
				}
				tree_parse_info(IteratorT stop_, bool match_, bool full_, std::size_t length_, typename tree_match<IteratorT, NodeFactoryT, T>::container_t trees_): stop(stop_), match(match_), full(full_), length(length_), trees()
				{
					using std::swap;
					using boost::swap;
					using boost::spirit::classic::swap;
					swap(trees, trees_);
				}
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename MatchPolicyT, typename NodeFactoryT, typename T=nil_t>
			struct pt_tree_policy;
			template<typename IteratorT, typename NodeFactoryT=node_val_data_factory<nil_t>, typename T=nil_t>
			struct pt_match_policy;
			template<typename T>
			struct gen_pt_node_parser;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename IteratorT, typename NodeFactoryT, typename T>
			struct pt_match_policy: public common_tree_match_policy<pt_match_policy<IteratorT, NodeFactoryT, T>, IteratorT, NodeFactoryT, pt_tree_policy<pt_match_policy<IteratorT, NodeFactoryT, T>, NodeFactoryT, T>, T>
			{
				typedef common_tree_match_policy<pt_match_policy<IteratorT, NodeFactoryT, T>, IteratorT, NodeFactoryT, pt_tree_policy<pt_match_policy<IteratorT, NodeFactoryT, T>, NodeFactoryT, T>, T>common_tree_match_policy_;
				pt_match_policy()
				{
				}
				template<typename PolicyT>
				pt_match_policy(PolicyT const&policies): common_tree_match_policy_(policies)
				{
				}
			};
			template<typename MatchPolicyT, typename NodeFactoryT, typename T>
			struct pt_tree_policy: public common_tree_tree_policy<MatchPolicyT, NodeFactoryT>
			{
				typedef typename MatchPolicyT::match_t match_t;
				typedef typename MatchPolicyT::iterator_t iterator_t;
				template<typename MatchAT, typename MatchBT>
				static void concat(MatchAT&a, MatchBT const&b)
				{
					typedef typename match_t::attr_t attr_t;
					(void)((!!(a&&b))||(_wassert(L"a && b", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\tree\\parse_tree.hpp", 80), 0));
					std::copy(b.trees.begin(), b.trees.end(), std::back_insert_iterator<typename match_t::container_t>(a.trees));
				}
				template<typename MatchT, typename Iterator1T, typename Iterator2T>
				static void group_match(MatchT&m, parser_id const&id, Iterator1T const&first, Iterator2T const&last)
				{
					if(!m)return ;
					typedef typename NodeFactoryT::template factory<iterator_t>factory_t;
					typedef typename tree_match<iterator_t, NodeFactoryT, T>::container_t container_t;
					typedef typename container_t::iterator cont_iterator_t;
					match_t newmatch(m.length(), factory_t::create_node(first, last, false));
					std::swap(newmatch.trees.begin()->children, m.trees);
					newmatch.trees.begin()->value.id(id);
					for(cont_iterator_t i=newmatch.trees.begin()->children.begin();
					i!=newmatch.trees.begin()->children.end();
					++i)
					{
						if(i->value.id()==0)i->value.id(id);
					}
					m=newmatch;
				}
				template<typename FunctorT, typename MatchT>
				static void apply_op_to_match(FunctorT const&op, MatchT&m)
				{
					op(m);
				}
			};
			namespace impl
			{
				template<typename IteratorT, typename NodeFactoryT, typename T>
				struct tree_policy_selector<pt_match_policy<IteratorT, NodeFactoryT, T> >
				{
					typedef pt_tree_policy<pt_match_policy<IteratorT, NodeFactoryT, T>, NodeFactoryT, T>type;
				};
			}
			struct gen_pt_node_parser_gen;
			template<typename T>
			struct gen_pt_node_parser: public unary<T, parser<gen_pt_node_parser<T> > >
			{
				typedef gen_pt_node_parser<T>self_t;
				typedef gen_pt_node_parser_gen parser_generator_t;
				typedef unary_parser_category parser_category_t;
				gen_pt_node_parser(T const&a): unary<T, parser<gen_pt_node_parser<T> > >(a)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename ScannerT::iteration_policy_t iteration_policy_t;
					typedef typename ScannerT::match_policy_t::iterator_t iterator_t;
					typedef typename ScannerT::match_policy_t::factory_t factory_t;
					typedef pt_match_policy<iterator_t, factory_t>match_policy_t;
					typedef typename ScannerT::action_policy_t action_policy_t;
					typedef scanner_policies<iteration_policy_t, match_policy_t, action_policy_t>policies_t;
					return this->subject().parse(scan.change_policies(policies_t(scan)));
				}
			};
			struct gen_pt_node_parser_gen
			{
				template<typename T>
				struct result
				{
					typedef gen_pt_node_parser<T>type;
				};
				template<typename T>
				static gen_pt_node_parser<T>generate(parser<T>const&s)
				{
					return gen_pt_node_parser<T>(s.derived());
				}
				template<typename T>
				gen_pt_node_parser<T>operator[](parser<T>const&s)const
				{
					return gen_pt_node_parser<T>(s.derived());
				}
			};
			const gen_pt_node_parser_gen gen_pt_node_d=gen_pt_node_parser_gen();
			template<typename NodeFactoryT, typename IteratorT, typename ParserT, typename SkipT>
			inline tree_parse_info<IteratorT, NodeFactoryT>pt_parse(IteratorT const&first_, IteratorT const&last, parser<ParserT>const&p, SkipT const&skip, NodeFactoryT const& =NodeFactoryT())
			{
				typedef skip_parser_iteration_policy<SkipT>iter_policy_t;
				typedef pt_match_policy<IteratorT, NodeFactoryT>pt_match_policy_t;
				typedef scanner_policies<iter_policy_t, pt_match_policy_t>scanner_policies_t;
				typedef scanner<IteratorT, scanner_policies_t>scanner_t;
				iter_policy_t iter_policy(skip);
				scanner_policies_t policies(iter_policy);
				IteratorT first=first_;
				scanner_t scan(first, last, policies);
				tree_match<IteratorT, NodeFactoryT>hit=p.derived().parse(scan);
				return tree_parse_info<IteratorT, NodeFactoryT>(first, hit, hit&&(first==last), hit.length(), hit.trees);
			}
			template<typename IteratorT, typename ParserT, typename SkipT>
			inline tree_parse_info<IteratorT>pt_parse(IteratorT const&first, IteratorT const&last, parser<ParserT>const&p, SkipT const&skip)
			{
				typedef node_val_data_factory<nil_t>default_node_factory_t;
				return pt_parse(first, last, p, skip, default_node_factory_t());
			}
			template<typename IteratorT, typename ParserT>
			inline tree_parse_info<IteratorT>pt_parse(IteratorT const&first_, IteratorT const&last, parser<ParserT>const&parser)
			{
				typedef pt_match_policy<IteratorT>pt_match_policy_t;
				IteratorT first=first_;
				scanner<IteratorT, scanner_policies<iteration_policy, pt_match_policy_t> >scan(first, last);
				tree_match<IteratorT>hit=parser.derived().parse(scan);
				return tree_parse_info<IteratorT>(first, hit, hit&&(first==last), hit.length(), hit.trees);
			}
			template<typename CharT, typename ParserT, typename SkipT>
			inline tree_parse_info<CharT const*>pt_parse(CharT const*str, parser<ParserT>const&p, SkipT const&skip)
			{
				CharT const*last=str;
				while(*last)last++;
				return pt_parse(str, last, p, skip);
			}
			template<typename CharT, typename ParserT>
			inline tree_parse_info<CharT const*>pt_parse(CharT const*str, parser<ParserT>const&parser)
			{
				CharT const*last=str;
				while(*last)
				{
					last++;
				}
				return pt_parse(str, last, parser);
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T>
			tree_node<T>const&get_first_leaf(tree_node<T>const&node);
			template<typename T>
			bool find_node(tree_node<T>const&node, parser_id node_to_search, tree_node<T>const**found_node);
			template<typename T>
			bool get_node_range(tree_node<T>const&node, parser_id node_to_search, std::pair<typename tree_node<T>::const_tree_iterator, typename tree_node<T>::const_tree_iterator>&nodes);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T>
			inline tree_node<T>const&get_first_leaf(tree_node<T>const&node)
			{
				if(node.children.size()>0)return get_first_leaf(*node.children.begin());
				return node;
			}
			template<typename T>
			inline bool find_node(tree_node<T>const&node, parser_id node_to_search, tree_node<T>const**found_node)
			{
				if(node.value.id()==node_to_search)
				{
					*found_node=&node;
					return true;
				}
				if(node.children.size()>0)
				{
					typedef typename tree_node<T>::const_tree_iterator const_tree_iterator;
					const_tree_iterator end=node.children.end();
					for(const_tree_iterator it=node.children.begin();
					it!=end;
					++it)
					{
						if(find_node(*it, node_to_search, found_node))return true;
					}
				}
				return false;
			}
			namespace impl
			{
				template<typename T>
				inline bool get_node_range(typename tree_node<T>::const_tree_iterator const&start, parser_id node_to_search, std::pair<typename tree_node<T>::const_tree_iterator, typename tree_node<T>::const_tree_iterator>&nodes)
				{
					tree_node<T>const&node=*start;
					if(node.value.id()==node_to_search)
					{
						if(node.children.size()>0)
						{
							nodes.first=node.children.begin();
							nodes.second=node.children.end();
						}
						else
						{
							nodes.first=start;
							nodes.second=start;
							std::advance(nodes.second, 1);
						}
						return true;
					}
					if(node.children.size()>0)
					{
						typedef typename tree_node<T>::const_tree_iterator const_tree_iterator;
						const_tree_iterator end=node.children.end();
						for(const_tree_iterator it=node.children.begin();
						it!=end;
						++it)
						{
							if(impl::get_node_range<T>(it, node_to_search, nodes))return true;
						}
					}
					return false;
				}
			}
			template<typename T>
			inline bool get_node_range(tree_node<T>const&node, parser_id node_to_search, std::pair<typename tree_node<T>::const_tree_iterator, typename tree_node<T>::const_tree_iterator>&nodes)
			{
				if(node.children.size()>0)
				{
					typedef typename tree_node<T>::const_tree_iterator const_tree_iterator;
					const_tree_iterator end=node.children.end();
					for(const_tree_iterator it=node.children.begin();
					it!=end;
					++it)
					{
						if(impl::get_node_range<T>(it, node_to_search, nodes))return true;
					}
				}
				return false;
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			namespace impl
			{
				template<typename StringT>
				inline bool would_form_universal_char(StringT const&value)
				{
					if('u'!=value[0]&&'U'!=value[0])return false;
					if('u'==value[0]&&value.size()<5)return false;
					if('U'==value[0]&&value.size()<9)return false;
					typename StringT::size_type pos=value.find_first_not_of("0123456789abcdefABCDEF", 1);
					if(StringT::npos==pos||('u'==value[0]&&pos>5)||('U'==value[0]&&pos>9))
					{
						return true;
					}
					return false;
				}
				template<typename StringT>
				inline bool handle_identifier(boost::wave::token_id prev, boost::wave::token_id before, StringT const&value)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case T_IDENTIFIER: case T_NONREPLACABLE_IDENTIFIER: case T_COMPL_ALT: case T_OR_ALT: case T_AND_ALT: case T_NOT_ALT: case T_XOR_ALT: case T_ANDASSIGN_ALT: case T_ORASSIGN_ALT: case T_XORASSIGN_ALT: case T_NOTEQUAL_ALT: case T_FIXEDPOINTLIT: return true;
						case T_FLOATLIT: case T_INTLIT: case T_PP_NUMBER: return (value.size()>1||(value[0]!='e'&&value[0]!='E'));
						case boost::wave::token_id(('\\')|(UnknownTokenType)): return would_form_universal_char(value);
					}
					return false;
				}
				inline bool handle_intlit(boost::wave::token_id prev, boost::wave::token_id)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case T_IDENTIFIER: case T_NONREPLACABLE_IDENTIFIER: case T_INTLIT: case T_FLOATLIT: case T_FIXEDPOINTLIT: case T_PP_NUMBER: return true;
					}
					return false;
				}
				inline bool handle_floatlit(boost::wave::token_id prev, boost::wave::token_id)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case T_IDENTIFIER: case T_NONREPLACABLE_IDENTIFIER: case T_INTLIT: case T_FLOATLIT: case T_FIXEDPOINTLIT: case T_PP_NUMBER: return true;
					}
					return false;
				}
				inline bool handle_alt_leftbrace(boost::wave::token_id prev, boost::wave::token_id)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case T_LESS: case T_SHIFTLEFT: return true;
					}
					return false;
				}
				inline bool handle_alt_leftbracket(boost::wave::token_id prev, boost::wave::token_id)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case T_LESS: case T_SHIFTLEFT: return true;
					}
					return false;
				}
				inline bool handle_fixedpointlit(boost::wave::token_id prev, boost::wave::token_id)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case T_IDENTIFIER: case T_NONREPLACABLE_IDENTIFIER: case T_INTLIT: case T_FLOATLIT: case T_FIXEDPOINTLIT: case T_PP_NUMBER: return true;
					}
					return false;
				}
				inline bool handle_dot(boost::wave::token_id prev, boost::wave::token_id before)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case T_DOT: if(T_DOT==before)return true;
						break;
					}
					return false;
				}
				inline bool handle_questionmark(boost::wave::token_id prev, boost::wave::token_id)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case boost::wave::token_id(('\\')|(UnknownTokenType)): case T_QUESTION_MARK: return true;
					}
					return false;
				}
				inline bool handle_newline(boost::wave::token_id prev, boost::wave::token_id before)
				{
					using namespace boost::wave;
					switch(static_cast<unsigned int>(prev))
					{
						case boost::wave::token_id(('\\')|(UnknownTokenType)): case T_DIVIDE: if(T_QUESTION_MARK==before)return true;
						break;
					}
					return false;
				}
				inline bool handle_parens(boost::wave::token_id prev)
				{
					switch(static_cast<unsigned int>(prev))
					{
						case T_LEFTPAREN: case T_RIGHTPAREN: case T_LEFTBRACKET: case T_RIGHTBRACKET: case T_LEFTBRACE: case T_RIGHTBRACE: case T_SEMICOLON: case T_COMMA: case T_COLON: return false;
						default: break;
					}
					return true;
				}
			}
			class insert_whitespace_detection
			{
			public:
				insert_whitespace_detection(bool insert_whitespace_=true): insert_whitespace(insert_whitespace_), prev(boost::wave::T_EOF), beforeprev(boost::wave::T_EOF)
				{
				}
				template<typename StringT>
				bool must_insert(boost::wave::token_id current, StringT const&value)
				{
					if(!insert_whitespace)return false;
					using namespace boost::wave;
					switch(static_cast<unsigned int>(current))
					{
						case T_NONREPLACABLE_IDENTIFIER: case T_IDENTIFIER: return impl::handle_identifier(prev, beforeprev, value);
						case T_PP_NUMBER: case T_INTLIT: return impl::handle_intlit(prev, beforeprev);
						case T_FLOATLIT: return impl::handle_floatlit(prev, beforeprev);
						case T_STRINGLIT: if(boost::wave::token_id(('L')|(IdentifierTokenType))==prev)return true;
						break;
						case T_LEFTBRACE_ALT: return impl::handle_alt_leftbrace(prev, beforeprev);
						case T_LEFTBRACKET_ALT: return impl::handle_alt_leftbracket(prev, beforeprev);
						case T_FIXEDPOINTLIT: return impl::handle_fixedpointlit(prev, beforeprev);
						case T_DOT: return impl::handle_dot(prev, beforeprev);
						case T_QUESTION_MARK: return impl::handle_questionmark(prev, beforeprev);
						case T_NEWLINE: return impl::handle_newline(prev, beforeprev);
						case T_LEFTPAREN: case T_RIGHTPAREN: case T_LEFTBRACKET: case T_RIGHTBRACKET: case T_SEMICOLON: case T_COMMA: case T_COLON: switch(static_cast<unsigned int>(prev))
						{
							case T_LEFTPAREN: case T_RIGHTPAREN: case T_LEFTBRACKET: case T_RIGHTBRACKET: case T_LEFTBRACE: case T_RIGHTBRACE: return false;
							default: if(((((prev)&boost::wave::TokenTypeMask)==(OperatorTokenType))?true: false))return false;
							break;
						}
						break;
						case T_LEFTBRACE: case T_RIGHTBRACE: switch(static_cast<unsigned int>(prev))
						{
							case T_LEFTPAREN: case T_RIGHTPAREN: case T_LEFTBRACKET: case T_RIGHTBRACKET: case T_LEFTBRACE: case T_RIGHTBRACE: case T_SEMICOLON: case T_COMMA: case T_COLON: return false;
							case T_QUESTION_MARK: if(T_QUESTION_MARK==beforeprev)return true;
							if(((((prev)&boost::wave::TokenTypeMask)==(OperatorTokenType))?true: false))return false;
							break;
							default: break;
						}
						break;
						case T_MINUS: case T_MINUSMINUS: case T_MINUSASSIGN: if(T_MINUS==prev||T_MINUSMINUS==prev)return true;
						if(!impl::handle_parens(prev))return false;
						if(T_QUESTION_MARK==prev&&T_QUESTION_MARK==beforeprev)return true;
						break;
						case T_PLUS: case T_PLUSPLUS: case T_PLUSASSIGN: if(T_PLUS==prev||T_PLUSPLUS==prev)return true;
						if(!impl::handle_parens(prev))return false;
						if(T_QUESTION_MARK==prev&&T_QUESTION_MARK==beforeprev)return true;
						break;
						case T_DIVIDE: case T_DIVIDEASSIGN: if(T_DIVIDE==prev)return true;
						if(!impl::handle_parens(prev))return false;
						if(T_QUESTION_MARK==prev&&T_QUESTION_MARK==beforeprev)return true;
						break;
						case T_EQUAL: case T_ASSIGN: switch(static_cast<unsigned int>(prev))
						{
							case T_PLUSASSIGN: case T_MINUSASSIGN: case T_DIVIDEASSIGN: case T_STARASSIGN: case T_SHIFTRIGHTASSIGN: case T_SHIFTLEFTASSIGN: case T_EQUAL: case T_NOTEQUAL: case T_LESSEQUAL: case T_GREATEREQUAL: case T_LESS: case T_GREATER: case T_PLUS: case T_MINUS: case T_STAR: case T_DIVIDE: case T_ORASSIGN: case T_ANDASSIGN: case T_XORASSIGN: case T_OR: case T_AND: case T_XOR: case T_OROR: case T_ANDAND: return true;
							case T_QUESTION_MARK: if(T_QUESTION_MARK==beforeprev)return true;
							break;
							default: if(!impl::handle_parens(prev))return false;
							break;
						}
						break;
						case T_GREATER: if(T_MINUS==prev||T_GREATER==prev)return true;
						if(!impl::handle_parens(prev))return false;
						if(T_QUESTION_MARK==prev&&T_QUESTION_MARK==beforeprev)return true;
						break;
						case T_LESS: if(T_LESS==prev)return true;
						case T_CHARLIT: case T_NOT: case T_NOTEQUAL: if(!impl::handle_parens(prev))return false;
						if(T_QUESTION_MARK==prev&&T_QUESTION_MARK==beforeprev)return true;
						break;
						case T_AND: case T_ANDAND: if(!impl::handle_parens(prev))return false;
						if(T_AND==prev||T_ANDAND==prev)return true;
						break;
						case T_OR: if(!impl::handle_parens(prev))return false;
						if(T_OR==prev)return true;
						break;
						case T_XOR: if(!impl::handle_parens(prev))return false;
						if(T_XOR==prev)return true;
						break;
						case T_COMPL_ALT: case T_OR_ALT: case T_AND_ALT: case T_NOT_ALT: case T_XOR_ALT: case T_ANDASSIGN_ALT: case T_ORASSIGN_ALT: case T_XORASSIGN_ALT: case T_NOTEQUAL_ALT: switch(static_cast<unsigned int>(prev))
						{
							case T_LEFTPAREN: case T_RIGHTPAREN: case T_LEFTBRACKET: case T_RIGHTBRACKET: case T_LEFTBRACE: case T_RIGHTBRACE: case T_SEMICOLON: case T_COMMA: case T_COLON: return false;
							case T_IDENTIFIER: if(T_NONREPLACABLE_IDENTIFIER==prev||((((prev)&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false))
							{
								return true;
							}
							break;
							default: break;
						}
						break;
						case T_STAR: if(T_STAR==prev)return false;
						if(T_GREATER==prev&&(T_MINUS==beforeprev||T_MINUSMINUS==beforeprev))
						{
							return true;
						}
						break;
					}
					return false;
				}
				void shift_tokens(boost::wave::token_id next_id)
				{
					if(insert_whitespace)
					{
						beforeprev=prev;
						prev=next_id;
					}
				}
			private:
				bool insert_whitespace;
				boost::wave::token_id prev;
				boost::wave::token_id beforeprev;
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename String=std::string>
			struct file_position_base;
			typedef file_position_base<std::string>file_position;
			template<typename String=std::string>
			struct file_position_without_column_base;
			typedef file_position_without_column_base<std::string>file_position_without_column;
			template<typename ForwardIteratorT, typename PositionT=file_position_base<std::basic_string<typename boost::detail::iterator_traits<ForwardIteratorT>::value_type> >, typename SelfT=nil_t>
			class position_iterator;
			template<typename ForwardIteratorT, typename PositionT=file_position_base<std::basic_string<typename boost::detail::iterator_traits<ForwardIteratorT>::value_type> > >
			class position_iterator2;
			template<typename PositionT>
			class position_policy;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename String>
			struct file_position_without_column_base
			{
				String file;
				int line;
				file_position_without_column_base(String const&file_=String(), int line_=1): file(file_), line(line_)
				{
				}
				bool operator==(const file_position_without_column_base&fp)const
				{
					return line==fp.line&&file==fp.file;
				}
			};
			template<typename String>
			struct file_position_base: public file_position_without_column_base<String>
			{
				int column;
				file_position_base(String const&file_=String(), int line_=1, int column_=1): file_position_without_column_base<String>(file_, line_), column(column_)
				{
				}
				bool operator==(const file_position_base&fp)const
				{
					return column==fp.column&&this->line==fp.line&&this->file==fp.file;
				}
			};
			template<typename PositionT>
			class position_policy;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename String>
			class position_policy<file_position_without_column_base<String> >
			{
			public:
				void next_line(file_position_without_column_base<String>&pos)
				{
					++pos.line;
				}
				void set_tab_chars(unsigned int)
				{
				}
				void next_char(file_position_without_column_base<String>&)
				{
				}
				void tabulation(file_position_without_column_base<String>&)
				{
				}
			};
			template<typename String>
			class position_policy<file_position_base<String> >
			{
			public:
				position_policy(): m_CharsPerTab(4)
				{
				}
				void next_line(file_position_base<String>&pos)
				{
					++pos.line;
					pos.column=1;
				}
				void set_tab_chars(unsigned int chars)
				{
					m_CharsPerTab=chars;
				}
				void next_char(file_position_base<String>&pos)
				{
					++pos.column;
				}
				void tabulation(file_position_base<String>&pos)
				{
					pos.column+=m_CharsPerTab-(pos.column-1)%m_CharsPerTab;
				}
			private:
				unsigned int m_CharsPerTab;
			};
			namespace iterator_
			{
				namespace impl
				{
					template<typename MainIterT, typename ForwardIterT, typename PositionT>
					struct position_iterator_base_generator
					{
					private:
						typedef boost::detail::iterator_traits<ForwardIterT>traits;
						typedef typename traits::value_type value_type;
						typedef typename traits::iterator_category iter_category_t;
						typedef typename boost::add_const<value_type>::type const_value_type;
					public:
						typedef typename boost::mpl::if_<typename boost::is_same<MainIterT, nil_t>::type, position_iterator<ForwardIterT, PositionT, nil_t>, MainIterT>::type main_iter_t;
						typedef boost::iterator_adaptor<main_iter_t, ForwardIterT, const_value_type, boost::forward_traversal_tag>type;
					};
				}
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename ForwardIteratorT, typename PositionT, typename SelfT>
			class position_iterator: public iterator_::impl::position_iterator_base_generator<SelfT, ForwardIteratorT, PositionT>::type, public position_policy<PositionT>
			{
			private:
				typedef position_policy<PositionT>position_policy_t;
				typedef typename iterator_::impl::position_iterator_base_generator<SelfT, ForwardIteratorT, PositionT>::type base_t;
				typedef typename iterator_::impl::position_iterator_base_generator<SelfT, ForwardIteratorT, PositionT>::main_iter_t main_iter_t;
			public:
				typedef PositionT position_t;
				position_iterator(): _isend(true)
				{
				}
				position_iterator(const ForwardIteratorT&begin, const ForwardIteratorT&end): base_t(begin), _end(end), _pos(PositionT()), _isend(begin==end)
				{
				}
				template<typename FileNameT>
				position_iterator(const ForwardIteratorT&begin, const ForwardIteratorT&end, FileNameT fileName): base_t(begin), _end(end), _pos(PositionT(fileName)), _isend(begin==end)
				{
				}
				template<typename FileNameT, typename LineT>
				position_iterator(const ForwardIteratorT&begin, const ForwardIteratorT&end, FileNameT fileName, LineT line): base_t(begin), _end(end), _pos(PositionT(fileName, line)), _isend(begin==end)
				{
				}
				template<typename FileNameT, typename LineT, typename ColumnT>
				position_iterator(const ForwardIteratorT&begin, const ForwardIteratorT&end, FileNameT fileName, LineT line, ColumnT column): base_t(begin), _end(end), _pos(PositionT(fileName, line, column)), _isend(begin==end)
				{
				}
				position_iterator(const ForwardIteratorT&begin, const ForwardIteratorT&end, const PositionT&pos): base_t(begin), _end(end), _pos(pos), _isend(begin==end)
				{
				}
				position_iterator(const position_iterator&iter): base_t(iter.base()), position_policy_t(iter), _end(iter._end), _pos(iter._pos), _isend(iter._isend)
				{
				}
				position_iterator&operator=(const position_iterator&iter)
				{
					base_t::operator=(iter);
					position_policy_t::operator=(iter);
					_end=iter._end;
					_pos=iter._pos;
					_isend=iter._isend;
					return *this;
				}
				void set_position(PositionT const&newpos)
				{
					_pos=newpos;
				}
				PositionT&get_position()
				{
					return _pos;
				}
				PositionT const&get_position()const
				{
					return _pos;
				}
				void set_tabchars(unsigned int chars)
				{
					this->position_policy_t::set_tab_chars(chars);
				}
			private:
				friend class boost::iterator_core_access;
				void increment()
				{
					typename base_t::reference val=*(this->base());
					if(val=='\n')
					{
						++this->base_reference();
						this->next_line(_pos);
						static_cast<main_iter_t&>(*this).newline();
					}
					else if(val=='\r')
					{
						++this->base_reference();
						if(this->base_reference()==_end||*(this->base())!='\n')
						{
							this->next_line(_pos);
							static_cast<main_iter_t&>(*this).newline();
						}
					}
					else if(val=='\t')
					{
						this->tabulation(_pos);
						++this->base_reference();
					}
					else
					{
						this->next_char(_pos);
						++this->base_reference();
					}
					_isend=(this->base_reference()==_end);
				}
				template<typename OtherDerivedT, typename OtherIteratorT, typename V, typename C, typename R, typename D>
				bool equal(iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D>const&x)const
				{
					OtherDerivedT const&rhs=static_cast<OtherDerivedT const&>(x);
					bool x_is_end=rhs._isend;
					return (_isend==x_is_end)&&(_isend||this->base()==rhs.base());
				}
				protected: void newline(void)
				{
				}
				ForwardIteratorT _end;
				PositionT _pos;
				bool _isend;
			};
			template<typename ForwardIteratorT, typename PositionT>
			class position_iterator2: public position_iterator<ForwardIteratorT, PositionT, position_iterator2<ForwardIteratorT, PositionT> >
			{
				typedef position_iterator<ForwardIteratorT, PositionT, position_iterator2<ForwardIteratorT, PositionT> >base_t;
			public:
				typedef typename base_t::value_type value_type;
				typedef PositionT position_t;
				position_iterator2()
				{
				}
				position_iterator2(const ForwardIteratorT&begin, const ForwardIteratorT&end): base_t(begin, end), _startline(begin)
				{
				}
				template<typename FileNameT>
				position_iterator2(const ForwardIteratorT&begin, const ForwardIteratorT&end, FileNameT file): base_t(begin, end, file), _startline(begin)
				{
				}
				template<typename FileNameT, typename LineT>
				position_iterator2(const ForwardIteratorT&begin, const ForwardIteratorT&end, FileNameT file, LineT line): base_t(begin, end, file, line), _startline(begin)
				{
				}
				template<typename FileNameT, typename LineT, typename ColumnT>
				position_iterator2(const ForwardIteratorT&begin, const ForwardIteratorT&end, FileNameT file, LineT line, ColumnT column): base_t(begin, end, file, line, column), _startline(begin)
				{
				}
				position_iterator2(const ForwardIteratorT&begin, const ForwardIteratorT&end, const PositionT&pos): base_t(begin, end, pos), _startline(begin)
				{
				}
				position_iterator2(const position_iterator2&iter): base_t(iter), _startline(iter._startline)
				{
				}
				position_iterator2&operator=(const position_iterator2&iter)
				{
					base_t::operator=(iter);
					_startline=iter._startline;
					return *this;
				}
				ForwardIteratorT get_currentline_begin(void)const
				{
					return _startline;
				}
				ForwardIteratorT get_currentline_end(void)const
				{
					return get_endline();
				}
				std::basic_string<value_type>get_currentline(void)const
				{
					return std::basic_string<value_type>(get_currentline_begin(), get_currentline_end());
				}
				protected: ForwardIteratorT _startline;
				friend class position_iterator<ForwardIteratorT, PositionT, position_iterator2<ForwardIteratorT, PositionT> >;
				ForwardIteratorT get_endline()const
				{
					ForwardIteratorT endline=_startline;
					while(endline!=this->_end&&*endline!='\r'&&*endline!='\n')
					{
						++endline;
					}
					return endline;
				}
				void newline(void)
				{
					_startline=this->base();
				}
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			namespace debug
			{
				template<typename StringT>
				inline bool is_escaped_lit(StringT const&value)
				{
					typename StringT::size_type pos=value.find_first_of("\\", 0);
					if(StringT::npos!=pos)
					{
						do
						{
							if('\\'==value[pos+1]||'\"'==value[pos+1]||'?'==value[pos+1])
							{
								return true;
							}
							else
							{
								pos=value.find_first_of("\\", pos+1);
							}
						}
						while(pos!=StringT::npos);
					}
					return false;
				}
			}
			template<typename StringT>
			struct file_position
			{
			public:
				typedef StringT string_type;
				file_position(): file(), line(1), column(1)
				{
				}
				explicit file_position(string_type const&file_, unsigned int line_=1, unsigned int column_=1): file(file_), line(line_), column(column_)
				{
					(void)((!!(!debug::is_escaped_lit(file)))||(_wassert(L"!debug::is_escaped_lit(file)", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\file_position.hpp", 89), 0));
				}
				string_type const&get_file()const
				{
					return file;
				}
				unsigned int get_line()const
				{
					return line;
				}
				unsigned int get_column()const
				{
					return column;
				}
				void set_file(string_type const&file_)
				{
					file=file_;
					(void)((!!(!debug::is_escaped_lit(file)))||(_wassert(L"!debug::is_escaped_lit(file)", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\file_position.hpp", 100), 0));
				}
				void set_line(unsigned int line_)
				{
					line=line_;
				}
				void set_column(unsigned int column_)
				{
					column=column_;
				}
			private:
				string_type file;
				unsigned int line;
				unsigned int column;
			};
			template<typename StringT>
			bool operator==(file_position<StringT>const&lhs, file_position<StringT>const&rhs)
			{
				return lhs.get_column()==rhs.get_column()&&lhs.get_line()==rhs.get_line()&&lhs.get_file()==rhs.get_file();
			}
			template<typename StringT>
			inline std::ostream&operator<<(std::ostream&o, file_position<StringT>const&pos)
			{
				o<<pos.get_file()<<":"<<pos.get_line()<<":"<<pos.get_column();
				return o;
			}
			typedef file_position<boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > > >file_position_type;
			template<typename IteratorT, typename PositionT>
			struct position_iterator: boost::spirit::classic::position_iterator<IteratorT, PositionT>
			{
				typedef boost::spirit::classic::position_iterator<IteratorT, PositionT>base_type;
				position_iterator()
				{
				}
				position_iterator(IteratorT const&begin, IteratorT const&end, PositionT const&pos): base_type(begin, end, pos)
				{
				}
			};
		}
	}
	namespace spirit
	{
		namespace classic
		{
			template<>
			class position_policy<boost::wave::util::file_position_type>
			{
			public:
				position_policy(): m_CharsPerTab(4)
				{
				}
				void next_line(boost::wave::util::file_position_type&pos)
				{
					pos.set_line(pos.get_line()+1);
					pos.set_column(1);
				}
				void set_tab_chars(unsigned int chars)
				{
					m_CharsPerTab=chars;
				}
				void next_char(boost::wave::util::file_position_type&pos)
				{
					pos.set_column(pos.get_column()+1);
				}
				void tabulation(boost::wave::util::file_position_type&pos)
				{
					pos.set_column(pos.get_column()+m_CharsPerTab-(pos.get_column()-1)%m_CharsPerTab);
				}
			private:
				unsigned int m_CharsPerTab;
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace impl
			{
				enum universal_char_type
				{
					universal_char_type_valid=0, universal_char_type_invalid=1, universal_char_type_base_charset=2, universal_char_type_not_allowed_for_identifiers=3
				};
				inline bool in_range(unsigned long ch, unsigned long l, unsigned long u)
				{
					return (l<=ch&&ch<=u);
				}
				inline universal_char_type classify_universal_char(unsigned long ch)
				{
					if(ch<=0x0020||in_range(ch, 0x007f, 0x009f))return universal_char_type_invalid;
					if(in_range(ch, 0x0021, 0x005f)||in_range(ch, 0x0061, 0x007e))return universal_char_type_base_charset;
					if(in_range(ch, 0x00c0, 0x00d6)||in_range(ch, 0x00d8, 0x00f6)||in_range(ch, 0x00f8, 0x01f5)||in_range(ch, 0x01fa, 0x0217)||in_range(ch, 0x0250, 0x02a8)||in_range(ch, 0x1e00, 0x1e9a)||in_range(ch, 0x1ea0, 0x1ef9))
					{
						return universal_char_type_valid;
					}
					if(0x0384==ch||in_range(ch, 0x0388, 0x038a)||0x038c==ch||in_range(ch, 0x038e, 0x03a1)||in_range(ch, 0x03a3, 0x03ce)||in_range(ch, 0x03d0, 0x03d6)||0x03da==ch||0x03dc==ch||0x03de==ch||0x03e0==ch||in_range(ch, 0x03e2, 0x03f3)||in_range(ch, 0x1f00, 0x1f15)||in_range(ch, 0x1f18, 0x1f1d)||in_range(ch, 0x1f20, 0x1f45)||in_range(ch, 0x1f48, 0x1f4d)||in_range(ch, 0x1f50, 0x1f57)||0x1f59==ch||0x1f5b==ch||0x1f5d==ch||in_range(ch, 0x1f5f, 0x1f7d)||in_range(ch, 0x1f80, 0x1fb4)||in_range(ch, 0x1fb6, 0x1fbc)||in_range(ch, 0x1fc2, 0x1fc4)||in_range(ch, 0x1fc6, 0x1fcc)||in_range(ch, 0x1fd0, 0x1fd3)||in_range(ch, 0x1fd6, 0x1fdb)||in_range(ch, 0x1fe0, 0x1fec)||in_range(ch, 0x1ff2, 0x1ff4)||in_range(ch, 0x1ff6, 0x1ffc))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0401, 0x040d)||in_range(ch, 0x040f, 0x044f)||in_range(ch, 0x0451, 0x045c)||in_range(ch, 0x045e, 0x0481)||in_range(ch, 0x0490, 0x04c4)||in_range(ch, 0x04c7, 0x04c8)||in_range(ch, 0x04cb, 0x04cc)||in_range(ch, 0x04d0, 0x04eb)||in_range(ch, 0x04ee, 0x04f5)||in_range(ch, 0x04f8, 0x04f9))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0531, 0x0556)||in_range(ch, 0x0561, 0x0587))return universal_char_type_valid;
					if(in_range(ch, 0x05d0, 0x05ea)||in_range(ch, 0x05f0, 0x05f4))return universal_char_type_valid;
					if(in_range(ch, 0x0621, 0x063a)||in_range(ch, 0x0640, 0x0652)||in_range(ch, 0x0670, 0x06b7)||in_range(ch, 0x06ba, 0x06be)||in_range(ch, 0x06c0, 0x06ce)||in_range(ch, 0x06e5, 0x06e7))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0905, 0x0939)||in_range(ch, 0x0958, 0x0962))return universal_char_type_valid;
					if(in_range(ch, 0x0985, 0x098c)||in_range(ch, 0x098f, 0x0990)||in_range(ch, 0x0993, 0x09a8)||in_range(ch, 0x09aa, 0x09b0)||0x09b2==ch||in_range(ch, 0x09b6, 0x09b9)||in_range(ch, 0x09dc, 0x09dd)||in_range(ch, 0x09df, 0x09e1)||in_range(ch, 0x09f0, 0x09f1))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0a05, 0x0a0a)||in_range(ch, 0x0a0f, 0x0a10)||in_range(ch, 0x0a13, 0x0a28)||in_range(ch, 0x0a2a, 0x0a30)||in_range(ch, 0x0a32, 0x0a33)||in_range(ch, 0x0a35, 0x0a36)||in_range(ch, 0x0a38, 0x0a39)||in_range(ch, 0x0a59, 0x0a5c)||0x0a5e==ch)
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0a85, 0x0a8b)||0x0a8d==ch||in_range(ch, 0x0a8f, 0x0a91)||in_range(ch, 0x0a93, 0x0aa8)||in_range(ch, 0x0aaa, 0x0ab0)||in_range(ch, 0x0ab2, 0x0ab3)||in_range(ch, 0x0ab5, 0x0ab9)||0x0ae0==ch)
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0b05, 0x0b0c)||in_range(ch, 0x0b0f, 0x0b10)||in_range(ch, 0x0b13, 0x0b28)||in_range(ch, 0x0b2a, 0x0b30)||in_range(ch, 0x0b32, 0x0b33)||in_range(ch, 0x0b36, 0x0b39)||in_range(ch, 0x0b5c, 0x0b5d)||in_range(ch, 0x0b5f, 0x0b61))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0b85, 0x0b8a)||in_range(ch, 0x0b8e, 0x0b90)||in_range(ch, 0x0b92, 0x0b95)||in_range(ch, 0x0b99, 0x0b9a)||0x0b9c==ch||in_range(ch, 0x0b9e, 0x0b9f)||in_range(ch, 0x0ba3, 0x0ba4)||in_range(ch, 0x0ba8, 0x0baa)||in_range(ch, 0x0bae, 0x0bb5)||in_range(ch, 0x0bb7, 0x0bb9))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0c05, 0x0c0c)||in_range(ch, 0x0c0e, 0x0c10)||in_range(ch, 0x0c12, 0x0c28)||in_range(ch, 0x0c2a, 0x0c33)||in_range(ch, 0x0c35, 0x0c39)||in_range(ch, 0x0c60, 0x0c61))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0c85, 0x0c8c)||in_range(ch, 0x0c8e, 0x0c90)||in_range(ch, 0x0c92, 0x0ca8)||in_range(ch, 0x0caa, 0x0cb3)||in_range(ch, 0x0cb5, 0x0cb9)||in_range(ch, 0x0ce0, 0x0ce1))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0d05, 0x0d0c)||in_range(ch, 0x0d0e, 0x0d10)||in_range(ch, 0x0d12, 0x0d28)||in_range(ch, 0x0d2a, 0x0d39)||in_range(ch, 0x0d60, 0x0d61))
					{
						return universal_char_type_valid;
					}
					if(in_range(ch, 0x0e01, 0x0e30)||in_range(ch, 0x0e32, 0x0e33)||in_range(ch, 0x0e40, 0x0e46)||in_range(ch, 0x0e4f, 0x0e5b))
					{
						return universal_char_type_valid;
					}
					return universal_char_type_not_allowed_for_identifiers;
				}
				template<typename StringT>
				inline void validate_identifier_name(StringT const&name, int line, int column, StringT const&file_name)
				{
					using namespace std;
					typename StringT::size_type pos=name.find_first_of('\\');
					while(StringT::npos!=pos)
					{
						(void)((!!('u'==name[pos+1]||'U'==name[pos+1]))||(_wassert(L"'u' == name[pos+1] || 'U' == name[pos+1]", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpplexer\\validate_universal_char.hpp", 231), 0));
						StringT uchar_val(name.substr(pos+2, ('u'==name[pos+1])?4: 8));
						universal_char_type type=classify_universal_char(strtoul(uchar_val.c_str(), 0, 16));
						if(universal_char_type_valid!=type)
						{
							StringT error_uchar(name.substr(pos, ('u'==name[pos+1])?6: 10));
							if(universal_char_type_invalid==type)
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<lexing_exception::severity_text(lexing_exception::universal_char_invalid)<<": "<<lexing_exception::error_text(lexing_exception::universal_char_invalid);
									if((error_uchar)[0]!=0)stream<<": "<<(error_uchar);
									stream<<std::ends;
									boost::throw_exception(lexing_exception(stream.str().c_str(), lexing_exception::universal_char_invalid, line, column, file_name.c_str()));
								};
							}
							else if(universal_char_type_base_charset==type)
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<lexing_exception::severity_text(lexing_exception::universal_char_base_charset)<<": "<<lexing_exception::error_text(lexing_exception::universal_char_base_charset);
									if((error_uchar)[0]!=0)stream<<": "<<(error_uchar);
									stream<<std::ends;
									boost::throw_exception(lexing_exception(stream.str().c_str(), lexing_exception::universal_char_base_charset, line, column, file_name.c_str()));
								};
							}
							else
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<lexing_exception::severity_text(lexing_exception::universal_char_not_allowed)<<": "<<lexing_exception::error_text(lexing_exception::universal_char_not_allowed);
									if((error_uchar)[0]!=0)stream<<": "<<(error_uchar);
									stream<<std::ends;
									boost::throw_exception(lexing_exception(stream.str().c_str(), lexing_exception::universal_char_not_allowed, line, column, file_name.c_str()));
								};
							}
						}
						pos=name.find_first_of('\\', pos+2);
					}
				}
				template<typename StringT>
				inline void validate_literal(StringT const&name, int line, int column, StringT const&file_name)
				{
					using namespace std;
					typename StringT::size_type pos=name.find_first_of('\\');
					while(StringT::npos!=pos)
					{
						if('u'==name[pos+1]||'U'==name[pos+1])
						{
							StringT uchar_val(name.substr(pos+2, ('u'==name[pos+1])?4: 8));
							universal_char_type type=classify_universal_char(strtoul(uchar_val.c_str(), 0, 16));
							if(universal_char_type_valid!=type&&universal_char_type_not_allowed_for_identifiers!=type)
							{
								StringT error_uchar(name.substr(pos, ('u'==name[pos+1])?6: 10));
								if(universal_char_type_invalid==type)
								{

									{
										using namespace boost::wave;
										std::stringstream stream;
										stream<<lexing_exception::severity_text(lexing_exception::universal_char_invalid)<<": "<<lexing_exception::error_text(lexing_exception::universal_char_invalid);
										if((error_uchar)[0]!=0)stream<<": "<<(error_uchar);
										stream<<std::ends;
										boost::throw_exception(lexing_exception(stream.str().c_str(), lexing_exception::universal_char_invalid, line, column, file_name.c_str()));
									};
								}
								else
								{

									{
										using namespace boost::wave;
										std::stringstream stream;
										stream<<lexing_exception::severity_text(lexing_exception::universal_char_base_charset)<<": "<<lexing_exception::error_text(lexing_exception::universal_char_base_charset);
										if((error_uchar)[0]!=0)stream<<": "<<(error_uchar);
										stream<<std::ends;
										boost::throw_exception(lexing_exception(stream.str().c_str(), lexing_exception::universal_char_base_charset, line, column, file_name.c_str()));
									};
								}
							}
						}
						pos=name.find_first_of('\\', pos+2);
					}
				}
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			namespace impl
			{
				template<typename StringT>
				inline StringT escape_lit(StringT const&value)
				{
					StringT result;
					typename StringT::size_type pos=0;
					typename StringT::size_type pos1=value.find_first_of("\"\\?", 0);
					if(StringT::npos!=pos1)
					{
						do
						{
							result+=value.substr(pos, pos1-pos)+StringT("\\")+StringT(1, value[pos1]);
							pos1=value.find_first_of("\"\\?", pos=pos1+1);
						}
						while(StringT::npos!=pos1);
						result+=value.substr(pos);
					}
					else
					{
						result=value;
					}
					return result;
				}
				template<typename StringT>
				inline StringT unescape_lit(StringT const&value)
				{
					StringT result;
					typename StringT::size_type pos=0;
					typename StringT::size_type pos1=value.find_first_of("\\", 0);
					if(StringT::npos!=pos1)
					{
						do
						{
							switch(value[pos1+1])
							{
								case '\\': case '\"': case '?': result=result+value.substr(pos, pos1-pos);
								pos1=value.find_first_of("\\", (pos=pos1+1)+1);
								break;
								case 'n': result=result+value.substr(pos, pos1-pos)+"\n";
								pos1=value.find_first_of("\\", pos=pos1+1);
								++pos;
								break;
								default: result=result+value.substr(pos, pos1-pos+1);
								pos1=value.find_first_of("\\", pos=pos1+1);
							}
						}
						while(pos1!=StringT::npos);
						result=result+value.substr(pos);
					}
					else
					{
						result=value;
					}
					return result;
				}
				template<typename ContainerT, typename PositionT>
				inline typename ContainerT::value_type::string_type as_stringlit(ContainerT const&token_sequence, PositionT const&pos)
				{
					using namespace boost::wave;
					typedef typename ContainerT::value_type::string_type string_type;
					string_type result("\"");
					bool was_whitespace=false;
					typename ContainerT::const_iterator end=token_sequence.end();
					for(typename ContainerT::const_iterator it=token_sequence.begin();
					it!=end;
					++it)
					{
						token_id id=token_id(*it);
						if(((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)||T_NEWLINE==id)
						{
							if(!was_whitespace)
							{
								result+=" ";
								was_whitespace=true;
							}
						}
						else if(T_STRINGLIT==id||T_CHARLIT==id)
						{
							result+=impl::escape_lit((*it).get_value());
							was_whitespace=false;
						}
						else if(T_PLACEMARKER!=id)
						{
							result+=(*it).get_value();
							was_whitespace=false;
						}
					}
					result+="\"";
					boost::wave::cpplexer::impl::validate_literal(result, pos.get_line(), pos.get_column(), pos.get_file());
					return result;
				}
				template<typename ContainerT, typename PositionT>
				inline typename ContainerT::value_type::string_type as_stringlit(std::vector<ContainerT>const&arguments, typename std::vector<ContainerT>::size_type i, PositionT const&pos)
				{
					using namespace boost::wave;
					typedef typename ContainerT::value_type::string_type string_type;
					(void)((!!(i<arguments.size()))||(_wassert(L"i < arguments.size()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\macro_helpers.hpp", 156), 0));
					string_type result("\"");
					bool was_whitespace=false;
					for(;
					i<arguments.size();
					++i)
					{
						typename ContainerT::const_iterator end=arguments[i].end();
						for(typename ContainerT::const_iterator it=arguments[i].begin();
						it!=end;
						++it)
						{
							token_id id=token_id(*it);
							if(((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)||T_NEWLINE==id)
							{
								if(!was_whitespace)
								{
									result+=" ";
									was_whitespace=true;
								}
							}
							else if(T_STRINGLIT==id||T_CHARLIT==id)
							{
								result+=impl::escape_lit((*it).get_value());
								was_whitespace=false;
							}
							else if(T_PLACEMARKER!=id)
							{
								result+=(*it).get_value();
								was_whitespace=false;
							}
						}
						if(i<arguments.size()-1)
						{
							result+=",";
							was_whitespace=false;
						}
					}
					result+="\"";
					boost::wave::cpplexer::impl::validate_literal(result, pos.get_line(), pos.get_column(), pos.get_file());
					return result;
				}
				template<typename StringT, typename IteratorT>
				inline StringT as_string(IteratorT it, IteratorT const&end)
				{
					StringT result;
					for(;
					it!=end;
					++it)
					{
						result+=(*it).get_value();
					}
					return result;
				}
				template<typename ContainerT>
				inline typename ContainerT::value_type::string_type as_string(ContainerT const&token_sequence)
				{
					typedef typename ContainerT::value_type::string_type string_type;
					return as_string<string_type>(token_sequence.begin(), token_sequence.end());
				}
				template<typename ContainerT, typename PositionT>
				void replace_ellipsis(std::vector<ContainerT>const&arguments, typename ContainerT::size_type index, ContainerT&expanded, PositionT const&pos)
				{
					using namespace cpplexer;
					typedef typename ContainerT::value_type token_type;
					token_type comma(T_COMMA, ",", pos);
					for(;
					index<arguments.size();
					++index)
					{
						ContainerT const&arg=arguments[index];
						std::copy(arg.begin(), arg.end(), std::inserter(expanded, expanded.end()));
						if(index<arguments.size()-1)expanded.push_back(comma);
					}
				}
				template<typename IteratorT>
				inline boost::wave::token_id skip_whitespace(IteratorT&first, IteratorT const&last)
				{
					token_id id=util::impl::next_token<IteratorT>::peek(first, last, false);
					if(((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
					{
						do
						{
							++first;
							id=util::impl::next_token<IteratorT>::peek(first, last, false);
						}
						while(((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false));
					}
					++first;
					return id;
				}
				template<typename IteratorT, typename ContainerT>
				inline boost::wave::token_id skip_whitespace(IteratorT&first, IteratorT const&last, ContainerT&queue)
				{
					queue.push_back(*first);
					token_id id=util::impl::next_token<IteratorT>::peek(first, last, false);
					if(((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
					{
						do
						{
							queue.push_back(*++first);
							id=util::impl::next_token<IteratorT>::peek(first, last, false);
						}
						while(((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false));
					}
					++first;
					return id;
				}
			}
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			namespace on_exit
			{
				template<typename ContainerT>
				class pop_front
				{
				public:
					pop_front(ContainerT&list_): list(list_)
					{
					}
					~pop_front()
					{
						list.pop_front();
					}
				private:
					ContainerT&list;
				};
				template<typename ContainerT>
				class splice_pop_front
				{
				public:
					splice_pop_front(ContainerT&list_, ContainerT&queue): list(list_)
					{
						list.splice(list.end(), queue);
					}
					~splice_pop_front()
					{
						list.pop_front();
					}
				private:
					ContainerT&list;
				};
				template<typename TypeT>
				class reset
				{
				public:
					reset(TypeT&target_value_, TypeT new_value): target_value(target_value_), old_value(target_value_)
					{
						target_value_=new_value;
					}
					~reset()
					{
						target_value=old_value;
					}
				private:
					TypeT&target_value;
					TypeT old_value;
				};
				template<typename IteratorT, typename UnputIteratorT>
				class assign
				{
				public:
					assign(IteratorT&it_, UnputIteratorT const&uit_): it(it_), uit(uit_)
					{
					}
					~assign()
					{
						it=uit.base();
					}
				private:
					IteratorT&it;
					UnputIteratorT const&uit;
				};
				template<typename IteratorT>
				class assign<IteratorT, IteratorT>
				{
				public:
					assign(IteratorT&it_, IteratorT const&uit_): it(it_), uit(uit_)
					{
					}
					~assign()
					{
						it=uit;
					}
				private:
					IteratorT&it;
					IteratorT const&uit;
				};
			}
			namespace impl
			{
				template<typename StringT>
				inline bool is_special_macroname(StringT const&name)
				{
					if(name.size()<7)return false;
					if("defined"==name)return true;
					if('_'==name[0]&&'_'==name[1])
					{
						StringT str=name.substr(2);
						if(str=="cplusplus"||str=="STDC__"||str=="TIME__"||str=="DATE__"||str=="LINE__"||str=="FILE__"||str=="INCLUDE_LEVEL__")
						{
							return true;
						}
					}
					return false;
				}
				template<typename TokenT>
				inline bool token_equals(TokenT const&left, TokenT const&right)
				{
					using namespace boost::wave;
					if(((((left)&boost::wave::TokenTypeMask)==(ParameterTokenType))?true: false))
					{
						token_id id=token_id(right);
						return (T_IDENTIFIER==id||((((id)&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false)||((((id)&boost::wave::ExtTokenTypeMask)==(OperatorTokenType|AltExtTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(BoolLiteralTokenType))?true: false))&&left.get_value()==right.get_value();
					}
					return token_id(left)==token_id(right)&&(((((left)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)||left.get_value()==right.get_value());
				}
				template<typename ContainerT>
				inline bool definition_equals(ContainerT const&definition, ContainerT const&new_definition)
				{
					typedef typename ContainerT::const_iterator const_iterator_type;
					const_iterator_type first1=definition.begin();
					const_iterator_type last1=definition.end();
					const_iterator_type first2=new_definition.begin();
					const_iterator_type last2=new_definition.end();
					while(first1!=last1&&first2!=last2&&token_equals(*first1, *first2))
					{
						token_id id1=next_token<const_iterator_type>::peek(first1, last1, false);
						token_id id2=next_token<const_iterator_type>::peek(first2, last2, false);
						if(((((id1)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&((((id2)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
						{
							skip_whitespace(first1, last1);
							skip_whitespace(first2, last2);
						}
						else if(!((((id1)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&!((((id2)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
						{
							++first1;
							++first2;
						}
						else
						{
							break;
						}
					}
					return (first1==last1&&first2==last2)?true: false;
				}
				template<typename ContainerT>
				inline bool parameters_equal(ContainerT const&parameters, ContainerT const&new_parameters)
				{
					if(parameters.size()!=new_parameters.size())return false;
					typedef typename ContainerT::const_iterator const_iterator_type;
					const_iterator_type first1=parameters.begin();
					const_iterator_type last1=parameters.end();
					const_iterator_type first2=new_parameters.begin();
					const_iterator_type last2=new_parameters.end();
					while(first1!=last1&&first2!=last2)
					{
						using namespace boost::wave;
						if(token_id(*first1)!=token_id(*first2)||(*first1).get_value()!=(*first2).get_value())
						{
							break;
						}
						++first1;
						++first2;
					}
					return (first1==last1&&first2==last2)?true: false;
				}
				template<typename ContainerT>
				inline void trim_replacement_list(ContainerT&replacement_list)
				{
					using namespace boost::wave;
					if(replacement_list.size()>0)
					{
						typename ContainerT::iterator end=replacement_list.end();
						typename ContainerT::iterator it=replacement_list.begin();
						while(it!=end&&((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
						{
							if(T_PLACEHOLDER!=token_id(*it))
							{
								typename ContainerT::iterator next=it;
								++next;
								replacement_list.erase(it);
								it=next;
							}
							else
							{
								++it;
							}
						}
					}
					if(replacement_list.size()>0)
					{
						typename ContainerT::reverse_iterator rend=replacement_list.rend();
						typename ContainerT::reverse_iterator rit=replacement_list.rbegin();
						while(rit!=rend&&((((*rit)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))++rit;
						typename ContainerT::iterator end=replacement_list.end();
						typename ContainerT::iterator it=rit.base();
						while(it!=end&&((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
						{
							if(T_PLACEHOLDER!=token_id(*it))
							{
								typename ContainerT::iterator next=it;
								++next;
								replacement_list.erase(it);
								it=next;
							}
							else
							{
								++it;
							}
						}
					}
				}
				template<typename ContainerT>
				inline void remove_placeholders(ContainerT&replacement_list)
				{
					using namespace boost::wave;
					if(replacement_list.size()>0)
					{
						typename ContainerT::iterator end=replacement_list.end();
						typename ContainerT::iterator it=replacement_list.begin();
						while(it!=end)
						{
							if(T_PLACEHOLDER==token_id(*it))
							{
								typename ContainerT::iterator next=it;
								++next;
								replacement_list.erase(it);
								it=next;
							}
							else
							{
								++it;
							}
						}
						trim_replacement_list(replacement_list);
					}
				}
				template<typename ContainerT>
				inline void trim_sequence_left(ContainerT&argument)
				{
					using namespace boost::wave;
					if(argument.size()>0&&((((argument.front())&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
					{
						argument.pop_front();
					}
				}
				template<typename ContainerT>
				inline void trim_sequence_right(ContainerT&argument)
				{
					using namespace boost::wave;
					if(argument.size()>0&&((((argument.back())&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
					{
						argument.pop_back();
					}
				}
				template<typename ContainerT>
				inline void trim_sequence(ContainerT&argument)
				{
					trim_sequence_left(argument);
					trim_sequence_right(argument);
				}
				template<typename ContainerT>
				inline bool is_whitespace_only(ContainerT const&argument)
				{
					typename ContainerT::const_iterator end=argument.end();
					for(typename ContainerT::const_iterator it=argument.begin();
					it!=end;
					++it)
					{
						if(!((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))return false;
					}
					return true;
				}
				template<typename IteratorT>
				inline bool skip_to_token(IteratorT&it, IteratorT const&end, token_id id, bool&seen_newline)
				{
					using namespace boost::wave;
					if(token_id(*it)==id)return true;
					if(++it==end)return false;
					while(((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)||T_NEWLINE==token_id(*it))
					{
						if(T_NEWLINE==token_id(*it))seen_newline=true;
						if(++it==end)return false;
					}
					return token_id(*it)==id;
				}
				template<typename IteratorT>
				inline std::string get_full_name(IteratorT const&begin, IteratorT const&end)
				{
					std::string full_name;
					for(IteratorT err_it=begin;
					err_it!=end;
					++err_it)full_name+=(*err_it).get_value().c_str();
					return full_name;
				}
				class find_concat_operator
				{
				public:
					find_concat_operator(bool&found_): found_concat(found_)
					{
					}
					template<typename TokenT>
					bool operator()(TokenT const&tok)
					{
						using namespace boost::wave;
						if(T_POUND_POUND==boost::wave::token_id((token_id(tok))&boost::wave::MainTokenMask))found_concat=true;
						return false;
					}
				private:
					bool&found_concat;
				};
				template<typename Target, typename Src>
				struct to_string_helper
				{
					typedef Target type;
					static Target call(Src const&str)
					{
						return Target(str.c_str());
					}
				};
				template<typename Src>
				struct to_string_helper<Src, Src>
				{
					typedef Src const&type;
					static Src const&call(Src const&str)
					{
						return str;
					}
				};
				template<typename Target>
				struct to_string_helper<Target, char const*>
				{
					typedef Target type;
					static Target call(char const*str)
					{
						return Target(str);
					}
				};
			}
			template<typename Target, typename Src>
			inline typename impl::to_string_helper<Target, Src>::type to_string(Src const&src)
			{
				return impl::to_string_helper<Target, Src>::call(src);
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct is_nested;
			struct non_nested;
			struct is_lexeme;
			struct non_lexeme;
			template<typename OpenT, typename ExprT, typename CloseT, typename CategoryT=plain_parser_category, typename NestedT=non_nested, typename LexemeT=non_lexeme>
			struct confix_parser;
			template<typename OpenT, typename CloseT>
			struct comment_nest_parser;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct non_nested_refactoring
			{
				typedef non_nested_refactoring embed_t;
			};
			struct self_nested_refactoring
			{
				typedef self_nested_refactoring embed_t;
			};
			namespace impl
			{
				template<typename CategoryT>
				struct refactor_unary_nested
				{
					template<typename ParserT, typename NestedT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, BinaryT const&binary, NestedT const&)
					{
						return binary.parse(scan);
					}
				};
				template<>
				struct refactor_unary_nested<unary_parser_category>
				{
					template<typename ParserT, typename ScannerT, typename BinaryT, typename NestedT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, BinaryT const&binary, NestedT const&nested_d)
					{
						typedef typename BinaryT::parser_generator_t op_t;
						typedef typename BinaryT::left_t::parser_generator_t unary_t;
						return unary_t::generate(nested_d[op_t::generate(binary.left().subject(), binary.right())]).parse(scan);
					}
				};
				template<typename CategoryT>
				struct refactor_unary_non_nested
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, BinaryT const&binary)
					{
						return binary.parse(scan);
					}
				};
				template<>
				struct refactor_unary_non_nested<unary_parser_category>
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, BinaryT const&binary)
					{
						typedef typename BinaryT::parser_generator_t op_t;
						typedef typename BinaryT::left_t::parser_generator_t unary_t;
						return unary_t::generate(op_t::generate(binary.left().subject(), binary.right())).parse(scan);
					}
				};
				template<typename NestedT>
				struct refactor_unary_type
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, BinaryT const&binary, NestedT const&nested_d)
					{
						typedef typename BinaryT::left_t::parser_category_t parser_category_t;
						return refactor_unary_nested<parser_category_t>::parse(p, scan, binary, nested_d);
					}
				};
				template<>
				struct refactor_unary_type<non_nested_refactoring>
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, BinaryT const&binary, non_nested_refactoring const&)
					{
						typedef typename BinaryT::left_t::parser_category_t parser_category_t;
						return refactor_unary_non_nested<parser_category_t>::parse(p, scan, binary);
					}
				};
				template<>
				struct refactor_unary_type<self_nested_refactoring>
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, BinaryT const&binary, self_nested_refactoring const&nested_tag)
					{
						typedef typename BinaryT::left_t::parser_category_t parser_category_t;
						typedef typename ParserT::parser_generator_t parser_generator_t;
						parser_generator_t nested_d(nested_tag);
						return refactor_unary_nested<parser_category_t>::parse(p, scan, binary, nested_d);
					}
				};
				template<typename CategoryT>
				struct refactor_action_nested
				{
					template<typename ParserT, typename ScannerT, typename BinaryT, typename NestedT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, BinaryT const&binary, NestedT const&nested_d)
					{
						return nested_d[binary].parse(scan);
					}
				};
				template<>
				struct refactor_action_nested<action_parser_category>
				{
					template<typename ParserT, typename ScannerT, typename BinaryT, typename NestedT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, BinaryT const&binary, NestedT const&nested_d)
					{
						typedef typename BinaryT::parser_generator_t binary_gen_t;
						return (nested_d[binary_gen_t::generate(binary.left().subject(), binary.right())][binary.left().predicate()]).parse(scan);
					}
				};
				template<typename CategoryT>
				struct refactor_action_non_nested
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, BinaryT const&binary)
					{
						return binary.parse(scan);
					}
				};
				template<>
				struct refactor_action_non_nested<action_parser_category>
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, BinaryT const&binary)
					{
						typedef typename BinaryT::parser_generator_t binary_gen_t;
						return (binary_gen_t::generate(binary.left().subject(), binary.right())[binary.left().predicate()]).parse(scan);
					}
				};
				template<typename NestedT>
				struct refactor_action_type
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, BinaryT const&binary, NestedT const&nested_d)
					{
						typedef typename BinaryT::left_t::parser_category_t parser_category_t;
						return refactor_action_nested<parser_category_t>::parse(p, scan, binary, nested_d);
					}
				};
				template<>
				struct refactor_action_type<non_nested_refactoring>
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, BinaryT const&binary, non_nested_refactoring const&)
					{
						typedef typename BinaryT::left_t::parser_category_t parser_category_t;
						return refactor_action_non_nested<parser_category_t>::parse(p, scan, binary);
					}
				};
				template<>
				struct refactor_action_type<self_nested_refactoring>
				{
					template<typename ParserT, typename ScannerT, typename BinaryT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, BinaryT const&binary, self_nested_refactoring const&nested_tag)
					{
						typedef typename ParserT::parser_generator_t parser_generator_t;
						typedef typename BinaryT::left_t::parser_category_t parser_category_t;
						parser_generator_t nested_d(nested_tag);
						return refactor_action_nested<parser_category_t>::parse(p, scan, binary, nested_d);
					}
				};
				template<typename CategoryT>
				struct attach_action_nested
				{
					template<typename ParserT, typename ScannerT, typename ActionT, typename NestedT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, ActionT const&action, NestedT const&nested_d)
					{
						return action.parse(scan);
					}
				};
				template<>
				struct attach_action_nested<binary_parser_category>
				{
					template<typename ParserT, typename ScannerT, typename ActionT, typename NestedT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, ActionT const&action, NestedT const&nested_d)
					{
						typedef typename ActionT::subject_t::parser_generator_t binary_gen_t;
						return (binary_gen_t::generate(nested_d[action.subject().left()[action.predicate()]], nested_d[action.subject().right()[action.predicate()]])).parse(scan);
					}
				};
				template<typename CategoryT>
				struct attach_action_non_nested
				{
					template<typename ParserT, typename ScannerT, typename ActionT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, ActionT const&action)
					{
						return action.parse(scan);
					}
				};
				template<>
				struct attach_action_non_nested<binary_parser_category>
				{
					template<typename ParserT, typename ScannerT, typename ActionT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&, ScannerT const&scan, ActionT const&action)
					{
						typedef typename ActionT::subject_t::parser_generator_t binary_gen_t;
						return (binary_gen_t::generate(action.subject().left()[action.predicate()], action.subject().right()[action.predicate()])).parse(scan);
					}
				};
				template<typename NestedT>
				struct attach_action_type
				{
					template<typename ParserT, typename ScannerT, typename ActionT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, ActionT const&action, NestedT const&nested_d)
					{
						typedef typename ActionT::subject_t::parser_category_t parser_category_t;
						return attach_action_nested<parser_category_t>::parse(p, scan, action, nested_d);
					}
				};
				template<>
				struct attach_action_type<non_nested_refactoring>
				{
					template<typename ParserT, typename ScannerT, typename ActionT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, ActionT const&action, non_nested_refactoring const&)
					{
						typedef typename ActionT::subject_t::parser_category_t parser_category_t;
						return attach_action_non_nested<parser_category_t>::parse(p, scan, action);
					}
				};
				template<>
				struct attach_action_type<self_nested_refactoring>
				{
					template<typename ParserT, typename ScannerT, typename ActionT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan, ActionT const&action, self_nested_refactoring const&nested_tag)
					{
						typedef typename ParserT::parser_generator_t parser_generator_t;
						typedef typename ActionT::subject_t::parser_category_t parser_category_t;
						parser_generator_t nested_d(nested_tag);
						return attach_action_nested<parser_category_t>::parse(p, scan, action, nested_d);
					}
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename NestedT=non_nested_refactoring>
			class refactor_unary_gen;
			template<typename BinaryT, typename NestedT=non_nested_refactoring>
			class refactor_unary_parser: public parser<refactor_unary_parser<BinaryT, NestedT> >
			{
			public:
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((boost::is_convertible<typename BinaryT::parser_category_t, binary_parser_category>::value))>)>boost_static_assert_typedef___COUNTER__;
				refactor_unary_parser(BinaryT const&binary_, NestedT const&nested_): binary(binary_), nested(nested_)
				{
				}
				typedef refactor_unary_parser<BinaryT, NestedT>self_t;
				typedef refactor_unary_gen<NestedT>parser_generator_t;
				typedef typename BinaryT::left_t::parser_category_t parser_category_t;
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					return impl::refactor_unary_type<NestedT>::parse(*this, scan, binary, nested);
				}
			private:
				typename as_parser<BinaryT>::type::embed_t binary;
				typename NestedT::embed_t nested;
			};
			template<typename NestedT>
			class refactor_unary_gen
			{
			public:
				typedef refactor_unary_gen<NestedT>embed_t;
				refactor_unary_gen(NestedT const&nested_=non_nested_refactoring()): nested(nested_)
				{
				}
				template<typename ParserT>
				refactor_unary_parser<ParserT, NestedT>operator[](parser<ParserT>const&subject)const
				{
					return refactor_unary_parser<ParserT, NestedT>(subject.derived(), nested);
				}
			private:
				typename NestedT::embed_t nested;
			};
			const refactor_unary_gen<>refactor_unary_d=refactor_unary_gen<>();
			template<typename NestedT=non_nested_refactoring>
			class refactor_action_gen;
			template<typename BinaryT, typename NestedT=non_nested_refactoring>
			class refactor_action_parser: public parser<refactor_action_parser<BinaryT, NestedT> >
			{
			public:
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((boost::is_convertible<typename BinaryT::parser_category_t, binary_parser_category>::value))>)>boost_static_assert_typedef___COUNTER__;
				refactor_action_parser(BinaryT const&binary_, NestedT const&nested_): binary(binary_), nested(nested_)
				{
				}
				typedef refactor_action_parser<BinaryT, NestedT>self_t;
				typedef refactor_action_gen<NestedT>parser_generator_t;
				typedef typename BinaryT::left_t::parser_category_t parser_category_t;
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					return impl::refactor_action_type<NestedT>::parse(*this, scan, binary, nested);
				}
			private:
				typename as_parser<BinaryT>::type::embed_t binary;
				typename NestedT::embed_t nested;
			};
			template<typename NestedT>
			class refactor_action_gen
			{
			public:
				typedef refactor_action_gen<NestedT>embed_t;
				refactor_action_gen(NestedT const&nested_=non_nested_refactoring()): nested(nested_)
				{
				}
				template<typename ParserT>
				refactor_action_parser<ParserT, NestedT>operator[](parser<ParserT>const&subject)const
				{
					return refactor_action_parser<ParserT, NestedT>(subject.derived(), nested);
				}
			private:
				typename NestedT::embed_t nested;
			};
			const refactor_action_gen<>refactor_action_d=refactor_action_gen<>();
			template<typename NestedT=non_nested_refactoring>
			class attach_action_gen;
			template<typename ActionT, typename NestedT=non_nested_refactoring>
			class attach_action_parser: public parser<attach_action_parser<ActionT, NestedT> >
			{
			public:
				typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)((boost::is_convertible<typename ActionT::parser_category_t, action_parser_category>::value))>)>boost_static_assert_typedef___COUNTER__;
				attach_action_parser(ActionT const&actor_, NestedT const&nested_): actor(actor_), nested(nested_)
				{
				}
				typedef attach_action_parser<ActionT, NestedT>self_t;
				typedef attach_action_gen<NestedT>parser_generator_t;
				typedef typename ActionT::parser_category_t parser_category_t;
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					return impl::attach_action_type<NestedT>::parse(*this, scan, actor, nested);
				}
			private:
				typename as_parser<ActionT>::type::embed_t actor;
				typename NestedT::embed_t nested;
			};
			template<typename NestedT>
			class attach_action_gen
			{
			public:
				typedef attach_action_gen<NestedT>embed_t;
				attach_action_gen(NestedT const&nested_=non_nested_refactoring()): nested(nested_)
				{
				}
				template<typename ParserT, typename ActionT>
				attach_action_parser<action<ParserT, ActionT>, NestedT>operator[](action<ParserT, ActionT>const&actor)const
				{
					return attach_action_parser<action<ParserT, ActionT>, NestedT>(actor, nested);
				}
			private:
				typename NestedT::embed_t nested;
			};
			const attach_action_gen<>attach_action_d=attach_action_gen<>();
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			struct is_nested
			{
			};
			struct non_nested
			{
			};
			struct is_lexeme
			{
			};
			struct non_lexeme
			{
			};
			namespace impl
			{
				template<typename LexemeT>
				struct select_confix_parse_lexeme;
				template<>
				struct select_confix_parse_lexeme<is_lexeme>
				{
					template<typename ParserT, typename ScannerT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan)
					{
						typedef typename parser_result<ParserT, ScannerT>::type result_t;
						return contiguous_parser_parse<result_t>(p, scan, scan);
					}
				};
				template<>
				struct select_confix_parse_lexeme<non_lexeme>
				{
					template<typename ParserT, typename ScannerT>
					static typename parser_result<ParserT, ScannerT>::type parse(ParserT const&p, ScannerT const&scan)
					{
						return p.parse(scan);
					}
				};
				template<typename NestedT>
				struct select_confix_parse_refactor;
				template<>
				struct select_confix_parse_refactor<is_nested>
				{
					template<typename LexemeT, typename ParserT, typename ScannerT, typename OpenT, typename ExprT, typename CloseT>
					static typename parser_result<ParserT, ScannerT>::type parse(LexemeT const&, ParserT const&this_, ScannerT const&scan, OpenT const&open, ExprT const&expr, CloseT const&close)
					{
						typedef refactor_action_gen<refactor_unary_gen<> >refactor_t;
						const refactor_t refactor_body_d=refactor_t(refactor_unary_d);
						return select_confix_parse_lexeme<LexemeT>::parse((open>>(this_|refactor_body_d[expr-close])>>close), scan);
					}
				};
				template<>
				struct select_confix_parse_refactor<non_nested>
				{
					template<typename LexemeT, typename ParserT, typename ScannerT, typename OpenT, typename ExprT, typename CloseT>
					static typename parser_result<ParserT, ScannerT>::type parse(LexemeT const&, ParserT const&, ScannerT const&scan, OpenT const&open, ExprT const&expr, CloseT const&close)
					{
						typedef refactor_action_gen<refactor_unary_gen<> >refactor_t;
						const refactor_t refactor_body_d=refactor_t(refactor_unary_d);
						return select_confix_parse_lexeme<LexemeT>::parse((open>>refactor_body_d[expr-close]>>close), scan);
					}
				};
				template<typename NestedT>
				struct select_confix_parse_no_refactor;
				template<>
				struct select_confix_parse_no_refactor<is_nested>
				{
					template<typename LexemeT, typename ParserT, typename ScannerT, typename OpenT, typename ExprT, typename CloseT>
					static typename parser_result<ParserT, ScannerT>::type parse(LexemeT const&, ParserT const&this_, ScannerT const&scan, OpenT const&open, ExprT const&expr, CloseT const&close)
					{
						return select_confix_parse_lexeme<LexemeT>::parse((open>>(this_|(expr-close))>>close), scan);
					}
				};
				template<>
				struct select_confix_parse_no_refactor<non_nested>
				{
					template<typename LexemeT, typename ParserT, typename ScannerT, typename OpenT, typename ExprT, typename CloseT>
					static typename parser_result<ParserT, ScannerT>::type parse(LexemeT const&, ParserT const&, ScannerT const&scan, OpenT const&open, ExprT const&expr, CloseT const&close)
					{
						return select_confix_parse_lexeme<LexemeT>::parse((open>>(expr-close)>>close), scan);
					}
				};
				template<typename CategoryT>
				struct confix_parser_type
				{
					template<typename NestedT, typename LexemeT, typename ParserT, typename ScannerT, typename OpenT, typename ExprT, typename CloseT>
					static typename parser_result<ParserT, ScannerT>::type parse(NestedT const&, LexemeT const&lexeme, ParserT const&this_, ScannerT const&scan, OpenT const&open, ExprT const&expr, CloseT const&close)
					{
						return select_confix_parse_refactor<NestedT>::parse(lexeme, this_, scan, open, expr, close);
					}
				};
				template<>
				struct confix_parser_type<plain_parser_category>
				{
					template<typename NestedT, typename LexemeT, typename ParserT, typename ScannerT, typename OpenT, typename ExprT, typename CloseT>
					static typename parser_result<ParserT, ScannerT>::type parse(NestedT const&, LexemeT const&lexeme, ParserT const&this_, ScannerT const&scan, OpenT const&open, ExprT const&expr, CloseT const&close)
					{
						return select_confix_parse_no_refactor<NestedT>::parse(lexeme, this_, scan, open, expr, close);
					}
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename NestedT=non_nested, typename LexemeT=non_lexeme>
			struct confix_parser_gen;
			template<typename OpenT, typename ExprT, typename CloseT, typename CategoryT, typename NestedT, typename LexemeT>
			struct confix_parser: public parser<confix_parser<OpenT, ExprT, CloseT, CategoryT, NestedT, LexemeT> >
			{
				typedef confix_parser<OpenT, ExprT, CloseT, CategoryT, NestedT, LexemeT>self_t;
				confix_parser(OpenT const&open_, ExprT const&expr_, CloseT const&close_): open(open_), expr(expr_), close(close_)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					return impl::confix_parser_type<CategoryT>::parse(NestedT(), LexemeT(), *this, scan, open, expr, close);
				}
			private:
				typename as_parser<OpenT>::type::embed_t open;
				typename as_parser<ExprT>::type::embed_t expr;
				typename as_parser<CloseT>::type::embed_t close;
			};
			template<typename NestedT, typename LexemeT>
			struct confix_parser_gen
			{
				template<typename StartT, typename ExprT, typename EndT>
				struct paren_op_result_type
				{
					typedef confix_parser<typename as_parser<StartT>::type, typename as_parser<ExprT>::type, typename as_parser<EndT>::type, typename as_parser<ExprT>::type::parser_category_t, NestedT, LexemeT>type;
				};
				template<typename StartT, typename ExprT, typename EndT>
				typename paren_op_result_type<StartT, ExprT, EndT>::type operator()(StartT const&start_, ExprT const&expr_, EndT const&end_)const
				{
					typedef typename paren_op_result_type<StartT, ExprT, EndT>::type return_t;
					return return_t(as_parser<StartT>::convert(start_), as_parser<ExprT>::convert(expr_), as_parser<EndT>::convert(end_));
				}
				template<typename StartT, typename ExprT, typename EndT>
				struct direct_result_type
				{
					typedef confix_parser<typename as_parser<StartT>::type, typename as_parser<ExprT>::type, typename as_parser<EndT>::type, plain_parser_category, NestedT, LexemeT>type;
				};
				template<typename StartT, typename ExprT, typename EndT>
				typename direct_result_type<StartT, ExprT, EndT>::type direct(StartT const&start_, ExprT const&expr_, EndT const&end_)const
				{
					typedef typename direct_result_type<StartT, ExprT, EndT>::type return_t;
					return return_t(as_parser<StartT>::convert(start_), as_parser<ExprT>::convert(expr_), as_parser<EndT>::convert(end_));
				}
			};
			const confix_parser_gen<non_nested, non_lexeme>confix_p=confix_parser_gen<non_nested, non_lexeme>();
			template<typename NestedT>
			struct comment_parser_gen
			{
				template<typename StartT>
				struct paren_op1_result_type
				{
					typedef confix_parser<typename as_parser<StartT>::type, kleene_star<anychar_parser>, alternative<eol_parser, end_parser>, unary_parser_category, NestedT, is_lexeme>type;
				};
				template<typename StartT>
				typename paren_op1_result_type<StartT>::type operator()(StartT const&start_)const
				{
					typedef typename paren_op1_result_type<StartT>::type return_t;
					return return_t(as_parser<StartT>::convert(start_), *anychar_p, eol_p|end_p);
				}
				template<typename StartT, typename EndT>
				struct paren_op2_result_type
				{
					typedef confix_parser<typename as_parser<StartT>::type, kleene_star<anychar_parser>, typename as_parser<EndT>::type, unary_parser_category, NestedT, is_lexeme>type;
				};
				template<typename StartT, typename EndT>
				typename paren_op2_result_type<StartT, EndT>::type operator()(StartT const&start_, EndT const&end_)const
				{
					typedef typename paren_op2_result_type<StartT, EndT>::type return_t;
					return return_t(as_parser<StartT>::convert(start_), *anychar_p, as_parser<EndT>::convert(end_));
				}
			};
			const comment_parser_gen<non_nested>comment_p=comment_parser_gen<non_nested>();
			template<typename OpenT, typename CloseT>
			struct comment_nest_parser: public parser<comment_nest_parser<OpenT, CloseT> >
			{
				typedef comment_nest_parser<OpenT, CloseT>self_t;
				comment_nest_parser(OpenT const&open_, CloseT const&close_): open(open_), close(close_)
				{
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					return do_parse(open>>*(*this|(anychar_p-close))>>close, scan);
				}
			private:
				template<typename ParserT, typename ScannerT>
				typename parser_result<self_t, ScannerT>::type do_parse(ParserT const&p, ScannerT const&scan)const
				{
					return impl::contiguous_parser_parse<typename parser_result<ParserT, ScannerT>::type>(p, scan, scan);
				}
				typename as_parser<OpenT>::type::embed_t open;
				typename as_parser<CloseT>::type::embed_t close;
			};
			template<typename OpenT, typename CloseT>
			struct comment_nest_p_result
			{
				typedef comment_nest_parser<typename as_parser<OpenT>::type, typename as_parser<CloseT>::type>type;
			};
			template<typename OpenT, typename CloseT>
			inline typename comment_nest_p_result<OpenT, CloseT>::type comment_nest_p(OpenT const&open, CloseT const&close)
			{
				typedef typename comment_nest_p_result<OpenT, CloseT>::type result_t;
				return result_t(as_parser<OpenT>::convert(open), as_parser<CloseT>::convert(close));
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			template<typename CharT=char>
			struct pattern_and: public boost::spirit::classic::char_parser<pattern_and<CharT> >
			{
				pattern_and(CharT pattern_, unsigned long pattern_mask_=0UL): pattern(pattern_), pattern_mask((0UL!=pattern_mask_)?pattern_mask_: pattern_)
				{
				}
				template<typename T>
				bool test(T pattern_)const
				{
					return ((unsigned long)pattern_&pattern_mask)==(unsigned long)pattern;
				}
				CharT pattern;
				unsigned long pattern_mask;
			};
			template<typename CharT>
			inline pattern_and<CharT>pattern_p(CharT pattern, unsigned long pattern_mask=0UL)
			{
				return pattern_and<CharT>(pattern, pattern_mask);
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		enum language_support
		{
			support_normal=0x01, support_cpp=support_normal, support_option_long_long=0x02, support_option_variadics=0x04, support_c99=support_option_variadics|support_option_long_long|0x08, support_option_mask=0xFF80, support_option_insert_whitespace=0x0080, support_option_preserve_comments=0x0100, support_option_no_character_validation=0x0200, support_option_convert_trigraphs=0x0400, support_option_single_line=0x0800, support_option_prefer_pp_numbers=0x1000, support_option_emit_line_directives=0x2000, support_option_include_guard_detection=0x4000, support_option_emit_pragma_directives=0x8000
		};
		inline bool need_cpp(language_support language)
		{
			return (language&~support_option_mask)==support_cpp;
		}
		inline bool need_c99(language_support language)
		{
			return (language&~support_option_mask)==support_c99;
		}
		inline language_support get_support_options(language_support language)
		{
			return static_cast<language_support>(language&support_option_mask);
		}
		inline language_support set_support_options(language_support language, language_support option)
		{
			return static_cast<language_support>((language&~support_option_mask)|(option&support_option_mask));
		}
		inline bool need_long_long(language_support language)
		{
			return (language&support_option_long_long)?true: false;
		}
		inline language_support enable_long_long(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_long_long);
			return static_cast<language_support>(language&~support_option_long_long);
		}
		inline bool need_no_character_validation(language_support language)
		{
			return (language&support_option_no_character_validation)?true: false;
		}
		inline language_support enable_no_character_validation(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_no_character_validation);
			return static_cast<language_support>(language&~support_option_no_character_validation);
		}
		inline bool need_preserve_comments(language_support language)
		{
			return (language&support_option_preserve_comments)?true: false;
		}
		inline language_support enable_preserve_comments(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_preserve_comments);
			return static_cast<language_support>(language&~support_option_preserve_comments);
		}
		inline bool need_prefer_pp_numbers(language_support language)
		{
			return (language&support_option_prefer_pp_numbers)?true: false;
		}
		inline language_support enable_prefer_pp_numbers(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_prefer_pp_numbers);
			return static_cast<language_support>(language&~support_option_prefer_pp_numbers);
		}
		inline bool need_emit_line_directives(language_support language)
		{
			return (language&support_option_emit_line_directives)?true: false;
		}
		inline language_support enable_emit_line_directives(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_emit_line_directives);
			return static_cast<language_support>(language&~support_option_emit_line_directives);
		}
		inline bool need_single_line(language_support language)
		{
			return (language&support_option_single_line)?true: false;
		}
		inline language_support enable_single_line(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_single_line);
			return static_cast<language_support>(language&~support_option_single_line);
		}
		inline bool need_convert_trigraphs(language_support language)
		{
			return (language&support_option_convert_trigraphs)?true: false;
		}
		inline language_support enable_convert_trigraphs(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_convert_trigraphs);
			return static_cast<language_support>(language&~support_option_convert_trigraphs);
		}
		inline bool need_include_guard_detection(language_support language)
		{
			return (language&support_option_include_guard_detection)?true: false;
		}
		inline language_support enable_include_guard_detection(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_include_guard_detection);
			return static_cast<language_support>(language&~support_option_include_guard_detection);
		}
		inline bool need_variadics(language_support language)
		{
			return (language&support_option_variadics)?true: false;
		}
		inline language_support enable_variadics(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_variadics);
			return static_cast<language_support>(language&~support_option_variadics);
		}
		inline bool need_emit_pragma_directives(language_support language)
		{
			return (language&support_option_emit_pragma_directives)?true: false;
		}
		inline language_support enable_emit_pragma_directives(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_emit_pragma_directives);
			return static_cast<language_support>(language&~support_option_emit_pragma_directives);
		}
		inline bool need_insert_whitespace(language_support language)
		{
			return (language&support_option_insert_whitespace)?true: false;
		}
		inline language_support enable_insert_whitespace(language_support language, bool enable=true)
		{
			if(enable)return static_cast<language_support>(language|support_option_insert_whitespace);
			return static_cast<language_support>(language&~support_option_insert_whitespace);
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace iteration_context_policies
		{
			struct load_file_to_string
			{
				template<typename IterContextT>
				class inner
				{
				public:
					template<typename PositionT>
					static void init_iterators(IterContextT&iter_ctx, PositionT const&act_pos, language_support language)
					{
						typedef typename IterContextT::iterator_type iterator_type;
						std::ifstream instream(iter_ctx.filename.c_str());
						if(!instream.is_open())
						{

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<preprocess_exception::severity_text(preprocess_exception::bad_include_file)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_include_file);
								if((iter_ctx.filename.c_str())[0]!=0)stream<<": "<<(iter_ctx.filename.c_str());
								stream<<std::ends;
								iter_ctx.ctx.get_hooks().throw_exception(iter_ctx.ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_include_file, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
							};
							return ;
						}
						instream.unsetf(std::ios::skipws);
						iter_ctx.instring.assign(std::istreambuf_iterator<char>(instream.rdbuf()), std::istreambuf_iterator<char>());
						iter_ctx.first=iterator_type(iter_ctx.instring.begin(), iter_ctx.instring.end(), PositionT(iter_ctx.filename), language);
						iter_ctx.last=iterator_type();
					}
				private:
					std::string instring;
				};
			};
		}
		template<typename ContextT, typename IteratorT>
		struct base_iteration_context
		{
		public:
			base_iteration_context(ContextT&ctx_, boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >const&fname, std::size_t if_block_depth=0): real_filename(fname), filename(fname), line(1), emitted_lines(1), if_block_depth(if_block_depth), ctx(ctx_)
			{
			}
			base_iteration_context(ContextT&ctx_, IteratorT const&first_, IteratorT const&last_, boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >const&fname, std::size_t if_block_depth=0): first(first_), last(last_), real_filename(fname), filename(fname), line(1), emitted_lines(1), if_block_depth(if_block_depth), ctx(ctx_)
			{
			}
			IteratorT first;
			IteratorT last;
			boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >real_filename;
			boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >filename;
			unsigned int line;
			unsigned int emitted_lines;
			std::size_t if_block_depth;
			ContextT&ctx;
		};
		template<typename ContextT, typename IteratorT, typename InputPolicyT=typename ContextT::input_policy_type>
		struct iteration_context: public base_iteration_context<ContextT, IteratorT>, public InputPolicyT::template inner<iteration_context<ContextT, IteratorT, InputPolicyT> >
		{
			typedef IteratorT iterator_type;
			typedef typename IteratorT::token_type::position_type position_type;
			typedef iteration_context<ContextT, IteratorT, InputPolicyT>self_type;
			iteration_context(ContextT&ctx, boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >const&fname, position_type const&act_pos, boost::wave::language_support language_): base_iteration_context<ContextT, IteratorT>(ctx, fname)
			{
				InputPolicyT::template inner<self_type>::init_iterators(*this, act_pos, language_);
			}
		};
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			template<typename ContextT, typename IteratorT, typename ContainerT>
			inline bool interpret_pragma(ContextT&ctx, typename ContextT::token_type const&act_token, IteratorT it, IteratorT const&end, ContainerT&pending)
			{
				typedef typename ContextT::token_type token_type;
				typedef typename token_type::string_type string_type;
				using namespace cpplexer;
				if(T_IDENTIFIER==token_id(*it))
				{
					if((*it).get_value()=="wave")
					{
						using namespace boost::spirit::classic;
						token_type option;
						ContainerT values;
						if(!parse(++it, end, (ch_p(T_IDENTIFIER)[boost::spirit::classic::assign_a(option)]|pattern_p(KeywordTokenType, TokenTypeMask)[boost::spirit::classic::assign_a(option)]|pattern_p(OperatorTokenType|AltExtTokenType, ExtTokenTypeMask)[boost::spirit::classic::assign_a(option)]|pattern_p(BoolLiteralTokenType, TokenTypeMask)[boost::spirit::classic::assign_a(option)])>>!comment_nest_p(ch_p(T_LEFTPAREN), ch_p(T_RIGHTPAREN))[boost::spirit::classic::assign_a(values)], pattern_p(WhiteSpaceTokenType, TokenTypeMask)).hit)
						{

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_pragma_option)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_pragma_option);
								if((impl::as_string<string_type>(it, end).c_str())[0]!=0)stream<<": "<<(impl::as_string<string_type>(it, end).c_str());
								stream<<std::ends;
								ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_pragma_option, (act_token.get_position()).get_line(), (act_token.get_position()).get_column(), (act_token.get_position()).get_file().c_str()));
							};
							return false;
						}
						if(values.size()>=2)
						{
							(void)((!!(T_LEFTPAREN==values.front()&&T_RIGHTPAREN==values.back()))||(_wassert(L"T_LEFTPAREN == values.front() && T_RIGHTPAREN == values.back()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\interpret_pragma.hpp", 117), 0));
							values.erase(values.begin());
							typename ContainerT::reverse_iterator rit=values.rbegin();
							values.erase((++rit).base());
						}
						if(!ctx.get_hooks().interpret_pragma(ctx.derived(), pending, option, values, act_token))
						{
							string_type option_str((*it).get_value());
							option_str+=option.get_value();
							if(values.size()>0)
							{
								option_str+="(";
								option_str+=impl::as_string(values);
								option_str+=")";
							}

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_pragma_option)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_pragma_option);
								if((option_str.c_str())[0]!=0)stream<<": "<<(option_str.c_str());
								stream<<std::ends;
								ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_pragma_option, (act_token.get_position()).get_line(), (act_token.get_position()).get_column(), (act_token.get_position()).get_file().c_str()));
							};
							return false;
						}
						return true;
					}
					else if((*it).get_value()=="once")
					{
						return ctx.add_pragma_once_header(act_token, ctx.get_current_filename());
					}
					else if((*it).get_value()=="message")
					{
						using namespace boost::spirit::classic;
						ContainerT values;
						if(!parse(++it, end, ((ch_p(T_LEFTPAREN)>>lexeme_d[*(anychar_p[boost::spirit::classic::push_back_a(values)]-ch_p(T_RIGHTPAREN))]>>ch_p(T_RIGHTPAREN))|lexeme_d[*(anychar_p[boost::spirit::classic::push_back_a(values)]-ch_p(T_NEWLINE))]), pattern_p(WhiteSpaceTokenType, TokenTypeMask)).hit)
						{

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_pragma_message)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_pragma_message);
								if((impl::as_string<string_type>(it, end).c_str())[0]!=0)stream<<": "<<(impl::as_string<string_type>(it, end).c_str());
								stream<<std::ends;
								ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_pragma_message, (act_token.get_position()).get_line(), (act_token.get_position()).get_column(), (act_token.get_position()).get_file().c_str()));
							};
							return false;
						}
						if(values.size()>0)
						{
							(void)((!!(T_RIGHTPAREN==values.back()||T_NEWLINE==values.back()))||(_wassert(L"T_RIGHTPAREN == values.back() || T_NEWLINE == values.back()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\interpret_pragma.hpp", 179), 0));
							typename ContainerT::reverse_iterator rit=values.rbegin();
							values.erase((++rit).base());
						}

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::pragma_message_directive)<<": "<<preprocess_exception::error_text(preprocess_exception::pragma_message_directive);
							if((impl::as_string(values).c_str())[0]!=0)stream<<": "<<(impl::as_string(values).c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::pragma_message_directive, (act_token.get_position()).get_line(), (act_token.get_position()).get_column(), (act_token.get_position()).get_file().c_str()));
						};
						return false;
					}
				}
				return false;
			}
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	template<class T>
	class integer_traits;
	template<>
	class integer_traits<bool>;
	template<>
	class integer_traits<char>;
	template<>
	class integer_traits<signed char>;
	template<>
	class integer_traits<unsigned char>;
	template<>
	class integer_traits<wchar_t>;
	template<>
	class integer_traits<short>;
	template<>
	class integer_traits<unsigned short>;
	template<>
	class integer_traits<int>;
	template<>
	class integer_traits<unsigned int>;
	template<>
	class integer_traits<long>;
	template<>
	class integer_traits<unsigned long>;
	template<typename LeastInt>
	struct int_fast_t;
	template<int Bits>
	struct int_t;
	template<int Bits>
	struct uint_t;
	template<long MaxValue>
	struct int_max_value_t;
	template<long MinValue>
	struct int_min_value_t;
	template<unsigned long Value>
	struct uint_value_t;
	template<std::size_t Bit>
	struct high_bit_mask_t;
	template<std::size_t Bits>
	struct low_bits_mask_t;
	template<>
	struct low_bits_mask_t< ::std::numeric_limits<unsigned char>::digits>;
	template<>
	struct low_bits_mask_t< ::std::numeric_limits<unsigned short>::digits>;
	template<>
	struct low_bits_mask_t< ::std::numeric_limits<unsigned int>::digits>;
	template<unsigned long Value>
	struct static_log2;
	template<>
	struct static_log2<0ul>;
	template<long Value1, long Value2>
	struct static_signed_min;
	template<long Value1, long Value2>
	struct static_signed_max;
	template<unsigned long Value1, unsigned long Value2>
	struct static_unsigned_min;
	template<unsigned long Value1, unsigned long Value2>
	struct static_unsigned_max;
}
namespace boost
{
	template<class T>
	class integer_traits: public std::numeric_limits<T>
	{
	public:
		static const bool is_integral=false;
	};
	namespace detail
	{
		template<class T, T min_val, T max_val>
		class integer_traits_base
		{
		public:
			static const bool is_integral=true;
			static const T const_min=min_val;
			static const T const_max=max_val;
		};
		template<class T, T min_val, T max_val>
		const bool integer_traits_base<T, min_val, max_val>::is_integral;
		template<class T, T min_val, T max_val>
		const T integer_traits_base<T, min_val, max_val>::const_min;
		template<class T, T min_val, T max_val>
		const T integer_traits_base<T, min_val, max_val>::const_max;
	}
	template<>
	class integer_traits<bool>: public std::numeric_limits<bool>, public detail::integer_traits_base<bool, false, true>
	{
	};
	template<>
	class integer_traits<char>: public std::numeric_limits<char>, public detail::integer_traits_base<char, (-128), 127>
	{
	};
	template<>
	class integer_traits<signed char>: public std::numeric_limits<signed char>, public detail::integer_traits_base<signed char, (-128), 127>
	{
	};
	template<>
	class integer_traits<unsigned char>: public std::numeric_limits<unsigned char>, public detail::integer_traits_base<unsigned char, 0, 0xff>
	{
	};
	template<>
	class integer_traits<wchar_t>: public std::numeric_limits<wchar_t>, public detail::integer_traits_base<wchar_t, 0, 0xffff>
	{
	};
	template<>
	class integer_traits<short>: public std::numeric_limits<short>, public detail::integer_traits_base<short, (-32768), 32767>
	{
	};
	template<>
	class integer_traits<unsigned short>: public std::numeric_limits<unsigned short>, public detail::integer_traits_base<unsigned short, 0, 0xffff>
	{
	};
	template<>
	class integer_traits<int>: public std::numeric_limits<int>, public detail::integer_traits_base<int, (-2147483647-1), 2147483647>
	{
	};
	template<>
	class integer_traits<unsigned int>: public std::numeric_limits<unsigned int>, public detail::integer_traits_base<unsigned int, 0, 0xffffffff>
	{
	};
	template<>
	class integer_traits<long>: public std::numeric_limits<long>, public detail::integer_traits_base<long, (-2147483647L-1), 2147483647L>
	{
	};
	template<>
	class integer_traits<unsigned long>: public std::numeric_limits<unsigned long>, public detail::integer_traits_base<unsigned long, 0, 0xffffffffUL>
	{
	};
}
namespace boost
{
	template<typename LeastInt>
	struct int_fast_t
	{
		typedef LeastInt fast;
	};
	template<int Category>
	struct int_least_helper
	{
	};
	template<>
	struct int_least_helper<1>
	{
		typedef long least;
	};
	template<>
	struct int_least_helper<2>
	{
		typedef int least;
	};
	template<>
	struct int_least_helper<3>
	{
		typedef short least;
	};
	template<>
	struct int_least_helper<4>
	{
		typedef signed char least;
	};
	template<>
	struct int_least_helper<6>
	{
		typedef unsigned long least;
	};
	template<>
	struct int_least_helper<7>
	{
		typedef unsigned int least;
	};
	template<>
	struct int_least_helper<8>
	{
		typedef unsigned short least;
	};
	template<>
	struct int_least_helper<9>
	{
		typedef unsigned char least;
	};
	template<int Bits>
	struct int_t
	{
		typedef typename int_least_helper<(Bits-1<=std::numeric_limits<long>::digits)+(Bits-1<=std::numeric_limits<int>::digits)+(Bits-1<=std::numeric_limits<short>::digits)+(Bits-1<=std::numeric_limits<signed char>::digits)>::least least;
		typedef typename int_fast_t<least>::fast fast;
	};
	template<int Bits>
	struct uint_t
	{
		typedef typename int_least_helper<5+(Bits<=std::numeric_limits<unsigned long>::digits)+(Bits<=std::numeric_limits<unsigned int>::digits)+(Bits<=std::numeric_limits<unsigned short>::digits)+(Bits<=std::numeric_limits<unsigned char>::digits)>::least least;
		typedef typename int_fast_t<least>::fast fast;
	};
	template<long MaxValue>
	struct int_max_value_t
	{
		typedef typename int_least_helper<(MaxValue<=integer_traits<long>::const_max)+(MaxValue<=integer_traits<int>::const_max)+(MaxValue<=integer_traits<short>::const_max)+(MaxValue<=integer_traits<signed char>::const_max)>::least least;
		typedef typename int_fast_t<least>::fast fast;
	};
	template<long MinValue>
	struct int_min_value_t
	{
		typedef typename int_least_helper<(MinValue>=integer_traits<long>::const_min)+(MinValue>=integer_traits<int>::const_min)+(MinValue>=integer_traits<short>::const_min)+(MinValue>=integer_traits<signed char>::const_min)>::least least;
		typedef typename int_fast_t<least>::fast fast;
	};
	template<unsigned long Value>
	struct uint_value_t
	{
		typedef typename int_least_helper<5+(Value<=integer_traits<unsigned long>::const_max)+(Value<=integer_traits<unsigned int>::const_max)+(Value<=integer_traits<unsigned short>::const_max)+(Value<=integer_traits<unsigned char>::const_max)>::least least;
		typedef typename int_fast_t<least>::fast fast;
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct has_trivial_dtor_impl
		{
			static const bool value=(::boost::type_traits::ice_or< ::boost::is_pod<T>::value, __has_trivial_destructor(T)>::value);
		};
	}
	template<typename T>
	struct has_trivial_destructor: ::boost::integral_constant<bool, ::boost::detail::has_trivial_dtor_impl<T>::value>
	{
	};
}
namespace boost
{
	namespace detail
	{
		template<typename T>
		struct is_union_impl
		{
			typedef typename remove_cv<T>::type cvt;
			static const bool value=__is_union(cvt);
		};
	}
	template<typename T>
	struct is_union: ::boost::integral_constant<bool, ::boost::detail::is_union_impl<T>::value>
	{
	};
}
namespace boost
{
	template<typename F, typename G>
	bool function_equal_impl(const F&f, const G&g, long)
	{
		return f==g;
	}
	template<typename F, typename G>
	bool function_equal(const F&f, const G&g)
	{
		return function_equal_impl(f, g, 0);
	}
}
namespace boost
{
	class bad_function_call;
	template<typename Signature>
	class function;
	template<typename Signature>
	inline void swap(function<Signature>&f1, function<Signature>&f2)
	{
		f1.swap(f2);
	}
	template<typename R>
	class function0;
	template<typename R, typename T1>
	class function1;
	template<typename R, typename T1, typename T2>
	class function2;
	template<typename R, typename T1, typename T2, typename T3>
	class function3;
	template<typename R, typename T1, typename T2, typename T3, typename T4>
	class function4;
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
	class function5;
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	class function6;
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	class function7;
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	class function8;
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	class function9;
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
	class function10;
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			class X;
			union function_buffer
			{
				mutable void*obj_ptr;
				struct type_t
				{
					const std::type_info*type;
					bool const_qualified;
					bool volatile_qualified;
				}
				type;
				mutable void(*func_ptr)();
				struct bound_memfunc_ptr_t
				{
					void(X::*memfunc_ptr)(int);
					void*obj_ptr;
				}
				bound_memfunc_ptr;
				struct obj_ref_t
				{
					mutable void*obj_ptr;
					bool is_const_qualified;
					bool is_volatile_qualified;
				}
				obj_ref;
				mutable char data;
			};
			struct unusable
			{
				unusable()
				{
				}
				template<typename T>
				unusable(const T&)
				{
				}
			};
			template<typename T>
			struct function_return_type
			{
				typedef T type;
			};
			template<>
			struct function_return_type<void>
			{
				typedef unusable type;
			};
			enum functor_manager_operation_type
			{
				clone_functor_tag, move_functor_tag, destroy_functor_tag, check_functor_type_tag, get_functor_type_tag
			};
			struct function_ptr_tag
			{
			};
			struct function_obj_tag
			{
			};
			struct member_ptr_tag
			{
			};
			struct function_obj_ref_tag
			{
			};
			template<typename F>
			class get_function_tag
			{
				typedef typename mpl::if_c<(is_pointer<F>::value), function_ptr_tag, function_obj_tag>::type ptr_or_obj_tag;
				typedef typename mpl::if_c<(is_member_pointer<F>::value), member_ptr_tag, ptr_or_obj_tag>::type ptr_or_obj_or_mem_tag;
				typedef typename mpl::if_c<(is_reference_wrapper<F>::value), function_obj_ref_tag, ptr_or_obj_or_mem_tag>::type or_ref_tag;
			public:
				typedef or_ref_tag type;
			};
			template<typename F>
			struct reference_manager
			{
				static inline void manage(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op)
				{
					switch(op)
					{
						case clone_functor_tag: out_buffer.obj_ref.obj_ptr=in_buffer.obj_ref.obj_ptr;
						return ;
						case move_functor_tag: out_buffer.obj_ref.obj_ptr=in_buffer.obj_ref.obj_ptr;
						in_buffer.obj_ref.obj_ptr=0;
						return ;
						case destroy_functor_tag: out_buffer.obj_ref.obj_ptr=0;
						return ;
						case check_functor_type_tag:
						{
							const std::type_info&check_type=*out_buffer.type.type;
							if(((check_type)==(typeid(F)))&&(!in_buffer.obj_ref.is_const_qualified||out_buffer.type.const_qualified)&&(!in_buffer.obj_ref.is_volatile_qualified||out_buffer.type.volatile_qualified))out_buffer.obj_ptr=in_buffer.obj_ref.obj_ptr;
							else out_buffer.obj_ptr=0;
						}
						return ;
						case get_functor_type_tag: out_buffer.type.type=&typeid(F);
						out_buffer.type.const_qualified=in_buffer.obj_ref.is_const_qualified;
						out_buffer.type.volatile_qualified=in_buffer.obj_ref.is_volatile_qualified;
						return ;
					}
				}
			};
			template<typename F>
			struct function_allows_small_object_optimization
			{
				static const bool value=((sizeof(F)<=sizeof(function_buffer)&&(alignment_of<function_buffer>::value%alignment_of<F>::value==0)));
			};
			template<typename F, typename A>
			struct functor_wrapper: public F, public A
			{
				functor_wrapper(F f, A a): F(f), A(a)
				{
				}
				functor_wrapper(const functor_wrapper&f): F(static_cast<const F&>(f)), A(static_cast<const A&>(f))
				{
				}
			};
			template<typename Functor>
			struct functor_manager_common
			{
				typedef Functor functor_type;
				static inline void manage_ptr(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op)
				{
					if(op==clone_functor_tag)out_buffer.func_ptr=in_buffer.func_ptr;
					else if(op==move_functor_tag)
					{
						out_buffer.func_ptr=in_buffer.func_ptr;
						in_buffer.func_ptr=0;
					}
					else if(op==destroy_functor_tag)out_buffer.func_ptr=0;
					else if(op==check_functor_type_tag)
					{
						const std::type_info&check_type=*out_buffer.type.type;
						if(((check_type)==(typeid(Functor))))out_buffer.obj_ptr=&in_buffer.func_ptr;
						else out_buffer.obj_ptr=0;
					}
					else
					{
						out_buffer.type.type=&typeid(Functor);
						out_buffer.type.const_qualified=false;
						out_buffer.type.volatile_qualified=false;
					}
				}
				static inline void manage_small(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op)
				{
					if(op==clone_functor_tag||op==move_functor_tag)
					{
						const functor_type*in_functor=reinterpret_cast<const functor_type*>(&in_buffer.data);
						new((void*)&out_buffer.data)functor_type(*in_functor);
						if(op==move_functor_tag)
						{
							reinterpret_cast<functor_type*>(&in_buffer.data)->~Functor();
						}
					}
					else if(op==destroy_functor_tag)
					{
						reinterpret_cast<functor_type*>(&out_buffer.data)->~Functor();
					}
					else if(op==check_functor_type_tag)
					{
						const std::type_info&check_type=*out_buffer.type.type;
						if(((check_type)==(typeid(Functor))))out_buffer.obj_ptr=&in_buffer.data;
						else out_buffer.obj_ptr=0;
					}
					else
					{
						out_buffer.type.type=&typeid(Functor);
						out_buffer.type.const_qualified=false;
						out_buffer.type.volatile_qualified=false;
					}
				}
			};
			template<typename Functor>
			struct functor_manager
			{
			private:
				typedef Functor functor_type;
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, function_ptr_tag)
				{
					functor_manager_common<Functor>::manage_ptr(in_buffer, out_buffer, op);
				}
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, mpl::true_)
				{
					functor_manager_common<Functor>::manage_small(in_buffer, out_buffer, op);
				}
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, mpl::false_)
				{
					if(op==clone_functor_tag)
					{
						const functor_type*f=(const functor_type*)(in_buffer.obj_ptr);
						functor_type*new_f=new functor_type(*f);
						out_buffer.obj_ptr=new_f;
					}
					else if(op==move_functor_tag)
					{
						out_buffer.obj_ptr=in_buffer.obj_ptr;
						in_buffer.obj_ptr=0;
					}
					else if(op==destroy_functor_tag)
					{
						functor_type*f=static_cast<functor_type*>(out_buffer.obj_ptr);
						delete f;
						out_buffer.obj_ptr=0;
					}
					else if(op==check_functor_type_tag)
					{
						const std::type_info&check_type=*out_buffer.type.type;
						if(((check_type)==(typeid(Functor))))out_buffer.obj_ptr=in_buffer.obj_ptr;
						else out_buffer.obj_ptr=0;
					}
					else
					{
						out_buffer.type.type=&typeid(Functor);
						out_buffer.type.const_qualified=false;
						out_buffer.type.volatile_qualified=false;
					}
				}
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, function_obj_tag)
				{
					manager(in_buffer, out_buffer, op, mpl::bool_<(function_allows_small_object_optimization<functor_type>::value)>());
				}
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, member_ptr_tag)
				{
					manager(in_buffer, out_buffer, op, mpl::true_());
				}
			public:
				static inline void manage(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op)
				{
					typedef typename get_function_tag<functor_type>::type tag_type;
					switch(op)
					{
						case get_functor_type_tag: out_buffer.type.type=&typeid(functor_type);
						out_buffer.type.const_qualified=false;
						out_buffer.type.volatile_qualified=false;
						return ;
						default: manager(in_buffer, out_buffer, op, tag_type());
						return ;
					}
				}
			};
			template<typename Functor, typename Allocator>
			struct functor_manager_a
			{
			private:
				typedef Functor functor_type;
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, function_ptr_tag)
				{
					functor_manager_common<Functor>::manage_ptr(in_buffer, out_buffer, op);
				}
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, mpl::true_)
				{
					functor_manager_common<Functor>::manage_small(in_buffer, out_buffer, op);
				}
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, mpl::false_)
				{
					typedef functor_wrapper<Functor, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					if(op==clone_functor_tag)
					{
						const functor_wrapper_type*f=(const functor_wrapper_type*)(in_buffer.obj_ptr);
						wrapper_allocator_type wrapper_allocator(static_cast<Allocator const&>(*f));
						wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
						wrapper_allocator.construct(copy, *f);
						functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
						out_buffer.obj_ptr=new_f;
					}
					else if(op==move_functor_tag)
					{
						out_buffer.obj_ptr=in_buffer.obj_ptr;
						in_buffer.obj_ptr=0;
					}
					else if(op==destroy_functor_tag)
					{
						functor_wrapper_type*victim=static_cast<functor_wrapper_type*>(in_buffer.obj_ptr);
						wrapper_allocator_type wrapper_allocator(static_cast<Allocator const&>(*victim));
						wrapper_allocator.destroy(victim);
						wrapper_allocator.deallocate(victim, 1);
						out_buffer.obj_ptr=0;
					}
					else if(op==check_functor_type_tag)
					{
						const std::type_info&check_type=*out_buffer.type.type;
						if(((check_type)==(typeid(Functor))))out_buffer.obj_ptr=in_buffer.obj_ptr;
						else out_buffer.obj_ptr=0;
					}
					else
					{
						out_buffer.type.type=&typeid(Functor);
						out_buffer.type.const_qualified=false;
						out_buffer.type.volatile_qualified=false;
					}
				}
				static inline void manager(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op, function_obj_tag)
				{
					manager(in_buffer, out_buffer, op, mpl::bool_<(function_allows_small_object_optimization<functor_type>::value)>());
				}
			public:
				static inline void manage(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op)
				{
					typedef typename get_function_tag<functor_type>::type tag_type;
					switch(op)
					{
						case get_functor_type_tag: out_buffer.type.type=&typeid(functor_type);
						out_buffer.type.const_qualified=false;
						out_buffer.type.volatile_qualified=false;
						return ;
						default: manager(in_buffer, out_buffer, op, tag_type());
						return ;
					}
				}
			};
			struct useless_clear_type
			{
			};
			struct vtable_base
			{
				void(*manager)(const function_buffer&in_buffer, function_buffer&out_buffer, functor_manager_operation_type op);
			};
		}
	}
	class function_base
	{
	public:
		function_base(): vtable(0)
		{
		}
		bool empty()const
		{
			return !vtable;
		}
		const std::type_info&target_type()const
		{
			if(!vtable)return typeid(void);
			detail::function::function_buffer type;
			get_vtable()->manager(functor, type, detail::function::get_functor_type_tag);
			return *type.type.type;
		}
		template<typename Functor>
		Functor*target()
		{
			if(!vtable)return 0;
			detail::function::function_buffer type_result;
			type_result.type.type=&typeid(Functor);
			type_result.type.const_qualified=is_const<Functor>::value;
			type_result.type.volatile_qualified=is_volatile<Functor>::value;
			get_vtable()->manager(functor, type_result, detail::function::check_functor_type_tag);
			return static_cast<Functor*>(type_result.obj_ptr);
		}
		template<typename Functor>
		const Functor*target()const
		{
			if(!vtable)return 0;
			detail::function::function_buffer type_result;
			type_result.type.type=&typeid(Functor);
			type_result.type.const_qualified=true;
			type_result.type.volatile_qualified=is_volatile<Functor>::value;
			get_vtable()->manager(functor, type_result, detail::function::check_functor_type_tag);
			return (const Functor*)(type_result.obj_ptr);
		}
		template<typename F>
		bool contains(const F&f)const
		{
			if(const F*fp=this->template target<F>())
			{
				return function_equal(*fp, f);
			}
			else
			{
				return false;
			}
		}
	public:
		detail::function::vtable_base*get_vtable()const
		{
			return reinterpret_cast<detail::function::vtable_base*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		bool has_trivial_copy_and_destroy()const
		{
			return reinterpret_cast<std::size_t>(vtable)&0x01;
		}
		detail::function::vtable_base*vtable;
		mutable detail::function::function_buffer functor;
	};
	class bad_function_call: public std::runtime_error
	{
	public:
		bad_function_call(): std::runtime_error("call to empty boost::function")
		{
		}
	};
	inline bool operator==(const function_base&f, detail::function::useless_clear_type*)
	{
		return f.empty();
	}
	inline bool operator!=(const function_base&f, detail::function::useless_clear_type*)
	{
		return !f.empty();
	}
	inline bool operator==(detail::function::useless_clear_type*, const function_base&f)
	{
		return f.empty();
	}
	inline bool operator!=(detail::function::useless_clear_type*, const function_base&f)
	{
		return !f.empty();
	}
	template<typename Functor>
	typename::boost::enable_if_c<(::boost::type_traits::ice_not<(::boost::is_integral<Functor>::value)>::value), bool>::type operator==(const function_base&f, Functor g)
	{
		if(const Functor*fp=f.template target<Functor>())return function_equal(*fp, g);
		else return false;
	}
	template<typename Functor>
	typename::boost::enable_if_c<(::boost::type_traits::ice_not<(::boost::is_integral<Functor>::value)>::value), bool>::type operator==(Functor g, const function_base&f)
	{
		if(const Functor*fp=f.template target<Functor>())return function_equal(g, *fp);
		else return false;
	}
	template<typename Functor>
	typename::boost::enable_if_c<(::boost::type_traits::ice_not<(::boost::is_integral<Functor>::value)>::value), bool>::type operator!=(const function_base&f, Functor g)
	{
		if(const Functor*fp=f.template target<Functor>())return !function_equal(*fp, g);
		else return true;
	}
	template<typename Functor>
	typename::boost::enable_if_c<(::boost::type_traits::ice_not<(::boost::is_integral<Functor>::value)>::value), bool>::type operator!=(Functor g, const function_base&f)
	{
		if(const Functor*fp=f.template target<Functor>())return !function_equal(g, *fp);
		else return true;
	}
	template<typename Functor>
	typename::boost::enable_if_c<(::boost::type_traits::ice_not<(::boost::is_integral<Functor>::value)>::value), bool>::type operator==(const function_base&f, reference_wrapper<Functor>g)
	{
		if(const Functor*fp=f.template target<Functor>())return fp==g.get_pointer();
		else return false;
	}
	template<typename Functor>
	typename::boost::enable_if_c<(::boost::type_traits::ice_not<(::boost::is_integral<Functor>::value)>::value), bool>::type operator==(reference_wrapper<Functor>g, const function_base&f)
	{
		if(const Functor*fp=f.template target<Functor>())return g.get_pointer()==fp;
		else return false;
	}
	template<typename Functor>
	typename::boost::enable_if_c<(::boost::type_traits::ice_not<(::boost::is_integral<Functor>::value)>::value), bool>::type operator!=(const function_base&f, reference_wrapper<Functor>g)
	{
		if(const Functor*fp=f.template target<Functor>())return fp!=g.get_pointer();
		else return true;
	}
	template<typename Functor>
	typename::boost::enable_if_c<(::boost::type_traits::ice_not<(::boost::is_integral<Functor>::value)>::value), bool>::type operator!=(reference_wrapper<Functor>g, const function_base&f)
	{
		if(const Functor*fp=f.template target<Functor>())return g.get_pointer()!=fp;
		else return true;
	}
	namespace detail
	{
		namespace function
		{
			inline bool has_empty_target(const function_base*f)
			{
				return f->empty();
			}
			inline bool has_empty_target(...)
			{
				return false;
			}
		}
	}
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R>
			struct function_invoker0
			{
				static R invoke(function_buffer&function_ptr)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f();
				}
			};
			template<typename FunctionPtr, typename R>
			struct void_function_invoker0
			{
				static void invoke(function_buffer&function_ptr)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f();
				}
			};
			template<typename FunctionObj, typename R>
			struct function_obj_invoker0
			{
				static R invoke(function_buffer&function_obj_ptr)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)();
				}
			};
			template<typename FunctionObj, typename R>
			struct void_function_obj_invoker0
			{
				static void invoke(function_buffer&function_obj_ptr)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)();
				}
			};
			template<typename FunctionObj, typename R>
			struct function_ref_invoker0
			{
				static R invoke(function_buffer&function_obj_ptr)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)();
				}
			};
			template<typename FunctionObj, typename R>
			struct void_function_ref_invoker0
			{
				static void invoke(function_buffer&function_obj_ptr)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)();
				}
			};
			template<typename FunctionPtr, typename R>
			struct get_function_invoker0
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker0<FunctionPtr, R>, function_invoker0<FunctionPtr, R> >::type type;
			};
			template<typename FunctionObj, typename R>
			struct get_function_obj_invoker0
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker0<FunctionObj, R>, function_obj_invoker0<FunctionObj, R> >::type type;
			};
			template<typename FunctionObj, typename R>
			struct get_function_ref_invoker0
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker0<FunctionObj, R>, function_ref_invoker0<FunctionObj, R> >::type type;
			};
			template<typename Tag>
			struct get_invoker0
			{
			};
			template<>
			struct get_invoker0<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R>
				struct apply
				{
					typedef typename get_function_invoker0<FunctionPtr, R>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker0<FunctionPtr, R>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker0<function_obj_tag>
			{
				template<typename FunctionObj, typename R>
				struct apply
				{
					typedef typename get_function_obj_invoker0<FunctionObj, R>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker0<FunctionObj, R>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker0<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R>
				struct apply
				{
					typedef typename get_function_ref_invoker0<typename RefWrapper::type, R>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker0<typename RefWrapper::type, R>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R>
			struct basic_vtable0
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R>
	class function0: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable0<R>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=0;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=0;
		typedef function0 self_type;
		function0(): function_base()
		{
		}
		template<typename Functor>
		function0(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function0(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function0(clear_type*): function_base()
		{
		}
		function0(const function0&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function0()
		{
			clear();
		}
		result_type operator()()const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function0&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function0&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function0&operator=(const function0&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function0&other)
		{
			if(&other==this)return ;
			function0 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function0&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker0<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker0<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function0&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R>
	inline void swap(function0<R>&f1, function0<R>&f2)
	{
		f1.swap(f2);
	}
	template<typename R>
	typename function0<R>::result_type inline function0<R>::operator()()const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor);
	}
	template<typename R>
	void operator==(const function0<R>&, const function0<R>&);
	template<typename R>
	void operator!=(const function0<R>&, const function0<R>&);
	template<typename R>
	class function<R(void)>: public function0<R>
	{
		typedef function0<R>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0>
			struct function_invoker1
			{
				static R invoke(function_buffer&function_ptr, T0 a0)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0);
				}
			};
			template<typename FunctionPtr, typename R, typename T0>
			struct void_function_invoker1
			{
				static void invoke(function_buffer&function_ptr, T0 a0)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0);
				}
			};
			template<typename FunctionObj, typename R, typename T0>
			struct function_obj_invoker1
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0);
				}
			};
			template<typename FunctionObj, typename R, typename T0>
			struct void_function_obj_invoker1
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0);
				}
			};
			template<typename FunctionObj, typename R, typename T0>
			struct function_ref_invoker1
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0);
				}
			};
			template<typename FunctionObj, typename R, typename T0>
			struct void_function_ref_invoker1
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0);
				}
			};
			template<typename MemberPtr, typename R, typename T0>
			struct function_mem_invoker1
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0);
				}
			};
			template<typename MemberPtr, typename R, typename T0>
			struct function_void_mem_invoker1
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0);
				}
			};
			template<typename FunctionPtr, typename R, typename T0>
			struct get_function_invoker1
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker1<FunctionPtr, R, T0>, function_invoker1<FunctionPtr, R, T0> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0>
			struct get_function_obj_invoker1
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker1<FunctionObj, R, T0>, function_obj_invoker1<FunctionObj, R, T0> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0>
			struct get_function_ref_invoker1
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker1<FunctionObj, R, T0>, function_ref_invoker1<FunctionObj, R, T0> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0>
			struct get_member_invoker1
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker1<MemberPtr, R, T0>, function_mem_invoker1<MemberPtr, R, T0> >::type type;
			};
			template<typename Tag>
			struct get_invoker1
			{
			};
			template<>
			struct get_invoker1<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0>
				struct apply
				{
					typedef typename get_function_invoker1<FunctionPtr, R, T0>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker1<FunctionPtr, R, T0>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker1<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0>
				struct apply
				{
					typedef typename get_member_invoker1<MemberPtr, R, T0>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker1<MemberPtr, R, T0>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker1<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0>
				struct apply
				{
					typedef typename get_function_obj_invoker1<FunctionObj, R, T0>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker1<FunctionObj, R, T0>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker1<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0>
				struct apply
				{
					typedef typename get_function_ref_invoker1<typename RefWrapper::type, R, T0>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker1<typename RefWrapper::type, R, T0>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0>
			struct basic_vtable1
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0>
	class function1: public function_base, public std::unary_function<T0, R>
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable1<R, T0>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=1;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		typedef T0 argument_type;
		static const int arity=1;
		typedef T0 arg1_type;
		typedef function1 self_type;
		function1(): function_base()
		{
		}
		template<typename Functor>
		function1(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function1(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function1(clear_type*): function_base()
		{
		}
		function1(const function1&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function1()
		{
			clear();
		}
		result_type operator()(T0 a0)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function1&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function1&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function1&operator=(const function1&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function1&other)
		{
			if(&other==this)return ;
			function1 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function1&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker1<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker1<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function1&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0>
	inline void swap(function1<R, T0>&f1, function1<R, T0>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0>
	typename function1<R, T0>::result_type inline function1<R, T0>::operator()(T0 a0)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0);
	}
	template<typename R, typename T0>
	void operator==(const function1<R, T0>&, const function1<R, T0>&);
	template<typename R, typename T0>
	void operator!=(const function1<R, T0>&, const function1<R, T0>&);
	template<typename R, typename T0>
	class function<R(T0)>: public function1<R, T0>
	{
		typedef function1<R, T0>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1>
			struct function_invoker2
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1>
			struct void_function_invoker2
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1>
			struct function_obj_invoker2
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1>
			struct void_function_obj_invoker2
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1>
			struct function_ref_invoker2
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1>
			struct void_function_ref_invoker2
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1>
			struct function_mem_invoker2
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1>
			struct function_void_mem_invoker2
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1>
			struct get_function_invoker2
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker2<FunctionPtr, R, T0, T1>, function_invoker2<FunctionPtr, R, T0, T1> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1>
			struct get_function_obj_invoker2
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker2<FunctionObj, R, T0, T1>, function_obj_invoker2<FunctionObj, R, T0, T1> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1>
			struct get_function_ref_invoker2
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker2<FunctionObj, R, T0, T1>, function_ref_invoker2<FunctionObj, R, T0, T1> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1>
			struct get_member_invoker2
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker2<MemberPtr, R, T0, T1>, function_mem_invoker2<MemberPtr, R, T0, T1> >::type type;
			};
			template<typename Tag>
			struct get_invoker2
			{
			};
			template<>
			struct get_invoker2<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1>
				struct apply
				{
					typedef typename get_function_invoker2<FunctionPtr, R, T0, T1>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker2<FunctionPtr, R, T0, T1>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker2<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1>
				struct apply
				{
					typedef typename get_member_invoker2<MemberPtr, R, T0, T1>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker2<MemberPtr, R, T0, T1>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker2<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1>
				struct apply
				{
					typedef typename get_function_obj_invoker2<FunctionObj, R, T0, T1>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker2<FunctionObj, R, T0, T1>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker2<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1>
				struct apply
				{
					typedef typename get_function_ref_invoker2<typename RefWrapper::type, R, T0, T1>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker2<typename RefWrapper::type, R, T0, T1>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1>
			struct basic_vtable2
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1>
	class function2: public function_base, public std::binary_function<T0, T1, R>
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable2<R, T0, T1>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=2;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		typedef T0 first_argument_type;
		typedef T1 second_argument_type;
		static const int arity=2;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef function2 self_type;
		function2(): function_base()
		{
		}
		template<typename Functor>
		function2(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function2(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function2(clear_type*): function_base()
		{
		}
		function2(const function2&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function2()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function2&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function2&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function2&operator=(const function2&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function2&other)
		{
			if(&other==this)return ;
			function2 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function2&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker2<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker2<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function2&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1>
	inline void swap(function2<R, T0, T1>&f1, function2<R, T0, T1>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1>
	typename function2<R, T0, T1>::result_type inline function2<R, T0, T1>::operator()(T0 a0, T1 a1)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1);
	}
	template<typename R, typename T0, typename T1>
	void operator==(const function2<R, T0, T1>&, const function2<R, T0, T1>&);
	template<typename R, typename T0, typename T1>
	void operator!=(const function2<R, T0, T1>&, const function2<R, T0, T1>&);
	template<typename R, typename T0, typename T1>
	class function<R(T0, T1)>: public function2<R, T0, T1>
	{
		typedef function2<R, T0, T1>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2>
			struct function_invoker3
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1, a2);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2>
			struct void_function_invoker3
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1, a2);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2>
			struct function_obj_invoker3
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2>
			struct void_function_obj_invoker3
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2>
			struct function_ref_invoker3
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2>
			struct void_function_ref_invoker3
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2>
			struct function_mem_invoker3
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1, a2);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2>
			struct function_void_mem_invoker3
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1, a2);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2>
			struct get_function_invoker3
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker3<FunctionPtr, R, T0, T1, T2>, function_invoker3<FunctionPtr, R, T0, T1, T2> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2>
			struct get_function_obj_invoker3
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker3<FunctionObj, R, T0, T1, T2>, function_obj_invoker3<FunctionObj, R, T0, T1, T2> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2>
			struct get_function_ref_invoker3
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker3<FunctionObj, R, T0, T1, T2>, function_ref_invoker3<FunctionObj, R, T0, T1, T2> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2>
			struct get_member_invoker3
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker3<MemberPtr, R, T0, T1, T2>, function_mem_invoker3<MemberPtr, R, T0, T1, T2> >::type type;
			};
			template<typename Tag>
			struct get_invoker3
			{
			};
			template<>
			struct get_invoker3<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2>
				struct apply
				{
					typedef typename get_function_invoker3<FunctionPtr, R, T0, T1, T2>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker3<FunctionPtr, R, T0, T1, T2>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker3<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2>
				struct apply
				{
					typedef typename get_member_invoker3<MemberPtr, R, T0, T1, T2>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker3<MemberPtr, R, T0, T1, T2>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker3<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2>
				struct apply
				{
					typedef typename get_function_obj_invoker3<FunctionObj, R, T0, T1, T2>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker3<FunctionObj, R, T0, T1, T2>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker3<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2>
				struct apply
				{
					typedef typename get_function_ref_invoker3<typename RefWrapper::type, R, T0, T1, T2>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker3<typename RefWrapper::type, R, T0, T1, T2>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1, typename T2>
			struct basic_vtable3
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1, T2);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1, typename T2>
	class function3: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable3<R, T0, T1, T2>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=3;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=3;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef T2 arg3_type;
		typedef function3 self_type;
		function3(): function_base()
		{
		}
		template<typename Functor>
		function3(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function3(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function3(clear_type*): function_base()
		{
		}
		function3(const function3&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function3()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1, T2 a2)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function3&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function3&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function3&operator=(const function3&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function3&other)
		{
			if(&other==this)return ;
			function3 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function3&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker3<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1, T2>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker3<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, T2, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function3&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1, typename T2>
	inline void swap(function3<R, T0, T1, T2>&f1, function3<R, T0, T1, T2>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1, typename T2>
	typename function3<R, T0, T1, T2>::result_type inline function3<R, T0, T1, T2>::operator()(T0 a0, T1 a1, T2 a2)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1, a2);
	}
	template<typename R, typename T0, typename T1, typename T2>
	void operator==(const function3<R, T0, T1, T2>&, const function3<R, T0, T1, T2>&);
	template<typename R, typename T0, typename T1, typename T2>
	void operator!=(const function3<R, T0, T1, T2>&, const function3<R, T0, T1, T2>&);
	template<typename R, typename T0, typename T1, typename T2>
	class function<R(T0, T1, T2)>: public function3<R, T0, T1, T2>
	{
		typedef function3<R, T0, T1, T2>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3>
			struct function_invoker4
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1, a2, a3);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3>
			struct void_function_invoker4
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1, a2, a3);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3>
			struct function_obj_invoker4
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3>
			struct void_function_obj_invoker4
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3>
			struct function_ref_invoker4
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3>
			struct void_function_ref_invoker4
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3>
			struct function_mem_invoker4
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1, a2, a3);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3>
			struct function_void_mem_invoker4
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1, a2, a3);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3>
			struct get_function_invoker4
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker4<FunctionPtr, R, T0, T1, T2, T3>, function_invoker4<FunctionPtr, R, T0, T1, T2, T3> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3>
			struct get_function_obj_invoker4
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker4<FunctionObj, R, T0, T1, T2, T3>, function_obj_invoker4<FunctionObj, R, T0, T1, T2, T3> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3>
			struct get_function_ref_invoker4
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker4<FunctionObj, R, T0, T1, T2, T3>, function_ref_invoker4<FunctionObj, R, T0, T1, T2, T3> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3>
			struct get_member_invoker4
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker4<MemberPtr, R, T0, T1, T2, T3>, function_mem_invoker4<MemberPtr, R, T0, T1, T2, T3> >::type type;
			};
			template<typename Tag>
			struct get_invoker4
			{
			};
			template<>
			struct get_invoker4<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3>
				struct apply
				{
					typedef typename get_function_invoker4<FunctionPtr, R, T0, T1, T2, T3>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker4<FunctionPtr, R, T0, T1, T2, T3>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker4<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3>
				struct apply
				{
					typedef typename get_member_invoker4<MemberPtr, R, T0, T1, T2, T3>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker4<MemberPtr, R, T0, T1, T2, T3>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker4<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3>
				struct apply
				{
					typedef typename get_function_obj_invoker4<FunctionObj, R, T0, T1, T2, T3>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker4<FunctionObj, R, T0, T1, T2, T3>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker4<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3>
				struct apply
				{
					typedef typename get_function_ref_invoker4<typename RefWrapper::type, R, T0, T1, T2, T3>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker4<typename RefWrapper::type, R, T0, T1, T2, T3>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1, typename T2, typename T3>
			struct basic_vtable4
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1, T2, T3);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3>
	class function4: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable4<R, T0, T1, T2, T3>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=4;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=4;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef T2 arg3_type;
		typedef T3 arg4_type;
		typedef function4 self_type;
		function4(): function_base()
		{
		}
		template<typename Functor>
		function4(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function4(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function4(clear_type*): function_base()
		{
		}
		function4(const function4&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function4()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1, T2 a2, T3 a3)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function4&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function4&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function4&operator=(const function4&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function4&other)
		{
			if(&other==this)return ;
			function4 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function4&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker4<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1, T2, T3>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker4<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, T2, T3, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function4&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1, typename T2, typename T3>
	inline void swap(function4<R, T0, T1, T2, T3>&f1, function4<R, T0, T1, T2, T3>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3>
	typename function4<R, T0, T1, T2, T3>::result_type inline function4<R, T0, T1, T2, T3>::operator()(T0 a0, T1 a1, T2 a2, T3 a3)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1, a2, a3);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3>
	void operator==(const function4<R, T0, T1, T2, T3>&, const function4<R, T0, T1, T2, T3>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3>
	void operator!=(const function4<R, T0, T1, T2, T3>&, const function4<R, T0, T1, T2, T3>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3>
	class function<R(T0, T1, T2, T3)>: public function4<R, T0, T1, T2, T3>
	{
		typedef function4<R, T0, T1, T2, T3>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct function_invoker5
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1, a2, a3, a4);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct void_function_invoker5
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1, a2, a3, a4);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct function_obj_invoker5
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct void_function_obj_invoker5
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct function_ref_invoker5
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct void_function_ref_invoker5
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct function_mem_invoker5
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1, a2, a3, a4);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct function_void_mem_invoker5
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1, a2, a3, a4);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct get_function_invoker5
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker5<FunctionPtr, R, T0, T1, T2, T3, T4>, function_invoker5<FunctionPtr, R, T0, T1, T2, T3, T4> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct get_function_obj_invoker5
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker5<FunctionObj, R, T0, T1, T2, T3, T4>, function_obj_invoker5<FunctionObj, R, T0, T1, T2, T3, T4> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct get_function_ref_invoker5
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker5<FunctionObj, R, T0, T1, T2, T3, T4>, function_ref_invoker5<FunctionObj, R, T0, T1, T2, T3, T4> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct get_member_invoker5
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker5<MemberPtr, R, T0, T1, T2, T3, T4>, function_mem_invoker5<MemberPtr, R, T0, T1, T2, T3, T4> >::type type;
			};
			template<typename Tag>
			struct get_invoker5
			{
			};
			template<>
			struct get_invoker5<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
				struct apply
				{
					typedef typename get_function_invoker5<FunctionPtr, R, T0, T1, T2, T3, T4>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker5<FunctionPtr, R, T0, T1, T2, T3, T4>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker5<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
				struct apply
				{
					typedef typename get_member_invoker5<MemberPtr, R, T0, T1, T2, T3, T4>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker5<MemberPtr, R, T0, T1, T2, T3, T4>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker5<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
				struct apply
				{
					typedef typename get_function_obj_invoker5<FunctionObj, R, T0, T1, T2, T3, T4>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker5<FunctionObj, R, T0, T1, T2, T3, T4>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker5<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
				struct apply
				{
					typedef typename get_function_ref_invoker5<typename RefWrapper::type, R, T0, T1, T2, T3, T4>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker5<typename RefWrapper::type, R, T0, T1, T2, T3, T4>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
			struct basic_vtable5
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1, T2, T3, T4);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
	class function5: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable5<R, T0, T1, T2, T3, T4>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=5;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=5;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef T2 arg3_type;
		typedef T3 arg4_type;
		typedef T4 arg5_type;
		typedef function5 self_type;
		function5(): function_base()
		{
		}
		template<typename Functor>
		function5(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function5(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function5(clear_type*): function_base()
		{
		}
		function5(const function5&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function5()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function5&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function5&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function5&operator=(const function5&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function5&other)
		{
			if(&other==this)return ;
			function5 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function5&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker5<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1, T2, T3, T4>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker5<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, T2, T3, T4, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function5&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
	inline void swap(function5<R, T0, T1, T2, T3, T4>&f1, function5<R, T0, T1, T2, T3, T4>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
	typename function5<R, T0, T1, T2, T3, T4>::result_type inline function5<R, T0, T1, T2, T3, T4>::operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1, a2, a3, a4);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
	void operator==(const function5<R, T0, T1, T2, T3, T4>&, const function5<R, T0, T1, T2, T3, T4>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
	void operator!=(const function5<R, T0, T1, T2, T3, T4>&, const function5<R, T0, T1, T2, T3, T4>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4>
	class function<R(T0, T1, T2, T3, T4)>: public function5<R, T0, T1, T2, T3, T4>
	{
		typedef function5<R, T0, T1, T2, T3, T4>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct function_invoker6
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1, a2, a3, a4, a5);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct void_function_invoker6
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1, a2, a3, a4, a5);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct function_obj_invoker6
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct void_function_obj_invoker6
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct function_ref_invoker6
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct void_function_ref_invoker6
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct function_mem_invoker6
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct function_void_mem_invoker6
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct get_function_invoker6
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker6<FunctionPtr, R, T0, T1, T2, T3, T4, T5>, function_invoker6<FunctionPtr, R, T0, T1, T2, T3, T4, T5> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct get_function_obj_invoker6
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker6<FunctionObj, R, T0, T1, T2, T3, T4, T5>, function_obj_invoker6<FunctionObj, R, T0, T1, T2, T3, T4, T5> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct get_function_ref_invoker6
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker6<FunctionObj, R, T0, T1, T2, T3, T4, T5>, function_ref_invoker6<FunctionObj, R, T0, T1, T2, T3, T4, T5> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct get_member_invoker6
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker6<MemberPtr, R, T0, T1, T2, T3, T4, T5>, function_mem_invoker6<MemberPtr, R, T0, T1, T2, T3, T4, T5> >::type type;
			};
			template<typename Tag>
			struct get_invoker6
			{
			};
			template<>
			struct get_invoker6<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
				struct apply
				{
					typedef typename get_function_invoker6<FunctionPtr, R, T0, T1, T2, T3, T4, T5>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker6<FunctionPtr, R, T0, T1, T2, T3, T4, T5>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker6<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
				struct apply
				{
					typedef typename get_member_invoker6<MemberPtr, R, T0, T1, T2, T3, T4, T5>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker6<MemberPtr, R, T0, T1, T2, T3, T4, T5>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker6<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
				struct apply
				{
					typedef typename get_function_obj_invoker6<FunctionObj, R, T0, T1, T2, T3, T4, T5>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker6<FunctionObj, R, T0, T1, T2, T3, T4, T5>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker6<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
				struct apply
				{
					typedef typename get_function_ref_invoker6<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker6<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
			struct basic_vtable6
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1, T2, T3, T4, T5);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
	class function6: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable6<R, T0, T1, T2, T3, T4, T5>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=6;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=6;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef T2 arg3_type;
		typedef T3 arg4_type;
		typedef T4 arg5_type;
		typedef T5 arg6_type;
		typedef function6 self_type;
		function6(): function_base()
		{
		}
		template<typename Functor>
		function6(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function6(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function6(clear_type*): function_base()
		{
		}
		function6(const function6&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function6()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function6&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function6&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function6&operator=(const function6&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function6&other)
		{
			if(&other==this)return ;
			function6 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function6&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker6<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1, T2, T3, T4, T5>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker6<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, T2, T3, T4, T5, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function6&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
	inline void swap(function6<R, T0, T1, T2, T3, T4, T5>&f1, function6<R, T0, T1, T2, T3, T4, T5>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
	typename function6<R, T0, T1, T2, T3, T4, T5>::result_type inline function6<R, T0, T1, T2, T3, T4, T5>::operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1, a2, a3, a4, a5);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
	void operator==(const function6<R, T0, T1, T2, T3, T4, T5>&, const function6<R, T0, T1, T2, T3, T4, T5>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
	void operator!=(const function6<R, T0, T1, T2, T3, T4, T5>&, const function6<R, T0, T1, T2, T3, T4, T5>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5>
	class function<R(T0, T1, T2, T3, T4, T5)>: public function6<R, T0, T1, T2, T3, T4, T5>
	{
		typedef function6<R, T0, T1, T2, T3, T4, T5>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct function_invoker7
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1, a2, a3, a4, a5, a6);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct void_function_invoker7
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1, a2, a3, a4, a5, a6);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct function_obj_invoker7
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5, a6);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct void_function_obj_invoker7
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5, a6);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct function_ref_invoker7
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5, a6);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct void_function_ref_invoker7
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5, a6);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct function_mem_invoker7
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5, a6);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct function_void_mem_invoker7
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5, a6);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct get_function_invoker7
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker7<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6>, function_invoker7<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct get_function_obj_invoker7
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker7<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6>, function_obj_invoker7<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct get_function_ref_invoker7
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker7<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6>, function_ref_invoker7<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct get_member_invoker7
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker7<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6>, function_mem_invoker7<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6> >::type type;
			};
			template<typename Tag>
			struct get_invoker7
			{
			};
			template<>
			struct get_invoker7<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
				struct apply
				{
					typedef typename get_function_invoker7<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker7<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker7<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
				struct apply
				{
					typedef typename get_member_invoker7<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker7<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker7<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
				struct apply
				{
					typedef typename get_function_obj_invoker7<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker7<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker7<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
				struct apply
				{
					typedef typename get_function_ref_invoker7<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5, T6>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker7<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5, T6>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
			struct basic_vtable7
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1, T2, T3, T4, T5, T6);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	class function7: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable7<R, T0, T1, T2, T3, T4, T5, T6>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=7;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=7;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef T2 arg3_type;
		typedef T3 arg4_type;
		typedef T4 arg5_type;
		typedef T5 arg6_type;
		typedef T6 arg7_type;
		typedef function7 self_type;
		function7(): function_base()
		{
		}
		template<typename Functor>
		function7(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function7(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function7(clear_type*): function_base()
		{
		}
		function7(const function7&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function7()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function7&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function7&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function7&operator=(const function7&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function7&other)
		{
			if(&other==this)return ;
			function7 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function7&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker7<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1, T2, T3, T4, T5, T6>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker7<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, T2, T3, T4, T5, T6, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function7&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	inline void swap(function7<R, T0, T1, T2, T3, T4, T5, T6>&f1, function7<R, T0, T1, T2, T3, T4, T5, T6>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	typename function7<R, T0, T1, T2, T3, T4, T5, T6>::result_type inline function7<R, T0, T1, T2, T3, T4, T5, T6>::operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1, a2, a3, a4, a5, a6);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	void operator==(const function7<R, T0, T1, T2, T3, T4, T5, T6>&, const function7<R, T0, T1, T2, T3, T4, T5, T6>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	void operator!=(const function7<R, T0, T1, T2, T3, T4, T5, T6>&, const function7<R, T0, T1, T2, T3, T4, T5, T6>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	class function<R(T0, T1, T2, T3, T4, T5, T6)>: public function7<R, T0, T1, T2, T3, T4, T5, T6>
	{
		typedef function7<R, T0, T1, T2, T3, T4, T5, T6>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct function_invoker8
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1, a2, a3, a4, a5, a6, a7);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct void_function_invoker8
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1, a2, a3, a4, a5, a6, a7);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct function_obj_invoker8
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5, a6, a7);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct void_function_obj_invoker8
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5, a6, a7);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct function_ref_invoker8
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5, a6, a7);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct void_function_ref_invoker8
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5, a6, a7);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct function_mem_invoker8
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5, a6, a7);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct function_void_mem_invoker8
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5, a6, a7);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct get_function_invoker8
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker8<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7>, function_invoker8<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct get_function_obj_invoker8
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker8<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7>, function_obj_invoker8<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct get_function_ref_invoker8
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker8<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7>, function_ref_invoker8<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct get_member_invoker8
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker8<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7>, function_mem_invoker8<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7> >::type type;
			};
			template<typename Tag>
			struct get_invoker8
			{
			};
			template<>
			struct get_invoker8<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
				struct apply
				{
					typedef typename get_function_invoker8<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker8<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker8<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
				struct apply
				{
					typedef typename get_member_invoker8<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker8<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker8<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
				struct apply
				{
					typedef typename get_function_obj_invoker8<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker8<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker8<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
				struct apply
				{
					typedef typename get_function_ref_invoker8<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5, T6, T7>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker8<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5, T6, T7>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
			struct basic_vtable8
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1, T2, T3, T4, T5, T6, T7);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	class function8: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable8<R, T0, T1, T2, T3, T4, T5, T6, T7>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=8;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=8;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef T2 arg3_type;
		typedef T3 arg4_type;
		typedef T4 arg5_type;
		typedef T5 arg6_type;
		typedef T6 arg7_type;
		typedef T7 arg8_type;
		typedef function8 self_type;
		function8(): function_base()
		{
		}
		template<typename Functor>
		function8(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function8(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function8(clear_type*): function_base()
		{
		}
		function8(const function8&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function8()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function8&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function8&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function8&operator=(const function8&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function8&other)
		{
			if(&other==this)return ;
			function8 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function8&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker8<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1, T2, T3, T4, T5, T6, T7>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker8<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, T2, T3, T4, T5, T6, T7, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function8&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	inline void swap(function8<R, T0, T1, T2, T3, T4, T5, T6, T7>&f1, function8<R, T0, T1, T2, T3, T4, T5, T6, T7>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	typename function8<R, T0, T1, T2, T3, T4, T5, T6, T7>::result_type inline function8<R, T0, T1, T2, T3, T4, T5, T6, T7>::operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1, a2, a3, a4, a5, a6, a7);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	void operator==(const function8<R, T0, T1, T2, T3, T4, T5, T6, T7>&, const function8<R, T0, T1, T2, T3, T4, T5, T6, T7>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	void operator!=(const function8<R, T0, T1, T2, T3, T4, T5, T6, T7>&, const function8<R, T0, T1, T2, T3, T4, T5, T6, T7>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	class function<R(T0, T1, T2, T3, T4, T5, T6, T7)>: public function8<R, T0, T1, T2, T3, T4, T5, T6, T7>
	{
		typedef function8<R, T0, T1, T2, T3, T4, T5, T6, T7>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct function_invoker9
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1, a2, a3, a4, a5, a6, a7, a8);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct void_function_invoker9
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1, a2, a3, a4, a5, a6, a7, a8);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct function_obj_invoker9
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct void_function_obj_invoker9
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct function_ref_invoker9
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct void_function_ref_invoker9
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct function_mem_invoker9
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct function_void_mem_invoker9
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct get_function_invoker9
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker9<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>, function_invoker9<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct get_function_obj_invoker9
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker9<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>, function_obj_invoker9<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct get_function_ref_invoker9
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker9<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>, function_ref_invoker9<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct get_member_invoker9
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker9<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>, function_mem_invoker9<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8> >::type type;
			};
			template<typename Tag>
			struct get_invoker9
			{
			};
			template<>
			struct get_invoker9<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
				struct apply
				{
					typedef typename get_function_invoker9<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker9<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker9<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
				struct apply
				{
					typedef typename get_member_invoker9<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker9<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker9<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
				struct apply
				{
					typedef typename get_function_obj_invoker9<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker9<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker9<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
				struct apply
				{
					typedef typename get_function_ref_invoker9<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker9<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
			struct basic_vtable9
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1, T2, T3, T4, T5, T6, T7, T8);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	class function9: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=9;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=9;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef T2 arg3_type;
		typedef T3 arg4_type;
		typedef T4 arg5_type;
		typedef T5 arg6_type;
		typedef T6 arg7_type;
		typedef T7 arg8_type;
		typedef T8 arg9_type;
		typedef function9 self_type;
		function9(): function_base()
		{
		}
		template<typename Functor>
		function9(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function9(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function9(clear_type*): function_base()
		{
		}
		function9(const function9&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function9()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function9&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function9&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function9&operator=(const function9&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function9&other)
		{
			if(&other==this)return ;
			function9 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function9&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker9<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1, T2, T3, T4, T5, T6, T7, T8>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker9<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function9&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	inline void swap(function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>&f1, function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	typename function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::result_type inline function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>::operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	void operator==(const function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>&, const function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	void operator!=(const function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>&, const function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	class function<R(T0, T1, T2, T3, T4, T5, T6, T7, T8)>: public function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>
	{
		typedef function9<R, T0, T1, T2, T3, T4, T5, T6, T7, T8>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	namespace detail
	{
		namespace function
		{
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct function_invoker10
			{
				static R invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					return f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct void_function_invoker10
			{
				static void invoke(function_buffer&function_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
				{
					FunctionPtr f=reinterpret_cast<FunctionPtr>(function_ptr.func_ptr);
					f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct function_obj_invoker10
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct void_function_obj_invoker10
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
				{
					FunctionObj*f;
					if(function_allows_small_object_optimization<FunctionObj>::value)f=reinterpret_cast<FunctionObj*>(&function_obj_ptr.data);
					else f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct function_ref_invoker10
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					return (*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct void_function_ref_invoker10
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
				{
					FunctionObj*f=reinterpret_cast<FunctionObj*>(function_obj_ptr.obj_ptr);
					(*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct function_mem_invoker10
			{
				static R invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					return boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct function_void_mem_invoker10
			{
				static void invoke(function_buffer&function_obj_ptr, T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
				{
					MemberPtr*f=reinterpret_cast<MemberPtr*>(&function_obj_ptr.data);
					boost::mem_fn(*f)(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			};
			template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct get_function_invoker10
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_invoker10<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>, function_invoker10<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct get_function_obj_invoker10
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_obj_invoker10<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>, function_obj_invoker10<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >::type type;
			};
			template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct get_function_ref_invoker10
			{
				typedef typename mpl::if_c<(is_void<R>::value), void_function_ref_invoker10<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>, function_ref_invoker10<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >::type type;
			};
			template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct get_member_invoker10
			{
				typedef typename mpl::if_c<(is_void<R>::value), function_void_mem_invoker10<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>, function_mem_invoker10<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >::type type;
			};
			template<typename Tag>
			struct get_invoker10
			{
			};
			template<>
			struct get_invoker10<function_ptr_tag>
			{
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
				struct apply
				{
					typedef typename get_function_invoker10<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
				template<typename FunctionPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_invoker10<FunctionPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type invoker_type;
					typedef functor_manager<FunctionPtr>manager_type;
				};
			};
			template<>
			struct get_invoker10<member_ptr_tag>
			{
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
				struct apply
				{
					typedef typename get_member_invoker10<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
				template<typename MemberPtr, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename Allocator>
				struct apply_a
				{
					typedef typename get_member_invoker10<MemberPtr, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type invoker_type;
					typedef functor_manager<MemberPtr>manager_type;
				};
			};
			template<>
			struct get_invoker10<function_obj_tag>
			{
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
				struct apply
				{
					typedef typename get_function_obj_invoker10<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type invoker_type;
					typedef functor_manager<FunctionObj>manager_type;
				};
				template<typename FunctionObj, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_obj_invoker10<FunctionObj, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type invoker_type;
					typedef functor_manager_a<FunctionObj, Allocator>manager_type;
				};
			};
			template<>
			struct get_invoker10<function_obj_ref_tag>
			{
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
				struct apply
				{
					typedef typename get_function_ref_invoker10<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
				template<typename RefWrapper, typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename Allocator>
				struct apply_a
				{
					typedef typename get_function_ref_invoker10<typename RefWrapper::type, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type invoker_type;
					typedef reference_manager<typename RefWrapper::type>manager_type;
				};
			};
			template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
			struct basic_vtable10
			{
				typedef R result_type;
				typedef result_type(*invoker_type)(function_buffer&, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9);
				template<typename F>
				bool assign_to(F f, function_buffer&functor)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to(f, functor, tag());
				}
				template<typename F, typename Allocator>
				bool assign_to_a(F f, function_buffer&functor, Allocator a)
				{
					typedef typename get_function_tag<F>::type tag;
					return assign_to_a(f, functor, a, tag());
				}
				void clear(function_buffer&functor)
				{
					if(base.manager)base.manager(functor, functor, destroy_functor_tag);
				}
			private:
				template<typename FunctionPtr>
				bool assign_to(FunctionPtr f, function_buffer&functor, function_ptr_tag)
				{
					this->clear(functor);
					if(f)
					{
						functor.func_ptr=(void(*)())(f);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionPtr, typename Allocator>
				bool assign_to_a(FunctionPtr f, function_buffer&functor, Allocator, function_ptr_tag)
				{
					return assign_to(f, functor, function_ptr_tag());
				}
				template<typename MemberPtr>
				bool assign_to(MemberPtr f, function_buffer&functor, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to(mem_fn(f), functor);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename MemberPtr, typename Allocator>
				bool assign_to_a(MemberPtr f, function_buffer&functor, Allocator a, member_ptr_tag)
				{
					if(f)
					{
						this->assign_to_a(mem_fn(f), functor, a);
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::true_)
				{
					new((void*)&functor.data)FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator, mpl::true_)
				{
					assign_functor(f, functor, mpl::true_());
				}
				template<typename FunctionObj>
				void assign_functor(FunctionObj f, function_buffer&functor, mpl::false_)
				{
					functor.obj_ptr=new FunctionObj(f);
				}
				template<typename FunctionObj, typename Allocator>
				void assign_functor_a(FunctionObj f, function_buffer&functor, Allocator a, mpl::false_)
				{
					typedef functor_wrapper<FunctionObj, Allocator>functor_wrapper_type;
					typedef typename Allocator::template rebind<functor_wrapper_type>::other wrapper_allocator_type;
					typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;
					wrapper_allocator_type wrapper_allocator(a);
					wrapper_allocator_pointer_type copy=wrapper_allocator.allocate(1);
					wrapper_allocator.construct(copy, functor_wrapper_type(f, a));
					functor_wrapper_type*new_f=static_cast<functor_wrapper_type*>(copy);
					functor.obj_ptr=new_f;
				}
				template<typename FunctionObj>
				bool assign_to(FunctionObj f, function_buffer&functor, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor(f, functor, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(FunctionObj f, function_buffer&functor, Allocator a, function_obj_tag)
				{
					if(!boost::detail::function::has_empty_target(boost::addressof(f)))
					{
						assign_functor_a(f, functor, a, mpl::bool_<(function_allows_small_object_optimization<FunctionObj>::value)>());
						return true;
					}
					else
					{
						return false;
					}
				}
				template<typename FunctionObj>
				bool assign_to(const reference_wrapper<FunctionObj>&f, function_buffer&functor, function_obj_ref_tag)
				{
					functor.obj_ref.obj_ptr=(void*)f.get_pointer();
					functor.obj_ref.is_const_qualified=is_const<FunctionObj>::value;
					functor.obj_ref.is_volatile_qualified=is_volatile<FunctionObj>::value;
					return true;
				}
				template<typename FunctionObj, typename Allocator>
				bool assign_to_a(const reference_wrapper<FunctionObj>&f, function_buffer&functor, Allocator, function_obj_ref_tag)
				{
					return assign_to(f, functor, function_obj_ref_tag());
				}
			public:
				vtable_base base;
				invoker_type invoker;
			};
		}
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	class function10: public function_base
	{
	public:
		typedef R result_type;
	private:
		typedef boost::detail::function::basic_vtable10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>vtable_type;
		vtable_type*get_vtable()const
		{
			return reinterpret_cast<vtable_type*>(reinterpret_cast<std::size_t>(vtable)&~(std::size_t)0x01);
		}
		struct clear_type
		{
		};
	public:
		static const int args=10;
		template<typename Args>
		struct sig
		{
			typedef result_type type;
		};
		static const int arity=10;
		typedef T0 arg1_type;
		typedef T1 arg2_type;
		typedef T2 arg3_type;
		typedef T3 arg4_type;
		typedef T4 arg5_type;
		typedef T5 arg6_type;
		typedef T6 arg7_type;
		typedef T7 arg8_type;
		typedef T8 arg9_type;
		typedef T9 arg10_type;
		typedef function10 self_type;
		function10(): function_base()
		{
		}
		template<typename Functor>
		function10(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to(f);
		}
		template<typename Functor, typename Allocator>
		function10(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): function_base()
		{
			this->assign_to_a(f, a);
		}
		function10(clear_type*): function_base()
		{
		}
		function10(const function10&f): function_base()
		{
			this->assign_to_own(f);
		}
		~function10()
		{
			clear();
		}
		result_type operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)const;
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), function10&>::type operator=(Functor f)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		template<typename Functor, typename Allocator>
		void assign(Functor f, Allocator a)
		{
			this->clear();

			{
				if(true)
				{
					this->assign_to_a(f, a);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
		function10&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		function10&operator=(const function10&f)
		{
			if(&f==this)return *this;
			this->clear();

			{
				if(true)
				{
					this->assign_to_own(f);
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
			return *this;
		}
		void swap(function10&other)
		{
			if(&other==this)return ;
			function10 tmp;
			tmp.move_assign(*this);
			this->move_assign(other);
			other.move_assign(tmp);
		}
		void clear()
		{
			if(vtable)
			{
				if(!this->has_trivial_copy_and_destroy())get_vtable()->clear(this->functor);
				vtable=0;
			}
		}
	private:
		struct dummy
		{
			void nonnull()
			{
			};
		};
		typedef void(dummy::*safe_bool)();
	public:
		operator safe_bool()const
		{
			return (this->empty())?0: &dummy::nonnull;
		}
		bool operator!()const
		{
			return this->empty();
		}
	private:
		void assign_to_own(const function10&f)
		{
			if(!f.empty())
			{
				this->vtable=f.vtable;
				if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
				else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::clone_functor_tag);
			}
		}
		template<typename Functor>
		void assign_to(Functor f)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker10<tag>get_invoker;
			typedef typename get_invoker::template apply<Functor, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to(f, functor))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		template<typename Functor, typename Allocator>
		void assign_to_a(Functor f, Allocator a)
		{
			using detail::function::vtable_base;
			typedef typename detail::function::get_function_tag<Functor>::type tag;
			typedef detail::function::get_invoker10<tag>get_invoker;
			typedef typename get_invoker::template apply_a<Functor, R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Allocator>handler_type;
			typedef typename handler_type::invoker_type invoker_type;
			typedef typename handler_type::manager_type manager_type;
			static vtable_type stored_vtable=
			{

				{
					&manager_type::manage
				}
				, &invoker_type::invoke
			};
			if(stored_vtable.assign_to_a(f, functor, a))
			{
				std::size_t value=reinterpret_cast<std::size_t>(&stored_vtable.base);
				if(boost::has_trivial_copy_constructor<Functor>::value&&boost::has_trivial_destructor<Functor>::value&&detail::function::function_allows_small_object_optimization<Functor>::value)value|=(std::size_t)0x01;
				vtable=reinterpret_cast<detail::function::vtable_base*>(value);
			}
			else vtable=0;
		}
		void move_assign(function10&f)
		{
			if(&f==this)return ;

			{
				if(true)
				{
					if(!f.empty())
					{
						this->vtable=f.vtable;
						if(this->has_trivial_copy_and_destroy())this->functor=f.functor;
						else get_vtable()->base.manager(f.functor, this->functor, boost::detail::function::move_functor_tag);
						f.vtable=0;
					}
					else
					{
						clear();
					}
				}
				else if(false)
				{
					vtable=0;
					;
				}
			}
		}
	};
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	inline void swap(function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>&f1, function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>&f2)
	{
		f1.swap(f2);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	typename function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::result_type inline function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::operator()(T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)const
	{
		if(this->empty())boost::throw_exception(bad_function_call());
		return get_vtable()->invoker(this->functor, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	void operator==(const function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>&, const function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	void operator!=(const function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>&, const function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>&);
	template<typename R, typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	class function<R(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>: public function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
	{
		typedef function10<R, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>base_type;
		typedef function self_type;
		struct clear_type
		{
		};
	public:
		function(): base_type()
		{
		}
		template<typename Functor>
		function(Functor f, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f)
		{
		}
		template<typename Functor, typename Allocator>
		function(Functor f, Allocator a, typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), int>::type=0): base_type(f, a)
		{
		}
		function(clear_type*): base_type()
		{
		}
		function(const self_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		function(const base_type&f): base_type(static_cast<const base_type&>(f))
		{
		}
		self_type&operator=(const self_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		template<typename Functor>
		typename enable_if_c<(boost::type_traits::ice_not<(is_integral<Functor>::value)>::value), self_type&>::type operator=(Functor f)
		{
			self_type(f).swap(*this);
			return *this;
		}
		self_type&operator=(clear_type*)
		{
			this->clear();
			return *this;
		}
		self_type&operator=(const base_type&f)
		{
			self_type(f).swap(*this);
			return *this;
		}
	};
}
namespace boost
{
	template<class UnaryFunction, class Iterator, class Reference=use_default, class Value=use_default>
	class transform_iterator;
	namespace detail
	{
		template<class UnaryFunc>
		struct function_object_result
		{
			typedef typename UnaryFunc::result_type type;
		};
		template<class Return, class Argument>
		struct function_object_result<Return(*)(Argument)>
		{
			typedef Return type;
		};
		template<class UnaryFunc, class Iterator, class Reference, class Value>
		struct transform_iterator_base
		{
		private:
			typedef typename ia_dflt_help<Reference, function_object_result<UnaryFunc> >::type reference;
			typedef typename ia_dflt_help<Value, remove_reference<reference> >::type cv_value_type;
		public:
			typedef iterator_adaptor<transform_iterator<UnaryFunc, Iterator, Reference, Value>, Iterator, cv_value_type, use_default, reference>type;
		};
	}
	template<class UnaryFunc, class Iterator, class Reference, class Value>
	class transform_iterator: public boost::detail::transform_iterator_base<UnaryFunc, Iterator, Reference, Value>::type
	{
		typedef typename boost::detail::transform_iterator_base<UnaryFunc, Iterator, Reference, Value>::type super_t;
		friend class iterator_core_access;
	public:
		transform_iterator()
		{
		}
		transform_iterator(Iterator const&x, UnaryFunc f): super_t(x), m_f(f)
		{
		}
		explicit transform_iterator(Iterator const&x): super_t(x)
		{
			typedef ::boost::static_assert_test<sizeof(::boost::STATIC_ASSERTION_FAILURE<(bool)(is_class<UnaryFunc>::value)>)>boost_static_assert_typedef___COUNTER__;
		}
		template<class OtherUnaryFunction, class OtherIterator, class OtherReference, class OtherValue>
		transform_iterator(transform_iterator<OtherUnaryFunction, OtherIterator, OtherReference, OtherValue>const&t, typename enable_if_convertible<OtherIterator, Iterator>::type* =0, typename enable_if_convertible<OtherUnaryFunction, UnaryFunc>::type* =0): super_t(t.base()), m_f(t.functor())
		{
		}
		UnaryFunc functor()const
		{
			return m_f;
		}
	private:
		typename super_t::reference dereference()const
		{
			return m_f(*this->base());
		}
		UnaryFunc m_f;
	};
	template<class UnaryFunc, class Iterator>
	transform_iterator<UnaryFunc, Iterator>make_transform_iterator(Iterator it, UnaryFunc fun)
	{
		return transform_iterator<UnaryFunc, Iterator>(it, fun);
	}
	template<class UnaryFunc, class Iterator>
	typename iterators::enable_if<is_class<UnaryFunc>, transform_iterator<UnaryFunc, Iterator> >::type make_transform_iterator(Iterator it)
	{
		return transform_iterator<UnaryFunc, Iterator>(it, UnaryFunc());
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace wave
	{
		namespace impl
		{
			template<class AdaptableUnaryFunctionT, class IteratorT>
			class ref_transform_iterator_generator
			{
				typedef typename AdaptableUnaryFunctionT::result_type return_type;
				typedef typename AdaptableUnaryFunctionT::argument_type argument_type;
			public:
				typedef boost::transform_iterator<return_type(*)(argument_type), IteratorT, return_type>type;
			};
			template<class AdaptableUnaryFunctionT, class IteratorT>
			inline typename ref_transform_iterator_generator<AdaptableUnaryFunctionT, IteratorT>::type make_ref_transform_iterator(IteratorT base, AdaptableUnaryFunctionT const&f)
			{
				typedef typename ref_transform_iterator_generator<AdaptableUnaryFunctionT, IteratorT>::type iterator_type;
				return iterator_type(base, f.transform);
			}
			template<typename TokenT, typename ParseTreeNodeT>
			struct get_token_value
			{
				typedef TokenT const&result_type;
				typedef ParseTreeNodeT const&argument_type;
				static result_type transform(argument_type node)
				{
					(void)((!!(1==std::distance(node.value.begin(), node.value.end())))||(_wassert(L"1 == std::distance(node.value.begin(), node.value.end())", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\transform_iterator.hpp", 73), 0));
					return *node.value.begin();
				}
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			struct functor_input
			{
				template<typename FunctorT>
				class inner
				{
				private:
					typedef typename FunctorT::result_type result_type;
				public:
					typedef result_type value_type;
				private:
					struct Data
					{
						Data(FunctorT const&ftor_): ftor(ftor_), was_initialized(false)
						{
						}
						FunctorT ftor;
						value_type curtok;
						bool was_initialized;
					};
					friend struct Data;
				public:
					typedef std::ptrdiff_t difference_type;
					typedef result_type*pointer;
					typedef result_type&reference;
					protected: inner(): data(0)
					{
					}
					inner(FunctorT const&x): data(new Data(x))
					{
					}
					inner(inner const&x): data(x.data)
					{
					}
					void destroy()
					{
						delete data;
						data=0;
					}
					bool same_input(inner const&x)const
					{
						return data==x.data;
					}
					void swap(inner&x)
					{
						boost::spirit::classic::impl::mp_swap(data, x.data);
					}
					void ensure_initialized()const
					{
						if(data&&!data->was_initialized)
						{
							data->curtok=(data->ftor)();
							data->was_initialized=true;
						}
					}
				public:
					reference get_input()const
					{
						ensure_initialized();
						return data->curtok;
					}
					void advance_input()
					{
						(void)((!!(0!=data))||(_wassert(L"0 != data", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\functor_input.hpp", 123), 0));
						data->curtok=(data->ftor)();
						data->was_initialized=true;
					}
					bool input_at_eof()const
					{
						ensure_initialized();
						return !data||data->curtok==data->ftor.eof;
					}
					FunctorT&get_functor()const
					{
						(void)((!!(0!=data))||(_wassert(L"0 != data", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\functor_input.hpp", 136), 0));
						return data->ftor;
					}
				private:
					mutable Data*data;
				};
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace grammars
		{
			template<typename LexIteratorT, typename TokenContainerT>
			struct cpp_grammar_gen
			{
				typedef LexIteratorT iterator_type;
				typedef typename LexIteratorT::token_type token_type;
				typedef TokenContainerT token_container_type;
				typedef typename token_type::position_type position_type;
				typedef boost::spirit::classic::node_val_data_factory<>node_factory_type;
				static boost::spirit::classic::tree_parse_info<iterator_type, node_factory_type>parse_cpp_grammar(iterator_type const&first, iterator_type const&last, position_type const&act_pos, bool&found_eof, token_type&found_directive, token_container_type&found_eoltokens);
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace grammars
		{
			enum value_error
			{
				error_noerror=0x0, error_division_by_zero=0x1, error_integer_overflow=0x2, error_character_overflow=0x4
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace grammars
		{
			template<typename TokenT>
			struct expression_grammar_gen
			{
				typedef TokenT token_type;
				typedef std::list<token_type, boost::fast_pool_allocator<token_type> >token_sequence_type;
				static bool evaluate(typename token_sequence_type::const_iterator const&first, typename token_sequence_type::const_iterator const&last, typename token_type::position_type const&tok, bool if_block_status, value_error&status);
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace grammars
		{
			template<typename LexIteratorT>
			struct predefined_macros_grammar_gen
			{
				typedef LexIteratorT iterator_type;
				static boost::spirit::classic::tree_parse_info<iterator_type>parse_predefined_macro(iterator_type const&first, iterator_type const&last);
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace context_policies
		{
			struct default_preprocessing_hooks
			{
				template<typename ContextT, typename TokenT, typename ContainerT, typename IteratorT>
				bool expanding_function_like_macro(ContextT const&ctx, TokenT const&macrodef, std::vector<TokenT>const&formal_args, ContainerT const&definition, TokenT const&macrocall, std::vector<ContainerT>const&arguments, IteratorT const&seqstart, IteratorT const&seqend)
				{
					return false;
				}
				template<typename ContextT, typename TokenT, typename ContainerT>
				bool expanding_object_like_macro(ContextT const&ctx, TokenT const&macro, ContainerT const&definition, TokenT const&macrocall)
				{
					return false;
				}
				template<typename ContextT, typename ContainerT>
				void expanded_macro(ContextT const&ctx, ContainerT const&result)
				{
				}
				template<typename ContextT, typename ContainerT>
				void rescanned_macro(ContextT const&ctx, ContainerT const&result)
				{
				}
				template<typename ContextT>
				bool found_include_directive(ContextT const&ctx, std::string const&filename, bool include_next)
				{
					return false;
				}
				template<typename ContextT>
				void opened_include_file(ContextT const&ctx, std::string const&relname, std::string const&absname, bool is_system_include)
				{
				}
				template<typename ContextT>
				void returning_from_include_file(ContextT const&ctx)
				{
				}
				template<typename ContextT>
				void detected_include_guard(ContextT const&ctx, std::string const&filename, std::string const&include_guard)
				{
				}
				template<typename ContextT, typename TokenT>
				void detected_pragma_once(ContextT const&ctx, TokenT const&pragma_token, std::string const&filename)
				{
				}
				template<typename ContextT, typename ContainerT>
				bool interpret_pragma(ContextT const&ctx, ContainerT&pending, typename ContextT::token_type const&option, ContainerT const&values, typename ContextT::token_type const&act_token)
				{
					return false;
				}
				template<typename ContextT, typename TokenT, typename ParametersT, typename DefinitionT>
				void defined_macro(ContextT const&ctx, TokenT const&macro_name, bool is_functionlike, ParametersT const&parameters, DefinitionT const&definition, bool is_predefined)
				{
				}
				template<typename ContextT, typename TokenT>
				void undefined_macro(ContextT const&ctx, TokenT const&macro_name)
				{
				}
				template<typename ContextT, typename TokenT>
				bool found_directive(ContextT const&ctx, TokenT const&directive)
				{
					return false;
				}
				template<typename ContextT, typename TokenT, typename ContainerT>
				bool evaluated_conditional_expression(ContextT const&ctx, TokenT const&directive, ContainerT const&expression, bool expression_value)
				{
					return false;
				}
				template<typename ContextT, typename TokenT>
				void skipped_token(ContextT const&ctx, TokenT const&token)
				{
				}
				template<typename ContextT, typename TokenT>
				TokenT const&generated_token(ContextT const&ctx, TokenT const&t)
				{
					return t;
				}
				template<typename ContextT, typename TokenT>
				bool may_skip_whitespace(ContextT const&ctx, TokenT&token, bool&skipped_newline)
				{
					return false;
				}
				template<typename ContextT, typename ContainerT>
				bool found_warning_directive(ContextT const&ctx, ContainerT const&message)
				{
					return false;
				}
				template<typename ContextT, typename ContainerT>
				bool found_error_directive(ContextT const&ctx, ContainerT const&message)
				{
					return false;
				}
				template<typename ContextT, typename ContainerT>
				void found_line_directive(ContextT const&ctx, ContainerT const&arguments, unsigned int line, std::string const&filename)
				{
				}
				template<typename ContextT, typename ExceptionT>
				void throw_exception(ContextT const&ctx, ExceptionT const&e)
				{
					boost::throw_exception(e);
				}
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace context_policies
		{
			namespace util
			{
				template<typename TokenT>
				bool ccomment_has_newline(TokenT const&token)
				{
					using namespace boost::wave;
					if(T_CCOMMENT==token_id(token)&&TokenT::string_type::npos!=token.get_value().find_first_of("\n"))
					{
						return true;
					}
					return false;
				}
				template<typename TokenT>
				int ccomment_count_newlines(TokenT const&token)
				{
					using namespace boost::wave;
					int newlines=0;
					if(T_CCOMMENT==token_id(token))
					{
						typename TokenT::string_type const&value=token.get_value();
						typename TokenT::string_type::size_type p=value.find_first_of("\n");
						while(TokenT::string_type::npos!=p)
						{
							++newlines;
							p=value.find_first_of("\n", p+1);
						}
					}
					return newlines;
				}
			}
			template<typename TokenT>
			class eat_whitespace: public default_preprocessing_hooks
			{
			public:
				eat_whitespace();
				template<typename ContextT>
				bool may_skip_whitespace(ContextT const&ctx, TokenT&token, bool&skipped_newline);
				protected: bool skip_cppcomment(boost::wave::token_id id)
				{
					return !preserve_comments&&T_CPPCOMMENT==id;
				}
			private:
				typedef bool state_t(TokenT&token, bool&skipped_newline);
				state_t eat_whitespace::*state;
				state_t general, newline, newline_2nd, whitespace;
				bool preserve_comments;
			};
			template<typename TokenT>
			inline eat_whitespace<TokenT>::eat_whitespace(): state(&eat_whitespace::newline), preserve_comments(false)
			{
			}
			template<typename TokenT>
			template<typename ContextT>
			inline bool eat_whitespace<TokenT>::may_skip_whitespace(ContextT const&ctx, TokenT&token, bool&skipped_newline)
			{
				preserve_comments=boost::wave::need_preserve_comments(ctx.get_language());
				return (this->*state)(token, skipped_newline);
			}
			template<typename TokenT>
			inline bool eat_whitespace<TokenT>::general(TokenT&token, bool&skipped_newline)
			{
				using namespace boost::wave;
				token_id id=token_id(token);
				if(T_NEWLINE==id||T_CPPCOMMENT==id)
				{
					state=&eat_whitespace::newline;
				}
				else if(T_SPACE==id||T_SPACE2==id||T_CCOMMENT==id)
				{
					state=&eat_whitespace::whitespace;
					if(util::ccomment_has_newline(token))skipped_newline=true;
					if((!preserve_comments||T_CCOMMENT!=id)&&token.get_value().size()>1)
					{
						token.set_value(" ");
					}
				}
				else
				{
					state=&eat_whitespace::general;
				}
				return false;
			}
			template<typename TokenT>
			inline bool eat_whitespace<TokenT>::newline(TokenT&token, bool&skipped_newline)
			{
				using namespace boost::wave;
				token_id id=token_id(token);
				if(T_NEWLINE==id||T_CPPCOMMENT==id)
				{
					skipped_newline=true;
					state=&eat_whitespace::newline_2nd;
					return T_NEWLINE==id||skip_cppcomment(id);
				}
				else if(T_SPACE!=id&&T_SPACE2!=id&&T_CCOMMENT!=id)
				{
					return general(token, skipped_newline);
				}
				if(T_CCOMMENT==id)
				{
					if(util::ccomment_has_newline(token))
					{
						skipped_newline=true;
						state=&eat_whitespace::newline_2nd;
					}
					if(preserve_comments)
					{
						state=&eat_whitespace::general;
						return false;
					}
				}
				return true;
			}
			template<typename TokenT>
			inline bool eat_whitespace<TokenT>::newline_2nd(TokenT&token, bool&skipped_newline)
			{
				using namespace boost::wave;
				token_id id=token_id(token);
				if(T_SPACE==id||T_SPACE2==id)return true;
				if(T_CCOMMENT==id)
				{
					if(util::ccomment_has_newline(token))skipped_newline=true;
					if(preserve_comments)
					{
						state=&eat_whitespace::general;
						return false;
					}
					return true;
				}
				if(T_NEWLINE!=id&&T_CPPCOMMENT!=id)return general(token, skipped_newline);
				skipped_newline=true;
				return T_NEWLINE==id||skip_cppcomment(id);
			}
			template<typename TokenT>
			inline bool eat_whitespace<TokenT>::whitespace(TokenT&token, bool&skipped_newline)
			{
				using namespace boost::wave;
				token_id id=token_id(token);
				if(T_SPACE!=id&&T_SPACE2!=id&&T_CCOMMENT!=id&&T_CPPCOMMENT!=id)
				{
					return general(token, skipped_newline);
				}
				if(T_CCOMMENT==id)
				{
					if(util::ccomment_has_newline(token))skipped_newline=true;
					return !preserve_comments;
				}
				return T_SPACE==id||T_SPACE2==id||skip_cppcomment(id);
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			template<typename ContextT, typename ParseNodeT, typename TokenT, typename PositionT>
			inline bool retrieve_macroname(ContextT&ctx, ParseNodeT const&node, boost::spirit::classic::parser_id id, TokenT&macroname, PositionT&act_pos, bool update_position)
			{
				ParseNodeT const*name_node=0;
				using boost::spirit::classic::find_node;
				if(!find_node(node, id, &name_node))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_define_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_define_statement);
						if(("bad parse tree (unexpected)")[0]!=0)stream<<": "<<("bad parse tree (unexpected)");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_define_statement, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return false;
				}
				typename ParseNodeT::children_t const&children=name_node->children;
				if(0==children.size()||children.front().value.begin()==children.front().value.end())
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_define_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_define_statement);
						if(("bad parse tree (unexpected)")[0]!=0)stream<<": "<<("bad parse tree (unexpected)");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_define_statement, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return false;
				}
				macroname=*children.front().value.begin();
				if(update_position)
				{
					macroname.set_position(act_pos);
					act_pos.set_column(act_pos.get_column()+macroname.get_value().size());
				}
				return true;
			}
			template<typename ParseNodeT, typename ContainerT, typename PositionT>
			inline bool retrieve_macrodefinition(ParseNodeT const&node, boost::spirit::classic::parser_id id, ContainerT&macrodefinition, PositionT&act_pos, bool update_position)
			{
				using namespace boost::wave;
				typedef typename ParseNodeT::const_tree_iterator const_tree_iterator;
				std::pair<const_tree_iterator, const_tree_iterator>nodes;
				using boost::spirit::classic::get_node_range;
				if(get_node_range(node, id, nodes))
				{
					typename ContainerT::iterator last_nonwhite=macrodefinition.end();
					const_tree_iterator end=nodes.second;
					for(const_tree_iterator cit=nodes.first;
					cit!=end;
					++cit)
					{
						if((*cit).value.begin()!=(*cit).value.end())
						{
							typename ContainerT::iterator inserted=macrodefinition.insert(macrodefinition.end(), *(*cit).value.begin());
							if(!((((macrodefinition.back())&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&T_NEWLINE!=token_id(macrodefinition.back())&&T_EOF!=token_id(macrodefinition.back()))
							{
								last_nonwhite=inserted;
							}
							if(update_position)
							{
								(*inserted).set_position(act_pos);
								act_pos.set_column(act_pos.get_column()+(*inserted).get_value().size());
							}
						}
					}
					if(last_nonwhite!=macrodefinition.end())
					{
						if(update_position)
						{
							act_pos.set_column((*last_nonwhite).get_position().get_column()+(*last_nonwhite).get_value().size());
						}
						macrodefinition.erase(++last_nonwhite, macrodefinition.end());
					}
					return true;
				}
				return false;
			}
			template<typename ContextT>
			bool add_macro_definition(ContextT&ctx, std::string macrostring, bool is_predefined, boost::wave::language_support language)
			{
				typedef typename ContextT::token_type token_type;
				typedef typename ContextT::lexer_type lexer_type;
				typedef typename token_type::position_type position_type;
				typedef boost::wave::grammars::predefined_macros_grammar_gen<lexer_type>predef_macros_type;
				using namespace boost::wave;
				using namespace std;
				std::string::iterator begin=macrostring.begin();
				std::string::iterator end=macrostring.end();
				while(begin!=end&&isspace(*begin))++begin;
				position_type act_pos("<command line>");
				boost::spirit::classic::tree_parse_info<lexer_type>hit=predef_macros_type::parse_predefined_macro(lexer_type(begin, end, position_type(), language), lexer_type());
				if(!hit.match||(!hit.full&&T_EOF!=token_id(*hit.stop)))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_macro_definition)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_macro_definition);
						if((macrostring.c_str())[0]!=0)stream<<": "<<(macrostring.c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_macro_definition, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return false;
				}
				token_type macroname;
				std::vector<token_type>macroparameters;
				typename ContextT::token_sequence_type macrodefinition;
				bool has_parameters=false;
				if(!boost::wave::util::retrieve_macroname(ctx, *hit.trees.begin(), 5, macroname, act_pos, true))return false;
				has_parameters=boost::wave::util::retrieve_macrodefinition(*hit.trees.begin(), 6, macroparameters, act_pos, true);
				boost::wave::util::retrieve_macrodefinition(*hit.trees.begin(), 7, macrodefinition, act_pos, true);
				if(0==macrodefinition.size()&&'='!=macrostring[macrostring.size()-1])
				{
					macrodefinition.push_back(token_type(T_INTLIT, "1", act_pos));
				}
				return ctx.add_macro_definition(macroname, has_parameters, macroparameters, macrodefinition, is_predefined);
			}
		}
		template<typename ContextT>
		class pp_iterator;
		namespace impl
		{
			template<typename ContextT>
			class pp_iterator_functor
			{
			public:
				typedef typename ContextT::token_type result_type;
				static result_type const eof;
			private:
				typedef typename ContextT::token_sequence_type token_sequence_type;
				typedef typename ContextT::lexer_type lexer_type;
				typedef typename result_type::string_type string_type;
				typedef typename result_type::position_type position_type;
				typedef boost::wave::grammars::cpp_grammar_gen<lexer_type, token_sequence_type>cpp_grammar_type;
				typedef base_iteration_context<ContextT, lexer_type>base_iteration_context_type;
				typedef iteration_context<ContextT, lexer_type>iteration_context_type;
				typedef typename cpp_grammar_type::node_factory_type node_factory_type;
				typedef boost::spirit::classic::tree_parse_info<lexer_type, node_factory_type>tree_parse_info_type;
				typedef boost::spirit::classic::tree_match<lexer_type, node_factory_type>parse_tree_match_type;
				typedef typename parse_tree_match_type::node_t parse_node_type;
				typedef typename parse_tree_match_type::parse_node_t parse_node_value_type;
				typedef typename parse_tree_match_type::container_t parse_tree_type;
			public:
				template<typename IteratorT>
				pp_iterator_functor(ContextT&ctx_, IteratorT const&first_, IteratorT const&last_, typename ContextT::position_type const&pos_): ctx(ctx_), iter_ctx(new base_iteration_context_type(ctx, lexer_type(first_, last_, pos_, boost::wave::enable_prefer_pp_numbers(ctx.get_language())), lexer_type(), pos_.get_file().c_str())), seen_newline(true), must_emit_line_directive(false), act_pos(ctx_.get_main_pos()), whitespace(boost::wave::need_insert_whitespace(ctx.get_language()))
				{
					act_pos.set_file(pos_.get_file());
					ctx_.set_current_filename(pos_.get_file().c_str());
				}
				result_type const&operator()();
				result_type const&current_token()const
				{
					return act_token;
				}
				protected: friend class pp_iterator<ContextT>;
				bool on_include_helper(char const*t, char const*s, bool is_system, bool include_next);
				protected: result_type const&get_next_token();
				result_type const&pp_token();
				template<typename IteratorT>
				bool extract_identifier(IteratorT&it);
				template<typename IteratorT>
				bool ensure_is_last_on_line(IteratorT&it);
				template<typename IteratorT>
				bool skip_to_eol_with_check(IteratorT&it);
				bool pp_directive();
				template<typename IteratorT>
				bool handle_pp_directive(IteratorT&it);
				bool dispatch_directive(tree_parse_info_type const&hit, result_type const&found_directive, token_sequence_type const&found_eoltokens);
				void replace_undefined_identifiers(token_sequence_type&expanded);
				void on_include(string_type const&s, bool is_system, bool include_next);
				void on_include(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end, bool include_next);
				void on_define(parse_node_type const&node);
				void on_undefine(lexer_type const&it);
				void on_ifdef(result_type const&found_directive, lexer_type const&it);
				void on_ifndef(result_type const&found_directive, lexer_type const&it);
				void on_else();
				void on_endif();
				void on_illformed(typename result_type::string_type s);
				void on_line(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end);
				void on_if(result_type const&found_directive, typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end);
				void on_elif(result_type const&found_directive, typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end, token_sequence_type const&found_eoltokens);
				void on_error(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end);
				void on_warning(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end);
				bool on_pragma(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end);
				bool emit_line_directive();
				bool returned_from_include();
				bool interpret_pragma(token_sequence_type const&pragma_body, token_sequence_type&result);
			private:
				ContextT&ctx;
				boost::shared_ptr<base_iteration_context_type>iter_ctx;
				bool seen_newline;
				bool skipped_newline;
				bool must_emit_line_directive;
				result_type act_token;
				typename result_type::position_type&act_pos;
				token_sequence_type unput_queue;
				token_sequence_type pending_queue;
				boost::wave::util::insert_whitespace_detection whitespace;
			};
			template<typename ContextT>
			typename pp_iterator_functor<ContextT>::result_type const pp_iterator_functor<ContextT>::eof;
			template<typename ContextT>
			inline bool pp_iterator_functor<ContextT>::returned_from_include()
			{
				if(iter_ctx->first==iter_ctx->last&&ctx.get_iteration_depth()>0)
				{
					ctx.get_hooks().returning_from_include_file(ctx.derived());
					boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >oldfile=iter_ctx->real_filename;
					position_type old_pos(act_pos);
					if(need_include_guard_detection(ctx.get_language()))
					{
						std::string guard_name;
						if(iter_ctx->first.has_include_guards(guard_name))ctx.add_pragma_once_header(ctx.get_current_filename(), guard_name);
					}
					iter_ctx=ctx.pop_iteration_context();
					must_emit_line_directive=true;
					seen_newline=true;
					act_pos.set_file(iter_ctx->filename);
					act_pos.set_line(iter_ctx->line);
					act_pos.set_column(0);
					namespace fs=boost::filesystem;
					fs::path rfp(wave::util::create_path(iter_ctx->real_filename.c_str()));
					std::string real_filename(rfp.string());
					ctx.set_current_filename(real_filename.c_str());
					ctx.set_current_directory(iter_ctx->real_filename.c_str());
					if(iter_ctx->if_block_depth!=ctx.get_if_block_depth())
					{
						using boost::wave::util::impl::escape_lit;

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::unbalanced_if_endif)<<": "<<preprocess_exception::error_text(preprocess_exception::unbalanced_if_endif);
							if((escape_lit(oldfile).c_str())[0]!=0)stream<<": "<<(escape_lit(oldfile).c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::unbalanced_if_endif, (old_pos).get_line(), (old_pos).get_column(), (old_pos).get_file().c_str()));
						};
					}
					return true;
				}
				return false;
			}
			namespace impl
			{
				template<typename ContextT>
				bool consider_emitting_line_directive(ContextT const&ctx, token_id id)
				{
					if(need_preserve_comments(ctx.get_language()))
					{
						if(!((((id)&boost::wave::TokenTypeMask)==(EOLTokenType))?true: false)&&!((((id)&boost::wave::TokenTypeMask)==(EOFTokenType))?true: false))
						{
							return true;
						}
					}
					if(!((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&!((((id)&boost::wave::TokenTypeMask)==(EOLTokenType))?true: false)&&!((((id)&boost::wave::TokenTypeMask)==(EOFTokenType))?true: false))
					{
						return true;
					}
					return false;
				}
			}
			template<typename ContextT>
			inline typename pp_iterator_functor<ContextT>::result_type const&pp_iterator_functor<ContextT>::operator()()
			{
				using namespace boost::wave;
				ctx.init_context();
				bool was_seen_newline=seen_newline;
				token_id id=T_UNKNOWN;
				try
				{
					do
					{
						if(skipped_newline)seen_newline=true;
						get_next_token();
						id=token_id(act_token);
						if(!need_preserve_comments(ctx.get_language())&&(T_CPPCOMMENT==id||context_policies::util::ccomment_has_newline(act_token)))
						{
							act_token.set_token_id(id=T_NEWLINE);
							act_token.set_value("\n");
						}
					}
					while(ctx.get_hooks().may_skip_whitespace(ctx.derived(), act_token, skipped_newline));
				}
				catch(boost::wave::cpplexer::lexing_exception const&e)
				{
					ctx.get_hooks().throw_exception(ctx.derived(), e);
					return act_token;
				}
				if((must_emit_line_directive||(was_seen_newline&&skipped_newline))&&impl::consider_emitting_line_directive(ctx, id))
				{
					if(need_emit_line_directives(ctx.get_language())&&emit_line_directive())
					{
						skipped_newline=false;
						ctx.get_hooks().may_skip_whitespace(ctx.derived(), act_token, skipped_newline);
						id=token_id(act_token);
					}
				}
				seen_newline=false;
				switch(static_cast<unsigned int>(id))
				{
					case T_NONREPLACABLE_IDENTIFIER: act_token.set_token_id(id=T_IDENTIFIER);
					break;
					case T_GENERATEDNEWLINE: act_token.set_token_id(id=T_NEWLINE);
					++iter_ctx->emitted_lines;
					seen_newline=true;
					break;
					case T_NEWLINE: case T_CPPCOMMENT: seen_newline=true;
					++iter_ctx->emitted_lines;
					break;
					case T_CCOMMENT: iter_ctx->emitted_lines+=context_policies::util::ccomment_count_newlines(act_token);
					break;
					case T_PP_NUMBER:
					{
						token_sequence_type rescanned;
						std::string pp_number(util::to_string<std::string>(act_token.get_value()));
						lexer_type it=lexer_type(pp_number.begin(), pp_number.end(), act_token.get_position(), ctx.get_language());
						lexer_type end=lexer_type();
						for(;
						it!=end&&T_EOF!=token_id(*it);
						++it)rescanned.push_back(*it);
						pending_queue.splice(pending_queue.begin(), rescanned);
						act_token=pending_queue.front();
						id=token_id(act_token);
						pending_queue.pop_front();
					}
					break;
					case T_EOF: seen_newline=true;
					break;
					default: if(((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))seen_newline=was_seen_newline;
					break;
				}
				if(whitespace.must_insert(id, act_token.get_value()))
				{
					whitespace.shift_tokens(T_SPACE);
					pending_queue.push_front(act_token);
					return act_token=result_type(T_SPACE, typename result_type::string_type(" "), act_token.get_position());
				}
				whitespace.shift_tokens(id);
				return ctx.get_hooks().generated_token(ctx.derived(), act_token);
			}
			template<typename ContextT>
			inline typename pp_iterator_functor<ContextT>::result_type const&pp_iterator_functor<ContextT>::get_next_token()
			{
				using namespace boost::wave;
				if(!pending_queue.empty()||!unput_queue.empty())return pp_token();
				bool returned_from_include_file=returned_from_include();
				if(iter_ctx->first!=iter_ctx->last)
				{
					do
					{
						if(!pending_queue.empty())
						{
							util::on_exit::pop_front<token_sequence_type>pop_front_token(pending_queue);
							return act_token=pending_queue.front();
						}
						bool was_seen_newline=seen_newline||returned_from_include_file;
						act_token=*iter_ctx->first;
						act_pos=act_token.get_position();
						token_id id=token_id(act_token);
						if(T_EOF==id)
						{
							whitespace.shift_tokens(T_EOF);
							++iter_ctx->first;
							if((!seen_newline||act_pos.get_column()>1)&&!need_single_line(ctx.get_language()))
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::last_line_not_terminated)<<": "<<preprocess_exception::error_text(preprocess_exception::last_line_not_terminated);
									if(("")[0]!=0)stream<<": "<<("");
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::last_line_not_terminated, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
								};
							}
							continue;
						}
						else if(T_NEWLINE==id||T_CPPCOMMENT==id)
						{
							seen_newline=true;
							++iter_ctx->first;
							if(!ctx.get_if_block_status())
							{
								whitespace.shift_tokens(id);
								ctx.get_hooks().skipped_token(ctx.derived(), act_token);
								continue;
							}
							return act_token;
						}
						seen_newline=false;
						if(was_seen_newline&&pp_directive())
						{
						}
						else if(ctx.get_if_block_status())
						{
							return pp_token();
						}
						else
						{
							if(T_NEWLINE==token_id(act_token))
							{
								seen_newline=true;
								must_emit_line_directive=true;
							}
							ctx.get_hooks().skipped_token(ctx.derived(), act_token);
							++iter_ctx->first;
						}
					}
					while((iter_ctx->first!=iter_ctx->last)||(returned_from_include_file=returned_from_include()));
					if(ctx.get_if_block_depth()>0&&!need_single_line(ctx.get_language()))
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::missing_matching_endif)<<": "<<preprocess_exception::error_text(preprocess_exception::missing_matching_endif);
							if(("")[0]!=0)stream<<": "<<("");
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::missing_matching_endif, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
				}
				else
				{
					act_token=eof;
				}
				return act_token;
			}
			template<typename ContextT>
			inline bool pp_iterator_functor<ContextT>::emit_line_directive()
			{
				using namespace boost::wave;
				typename ContextT::position_type pos=act_token.get_position();
				if(must_emit_line_directive||iter_ctx->emitted_lines!=act_pos.get_line())
				{
					pending_queue.push_front(act_token);
					pos.set_line(act_pos.get_line());
					if(!must_emit_line_directive&&iter_ctx->emitted_lines+1==act_pos.get_line())
					{
						act_token=result_type(T_NEWLINE, "\n", pos);
					}
					else
					{
						act_pos.set_line(act_pos.get_line()-1);
						iter_ctx->emitted_lines=act_pos.get_line();
						std::string file("\"");
						boost::filesystem::path filename(wave::util::create_path(act_pos.get_file().c_str()));
						using wave::util::impl::escape_lit;
						file+=escape_lit(wave::util::native_file_string(filename))+"\"";
						char buffer[22];
						using namespace std;
						sprintf(buffer, "%d", pos.get_line());
						unsigned int filenamelen=(unsigned int)file.size();
						unsigned int column=7+(unsigned int)strlen(buffer)+filenamelen;
						pos.set_line(pos.get_line()-1);
						pos.set_column(column);
						pending_queue.push_front(result_type(T_GENERATEDNEWLINE, "\n", pos));
						pos.set_column(column-=filenamelen);
						pending_queue.push_front(result_type(T_STRINGLIT, file.c_str(), pos));
						pos.set_column(--column);
						pending_queue.push_front(result_type(T_SPACE, " ", pos));
						pos.set_column(column-=(unsigned int)strlen(buffer));
						pending_queue.push_front(result_type(T_INTLIT, buffer, pos));
						pos.set_column(--column);
						pending_queue.push_front(result_type(T_SPACE, " ", pos));
						pos.set_column(1);
						act_token=result_type(T_PP_LINE, "#line", pos);
					}
					must_emit_line_directive=false;
					return true;
				}
				must_emit_line_directive=false;
				return false;
			}
			template<typename ContextT>
			inline typename pp_iterator_functor<ContextT>::result_type const&pp_iterator_functor<ContextT>::pp_token()
			{
				using namespace boost::wave;
				token_id id=token_id(*iter_ctx->first);
				do
				{
					if(!pending_queue.empty())
					{
						act_token=pending_queue.front();
						pending_queue.pop_front();
						act_pos=act_token.get_position();
					}
					else if(!unput_queue.empty()||T_IDENTIFIER==id||((((id)&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false)||((((id)&boost::wave::ExtTokenTypeMask)==(OperatorTokenType|AltExtTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(BoolLiteralTokenType))?true: false))
					{
						act_token=ctx.expand_tokensequence(iter_ctx->first, iter_ctx->last, pending_queue, unput_queue, skipped_newline);
					}
					else
					{
						act_token=*iter_ctx->first;
						++iter_ctx->first;
					}
					id=token_id(act_token);
				}
				while(T_PLACEHOLDER==id);
				return act_token;
			}
			namespace impl
			{
				template<typename ContextT, typename IteratorT>
				bool next_token_is_pp_directive(ContextT&ctx, IteratorT&it, IteratorT const&end)
				{
					using namespace boost::wave;
					token_id id=T_UNKNOWN;
					for(;
					it!=end;
					++it)
					{
						id=token_id(*it);
						if(!((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))break;
						if(((((id)&boost::wave::TokenTypeMask)==(EOLTokenType))?true: false))break;
						ctx.get_hooks().skipped_token(ctx.derived(), *it);
					}
					(void)((!!(it==end||id!=T_UNKNOWN))||(_wassert(L"it == end || id != T_UNKNOWN", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 878), 0));
					return it!=end&&((((id)&boost::wave::TokenTypeMask)==(PPTokenType))?true: false);
				}
				template<typename ContextT>
				bool call_found_directive_hook(ContextT&ctx, typename ContextT::token_type const&found_directive)
				{
					if(ctx.get_hooks().found_directive(ctx.derived(), found_directive))return true;
					return false;
				}
				template<typename ContextT>
				void call_skipped_token_hook(ContextT&ctx, typename ContextT::token_type const&skipped)
				{
					ctx.get_hooks().skipped_token(ctx.derived(), skipped);
				}
				template<typename ContextT, typename IteratorT>
				bool pp_is_last_on_line(ContextT&ctx, IteratorT&it, IteratorT const&end, bool call_hook=true)
				{
					using namespace boost::wave;
					if(call_hook)call_skipped_token_hook(ctx, *it);
					for(++it;
					it!=end;
					++it)
					{
						token_id id=token_id(*it);
						if(T_CPPCOMMENT==id||T_NEWLINE==id||context_policies::util::ccomment_has_newline(*it))
						{
							if(call_hook)call_skipped_token_hook(ctx, *it);
							++it;
							return true;
						}
						if(!((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))break;
						if(call_hook)call_skipped_token_hook(ctx, *it);
					}
					return false;
				}
				template<typename ContextT, typename IteratorT>
				bool skip_to_eol(ContextT&ctx, IteratorT&it, IteratorT const&end)
				{
					using namespace boost::wave;
					for(;
					it!=end;
					++it)
					{
						token_id id=token_id(*it);
						call_skipped_token_hook(ctx, *it);
						if(T_CPPCOMMENT==id||T_NEWLINE==id||context_policies::util::ccomment_has_newline(*it))
						{
							++it;
							return true;
						}
					}
					return false;
				}
			}
			template<typename ContextT>
			template<typename IteratorT>
			inline bool pp_iterator_functor<ContextT>::extract_identifier(IteratorT&it)
			{
				token_id id=util::impl::skip_whitespace(it, iter_ctx->last);
				if(T_IDENTIFIER==id||((((id)&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false)||((((id)&boost::wave::ExtTokenTypeMask)==(OperatorTokenType|AltExtTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(BoolLiteralTokenType))?true: false))
				{
					IteratorT save=it;
					if(impl::pp_is_last_on_line(ctx, save, iter_ctx->last, false))return true;
				}
				impl::skip_to_eol(ctx, it, iter_ctx->last);
				string_type str(util::impl::as_string<string_type>(iter_ctx->first, it));
				seen_newline=true;
				iter_ctx->first=it;
				on_illformed(str);
				return false;
			}
			template<typename ContextT>
			template<typename IteratorT>
			inline bool pp_iterator_functor<ContextT>::ensure_is_last_on_line(IteratorT&it)
			{
				if(!impl::pp_is_last_on_line(ctx, it, iter_ctx->last, false))
				{
					impl::skip_to_eol(ctx, it, iter_ctx->last);
					string_type str(util::impl::as_string<string_type>(iter_ctx->first, it));
					seen_newline=true;
					iter_ctx->first=it;
					on_illformed(str);
					return false;
				}
				if(it==iter_ctx->last&&!need_single_line(ctx.get_language()))
				{
					seen_newline=true;
					iter_ctx->first=it;

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::last_line_not_terminated)<<": "<<preprocess_exception::error_text(preprocess_exception::last_line_not_terminated);
						if(("")[0]!=0)stream<<": "<<("");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::last_line_not_terminated, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return false;
				}
				return true;
			}
			template<typename ContextT>
			template<typename IteratorT>
			inline bool pp_iterator_functor<ContextT>::skip_to_eol_with_check(IteratorT&it)
			{
				typename ContextT::string_type value((*it).get_value());
				if(!impl::skip_to_eol(ctx, it, iter_ctx->last)&&!need_single_line(ctx.get_language()))
				{
					seen_newline=true;
					iter_ctx->first=it;

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::last_line_not_terminated)<<": "<<preprocess_exception::error_text(preprocess_exception::last_line_not_terminated);
						if(("")[0]!=0)stream<<": "<<("");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::last_line_not_terminated, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return false;
				}
				seen_newline=true;
				iter_ctx->first=it;
				return true;
			}
			template<typename ContextT>
			template<typename IteratorT>
			inline bool pp_iterator_functor<ContextT>::handle_pp_directive(IteratorT&it)
			{
				token_id id=token_id(*it);
				bool can_exit=true;
				if(!ctx.get_if_block_status())
				{
					if(((((*it)&boost::wave::ExtTokenTypeMask)==(PPConditionalTokenType))?true: false))
					{
						switch(static_cast<unsigned int>(id))
						{
							case T_PP_IFDEF: case T_PP_IFNDEF: case T_PP_IF: ctx.enter_if_block(false);
							break;
							case T_PP_ELIF: if(!ctx.get_enclosing_if_block_status())
							{
								if(!ctx.enter_elif_block(false))
								{

									{
										using namespace boost::wave;
										std::stringstream stream;
										stream<<preprocess_exception::severity_text(preprocess_exception::missing_matching_if)<<": "<<preprocess_exception::error_text(preprocess_exception::missing_matching_if);
										if(("#elif")[0]!=0)stream<<": "<<("#elif");
										stream<<std::ends;
										ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::missing_matching_if, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
									};
									return true;
								}
							}
							else
							{
								can_exit=false;
							}
							break;
							case T_PP_ELSE: case T_PP_ENDIF:
							{
								if(T_PP_ELSE==token_id(*it))on_else();
								else on_endif();
								ensure_is_last_on_line(it);
								seen_newline=true;
								iter_ctx->first=it;
							}
							return true;
							default: on_illformed((*it).get_value());
							break;
						}
					}
				}
				else
				{
					result_type directive=*it;
					bool include_next=false;
					switch(static_cast<unsigned int>(id))
					{
						case T_PP_QHEADER: case T_PP_QHEADER_NEXT: include_next=(T_PP_QHEADER_NEXT==id)?true: false;
						if(!impl::call_found_directive_hook(ctx, *it))
						{
							string_type dir((*it).get_value());
							if(ensure_is_last_on_line(it))
							{
								seen_newline=true;
								iter_ctx->first=it;
								on_include(dir, false, include_next);
							}
							return true;
						}
						break;
						case T_PP_HHEADER: case T_PP_HHEADER_NEXT: include_next=(T_PP_HHEADER_NEXT==id)?true: false;
						if(!impl::call_found_directive_hook(ctx, *it))
						{
							string_type dir((*it).get_value());
							if(ensure_is_last_on_line(it))
							{
								seen_newline=true;
								iter_ctx->first=it;
								on_include(dir, true, include_next);
							}
							return true;
						}
						break;
						case T_PP_ELSE: case T_PP_ENDIF: if(!impl::call_found_directive_hook(ctx, *it))
						{
							if(T_PP_ELSE==token_id(*it))on_else();
							else on_endif();
							ensure_is_last_on_line(it);
							seen_newline=true;
							iter_ctx->first=it;
							return true;
						}
						break;
						case T_PP_UNDEF: if(!impl::call_found_directive_hook(ctx, *it)&&extract_identifier(it))
						{
							on_undefine(it);
						}
						break;
						case T_PP_IFDEF: if(!impl::call_found_directive_hook(ctx, *it)&&extract_identifier(it))
						{
							on_ifdef(directive, it);
						}
						break;
						case T_PP_IFNDEF: if(!impl::call_found_directive_hook(ctx, *it)&&extract_identifier(it))
						{
							on_ifndef(directive, it);
						}
						break;
						default: can_exit=false;
						break;
					}
				}
				if(can_exit)
				{
					skip_to_eol_with_check(it);
					return true;
				}
				return false;
			}
			template<typename ContextT>
			inline bool pp_iterator_functor<ContextT>::pp_directive()
			{
				using namespace cpplexer;
				lexer_type it=iter_ctx->first;
				if(!impl::next_token_is_pp_directive(ctx, it, iter_ctx->last))
				{
					if(it!=iter_ctx->last&&T_POUND==boost::wave::token_id((token_id(*it))&boost::wave::MainTokenMask))
					{
						if(impl::pp_is_last_on_line(ctx, it, iter_ctx->last))
						{
							seen_newline=true;
							iter_ctx->first=it;
							return true;
						}
						else if(ctx.get_if_block_status())
						{
							on_illformed((*it).get_value());
						}
					}
					return false;
				}
				if(it==iter_ctx->last)return false;
				if(handle_pp_directive(it))
				{
					return true;
				}
				bool found_eof=false;
				result_type found_directive;
				token_sequence_type found_eoltokens;
				tree_parse_info_type hit=cpp_grammar_type::parse_cpp_grammar(it, iter_ctx->last, act_pos, found_eof, found_directive, found_eoltokens);
				if(hit.match)
				{
					iter_ctx->first=hit.stop;
					seen_newline=true;
					must_emit_line_directive=true;
					bool result=dispatch_directive(hit, found_directive, found_eoltokens);
					if(found_eof&&!need_single_line(ctx.get_language()))
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::last_line_not_terminated)<<": "<<preprocess_exception::error_text(preprocess_exception::last_line_not_terminated);
							if(("")[0]!=0)stream<<": "<<("");
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::last_line_not_terminated, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
					return result;
				}
				else if(token_id(found_directive)!=T_EOF)
				{
					impl::skip_to_eol(ctx, it, iter_ctx->last);
					seen_newline=true;
					string_type str(boost::wave::util::impl::as_string<string_type>(iter_ctx->first, it));
					iter_ctx->first=it;
					on_illformed(str);
				}
				return false;
			}
			template<typename ContextT>
			inline bool pp_iterator_functor<ContextT>::dispatch_directive(tree_parse_info_type const&hit, result_type const&found_directive, token_sequence_type const&found_eoltokens)
			{
				using namespace cpplexer;
				typedef typename parse_tree_type::const_iterator const_child_iterator_t;
				const_child_iterator_t begin=hit.trees.begin();
				parse_tree_type const&root=(*begin).children;
				parse_node_value_type const&nodeval=get_first_leaf(*root.begin()).value;
				const_child_iterator_t begin_child_it=(*root.begin()).children.begin();
				const_child_iterator_t end_child_it=(*root.begin()).children.end();
				token_id id=token_id(found_directive);
				if(impl::call_found_directive_hook(ctx, found_directive))return true;
				switch(static_cast<unsigned int>(id))
				{
					case T_PP_INCLUDE: case T_PP_INCLUDE_NEXT: on_include(begin_child_it, end_child_it, T_PP_INCLUDE_NEXT==id);
					break;
					case T_PP_DEFINE: on_define(*begin);
					break;
					case T_PP_IF: on_if(found_directive, begin_child_it, end_child_it);
					break;
					case T_PP_ELIF: on_elif(found_directive, begin_child_it, end_child_it, found_eoltokens);
					break;
					case T_PP_LINE: on_line(begin_child_it, end_child_it);
					break;
					case T_PP_ERROR: on_error(begin_child_it, end_child_it);
					break;
					case T_PP_WARNING: on_warning(begin_child_it, end_child_it);
					break;
					case T_PP_PRAGMA: return on_pragma(begin_child_it, end_child_it);
					default: on_illformed((*nodeval.begin()).get_value());

					{
						token_sequence_type expanded;
						get_token_value<result_type, parse_node_type>get_value;
						std::copy(make_ref_transform_iterator(begin_child_it, get_value), make_ref_transform_iterator(end_child_it, get_value), std::inserter(expanded, expanded.end()));
						pending_queue.splice(pending_queue.begin(), expanded);
					}
					break;
				}
				return true;
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_include(string_type const&s, bool is_system, bool include_next)
			{
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 1461), 0));
				typename string_type::size_type pos_end=s.find_last_of(is_system?'>': '\"');
				if(string_type::npos==pos_end)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_include_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_include_statement);
						if((s.c_str())[0]!=0)stream<<": "<<(s.c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_include_statement, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return ;
				}
				typename string_type::size_type pos_begin=s.find_last_of(is_system?'<': '\"', pos_end-1);
				if(string_type::npos==pos_begin)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_include_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_include_statement);
						if((s.c_str())[0]!=0)stream<<": "<<(s.c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_include_statement, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return ;
				}
				std::string file_token(s.substr(pos_begin, pos_end-pos_begin+1).c_str());
				std::string file_path(s.substr(pos_begin+1, pos_end-pos_begin-1).c_str());
				on_include_helper(file_token.c_str(), file_path.c_str(), is_system, include_next);
			}
			template<typename ContextT>
			inline bool pp_iterator_functor<ContextT>::on_include_helper(char const*f, char const*s, bool is_system, bool include_next)
			{
				namespace fs=boost::filesystem;
				std::string file_path(s);
				std::string dir_path;
				char const*current_name=include_next?iter_ctx->real_filename.c_str(): 0;
				if(ctx.get_hooks().found_include_directive(ctx.derived(), f, include_next))return true;
				file_path=util::impl::unescape_lit(file_path);
				if(!ctx.find_include_file(file_path, dir_path, is_system, current_name))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_include_file)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_include_file);
						if((file_path.c_str())[0]!=0)stream<<": "<<(file_path.c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_include_file, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return false;
				}
				fs::path native_path(wave::util::create_path(file_path));
				if(!fs::exists(native_path))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_include_file)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_include_file);
						if((file_path.c_str())[0]!=0)stream<<": "<<(file_path.c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_include_file, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return false;
				}
				ctx.get_hooks().resolved_include_file(ctx, dir_path, file_path, is_system);
				std::string native_path_str(wave::util::native_file_string(native_path));
				if(!ctx.has_pragma_once(native_path.string()))
				{
					ctx.set_current_directory(native_path_str.c_str());
					boost::shared_ptr<base_iteration_context_type>new_iter_ctx(new iteration_context_type(ctx, native_path_str.c_str(), act_pos, boost::wave::enable_prefer_pp_numbers(ctx.get_language())));
					ctx.get_hooks().opened_include_file(ctx.derived(), dir_path, file_path, is_system);
					iter_ctx->filename=act_pos.get_file();
					iter_ctx->line=act_pos.get_line();
					iter_ctx->if_block_depth=ctx.get_if_block_depth();
					ctx.push_iteration_context(act_pos, iter_ctx);
					iter_ctx=new_iter_ctx;
					seen_newline=true;
					must_emit_line_directive=true;
					act_pos.set_file(iter_ctx->filename);
					fs::path rfp(wave::util::create_path(iter_ctx->real_filename.c_str()));
					std::string real_filename(rfp.string());
					ctx.set_current_filename(real_filename.c_str());
					act_pos.set_line(iter_ctx->line);
					act_pos.set_column(0);
				}
				return true;
			}
			namespace impl
			{
				template<typename StringT>
				inline StringT trim_whitespace(StringT const&s)
				{
					typedef typename StringT::size_type size_type;
					size_type first=s.find_first_not_of(" \t\v\f");
					if(StringT::npos==first)return StringT();
					size_type last=s.find_last_not_of(" \t\v\f");
					return s.substr(first, last-first+1);
				}
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_include(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end, bool include_next)
			{
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 1606), 0));
				get_token_value<result_type, parse_node_type>get_value;
				token_sequence_type expanded;
				token_sequence_type toexpand;
				std::copy(make_ref_transform_iterator(begin, get_value), make_ref_transform_iterator(end, get_value), std::inserter(toexpand, toexpand.end()));
				typename token_sequence_type::iterator begin2=toexpand.begin();
				ctx.expand_whole_tokensequence(begin2, toexpand.end(), expanded, false);
				string_type s(impl::trim_whitespace(boost::wave::util::impl::as_string(expanded)));
				bool is_system='<'==s[0]&&'>'==s[s.size()-1];
				if(!is_system&&!('\"'==s[0]&&'\"'==s[s.size()-1]))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_include_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_include_statement);
						if((s.c_str())[0]!=0)stream<<": "<<(s.c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_include_statement, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return ;
				}
				on_include(s, is_system, include_next);
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_define(parse_node_type const&node)
			{
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 1644), 0));
				result_type macroname;
				std::vector<result_type>macroparameters;
				token_sequence_type macrodefinition;
				bool has_parameters=false;
				position_type pos(act_token.get_position());
				if(!boost::wave::util::retrieve_macroname(ctx, node, 5, macroname, pos, false))return ;
				has_parameters=boost::wave::util::retrieve_macrodefinition(node, 6, macroparameters, pos, false);
				boost::wave::util::retrieve_macrodefinition(node, 7, macrodefinition, pos, false);
				if(has_parameters)
				{
					if(boost::wave::need_variadics(ctx.get_language()))
					{
						using namespace cpplexer;
						typedef typename std::vector<result_type>::iterator parameter_iterator_t;
						bool seen_ellipses=false;
						parameter_iterator_t end=macroparameters.end();
						for(parameter_iterator_t pit=macroparameters.begin();
						pit!=end;
						++pit)
						{
							if(seen_ellipses)
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::bad_define_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_define_statement);
									if((macroname.get_value().c_str())[0]!=0)stream<<": "<<(macroname.get_value().c_str());
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_define_statement, ((*pit).get_position()).get_line(), ((*pit).get_position()).get_column(), ((*pit).get_position()).get_file().c_str()));
								};
								return ;
							}
							if(T_ELLIPSIS==token_id(*pit))seen_ellipses=true;
							if("__VA_ARGS__"==(*pit).get_value())
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::bad_define_statement_va_args)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_define_statement_va_args);
									if((macroname.get_value().c_str())[0]!=0)stream<<": "<<(macroname.get_value().c_str());
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_define_statement_va_args, ((*pit).get_position()).get_line(), ((*pit).get_position()).get_column(), ((*pit).get_position()).get_file().c_str()));
								};
								return ;
							}
						}
						if(!seen_ellipses)
						{
							typedef typename token_sequence_type::iterator definition_iterator_t;
							bool seen_va_args=false;
							definition_iterator_t pend=macrodefinition.end();
							for(definition_iterator_t dit=macrodefinition.begin();
							dit!=pend;
							++dit)
							{
								if(T_IDENTIFIER==token_id(*dit)&&"__VA_ARGS__"==(*dit).get_value())
								{
									seen_va_args=true;
								}
							}
							if(seen_va_args)
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::bad_define_statement_va_args)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_define_statement_va_args);
									if((macroname.get_value().c_str())[0]!=0)stream<<": "<<(macroname.get_value().c_str());
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_define_statement_va_args, (act_token.get_position()).get_line(), (act_token.get_position()).get_column(), (act_token.get_position()).get_file().c_str()));
								};
								return ;
							}
						}
					}
					else
					{
						using namespace cpplexer;
						typedef typename std::vector<result_type>::iterator parameter_iterator_t;
						parameter_iterator_t end=macroparameters.end();
						for(parameter_iterator_t pit=macroparameters.begin();
						pit!=end;
						++pit)
						{
							if(T_ELLIPSIS==token_id(*pit))
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::bad_define_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_define_statement);
									if((macroname.get_value().c_str())[0]!=0)stream<<": "<<(macroname.get_value().c_str());
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_define_statement, ((*pit).get_position()).get_line(), ((*pit).get_position()).get_column(), ((*pit).get_position()).get_file().c_str()));
								};
								return ;
							}
						}
					}
				}
				ctx.add_macro_definition(macroname, has_parameters, macroparameters, macrodefinition);
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_undefine(lexer_type const&it)
			{
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 1756), 0));
				ctx.remove_macro_definition((*it).get_value());
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_ifdef(result_type const&found_directive, lexer_type const&it)
			{
				bool is_defined=false;
				token_sequence_type directive;
				directive.insert(directive.end(), *it);
				do
				{
					is_defined=ctx.is_defined_macro((*it).get_value());
				}
				while(ctx.get_hooks().evaluated_conditional_expression(ctx.derived(), found_directive, directive, is_defined));
				ctx.enter_if_block(is_defined);
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_ifndef(result_type const&found_directive, lexer_type const&it)
			{
				bool is_defined=false;
				token_sequence_type directive;
				directive.insert(directive.end(), *it);
				do
				{
					is_defined=ctx.is_defined_macro((*it).get_value());
				}
				while(ctx.get_hooks().evaluated_conditional_expression(ctx.derived(), found_directive, directive, is_defined));
				ctx.enter_if_block(!is_defined);
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_else()
			{
				if(!ctx.enter_else_block())
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::missing_matching_if)<<": "<<preprocess_exception::error_text(preprocess_exception::missing_matching_if);
						if(("#else")[0]!=0)stream<<": "<<("#else");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::missing_matching_if, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
				}
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_endif()
			{
				if(!ctx.exit_if_block())
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::missing_matching_if)<<": "<<preprocess_exception::error_text(preprocess_exception::missing_matching_if);
						if(("#endif")[0]!=0)stream<<": "<<("#endif");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::missing_matching_if, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
				}
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::replace_undefined_identifiers(token_sequence_type&expanded)
			{
				typename token_sequence_type::iterator exp_end=expanded.end();
				for(typename token_sequence_type::iterator exp_it=expanded.begin();
				exp_it!=exp_end;
				++exp_it)
				{
					using namespace boost::wave;
					token_id id=token_id(*exp_it);
					if(((((id)&boost::wave::TokenTypeMask)==(IdentifierTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false))
					{
						(*exp_it).set_token_id(T_INTLIT);
						(*exp_it).set_value("0");
					}
				}
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_if(result_type const&found_directive, typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end)
			{
				get_token_value<result_type, parse_node_type>get_value;
				token_sequence_type toexpand;
				std::copy(make_ref_transform_iterator(begin, get_value), make_ref_transform_iterator(end, get_value), std::inserter(toexpand, toexpand.end()));
				bool if_status=false;
				grammars::value_error status=grammars::error_noerror;
				token_sequence_type expanded;
				do
				{
					expanded.clear();
					typename token_sequence_type::iterator begin2=toexpand.begin();
					ctx.expand_whole_tokensequence(begin2, toexpand.end(), expanded);
					replace_undefined_identifiers(expanded);
					try
					{
						if_status=grammars::expression_grammar_gen<result_type>::evaluate(expanded.begin(), expanded.end(), act_pos, ctx.get_if_block_status(), status);
					}
					catch(boost::wave::preprocess_exception const&e)
					{
						ctx.get_hooks().throw_exception(ctx.derived(), e);
						break;
					}
				}
				while(ctx.get_hooks().evaluated_conditional_expression(ctx.derived(), found_directive, toexpand, if_status)&&status==grammars::error_noerror);
				ctx.enter_if_block(if_status);
				if(grammars::error_noerror!=status)
				{
					string_type expression=util::impl::as_string(expanded);
					if(0==expression.size())expression="<empty expression>";
					if(grammars::error_division_by_zero&status)
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::division_by_zero)<<": "<<preprocess_exception::error_text(preprocess_exception::division_by_zero);
							if((expression.c_str())[0]!=0)stream<<": "<<(expression.c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::division_by_zero, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
					else if(grammars::error_integer_overflow&status)
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::integer_overflow)<<": "<<preprocess_exception::error_text(preprocess_exception::integer_overflow);
							if((expression.c_str())[0]!=0)stream<<": "<<(expression.c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::integer_overflow, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
					else if(grammars::error_character_overflow&status)
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::character_literal_out_of_range)<<": "<<preprocess_exception::error_text(preprocess_exception::character_literal_out_of_range);
							if((expression.c_str())[0]!=0)stream<<": "<<(expression.c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::character_literal_out_of_range, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
				}
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_elif(result_type const&found_directive, typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end, token_sequence_type const&found_eoltokens)
			{
				get_token_value<result_type, parse_node_type>get_value;
				token_sequence_type toexpand;
				std::copy(make_ref_transform_iterator(begin, get_value), make_ref_transform_iterator(end, get_value), std::inserter(toexpand, toexpand.end()));
				if(ctx.get_if_block_some_part_status())
				{
					if(!ctx.enter_elif_block(false))
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::missing_matching_if)<<": "<<preprocess_exception::error_text(preprocess_exception::missing_matching_if);
							if(("#elif")[0]!=0)stream<<": "<<("#elif");
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::missing_matching_if, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
					typename token_sequence_type::iterator begin2=toexpand.begin();
					typename token_sequence_type::const_iterator begin3=found_eoltokens.begin();
					impl::skip_to_eol(ctx, begin2, toexpand.end());
					impl::skip_to_eol(ctx, begin3, found_eoltokens.end());
					return ;
				}
				bool if_status=false;
				grammars::value_error status=grammars::error_noerror;
				token_sequence_type expanded;
				do
				{
					expanded.clear();
					typename token_sequence_type::iterator begin2=toexpand.begin();
					ctx.expand_whole_tokensequence(begin2, toexpand.end(), expanded);
					replace_undefined_identifiers(expanded);
					try
					{
						if_status=grammars::expression_grammar_gen<result_type>::evaluate(expanded.begin(), expanded.end(), act_pos, ctx.get_if_block_status(), status);
					}
					catch(boost::wave::preprocess_exception const&e)
					{
						ctx.get_hooks().throw_exception(ctx.derived(), e);
					}
				}
				while(ctx.get_hooks().evaluated_conditional_expression(ctx.derived(), found_directive, toexpand, if_status)&&status==grammars::error_noerror);
				if(!ctx.enter_elif_block(if_status))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::missing_matching_if)<<": "<<preprocess_exception::error_text(preprocess_exception::missing_matching_if);
						if(("#elif")[0]!=0)stream<<": "<<("#elif");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::missing_matching_if, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
					return ;
				}
				if(grammars::error_noerror!=status)
				{
					string_type expression=util::impl::as_string(expanded);
					if(0==expression.size())expression="<empty expression>";
					if(grammars::error_division_by_zero&status)
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::division_by_zero)<<": "<<preprocess_exception::error_text(preprocess_exception::division_by_zero);
							if((expression.c_str())[0]!=0)stream<<": "<<(expression.c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::division_by_zero, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
					else if(grammars::error_integer_overflow&status)
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::integer_overflow)<<": "<<preprocess_exception::error_text(preprocess_exception::integer_overflow);
							if((expression.c_str())[0]!=0)stream<<": "<<(expression.c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::integer_overflow, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
					else if(grammars::error_character_overflow&status)
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::character_literal_out_of_range)<<": "<<preprocess_exception::error_text(preprocess_exception::character_literal_out_of_range);
							if((expression.c_str())[0]!=0)stream<<": "<<(expression.c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::character_literal_out_of_range, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						};
					}
				}
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_illformed(typename result_type::string_type s)
			{
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2092), 0));
				typename string_type::size_type p=s.find_last_not_of('\n');
				if(string_type::npos!=p)s=s.substr(0, p+1);

				{
					using namespace boost::wave;
					std::stringstream stream;
					stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_directive)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_directive);
					if((s.c_str())[0]!=0)stream<<": "<<(s.c_str());
					stream<<std::ends;
					ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_directive, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
				};
			}
			namespace impl
			{
				template<typename IteratorT, typename StringT>
				bool retrieve_line_info(IteratorT first, IteratorT const&last, unsigned int&line, StringT&file, boost::wave::preprocess_exception::error_code&error)
				{
					using namespace boost::wave;
					token_id id=token_id(*first);
					if(T_PP_NUMBER==id||T_INTLIT==id)
					{
						using namespace std;
						line=(unsigned int)atoi((*first).get_value().c_str());
						if(0==line)error=preprocess_exception::bad_line_number;
						using namespace boost::spirit::classic;
						if(!parse((*first).get_value().c_str(), int_p).full)error=preprocess_exception::bad_line_number;
						while(++first!=last&&((((*first)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false));
						if(first!=last)
						{
							if(T_STRINGLIT!=token_id(*first))
							{
								error=preprocess_exception::bad_line_filename;
								return false;
							}
							StringT const&file_lit=(*first).get_value();
							if('L'==file_lit[0])
							{
								error=preprocess_exception::bad_line_filename;
								return false;
							}
							file=file_lit.substr(1, file_lit.size()-2);
							while(++first!=last&&((((*first)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false));
						}
						return first==last;
					}
					error=preprocess_exception::bad_line_statement;
					return false;
				}
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_line(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end)
			{
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2167), 0));
				token_sequence_type expanded;
				get_token_value<result_type, parse_node_type>get_value;
				typedef typename ref_transform_iterator_generator<get_token_value<result_type, parse_node_type>, typename parse_tree_type::const_iterator>::type const_tree_iterator_t;
				const_tree_iterator_t first=make_ref_transform_iterator(begin, get_value);
				const_tree_iterator_t last=make_ref_transform_iterator(end, get_value);
				unsigned int line=0;
				preprocess_exception::error_code error=preprocess_exception::no_error;
				string_type file_name;
				token_sequence_type toexpand;
				std::copy(first, last, std::inserter(toexpand, toexpand.end()));
				if(!impl::retrieve_line_info(first, last, line, file_name, error))
				{
					typename token_sequence_type::iterator begin2=toexpand.begin();
					ctx.expand_whole_tokensequence(begin2, toexpand.end(), expanded, false);
					error=preprocess_exception::no_error;
					if(!impl::retrieve_line_info(expanded.begin(), expanded.end(), line, file_name, error))
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(error)<<": "<<preprocess_exception::error_text(error);
							if((boost::wave::util::impl::as_string(expanded).c_str())[0]!=0)stream<<": "<<(boost::wave::util::impl::as_string(expanded).c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), error, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
						}
						return ;
					}
					ctx.get_hooks().found_line_directive(ctx.derived(), expanded, line, file_name.c_str());
				}
				else
				{
					ctx.get_hooks().found_line_directive(ctx.derived(), toexpand, line, file_name.c_str());
				}
				(void)((!!(unput_queue.empty()))||(_wassert(L"unput_queue.empty()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2217), 0));
				(void)((!!(pending_queue.empty()))||(_wassert(L"pending_queue.empty()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2218), 0));
				must_emit_line_directive=true;
				if(error!=preprocess_exception::no_error)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(error)<<": "<<preprocess_exception::error_text(error);
						if((boost::wave::util::impl::as_string(expanded).c_str())[0]!=0)stream<<": "<<(boost::wave::util::impl::as_string(expanded).c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), error, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					}
					return ;
				}
				if(!file_name.empty())
				{
					using boost::wave::util::impl::unescape_lit;
					act_pos.set_file(unescape_lit(file_name).c_str());
				}
				act_pos.set_line(line);
				iter_ctx->first.set_position(act_pos);
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_error(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end)
			{
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2250), 0));
				token_sequence_type expanded;
				get_token_value<result_type, parse_node_type>get_value;
				typename ref_transform_iterator_generator<get_token_value<result_type, parse_node_type>, typename parse_tree_type::const_iterator>::type first=make_ref_transform_iterator(begin, get_value);
				token_sequence_type toexpand;
				std::copy(first, make_ref_transform_iterator(end, get_value), std::inserter(toexpand, toexpand.end()));
				typename token_sequence_type::iterator begin2=toexpand.begin();
				ctx.expand_whole_tokensequence(begin2, toexpand.end(), expanded, false);
				if(!ctx.get_hooks().found_error_directive(ctx.derived(), toexpand))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::error_directive)<<": "<<preprocess_exception::error_text(preprocess_exception::error_directive);
						if((boost::wave::util::impl::as_string(expanded).c_str())[0]!=0)stream<<": "<<(boost::wave::util::impl::as_string(expanded).c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::error_directive, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
				}
			}
			template<typename ContextT>
			inline void pp_iterator_functor<ContextT>::on_warning(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end)
			{
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2298), 0));
				token_sequence_type expanded;
				get_token_value<result_type, parse_node_type>get_value;
				typename ref_transform_iterator_generator<get_token_value<result_type, parse_node_type>, typename parse_tree_type::const_iterator>::type first=make_ref_transform_iterator(begin, get_value);
				token_sequence_type toexpand;
				std::copy(first, make_ref_transform_iterator(end, get_value), std::inserter(toexpand, toexpand.end()));
				typename token_sequence_type::iterator begin2=toexpand.begin();
				ctx.expand_whole_tokensequence(begin2, toexpand.end(), expanded, false);
				if(!ctx.get_hooks().found_warning_directive(ctx.derived(), toexpand))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::warning_directive)<<": "<<preprocess_exception::error_text(preprocess_exception::warning_directive);
						if((boost::wave::util::impl::as_string(expanded).c_str())[0]!=0)stream<<": "<<(boost::wave::util::impl::as_string(expanded).c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::warning_directive, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
					};
				}
			}
			template<typename ContextT>
			inline bool pp_iterator_functor<ContextT>::on_pragma(typename parse_tree_type::const_iterator const&begin, typename parse_tree_type::const_iterator const&end)
			{
				using namespace boost::wave;
				(void)((!!(ctx.get_if_block_status()))||(_wassert(L"ctx.get_if_block_status()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2348), 0));
				token_sequence_type expanded;
				get_token_value<result_type, parse_node_type>get_value;
				typedef typename ref_transform_iterator_generator<get_token_value<result_type, parse_node_type>, typename parse_tree_type::const_iterator>::type const_tree_iterator_t;
				const_tree_iterator_t first=make_ref_transform_iterator(begin, get_value);
				const_tree_iterator_t last=make_ref_transform_iterator(end, get_value);
				expanded.push_back(result_type(T_PP_PRAGMA, "#pragma", act_token.get_position()));
				expanded.push_back(result_type(T_SPACE, " ", act_token.get_position()));
				while(++first!=last&&((((*first)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))expanded.push_back(*first);
				if(first!=last)
				{
					if(T_IDENTIFIER==token_id(*first)&&boost::wave::need_c99(ctx.get_language())&&(*first).get_value()=="STDC")
					{
						std::copy(first, last, std::inserter(expanded, expanded.end()));
					}
					else
					{
						token_sequence_type toexpand;
						std::copy(first, last, std::inserter(toexpand, toexpand.end()));
						typename token_sequence_type::iterator begin2=toexpand.begin();
						ctx.expand_whole_tokensequence(begin2, toexpand.end(), expanded, false);
					}
				}
				expanded.push_back(result_type(T_NEWLINE, "\n", act_token.get_position()));
				(void)((!!(unput_queue.empty()))||(_wassert(L"unput_queue.empty()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2397), 0));
				(void)((!!(pending_queue.empty()))||(_wassert(L"pending_queue.empty()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_iterator.hpp", 2398), 0));
				token_sequence_type pending;
				if(interpret_pragma(expanded, pending))
				{
					if(pending.size()>0)pending_queue.splice(pending_queue.begin(), pending);
					return true;
				}
				if(boost::wave::need_emit_pragma_directives(ctx.get_language()))
				{
					pending_queue.splice(pending_queue.begin(), expanded);
					return false;
				}
				return true;
			}
			template<typename ContextT>
			inline bool pp_iterator_functor<ContextT>::interpret_pragma(token_sequence_type const&pragma_body, token_sequence_type&result)
			{
				using namespace cpplexer;
				typename token_sequence_type::const_iterator end=pragma_body.end();
				typename token_sequence_type::const_iterator it=pragma_body.begin();
				for(++it;
				it!=end&&((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false);
				++it);
				if(it==end)return false;
				return boost::wave::util::interpret_pragma(ctx.derived(), act_token, it, end, result);
			}
		}
		template<typename ContextT>
		class pp_iterator: public boost::spirit::classic::multi_pass<boost::wave::impl::pp_iterator_functor<ContextT>, boost::wave::util::functor_input>
		{
		public:
			typedef boost::wave::impl::pp_iterator_functor<ContextT>input_policy_type;
		private:
			typedef boost::spirit::classic::multi_pass<input_policy_type, boost::wave::util::functor_input>base_type;
			typedef pp_iterator<ContextT>self_type;
			typedef boost::wave::util::functor_input functor_input_type;
		public:
			pp_iterator()
			{
			}
			template<typename IteratorT>
			pp_iterator(ContextT&ctx, IteratorT const&first, IteratorT const&last, typename ContextT::position_type const&pos): base_type(input_policy_type(ctx, first, last, pos))
			{
			}
			bool force_include(char const*path_, bool is_last)
			{
				bool result=this->get_functor().on_include_helper(path_, path_, false, false);
				if(is_last)
				{
					this->functor_input_type::template inner<input_policy_type>::advance_input();
				}
				return result;
			}
		};
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename CharT, typename T>
				class tst;
			}
			template<typename T=int, typename CharT=char, typename SetT=impl::tst<T, CharT> >
			class symbols;
			template<typename T, typename SetT>
			class symbol_inserter;
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T, typename CharT, typename SetT>
			class symbols: private SetT, public parser<symbols<T, CharT, SetT> >
			{
			public:
				typedef parser<symbols<T, CharT, SetT> >parser_base_t;
				typedef symbols<T, CharT, SetT>self_t;
				typedef self_t const&embed_t;
				typedef T symbol_data_t;
				typedef boost::reference_wrapper<T>symbol_ref_t;
				symbols();
				symbols(symbols const&other);
				~symbols();
				symbols&operator=(symbols const&other);
				symbol_inserter<T, SetT>const&operator=(CharT const*str);
				template<typename ScannerT>
				struct result
				{
					typedef typename match_result<ScannerT, symbol_ref_t>::type type;
				};
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse_main(ScannerT const&scan)const
				{
					typedef typename ScannerT::iterator_t iterator_t;
					iterator_t first=scan.first;
					typename SetT::search_info result=SetT::find(scan);
					if(result.data)return scan.create_match(result.length, symbol_ref_t(*result.data), first, scan.first);
					else return scan.no_match();
				}
				template<typename ScannerT>
				typename parser_result<self_t, ScannerT>::type parse(ScannerT const&scan)const
				{
					typedef typename parser_result<self_t, ScannerT>::type result_t;
					return impl::implicit_lexeme_parse<result_t>(*this, scan, scan);
				}
				template<typename ScannerT>
				T*find(ScannerT const&scan)const
				{
					return SetT::find(scan).data;
				}
				symbol_inserter<T, SetT>const add;
			};
			template<typename T, typename CharT, typename SetT>
			T*add(symbols<T, CharT, SetT>&table, CharT const*sym, T const&data=T());
			template<typename T, typename CharT, typename SetT>
			T*find(symbols<T, CharT, SetT>const&table, CharT const*sym);
			template<typename T, typename SetT>
			class symbol_inserter
			{
			public:
				symbol_inserter(SetT&set_): set(set_)
				{
				}
				typedef symbol_inserter const&result_type;
				template<typename IteratorT>
				symbol_inserter const&operator()(IteratorT first, IteratorT const&last, T const&data=T())const
				{
					set.add(first, last, data);
					return *this;
				}
				template<typename CharT>
				symbol_inserter const&operator()(CharT const*str, T const&data=T())const
				{
					CharT const*last=str;
					while(*last)last++;
					set.add(str, last, data);
					return *this;
				}
				template<typename CharT>
				symbol_inserter const&operator, (CharT const*str)const
				{
					CharT const*last=str;
					while(*last)last++;
					set.add(str, last, T());
					return *this;
				}
			private:
				SetT&set;
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			namespace impl
			{
				template<typename T, typename CharT>
				struct tst_node
				{
					tst_node(CharT value_): value(value_), left(0), right(0)
					{
						middle.link=0;
					}
					~tst_node()
					{
						delete left;
						delete right;
						if(value)delete middle.link;
						else delete middle.data;
					}
					tst_node*clone()const
					{
						std::auto_ptr<tst_node>copy(new tst_node(value));
						if(left)copy->left=left->clone();
						if(right)copy->right=right->clone();
						if(value&&middle.link)
						{
							copy->middle.link=middle.link->clone();
						}
						else
						{
							std::auto_ptr<T>mid_data(new T(*middle.data));
							copy->middle.data=mid_data.release();
						}
						return copy.release();
					}
					union center
					{
						tst_node*link;
						T*data;
					};
					CharT value;
					tst_node*left;
					center middle;
					tst_node*right;
				};
				template<typename T, typename CharT>
				class tst
				{
				public:
					struct search_info
					{
						T*data;
						std::size_t length;
					};
					tst(): root(0)
					{
					}
					tst(tst const&other): root(other.root?other.root->clone(): 0)
					{
					}
					~tst()
					{
						delete root;
					}
					tst&operator=(tst const&other)
					{
						if(this!=&other)
						{
							node_t*new_root=other.root?other.root->clone(): 0;
							delete root;
							root=new_root;
						}
						return *this;
					}
					template<typename IteratorT>
					T*add(IteratorT first, IteratorT const&last, T const&data)
					{
						if(first==last)return 0;
						node_t**np=&root;
						CharT ch=*first;
						(void)((!!((first==last||ch!=0)&&"Won't add string containing null character"))||(_wassert(L"(first == last || ch != 0) && \"Won't add string containing null character\"", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\symbols\\impl\\tst.ipp", 139), 0));
						for(;
						;
						)
						{
							if(*np==0||ch==0)
							{
								node_t*right=0;
								if(np!=0)right=*np;
								*np=new node_t(ch);
								if(right)(**np).right=right;
							}
							if(ch<(**np).value)
							{
								np=&(**np).left;
							}
							else
							{
								if(ch==(**np).value)
								{
									if(ch==0)
									{
										if((**np).middle.data==0)
										{
											(**np).middle.data=new T(data);
											return (**np).middle.data;
										}
										else
										{
											return 0;
										}
									}
									++first;
									ch=(first==last)?CharT(0): *first;
									(void)((!!((first==last||ch!=0)&&"Won't add string containing null character"))||(_wassert(L"(first == last || ch != 0) && \"Won't add string containing null character\"", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\classic\\symbols\\impl\\tst.ipp", 177), 0));
									np=&(**np).middle.link;
								}
								else
								{
									np=&(**np).right;
								}
							}
						}
					}
					template<typename ScannerT>
					search_info find(ScannerT const&scan)const
					{
						search_info result=
						{
							0, 0
						};
						if(scan.at_end())
						{
							return result;
						}
						typedef typename ScannerT::iterator_t iterator_t;
						node_t*np=root;
						CharT ch=*scan;
						iterator_t save=scan.first;
						iterator_t latest=scan.first;
						std::size_t latest_len=0;
						while(np)
						{
							if(ch<np->value)
							{
								if(np->value==0)
								{
									result.data=np->middle.data;
									if(result.data)
									{
										latest=scan.first;
										latest_len=result.length;
									}
								}
								np=np->left;
							}
							else if(ch==np->value)
							{
								if(np->value==0)
								{
									result.data=np->middle.data;
									if(result.data)
									{
										latest=scan.first;
										latest_len=result.length;
									}
									break;
								}
								++scan;
								ch=scan.at_end()?CharT(0): *scan;
								np=np->middle.link;
								++result.length;
							}
							else
							{
								if(np->value==0)
								{
									result.data=np->middle.data;
									if(result.data)
									{
										latest=scan.first;
										latest_len=result.length;
									}
								}
								np=np->right;
							}
						}
						if(result.data==0)
						{
							scan.first=save;
						}
						else
						{
							scan.first=latest;
							result.length=latest_len;
						}
						return result;
					}
				private:
					typedef tst_node<T, CharT>node_t;
					node_t*root;
				};
			}
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace classic
		{
			template<typename T, typename CharT, typename SetT>
			inline symbols<T, CharT, SetT>::symbols(): SetT(), add(*this)
			{
			}
			template<typename T, typename CharT, typename SetT>
			symbols<T, CharT, SetT>::symbols(symbols const&other): SetT(other), parser<symbols<T, CharT, SetT> >(), add(*this)
			{
			}
			template<typename T, typename CharT, typename SetT>
			inline symbols<T, CharT, SetT>::~symbols()
			{
			}
			template<typename T, typename CharT, typename SetT>
			inline symbols<T, CharT, SetT>&symbols<T, CharT, SetT>::operator=(symbols const&other)
			{
				SetT::operator=(other);
				return *this;
			}
			template<typename T, typename CharT, typename SetT>
			inline symbol_inserter<T, SetT>const&symbols<T, CharT, SetT>::operator=(CharT const*str)
			{
				return add, str;
			}
			template<typename T, typename CharT, typename SetT>
			inline T*find(symbols<T, CharT, SetT>const&table, CharT const*sym)
			{
				CharT const*last=sym;
				while(*last)last++;
				scanner<CharT const*>scan(sym, last);
				T*result=table.find(scan);
				return scan.at_end()?result: 0;
			}
			template<typename T, typename CharT, typename SetT>
			inline T*add(symbols<T, CharT, SetT>&table, CharT const*sym, T const&data)
			{
				CharT const*first=sym;
				CharT const*last=sym;
				while(*last)last++;
				scanner<CharT const*>scan(first, last);
				if(table.find(scan)&&scan.at_end())return 0;
				table.add(sym, last, data);
				first=sym;
				return table.find(scan);
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			namespace time_conversion
			{
				using namespace std;
				class time_conversion_grammar: public boost::spirit::classic::grammar<time_conversion_grammar>
				{
				public:
					time_conversion_grammar(): fYearIsCorrected(false)
					{
						using namespace std;
						memset(&time_stamp, 0, sizeof(tm));
						;
					}
					template<typename ScannerT>
					struct definition
					{
						definition(time_conversion_grammar const&self)
						{
							using boost::spirit::classic::int_p;
							using boost::spirit::classic::add;
							char const*m[]=
							{
								"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
							};
							for(int i=0;
							i<12;
							++i)add(month, m[i], i);
							time_rule=month[boost::spirit::classic::assign_a(self.time_stamp.tm_mon)]>>int_p[boost::spirit::classic::assign_a(self.time_stamp.tm_mday)]>>int_p[boost::spirit::classic::assign_a(self.time_stamp.tm_year)]>>int_p[boost::spirit::classic::assign_a(self.time_stamp.tm_hour)]>>':'>>int_p[boost::spirit::classic::assign_a(self.time_stamp.tm_min)]>>':'>>int_p[boost::spirit::classic::assign_a(self.time_stamp.tm_sec)];
							;
						}
						boost::spirit::classic::rule<ScannerT>time_rule;
						boost::spirit::classic::symbols<>month;
						boost::spirit::classic::rule<ScannerT>const&start()const
						{
							return time_rule;
						}
					};
					void correct_year()
					{
						if(!fYearIsCorrected)
						{
							time_stamp.tm_year-=1900;
							fYearIsCorrected=true;
						}
					}
					mutable tm time_stamp;
					bool fYearIsCorrected;
				};
				class time_conversion_helper
				{
				public:
					time_conversion_helper(char const*act_time): compile_time(0)
					{
						using namespace boost::spirit::classic;
						time_conversion_grammar g;
						parse_info<>pi=parse(act_time, g, space_p);
						if(pi.hit)
						{
							g.correct_year();
							compile_time=mktime(&g.time_stamp);
						}
						(void)((!!(0!=compile_time))||(_wassert(L"0 != compile_time", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\time_conversion_helper.hpp", 127), 0));
					}
					time_t get_time()const
					{
						return compile_time;
					}
				private:
					time_t compile_time;
				};
			}
			using namespace time_conversion;
		}
	}
}
namespace boost
{
	namespace detail
	{
		typedef long atomic_count;
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	template<class T>
	class intrusive_ptr
	{
	private:
		typedef intrusive_ptr this_type;
	public:
		typedef T element_type;
		intrusive_ptr(): px(0)
		{
		}
		intrusive_ptr(T*p, bool add_ref=true): px(p)
		{
			if(px!=0&&add_ref)intrusive_ptr_add_ref(px);
		}
		template<class U>
		intrusive_ptr(intrusive_ptr<U>const&rhs, typename detail::sp_enable_if_convertible<U, T>::type=detail::sp_empty()): px(rhs.get())
		{
			if(px!=0)intrusive_ptr_add_ref(px);
		}
		intrusive_ptr(intrusive_ptr const&rhs): px(rhs.px)
		{
			if(px!=0)intrusive_ptr_add_ref(px);
		}
		~intrusive_ptr()
		{
			if(px!=0)intrusive_ptr_release(px);
		}
		template<class U>
		intrusive_ptr&operator=(intrusive_ptr<U>const&rhs)
		{
			this_type(rhs).swap(*this);
			return *this;
		}
		intrusive_ptr&operator=(intrusive_ptr const&rhs)
		{
			this_type(rhs).swap(*this);
			return *this;
		}
		intrusive_ptr&operator=(T*rhs)
		{
			this_type(rhs).swap(*this);
			return *this;
		}
		void reset()
		{
			this_type().swap(*this);
		}
		void reset(T*rhs)
		{
			this_type(rhs).swap(*this);
		}
		T*get()const
		{
			return px;
		}
		T&operator*()const
		{
			(void)((!!(px!=0))||(_wassert(L"px != 0", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\intrusive_ptr.hpp", 160), 0));
			return *px;
		}
		T*operator->()const
		{
			(void)((!!(px!=0))||(_wassert(L"px != 0", L"D:\\dev\\boost_1_41_0\\boost\\smart_ptr\\intrusive_ptr.hpp", 166), 0));
			return px;
		}
		typedef T*this_type::*unspecified_bool_type;
		operator unspecified_bool_type()const
		{
			return px==0?0: &this_type::px;
		}
		bool operator!()const
		{
			return px==0;
		}
		void swap(intrusive_ptr&rhs)
		{
			T*tmp=px;
			px=rhs.px;
			rhs.px=tmp;
		}
	private:
		T*px;
	};
	template<class T, class U>
	inline bool operator==(intrusive_ptr<T>const&a, intrusive_ptr<U>const&b)
	{
		return a.get()==b.get();
	}
	template<class T, class U>
	inline bool operator!=(intrusive_ptr<T>const&a, intrusive_ptr<U>const&b)
	{
		return a.get()!=b.get();
	}
	template<class T, class U>
	inline bool operator==(intrusive_ptr<T>const&a, U*b)
	{
		return a.get()==b;
	}
	template<class T, class U>
	inline bool operator!=(intrusive_ptr<T>const&a, U*b)
	{
		return a.get()!=b;
	}
	template<class T, class U>
	inline bool operator==(T*a, intrusive_ptr<U>const&b)
	{
		return a==b.get();
	}
	template<class T, class U>
	inline bool operator!=(T*a, intrusive_ptr<U>const&b)
	{
		return a!=b.get();
	}
	template<class T>
	inline bool operator<(intrusive_ptr<T>const&a, intrusive_ptr<T>const&b)
	{
		return std::less<T*>()(a.get(), b.get());
	}
	template<class T>
	void swap(intrusive_ptr<T>&lhs, intrusive_ptr<T>&rhs)
	{
		lhs.swap(rhs);
	}
	template<class T>
	T*get_pointer(intrusive_ptr<T>const&p)
	{
		return p.get();
	}
	template<class T, class U>
	intrusive_ptr<T>static_pointer_cast(intrusive_ptr<U>const&p)
	{
		return static_cast<T*>(p.get());
	}
	template<class T, class U>
	intrusive_ptr<T>const_pointer_cast(intrusive_ptr<U>const&p)
	{
		return const_cast<T*>(p.get());
	}
	template<class T, class U>
	intrusive_ptr<T>dynamic_pointer_cast(intrusive_ptr<U>const&p)
	{
		return dynamic_cast<T*>(p.get());
	}
	template<class E, class T, class Y>
	std::basic_ostream<E, T>&operator<<(std::basic_ostream<E, T>&os, intrusive_ptr<Y>const&p)
	{
		os<<p.get();
		return os;
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			template<typename TokenT, typename ContainerT>
			struct macro_definition
			{
				typedef std::vector<TokenT>parameter_container_type;
				typedef ContainerT definition_container_type;
				typedef typename parameter_container_type::const_iterator const_parameter_iterator_t;
				typedef typename definition_container_type::const_iterator const_definition_iterator_t;
				macro_definition(TokenT const&token_, bool has_parameters, bool is_predefined_, long uid_): macroname(token_), uid(uid_), is_functionlike(has_parameters), replaced_parameters(false), is_available_for_replacement(true), is_predefined(is_predefined_), has_ellipsis(false), use_count(0)
				{
				}
				void replace_parameters()
				{
					using namespace boost::wave;
					if(!replaced_parameters)
					{
						typename definition_container_type::iterator end=macrodefinition.end();
						typename definition_container_type::iterator it=macrodefinition.begin();
						for(;
						it!=end;
						++it)
						{
							token_id id=*it;
							if(T_IDENTIFIER==id||((((id)&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false)||((((id)&boost::wave::ExtTokenTypeMask)==(OperatorTokenType|AltExtTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(OperatorTokenType))?true: false))
							{
								const_parameter_iterator_t cend=macroparameters.end();
								const_parameter_iterator_t cit=macroparameters.begin();
								for(typename parameter_container_type::size_type i=0;
								cit!=cend;
								++cit, ++i)
								{
									if((*it).get_value()==(*cit).get_value())
									{
										(*it).set_token_id(token_id(T_PARAMETERBASE+i));
										break;
									}
									else if(T_ELLIPSIS==token_id(*cit)&&"__VA_ARGS__"==(*it).get_value())
									{
										(*it).set_token_id(token_id(T_EXTPARAMETERBASE+i));
										break;
									}
								}
							}
						}
						if(macroparameters.size()>0&&T_ELLIPSIS==token_id(macroparameters.back()))
						{
							has_ellipsis=true;
						}
						replaced_parameters=true;
					}
				}
				TokenT macroname;
				parameter_container_type macroparameters;
				definition_container_type macrodefinition;
				long uid;
				bool is_functionlike;
				bool replaced_parameters;
				bool is_available_for_replacement;
				bool is_predefined;
				bool has_ellipsis;
				boost::detail::atomic_count use_count;
			};
			template<typename TokenT, typename ContainerT>
			inline void intrusive_ptr_add_ref(macro_definition<TokenT, ContainerT>*p)
			{
				++p->use_count;
			}
			template<typename TokenT, typename ContainerT>
			inline void intrusive_ptr_release(macro_definition<TokenT, ContainerT>*p)
			{
				if(--p->use_count==0)delete p;
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			template<typename StringT, typename MacroDefT>
			struct symbol_table: public std::map<StringT, boost::intrusive_ptr<MacroDefT> >
			{
				typedef std::map<StringT, boost::intrusive_ptr<MacroDefT> >base_type;
				typedef typename base_type::iterator iterator_type;
				typedef typename base_type::const_iterator const_iterator_type;
				symbol_table(long uid_=0)
				{
				}
			private:
				template<typename StringT1>
				struct get_first
				{
					typedef StringT1 const&result_type;
					template<typename First, typename Second>
					StringT1 const&operator()(std::pair<First, Second>const&p)const
					{
						return p.first;
					}
				};
				typedef get_first<StringT>unary_functor;
			public:
				typedef transform_iterator<unary_functor, iterator_type>name_iterator;
				typedef transform_iterator<unary_functor, const_iterator_type>const_name_iterator;
				template<typename Iterator>
				static transform_iterator<unary_functor, Iterator>make_iterator(Iterator it)
				{
					return boost::make_transform_iterator<unary_functor>(it);
				}
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace wave
	{
		bool test_configuration(unsigned int config, char const*pragma_keyword, char const*string_type);
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			class predefined_macros
			{
				typedef boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >string_type;
			public:
				struct static_macros
				{
					char const*name;
					boost::wave::token_id token_id;
					char const*value;
				};
				struct dynamic_macros
				{
					char const*name;
					boost::wave::token_id token_id;
					string_type(predefined_macros::*generator)()const;
				};
			private:
				boost::wave::util::time_conversion_helper compilation_time_;
				string_type datestr_;
				string_type timestr_;
				string_type version_;
				string_type versionstr_;
				protected: void reset_datestr()
				{
					static const char*const monthnames[]=
					{
						"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
					};
					using namespace std;
					time_t tt=time(0);
					struct tm*tb=0;
					if(tt!=(time_t)-1)
					{
						char buffer[sizeof("\"Oct 11 1347\"")+1];
						tb=localtime(&tt);
						sprintf(buffer, "\"%s %2d %4d\"", monthnames[tb->tm_mon], tb->tm_mday, tb->tm_year+1900);
						datestr_=buffer;
					}
					else
					{
						datestr_="\"??? ?? ????\"";
					}
				}
				void reset_timestr()
				{
					using namespace std;
					time_t tt=time(0);
					struct tm*tb=0;
					if(tt!=(time_t)-1)
					{
						char buffer[sizeof("\"12:34:56\"")+1];
						tb=localtime(&tt);
						sprintf(buffer, "\"%02d:%02d:%02d\"", tb->tm_hour, tb->tm_min, tb->tm_sec);
						timestr_=buffer;
					}
					else
					{
						timestr_="\"??:??:??\"";
					}
				}
				void reset_version()
				{
					char buffer[sizeof("0x00000000")+1];
					using namespace std;
					tm first_day;
					using namespace std;
					memset(&first_day, 0, sizeof(tm));
					first_day.tm_mon=11;
					first_day.tm_mday=13;
					first_day.tm_year=101;
					long seconds=long(difftime(compilation_time_.get_time(), mktime(&first_day)));
					sprintf(buffer, "0x%02d%1d%1d%04ld", 2, 0, 3, seconds/(3600*24));
					version_=buffer;
				}
				void reset_versionstr()
				{
					char buffer[sizeof("\"00.00.00.0000 \"")+sizeof("Win32")+sizeof("Microsoft Visual C++ version " "8.0")+4];
					using namespace std;
					tm first_day;
					memset(&first_day, 0, sizeof(tm));
					first_day.tm_mon=11;
					first_day.tm_mday=13;
					first_day.tm_year=101;
					long seconds=long(difftime(compilation_time_.get_time(), mktime(&first_day)));
					sprintf(buffer, "\"%d.%d.%d.%ld [%s/%s]\"", 2, 0, 3, seconds/(3600*24), "Win32", "Microsoft Visual C++ version " "8.0");
					versionstr_=buffer;
				}
				string_type get_date()const
				{
					return datestr_;
				}
				string_type get_time()const
				{
					return timestr_;
				}
				string_type get_version()const
				{
					char buffer[sizeof("0x0000")+1];
					using namespace std;
					sprintf(buffer, "0x%02d%1d%1d", 2, 0, 3);
					return buffer;
				}
				string_type get_config()const
				{
					char buffer[sizeof("0x00000000")+1];
					using namespace std;
					sprintf(buffer, "0x%08x", (0x00000001|0x00000002|0x00000000|0x00000008|0x00000000|0x00000000));
					return buffer;
				}
			public:
				predefined_macros(): compilation_time_("Jul 31 2013" " " "21:37:55")
				{
					reset();
					reset_version();
					reset_versionstr();
				}
				void reset()
				{
					reset_datestr();
					reset_timestr();
				}
				string_type get_fullversion()const
				{
					return version_;
				}
				string_type get_versionstr()const
				{
					return versionstr_;
				}
				static_macros const&static_data_cpp(std::size_t i)const
				{
					static static_macros data[]=
					{

						{
							"__STDC__", T_INTLIT, "1"
						}
						,
						{
							"__cplusplus", T_INTLIT, "199711L"
						}
						,
						{
							0, T_EOF, 0
						}
					};
					(void)((!!(i<sizeof(data)/sizeof(data[0])))||(_wassert(L"i < sizeof(data)/sizeof(data[0])", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap_predef.hpp", 222), 0));
					return data[i];
				}
				static_macros const&static_data_c99(std::size_t i)const
				{
					static static_macros data[]=
					{

						{
							"__STDC__", T_INTLIT, "1"
						}
						,
						{
							"__STDC_VERSION__", T_INTLIT, "199901L"
						}
						,
						{
							"__STDC_HOSTED__", T_INTLIT, "0"
						}
						,
						{
							"__WAVE_HAS_VARIADICS__", T_INTLIT, "1"
						}
						,
						{
							0, T_EOF, 0
						}
					};
					(void)((!!(i<sizeof(data)/sizeof(data[0])))||(_wassert(L"i < sizeof(data)/sizeof(data[0])", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap_predef.hpp", 237), 0));
					return data[i];
				}
				dynamic_macros const&dynamic_data(std::size_t i)const
				{
					static dynamic_macros data[]=
					{

						{
							"__DATE__", T_STRINGLIT, &predefined_macros::get_date
						}
						,
						{
							"__TIME__", T_STRINGLIT, &predefined_macros::get_time
						}
						,
						{
							"__SPIRIT_PP__", T_INTLIT, &predefined_macros::get_version
						}
						,
						{
							"__SPIRIT_PP_VERSION__", T_INTLIT, &predefined_macros::get_fullversion
						}
						,
						{
							"__SPIRIT_PP_VERSION_STR__", T_STRINGLIT, &predefined_macros::get_versionstr
						}
						,
						{
							"__WAVE__", T_INTLIT, &predefined_macros::get_version
						}
						,
						{
							"__WAVE_VERSION__", T_INTLIT, &predefined_macros::get_fullversion
						}
						,
						{
							"__WAVE_VERSION_STR__", T_STRINGLIT, &predefined_macros::get_versionstr
						}
						,
						{
							"__WAVE_CONFIG__", T_INTLIT, &predefined_macros::get_config
						}
						,
						{
							0, T_EOF, 0
						}
					};
					(void)((!!(i<sizeof(data)/sizeof(data[0])))||(_wassert(L"i < sizeof(data)/sizeof(data[0])", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap_predef.hpp", 256), 0));
					return data[i];
				}
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace grammars
		{
			template<typename LexIteratorT>
			struct defined_grammar_gen
			{
				typedef typename LexIteratorT::token_type token_type;
				typedef std::list<token_type, boost::fast_pool_allocator<token_type> >token_sequence_type;
				typedef boost::wave::util::unput_queue_iterator<typename token_sequence_type::iterator, token_type, token_sequence_type>iterator1_type;
				typedef boost::wave::util::unput_queue_iterator<LexIteratorT, token_type, token_sequence_type>iterator2_type;
				static boost::spirit::classic::parse_info<iterator1_type>parse_operator_defined(iterator1_type const&first, iterator1_type const&last, token_sequence_type&found_qualified_name);
				static boost::spirit::classic::parse_info<iterator2_type>parse_operator_defined(iterator2_type const&first, iterator2_type const&last, token_sequence_type&found_qualified_name);
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace util
		{
			template<typename ContextT>
			class macromap
			{
				typedef macromap<ContextT>self_type;
				typedef typename ContextT::token_type token_type;
				typedef typename token_type::string_type string_type;
				typedef typename token_type::position_type position_type;
				typedef typename ContextT::token_sequence_type definition_container_type;
				typedef std::vector<token_type>parameter_container_type;
				typedef macro_definition<token_type, definition_container_type>macro_definition_type;
				typedef symbol_table<string_type, macro_definition_type>defined_macros_type;
				typedef typename defined_macros_type::value_type::second_type macro_ref_type;
			public:
				macromap(ContextT&ctx_): current_macros(0), defined_macros(new defined_macros_type(1)), main_pos("", 0), ctx(ctx_), macro_uid(1)
				{
					current_macros=defined_macros.get();
				}
				~macromap()
				{
				}
				bool add_macro(token_type const&name, bool has_parameters, parameter_container_type&parameters, definition_container_type&definition, bool is_predefined=false, defined_macros_type*scope=0);
				bool is_defined(string_type const&name, typename defined_macros_type::iterator&it, defined_macros_type*scope=0)const;
				template<typename IteratorT>
				bool is_defined(IteratorT const&begin, IteratorT const&end)const;
				bool is_defined(string_type const&str)const;
				bool get_macro(string_type const&name, bool&has_parameters, bool&is_predefined, position_type&pos, parameter_container_type&parameters, definition_container_type&definition, defined_macros_type*scope=0)const;
				bool remove_macro(string_type const&name, position_type const&pos, bool even_predefined=false);
				template<typename IteratorT, typename ContainerT>
				token_type const&expand_tokensequence(IteratorT&first, IteratorT const&last, ContainerT&pending, ContainerT&expanded, bool&seen_newline, bool expand_operator_defined);
				template<typename IteratorT, typename ContainerT>
				void expand_whole_tokensequence(ContainerT&expanded, IteratorT&first, IteratorT const&last, bool expand_operator_defined);
				void init_predefined_macros(char const*fname="<Unknown>", defined_macros_type*scope=0, bool at_global_scope=true);
				void predefine_macro(defined_macros_type*scope, string_type const&name, token_type const&t);
				void reset_macromap();
				position_type&get_main_pos()
				{
					return main_pos;
				}
				typedef typename defined_macros_type::name_iterator name_iterator;
				typedef typename defined_macros_type::const_name_iterator const_name_iterator;
				name_iterator begin()
				{
					return defined_macros_type::make_iterator(current_macros->begin());
				}
				name_iterator end()
				{
					return defined_macros_type::make_iterator(current_macros->end());
				}
				const_name_iterator begin()const
				{
					return defined_macros_type::make_iterator(current_macros->begin());
				}
				const_name_iterator end()const
				{
					return defined_macros_type::make_iterator(current_macros->end());
				}
				protected: template<typename IteratorT, typename ContainerT>token_type const&expand_tokensequence_worker(ContainerT&pending, unput_queue_iterator<IteratorT, token_type, ContainerT>&first, unput_queue_iterator<IteratorT, token_type, ContainerT>const&last, bool&seen_newline, bool expand_operator_defined);
				template<typename IteratorT, typename ContainerT, typename SizeT>
				typename std::vector<ContainerT>::size_type collect_arguments(token_type const curr_token, std::vector<ContainerT>&arguments, IteratorT&next, IteratorT&endparen, IteratorT const&end, SizeT const&parameter_count, bool&seen_newline);
				template<typename IteratorT, typename ContainerT>
				bool expand_macro(ContainerT&pending, token_type const&name, typename defined_macros_type::iterator it, IteratorT&first, IteratorT const&last, bool&seen_newline, bool expand_operator_defined, defined_macros_type*scope=0, ContainerT*queue_symbol=0);
				template<typename ContainerT>
				bool expand_predefined_macro(token_type const&curr_token, ContainerT&expanded);
				template<typename ContainerT>
				void expand_argument(typename std::vector<ContainerT>::size_type arg, std::vector<ContainerT>&arguments, std::vector<ContainerT>&expanded_args, bool expand_operator_defined, std::vector<bool>&has_expanded_args);
				template<typename ContainerT>
				void expand_replacement_list(macro_definition_type const&macrodefinition, std::vector<ContainerT>&arguments, bool expand_operator_defined, ContainerT&expanded);
				template<typename IteratorT, typename ContainerT>
				void rescan_replacement_list(token_type const&curr_token, macro_definition_type&macrodef, ContainerT&replacement_list, ContainerT&expanded, bool expand_operator_defined, IteratorT&nfirst, IteratorT const&nlast);
				template<typename IteratorT, typename ContainerT>
				token_type const&resolve_defined(IteratorT&first, IteratorT const&last, ContainerT&expanded);
				template<typename IteratorT, typename ContainerT>
				bool resolve_operator_pragma(IteratorT&first, IteratorT const&last, ContainerT&expanded, bool&seen_newline);
				template<typename ContainerT>
				bool concat_tokensequence(ContainerT&expanded);
				template<typename ContainerT>
				bool is_valid_concat(string_type new_value, position_type const&pos, ContainerT&rescanned);
			private:
				defined_macros_type*current_macros;
				boost::shared_ptr<defined_macros_type>defined_macros;
				token_type act_token;
				position_type main_pos;
				string_type base_name;
				ContextT&ctx;
				long macro_uid;
				predefined_macros predef;
			};
			template<typename ContextT>
			inline bool macromap<ContextT>::add_macro(token_type const&name, bool has_parameters, parameter_container_type&parameters, definition_container_type&definition, bool is_predefined, defined_macros_type*scope)
			{
				if(!is_predefined&&impl::is_special_macroname(name.get_value()))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<macro_handling_exception::severity_text(macro_handling_exception::illegal_redefinition)<<": "<<macro_handling_exception::error_text(macro_handling_exception::illegal_redefinition);
						if((name.get_value().c_str())[0]!=0)stream<<": "<<(name.get_value().c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), macro_handling_exception(stream.str().c_str(), macro_handling_exception::illegal_redefinition, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str(), (name.get_value().c_str())));
					};
					return false;
				}
				if(boost::wave::need_variadics(ctx.get_language())&&"__VA_ARGS__"==name.get_value())
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<macro_handling_exception::severity_text(macro_handling_exception::bad_define_statement_va_args)<<": "<<macro_handling_exception::error_text(macro_handling_exception::bad_define_statement_va_args);
						if((name.get_value().c_str())[0]!=0)stream<<": "<<(name.get_value().c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), macro_handling_exception(stream.str().c_str(), macro_handling_exception::bad_define_statement_va_args, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str(), (name.get_value().c_str())));
					};
					return false;
				}
				if(AltExtTokenType==(token_id(name)&ExtTokenOnlyMask))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<macro_handling_exception::severity_text(macro_handling_exception::illegal_operator_redefinition)<<": "<<macro_handling_exception::error_text(macro_handling_exception::illegal_operator_redefinition);
						if((name.get_value().c_str())[0]!=0)stream<<": "<<(name.get_value().c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), macro_handling_exception(stream.str().c_str(), macro_handling_exception::illegal_operator_redefinition, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str(), (name.get_value().c_str())));
					};
					return false;
				}
				defined_macros_type*current_scope=scope?scope: current_macros;
				typename defined_macros_type::iterator it=current_scope->find(name.get_value());
				if(it!=current_scope->end())
				{
					macro_definition_type*macrodef=(*it).second.get();
					if(macrodef->is_functionlike!=has_parameters||!impl::parameters_equal(macrodef->macroparameters, parameters)||!impl::definition_equals(macrodef->macrodefinition, definition))
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<macro_handling_exception::severity_text(macro_handling_exception::macro_redefinition)<<": "<<macro_handling_exception::error_text(macro_handling_exception::macro_redefinition);
							if((name.get_value().c_str())[0]!=0)stream<<": "<<(name.get_value().c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), macro_handling_exception(stream.str().c_str(), macro_handling_exception::macro_redefinition, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str(), (name.get_value().c_str())));
						};
					}
					return false;
				}
				if(has_parameters)
				{
					std::set<typename token_type::string_type>names;
					typedef typename parameter_container_type::iterator parameter_iterator_type;
					typedef typename std::set<typename token_type::string_type>::iterator name_iterator_type;
					parameter_iterator_type end=parameters.end();
					for(parameter_iterator_type itp=parameters.begin();
					itp!=end;
					++itp)
					{
						name_iterator_type pit=names.find((*itp).get_value());
						if(pit!=names.end())
						{

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<macro_handling_exception::severity_text(macro_handling_exception::duplicate_parameter_name)<<": "<<macro_handling_exception::error_text(macro_handling_exception::duplicate_parameter_name);
								if(((*pit).c_str())[0]!=0)stream<<": "<<((*pit).c_str());
								stream<<std::ends;
								ctx.get_hooks().throw_exception(ctx.derived(), macro_handling_exception(stream.str().c_str(), macro_handling_exception::duplicate_parameter_name, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str(), (name.get_value().c_str())));
							};
							return false;
						}
						names.insert((*itp).get_value());
					}
				}
				std::pair<typename defined_macros_type::iterator, bool>p=current_scope->insert(typename defined_macros_type::value_type(name.get_value(), macro_ref_type(new macro_definition_type(name, has_parameters, is_predefined, ++macro_uid))));
				if(!p.second)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<macro_handling_exception::severity_text(macro_handling_exception::macro_insertion_error)<<": "<<macro_handling_exception::error_text(macro_handling_exception::macro_insertion_error);
						if((name.get_value().c_str())[0]!=0)stream<<": "<<(name.get_value().c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), macro_handling_exception(stream.str().c_str(), macro_handling_exception::macro_insertion_error, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str(), (name.get_value().c_str())));
					};
					return false;
				}
				std::swap((*p.first).second->macroparameters, parameters);
				std::swap((*p.first).second->macrodefinition, definition);
				ctx.get_hooks().defined_macro(ctx.derived(), name, has_parameters, (*p.first).second->macroparameters, (*p.first).second->macrodefinition, is_predefined);
				return true;
			}
			template<typename ContextT>
			inline bool macromap<ContextT>::is_defined(typename token_type::string_type const&name, typename defined_macros_type::iterator&it, defined_macros_type*scope)const
			{
				if(0==scope)scope=current_macros;
				if((it=scope->find(name))!=scope->end())return true;
				if(name.size()<8||'_'!=name[0]||'_'!=name[1])return false;
				return name=="__LINE__"||name=="__FILE__"||name=="__INCLUDE_LEVEL__";
			}
			template<typename ContextT>
			template<typename IteratorT>
			inline bool macromap<ContextT>::is_defined(IteratorT const&begin, IteratorT const&end)const
			{
				token_id id=token_id(*begin);
				if(T_IDENTIFIER!=id&&!((((id)&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false)&&!((((id)&boost::wave::ExtTokenTypeMask)==(OperatorTokenType|AltExtTokenType))?true: false)&&!((((id)&boost::wave::TokenTypeMask)==(BoolLiteralTokenType))?true: false))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::invalid_macroname)<<": "<<preprocess_exception::error_text(preprocess_exception::invalid_macroname);
						if((impl::get_full_name(begin, end).c_str())[0]!=0)stream<<": "<<(impl::get_full_name(begin, end).c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::invalid_macroname, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
					};
					return false;
				}
				IteratorT it=begin;
				string_type name((*it).get_value());
				typename defined_macros_type::iterator cit;
				if(++it!=end)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::invalid_macroname)<<": "<<preprocess_exception::error_text(preprocess_exception::invalid_macroname);
						if((impl::get_full_name(begin, end).c_str())[0]!=0)stream<<": "<<(impl::get_full_name(begin, end).c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::invalid_macroname, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
					};
					return false;
				}
				return is_defined(name, cit, 0);
			}
			template<typename ContextT>
			inline bool macromap<ContextT>::is_defined(string_type const&str)const
			{
				typename defined_macros_type::iterator cit;
				return is_defined(str, cit, 0);
			}
			template<typename ContextT>
			inline bool macromap<ContextT>::get_macro(string_type const&name, bool&has_parameters, bool&is_predefined, position_type&pos, parameter_container_type&parameters, definition_container_type&definition, defined_macros_type*scope)const
			{
				typename defined_macros_type::iterator it;
				if(!is_defined(name, it, scope))return false;
				macro_definition_type&macro_def=*(*it).second.get();
				has_parameters=macro_def.is_functionlike;
				is_predefined=macro_def.is_predefined;
				pos=macro_def.macroname.get_position();
				parameters=macro_def.macroparameters;
				definition=macro_def.macrodefinition;
				return true;
			}
			template<typename ContextT>
			inline bool macromap<ContextT>::remove_macro(string_type const&name, position_type const&pos, bool even_predefined)
			{
				typename defined_macros_type::iterator it=current_macros->find(name);
				if(it!=current_macros->end())
				{
					if((*it).second->is_predefined)
					{
						if(!even_predefined||impl::is_special_macroname(name))
						{

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<preprocess_exception::severity_text(preprocess_exception::bad_undefine_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_undefine_statement);
								if((name.c_str())[0]!=0)stream<<": "<<(name.c_str());
								stream<<std::ends;
								ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_undefine_statement, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
							};
							return false;
						}
					}
					current_macros->erase(it);
					token_type tok(T_IDENTIFIER, name, pos);
					ctx.get_hooks().undefined_macro(ctx.derived(), tok);
					return true;
				}
				else if(impl::is_special_macroname(name))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::bad_undefine_statement)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_undefine_statement);
						if((name.c_str())[0]!=0)stream<<": "<<(name.c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_undefine_statement, (pos).get_line(), (pos).get_column(), (pos).get_file().c_str()));
					};
				}
				return false;
			}
			template<typename ContextT>
			template<typename IteratorT, typename ContainerT>
			inline typename ContextT::token_type const&macromap<ContextT>::expand_tokensequence(IteratorT&first, IteratorT const&last, ContainerT&pending, ContainerT&expanded, bool&seen_newline, bool expand_operator_defined)
			{
				typedef impl::gen_unput_queue_iterator<IteratorT, token_type, ContainerT>gen_type;
				typedef typename gen_type::return_type iterator_type;
				iterator_type first_it=gen_type::generate(expanded, first);
				iterator_type last_it=gen_type::generate(last);
				on_exit::assign<IteratorT, iterator_type>on_exit(first, first_it);
				return expand_tokensequence_worker(pending, first_it, last_it, seen_newline, expand_operator_defined);
			}
			template<typename ContextT>
			template<typename IteratorT, typename ContainerT>
			inline typename ContextT::token_type const&macromap<ContextT>::expand_tokensequence_worker(ContainerT&pending, unput_queue_iterator<IteratorT, token_type, ContainerT>&first, unput_queue_iterator<IteratorT, token_type, ContainerT>const&last, bool&seen_newline, bool expand_operator_defined)
			{
				if(!pending.empty())
				{
					on_exit::pop_front<definition_container_type>pop_front_token(pending);
					return act_token=pending.front();
				}
				using namespace boost::wave;
				typedef unput_queue_iterator<IteratorT, token_type, ContainerT>iterator_type;
				if(first!=last)
				{
					token_id id=token_id(*first);
					if(T_PLACEHOLDER==id)
					{
						token_type placeholder=*first;
						++first;
						if(first==last)return act_token=placeholder;
						id=token_id(*first);
					}
					if(T_IDENTIFIER==id||((((id)&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false)||((((id)&boost::wave::ExtTokenTypeMask)==(OperatorTokenType|AltExtTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(BoolLiteralTokenType))?true: false))
					{
						if(expand_operator_defined&&(*first).get_value()=="defined")
						{
							return resolve_defined(first, last, pending);
						}
						else if(boost::wave::need_variadics(ctx.get_language())&&(*first).get_value()=="_Pragma")
						{
							token_type curr_token=*first;
							if(!resolve_operator_pragma(first, last, pending, seen_newline)||pending.size()>0)
							{
								on_exit::pop_front<definition_container_type>pop_token(pending);
								return act_token=pending.front();
							}
							return act_token=token_type(T_PLACEHOLDER, "_", curr_token.get_position());
						}
						token_type name_token(*first);
						typename defined_macros_type::iterator it;
						if(is_defined(name_token.get_value(), it))
						{
							if(expand_macro(pending, name_token, it, first, last, seen_newline, expand_operator_defined))
							{
								if(first!=last)
								{
									typename ContainerT::reverse_iterator rit=pending.rbegin();
									first.get_unput_queue().splice(first.get_unput_queue().begin(), pending, (++rit).base(), pending.end());
								}
							}
							else if(!pending.empty())
							{
								on_exit::pop_front<definition_container_type>pop_queue(pending);
								return act_token=pending.front();
							}
							else
							{
								return act_token=token_type();
							}
							return expand_tokensequence_worker(pending, first, last, seen_newline, expand_operator_defined);
						}
						else
						{
							act_token=name_token;
							++first;
							return act_token;
						}
					}
					else if(expand_operator_defined&&((((*first)&boost::wave::TokenTypeMask)==(BoolLiteralTokenType))?true: false))
					{
						return act_token=token_type(T_INTLIT, T_TRUE!=id?"0": "1", (*first++).get_position());
					}
					else
					{
						act_token=*first;
						++first;
						return act_token;
					}
				}
				return act_token=token_type();
			}
			template<typename ContextT>
			template<typename IteratorT, typename ContainerT, typename SizeT>
			inline typename std::vector<ContainerT>::size_type macromap<ContextT>::collect_arguments(token_type const curr_token, std::vector<ContainerT>&arguments, IteratorT&next, IteratorT&endparen, IteratorT const&end, SizeT const&parameter_count, bool&seen_newline)
			{
				using namespace boost::wave;
				arguments.push_back(ContainerT());
				typename std::vector<ContainerT>::size_type count_arguments=0;
				int nested_parenthesis_level=1;
				ContainerT*argument=&arguments[0];
				bool was_whitespace=false;
				token_type startof_argument_list=*next;
				while(++next!=end&&nested_parenthesis_level)
				{
					token_id id=token_id(*next);
					if(0==parameter_count&&!(((((*next))&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&id!=T_NEWLINE&&id!=T_RIGHTPAREN&&id!=T_LEFTPAREN)
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::too_many_macroarguments)<<": "<<preprocess_exception::error_text(preprocess_exception::too_many_macroarguments);
							if((curr_token.get_value().c_str())[0]!=0)stream<<": "<<(curr_token.get_value().c_str());
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::too_many_macroarguments, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
						};
						return 0;
					}
					switch(static_cast<unsigned int>(id))
					{
						case T_LEFTPAREN: ++nested_parenthesis_level;
						argument->push_back(*next);
						was_whitespace=false;
						break;
						case T_RIGHTPAREN:
						{
							if(--nested_parenthesis_level>=1)argument->push_back(*next);
							else
							{
								endparen=next;
								if(parameter_count>0)
								{
									if(argument->empty()||impl::is_whitespace_only(*argument))
									{
										if(boost::wave::need_variadics(ctx.get_language()))
										{
											argument->push_back(token_type(T_PLACEMARKER, "\xA7", (*next).get_position()));
											++count_arguments;
										}
									}
									else
									{
										++count_arguments;
									}
								}
							}
							was_whitespace=false;
						}
						break;
						case T_COMMA: if(1==nested_parenthesis_level)
						{
							if(argument->empty()||impl::is_whitespace_only(*argument))
							{
								if(boost::wave::need_variadics(ctx.get_language()))
								{
									argument->push_back(token_type(T_PLACEMARKER, "\xA7", (*next).get_position()));
									++count_arguments;
								}
							}
							else
							{
								++count_arguments;
							}
							arguments.push_back(ContainerT());
							argument=&arguments[arguments.size()-1];
						}
						else
						{
							argument->push_back(*next);
						}
						was_whitespace=false;
						break;
						case T_NEWLINE: seen_newline=true;
						case T_SPACE: case T_SPACE2: case T_CCOMMENT: if(!was_whitespace)argument->push_back(token_type(T_SPACE, " ", (*next).get_position()));
						was_whitespace=true;
						break;
						case T_PLACEHOLDER: break;
						default: argument->push_back(*next);
						was_whitespace=false;
						break;
					}
				}
				if(nested_parenthesis_level>=1)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::improperly_terminated_macro)<<": "<<preprocess_exception::error_text(preprocess_exception::improperly_terminated_macro);
						if(("missing ')'")[0]!=0)stream<<": "<<("missing ')'");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::improperly_terminated_macro, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
					};
					return 0;
				}
				if(0==parameter_count&&0==count_arguments)
				{
					(void)((!!(1==arguments.size()))||(_wassert(L"1 == arguments.size()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap.hpp", 841), 0));
					arguments.clear();
				}
				return count_arguments;
			}
			template<typename ContextT>
			template<typename IteratorT, typename ContainerT>
			inline void macromap<ContextT>::expand_whole_tokensequence(ContainerT&expanded, IteratorT&first, IteratorT const&last, bool expand_operator_defined)
			{
				typedef impl::gen_unput_queue_iterator<IteratorT, token_type, ContainerT>gen_type;
				typedef typename gen_type::return_type iterator_type;
				ContainerT empty;
				iterator_type first_it=gen_type::generate(empty, first);
				iterator_type last_it=gen_type::generate(last);
				on_exit::assign<IteratorT, iterator_type>on_exit(first, first_it);
				ContainerT pending_queue;
				bool seen_newline;
				while(!pending_queue.empty()||first_it!=last_it)
				{
					expanded.push_back(expand_tokensequence_worker(pending_queue, first_it, last_it, seen_newline, expand_operator_defined));
				}
				(void)((!!(pending_queue.empty()))||(_wassert(L"pending_queue.empty()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap.hpp", 881), 0));
			}
			template<typename ContextT>
			template<typename ContainerT>
			inline void macromap<ContextT>::expand_argument(typename std::vector<ContainerT>::size_type arg, std::vector<ContainerT>&arguments, std::vector<ContainerT>&expanded_args, bool expand_operator_defined, std::vector<bool>&has_expanded_args)
			{
				if(!has_expanded_args[arg])
				{
					typedef typename std::vector<ContainerT>::value_type::iterator argument_iterator_type;
					argument_iterator_type begin_it=arguments[arg].begin();
					argument_iterator_type end_it=arguments[arg].end();
					expand_whole_tokensequence(expanded_args[arg], begin_it, end_it, expand_operator_defined);
					impl::remove_placeholders(expanded_args[arg]);
					has_expanded_args[arg]=true;
				}
			}
			template<typename ContextT>
			template<typename ContainerT>
			inline void macromap<ContextT>::expand_replacement_list(macro_definition_type const&macrodef, std::vector<ContainerT>&arguments, bool expand_operator_defined, ContainerT&expanded)
			{
				using namespace boost::wave;
				typedef typename macro_definition_type::const_definition_iterator_t macro_definition_iter_t;
				std::vector<ContainerT>expanded_args(arguments.size());
				std::vector<bool>has_expanded_args(arguments.size());
				bool seen_concat=false;
				bool adjacent_concat=false;
				bool adjacent_stringize=false;
				macro_definition_iter_t cend=macrodef.macrodefinition.end();
				for(macro_definition_iter_t cit=macrodef.macrodefinition.begin();
				cit!=cend;
				++cit)
				{
					bool use_replaced_arg=true;
					token_id base_id=boost::wave::token_id((token_id(*cit))&boost::wave::MainTokenMask);
					if(T_POUND_POUND==base_id)
					{
						adjacent_concat=true;
						seen_concat=true;
					}
					else if(T_POUND==base_id)
					{
						adjacent_stringize=true;
					}
					else
					{
						if(adjacent_stringize||adjacent_concat||T_POUND_POUND==impl::next_token<macro_definition_iter_t>::peek(cit, cend))
						{
							use_replaced_arg=false;
						}
						if(adjacent_concat)adjacent_concat=((((*cit)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false);
					}
					if((((((*cit))&boost::wave::TokenTypeMask)==(ParameterTokenType))?true: false))
					{
						typename ContainerT::size_type i;
						bool is_ellipsis=false;
						if((((((*cit))&boost::wave::ExtTokenTypeMask)==(ExtParameterTokenType))?true: false))
						{
							(void)((!!(boost::wave::need_variadics(ctx.get_language())))||(_wassert(L"boost::wave::need_variadics(ctx.get_language())", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap.hpp", 975), 0));
							i=token_id(*cit)-T_EXTPARAMETERBASE;
							is_ellipsis=true;
						}
						else
						{
							i=token_id(*cit)-T_PARAMETERBASE;
						}
						(void)((!!(i<arguments.size()))||(_wassert(L"i < arguments.size()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap.hpp", 985), 0));
						if(use_replaced_arg)
						{
							if(is_ellipsis)
							{
								position_type const&pos=(*cit).get_position();
								(void)((!!(boost::wave::need_variadics(ctx.get_language())))||(_wassert(L"boost::wave::need_variadics(ctx.get_language())", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap.hpp", 992), 0));
								for(typename vector<ContainerT>::size_type arg=i;
								arg<expanded_args.size();
								++arg)
								{
									expand_argument(arg, arguments, expanded_args, expand_operator_defined, has_expanded_args);
								}
								impl::replace_ellipsis(expanded_args, i, expanded, pos);
							}
							else
							{
								expand_argument(i, arguments, expanded_args, expand_operator_defined, has_expanded_args);
								ContainerT const&arg=expanded_args[i];
								std::copy(arg.begin(), arg.end(), std::inserter(expanded, expanded.end()));
							}
						}
						else if(adjacent_stringize&&!((((*cit)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
						{
							(void)((!!(!arguments[i].empty()))||(_wassert(L"!arguments[i].empty()", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap.hpp", 1021), 0));
							position_type pos((*arguments[i].begin()).get_position());
							if(is_ellipsis&&boost::wave::need_variadics(ctx.get_language()))
							{
								impl::trim_sequence_left(arguments[i]);
								impl::trim_sequence_right(arguments.back());
								expanded.push_back(token_type(T_STRINGLIT, impl::as_stringlit(arguments, i, pos), pos));
							}
							else
							{
								impl::trim_sequence(arguments[i]);
								expanded.push_back(token_type(T_STRINGLIT, impl::as_stringlit(arguments[i], pos), pos));
							}
							adjacent_stringize=false;
						}
						else
						{
							if(is_ellipsis)
							{
								position_type const&pos=(*cit).get_position();
								impl::trim_sequence_left(arguments[i]);
								impl::trim_sequence_right(arguments.back());
								(void)((!!(boost::wave::need_variadics(ctx.get_language())))||(_wassert(L"boost::wave::need_variadics(ctx.get_language())", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap.hpp", 1050), 0));
								impl::replace_ellipsis(arguments, i, expanded, pos);
							}
							else
							{
								ContainerT&arg=arguments[i];
								impl::trim_sequence(arg);
								std::copy(arg.begin(), arg.end(), std::inserter(expanded, expanded.end()));
							}
						}
					}
					else if(!adjacent_stringize||T_POUND!=base_id)
					{
						expanded.push_back(*cit);
					}
				}
				if(adjacent_stringize)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_operator)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_operator);
						if(("stringize ('#')")[0]!=0)stream<<": "<<("stringize ('#')");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_operator, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
					};
					return ;
				}
				if(seen_concat)concat_tokensequence(expanded);
			}
			template<typename ContextT>
			template<typename IteratorT, typename ContainerT>
			inline void macromap<ContextT>::rescan_replacement_list(token_type const&curr_token, macro_definition_type&macro_def, ContainerT&replacement_list, ContainerT&expanded, bool expand_operator_defined, IteratorT&nfirst, IteratorT const&nlast)
			{
				if(!replacement_list.empty())
				{
					if(boost::wave::need_variadics(ctx.get_language()))
					{
						typename ContainerT::iterator end=replacement_list.end();
						typename ContainerT::iterator it=replacement_list.begin();
						while(it!=end)
						{
							using namespace boost::wave;
							if(T_PLACEMARKER==token_id(*it))
							{
								typename ContainerT::iterator placemarker=it;
								++it;
								replacement_list.erase(placemarker);
							}
							else
							{
								++it;
							}
						}
					}
					on_exit::reset<bool>on_exit(macro_def.is_available_for_replacement, false);
					typename ContainerT::iterator begin_it=replacement_list.begin();
					typename ContainerT::iterator end_it=replacement_list.end();
					expand_whole_tokensequence(expanded, begin_it, end_it, expand_operator_defined);
					impl::trim_replacement_list(expanded);
				}
				if(expanded.empty())
				{
					expanded.push_back(token_type(T_PLACEHOLDER, "_", curr_token.get_position()));
				}
			}
			template<typename ContextT>
			template<typename IteratorT, typename ContainerT>
			inline bool macromap<ContextT>::expand_macro(ContainerT&expanded, token_type const&curr_token, typename defined_macros_type::iterator it, IteratorT&first, IteratorT const&last, bool&seen_newline, bool expand_operator_defined, defined_macros_type*scope, ContainerT*queue_symbol)
			{
				using namespace boost::wave;
				if(0==scope)scope=current_macros;
				(void)((!!(T_IDENTIFIER==token_id(curr_token)||((((token_id(curr_token))&boost::wave::TokenTypeMask)==(KeywordTokenType))?true: false)||((((token_id(curr_token))&boost::wave::ExtTokenTypeMask)==(OperatorTokenType|AltExtTokenType))?true: false)||((((token_id(curr_token))&boost::wave::TokenTypeMask)==(BoolLiteralTokenType))?true: false)))||(_wassert(L"T_IDENTIFIER == token_id(curr_token) || ((((token_id(curr_token)) & boost::wave::TokenTypeMask) == (KeywordTokenType)) ? true : false) || ((((token_id(curr_token)) & boost::wave::ExtTokenTypeMask) == (OperatorTokenType|AltExtTokenType)) ? true : false) || ((((token_id(curr_token)) & boost::wave::TokenTypeMask) == (BoolLiteralTokenType)) ? true : false)", L"D:\\dev\\boost_1_41_0\\boost\\wave\\util\\cpp_macromap.hpp", 1162), 0));
				if(it==scope->end())
				{
					++first;
					if(expand_predefined_macro(curr_token, expanded))return false;
					if(0!=queue_symbol)
					{
						expanded.splice(expanded.end(), *queue_symbol);
					}
					else
					{
						expanded.push_back(curr_token);
					}
					return false;
				}
				macro_definition_type&macro_def=*(*it).second.get();
				macro_def.replace_parameters();
				if(!macro_def.is_available_for_replacement)
				{
					if(0!=queue_symbol)
					{
						queue_symbol->push_back(token_type(T_NONREPLACABLE_IDENTIFIER, curr_token.get_value(), curr_token.get_position()));
						expanded.splice(expanded.end(), *queue_symbol);
					}
					else
					{
						expanded.push_back(token_type(T_NONREPLACABLE_IDENTIFIER, curr_token.get_value(), curr_token.get_position()));
					}
					++first;
					return false;
				}
				ContainerT replacement_list;
				if(T_LEFTPAREN==impl::next_token<IteratorT>::peek(first, last))
				{
					impl::skip_to_token(first, last, T_LEFTPAREN, seen_newline);
					IteratorT seqstart=first;
					IteratorT seqend=first;
					if(macro_def.is_functionlike)
					{
						std::vector<ContainerT>arguments;
						typename std::vector<ContainerT>::size_type count_args=collect_arguments(curr_token, arguments, first, seqend, last, macro_def.macroparameters.size(), seen_newline);
						if(count_args<macro_def.macroparameters.size()||arguments.size()<macro_def.macroparameters.size())
						{
							if(count_args!=arguments.size())
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::empty_macroarguments)<<": "<<preprocess_exception::error_text(preprocess_exception::empty_macroarguments);
									if((curr_token.get_value().c_str())[0]!=0)stream<<": "<<(curr_token.get_value().c_str());
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::empty_macroarguments, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
								};
							}
							else
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::too_few_macroarguments)<<": "<<preprocess_exception::error_text(preprocess_exception::too_few_macroarguments);
									if((curr_token.get_value().c_str())[0]!=0)stream<<": "<<(curr_token.get_value().c_str());
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::too_few_macroarguments, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
								};
							}
							return false;
						}
						if(count_args>macro_def.macroparameters.size()||arguments.size()>macro_def.macroparameters.size())
						{
							if(!macro_def.has_ellipsis)
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::too_many_macroarguments)<<": "<<preprocess_exception::error_text(preprocess_exception::too_many_macroarguments);
									if((curr_token.get_value().c_str())[0]!=0)stream<<": "<<(curr_token.get_value().c_str());
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::too_many_macroarguments, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
								};
								return false;
							}
						}
						if(ctx.get_hooks().expanding_function_like_macro(ctx.derived(), macro_def.macroname, macro_def.macroparameters, macro_def.macrodefinition, curr_token, arguments, seqstart, seqend))
						{
							std::copy(seqstart, first, std::inserter(replacement_list, replacement_list.end()));
							return false;
						}
						expand_replacement_list(macro_def, arguments, expand_operator_defined, replacement_list);
					}
					else
					{
						if(ctx.get_hooks().expanding_object_like_macro(ctx.derived(), macro_def.macroname, macro_def.macrodefinition, curr_token))
						{
							replacement_list.push_back(curr_token);
							++first;
							return false;
						}
						bool found=false;
						impl::find_concat_operator concat_tag(found);
						std::remove_copy_if(macro_def.macrodefinition.begin(), macro_def.macrodefinition.end(), std::inserter(replacement_list, replacement_list.end()), concat_tag);
						if(found&&!concat_tokensequence(replacement_list))return false;
					}
				}
				else
				{
					if((*it).second->is_functionlike)
					{
						if(0!=queue_symbol)
						{
							queue_symbol->push_back(curr_token);
							expanded.splice(expanded.end(), *queue_symbol);
						}
						else
						{
							expanded.push_back(curr_token);
						}
						++first;
						return false;
					}
					else
					{
						if(ctx.get_hooks().expanding_object_like_macro(ctx.derived(), macro_def.macroname, macro_def.macrodefinition, curr_token))
						{
							replacement_list.push_back(curr_token);
							++first;
							return false;
						}
						bool found=false;
						impl::find_concat_operator concat_tag(found);
						std::remove_copy_if(macro_def.macrodefinition.begin(), macro_def.macrodefinition.end(), std::inserter(replacement_list, replacement_list.end()), concat_tag);
						if(found&&!concat_tokensequence(replacement_list))return false;
						++first;
					}
				}
				ContainerT expanded_list;
				ctx.get_hooks().expanded_macro(ctx.derived(), replacement_list);
				rescan_replacement_list(curr_token, macro_def, replacement_list, expanded_list, expand_operator_defined, first, last);
				ctx.get_hooks().rescanned_macro(ctx.derived(), expanded_list);
				expanded.splice(expanded.end(), expanded_list);
				return true;
			}
			template<typename ContextT>
			template<typename ContainerT>
			inline bool macromap<ContextT>::expand_predefined_macro(token_type const&curr_token, ContainerT&expanded)
			{
				using namespace boost::wave;
				string_type const&value=curr_token.get_value();
				if(value.size()<8||'_'!=value[0]||'_'!=value[1])return false;
				if(value=="__LINE__")
				{
					char buffer[22];
					using namespace std;
					sprintf(buffer, "%d", main_pos.get_line());
					expanded.push_back(token_type(T_INTLIT, buffer, curr_token.get_position()));
					return true;
				}
				else if(value=="__FILE__")
				{
					namespace fs=boost::filesystem;
					std::string file("\"");
					fs::path filename(wave::util::create_path(main_pos.get_file().c_str()));
					using boost::wave::util::impl::escape_lit;
					file+=escape_lit(wave::util::native_file_string(filename))+"\"";
					expanded.push_back(token_type(T_STRINGLIT, file.c_str(), curr_token.get_position()));
					return true;
				}
				else if(value=="__INCLUDE_LEVEL__")
				{
					char buffer[22];
					using namespace std;
					sprintf(buffer, "%d", (int)ctx.get_iteration_depth());
					expanded.push_back(token_type(T_INTLIT, buffer, curr_token.get_position()));
					return true;
				}
				return false;
			}
			template<typename ContextT>
			template<typename IteratorT, typename ContainerT>
			inline typename ContextT::token_type const&macromap<ContextT>::resolve_defined(IteratorT&first, IteratorT const&last, ContainerT&pending)
			{
				using namespace boost::wave;
				using namespace boost::wave::grammars;
				ContainerT result;
				IteratorT start=first;
				boost::spirit::classic::parse_info<IteratorT>hit=defined_grammar_gen<typename ContextT::lexer_type>::parse_operator_defined(start, last, result);
				if(!hit.hit)
				{
					string_type msg("defined(): ");
					msg=msg+util::impl::as_string<string_type>(first, last);

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_expression)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_expression);
						if((msg.c_str())[0]!=0)stream<<": "<<(msg.c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_expression, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
					};
					pending.push_back(token_type(T_INTLIT, "0", main_pos));
				}
				else
				{
					impl::assign_iterator<IteratorT>::do_(first, hit.stop);
					pending.push_back(token_type(T_INTLIT, is_defined(result.begin(), result.end())?"1": "0", main_pos));
				}
				on_exit::pop_front<definition_container_type>pop_front_token(pending);
				return act_token=pending.front();
			}
			template<typename ContextT>
			template<typename IteratorT, typename ContainerT>
			inline bool macromap<ContextT>::resolve_operator_pragma(IteratorT&first, IteratorT const&last, ContainerT&pending, bool&seen_newline)
			{
				token_type pragma_token=*first;
				if(!impl::skip_to_token(first, last, T_LEFTPAREN, seen_newline))
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_expression)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_expression);
						if(("operator _Pragma()")[0]!=0)stream<<": "<<("operator _Pragma()");
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_expression, (pragma_token.get_position()).get_line(), (pragma_token.get_position()).get_column(), (pragma_token.get_position()).get_file().c_str()));
					};
					return false;
				}
				std::vector<ContainerT>arguments;
				IteratorT endparen=first;
				typename std::vector<ContainerT>::size_type count_args=collect_arguments(pragma_token, arguments, first, endparen, last, 1, seen_newline);
				if(pragma_token.get_position().get_file().empty())pragma_token.set_position(act_token.get_position());
				if(count_args<1||arguments.size()<1)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::too_few_macroarguments)<<": "<<preprocess_exception::error_text(preprocess_exception::too_few_macroarguments);
						if((pragma_token.get_value().c_str())[0]!=0)stream<<": "<<(pragma_token.get_value().c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::too_few_macroarguments, (pragma_token.get_position()).get_line(), (pragma_token.get_position()).get_column(), (pragma_token.get_position()).get_file().c_str()));
					};
					return false;
				}
				if(count_args>1||arguments.size()>1)
				{

					{
						using namespace boost::wave;
						std::stringstream stream;
						stream<<preprocess_exception::severity_text(preprocess_exception::too_many_macroarguments)<<": "<<preprocess_exception::error_text(preprocess_exception::too_many_macroarguments);
						if((pragma_token.get_value().c_str())[0]!=0)stream<<": "<<(pragma_token.get_value().c_str());
						stream<<std::ends;
						ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::too_many_macroarguments, (pragma_token.get_position()).get_line(), (pragma_token.get_position()).get_column(), (pragma_token.get_position()).get_file().c_str()));
					};
					return false;
				}
				typedef typename std::vector<ContainerT>::value_type::iterator argument_iterator_type;
				ContainerT expanded;
				argument_iterator_type begin_it=arguments[0].begin();
				argument_iterator_type end_it=arguments[0].end();
				expand_whole_tokensequence(expanded, begin_it, end_it, false);
				typedef typename token_type::string_type string_type;
				string_type pragma_cmd;
				typename ContainerT::const_iterator end_exp=expanded.end();
				for(typename ContainerT::const_iterator it_exp=expanded.begin();
				it_exp!=end_exp;
				++it_exp)
				{
					if(T_EOF==token_id(*it_exp))break;
					if(((((*it_exp)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))continue;
					if(T_STRINGLIT!=token_id(*it_exp))
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_pragma_option)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_pragma_option);
							if(("_Pragma")[0]!=0)stream<<": "<<("_Pragma");
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_pragma_option, (pragma_token.get_position()).get_line(), (pragma_token.get_position()).get_column(), (pragma_token.get_position()).get_file().c_str()));
						};
						return false;
					}
					if(pragma_cmd.size()>0)
					{

						{
							using namespace boost::wave;
							std::stringstream stream;
							stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_pragma_option)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_pragma_option);
							if(("_Pragma")[0]!=0)stream<<": "<<("_Pragma");
							stream<<std::ends;
							ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_pragma_option, (pragma_token.get_position()).get_line(), (pragma_token.get_position()).get_column(), (pragma_token.get_position()).get_file().c_str()));
						};
						return false;
					}
					string_type token_str=(*it_exp).get_value();
					pragma_cmd+=token_str.substr(1, token_str.size()-2);
				}
				string_type pragma_cmd_unesc=impl::unescape_lit(pragma_cmd);
				typedef typename ContextT::lexer_type lexer_type;
				ContainerT pragma;
				std::string pragma_cmd_str(pragma_cmd_unesc.c_str());
				lexer_type it=lexer_type(pragma_cmd_str.begin(), pragma_cmd_str.end(), pragma_token.get_position(), ctx.get_language());
				lexer_type end=lexer_type();
				for(;
				it!=end;
				++it)pragma.push_back(*it);
				if(interpret_pragma(ctx, pragma_token, pragma.begin(), pragma.end(), pending))
				{
					return true;
				}
				pending.push_front(token_type(T_SPACE, " ", pragma_token.get_position()));
				pending.push_front(token_type(T_RIGHTPAREN, ")", pragma_token.get_position()));
				pending.push_front(token_type(T_STRINGLIT, string_type("\"")+pragma_cmd+"\"", pragma_token.get_position()));
				pending.push_front(token_type(T_LEFTPAREN, "(", pragma_token.get_position()));
				pending.push_front(pragma_token);
				return false;
			}
			template<typename ContextT>
			template<typename ContainerT>
			inline bool macromap<ContextT>::is_valid_concat(string_type new_value, position_type const&pos, ContainerT&rescanned)
			{
				typedef typename ContextT::lexer_type lexer_type;
				std::string value_to_test(new_value.c_str());
				boost::wave::language_support lang=boost::wave::enable_prefer_pp_numbers(ctx.get_language());
				lang=boost::wave::enable_single_line(lang);
				lexer_type it=lexer_type(value_to_test.begin(), value_to_test.end(), pos, lang);
				lexer_type end=lexer_type();
				for(;
				it!=end&&T_EOF!=token_id(*it);
				++it)rescanned.push_back(*it);
				if(boost::wave::need_variadics(ctx.get_language()))return true;
				return 1==rescanned.size();
			}
			template<typename ContextT>
			template<typename ContainerT>
			inline bool macromap<ContextT>::concat_tokensequence(ContainerT&expanded)
			{
				using namespace boost::wave;
				typedef typename ContainerT::iterator iterator_type;
				iterator_type end=expanded.end();
				iterator_type prev=end;
				for(iterator_type it=expanded.begin();
				it!=end;
				)
				{
					if(T_POUND_POUND==boost::wave::token_id((token_id(*it))&boost::wave::MainTokenMask))
					{
						iterator_type next=it;
						++next;
						if(prev==end||next==end)
						{

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_operator)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_operator);
								if(("concat ('##')")[0]!=0)stream<<": "<<("concat ('##')");
								stream<<std::ends;
								ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_operator, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
							};
							return false;
						}
						while(((((*next)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
						{
							++next;
							if(next==end)
							{

								{
									using namespace boost::wave;
									std::stringstream stream;
									stream<<preprocess_exception::severity_text(preprocess_exception::ill_formed_operator)<<": "<<preprocess_exception::error_text(preprocess_exception::ill_formed_operator);
									if(("concat ('##')")[0]!=0)stream<<": "<<("concat ('##')");
									stream<<std::ends;
									ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::ill_formed_operator, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
								};
								return false;
							}
						}
						if(boost::wave::need_variadics(ctx.get_language()))
						{
							if(T_PLACEMARKER==token_id(*next))
							{
								iterator_type first_to_delete=prev;
								expanded.erase(++first_to_delete, ++next);
								it=next;
								continue;
							}
							else if(T_PLACEMARKER==token_id(*prev))
							{
								iterator_type first_to_delete=prev;
								*prev=*next;
								expanded.erase(++first_to_delete, ++next);
								it=next;
								continue;
							}
						}
						string_type concat_result;
						ContainerT rescanned;
						concat_result=((*prev).get_value()+(*next).get_value());
						if(!is_valid_concat(concat_result, (*prev).get_position(), rescanned)&&!((((*prev)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)&&!((((*next)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))
						{
							string_type error_string("\"");
							error_string+=(*prev).get_value();
							error_string+="\" and \"";
							error_string+=(*next).get_value();
							error_string+="\"";

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<preprocess_exception::severity_text(preprocess_exception::invalid_concat)<<": "<<preprocess_exception::error_text(preprocess_exception::invalid_concat);
								if((error_string.c_str())[0]!=0)stream<<": "<<(error_string.c_str());
								stream<<std::ends;
								ctx.get_hooks().throw_exception(ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::invalid_concat, (main_pos).get_line(), (main_pos).get_column(), (main_pos).get_file().c_str()));
							};
							return false;
						}
						if(boost::wave::need_variadics(ctx.get_language()))
						{
							expanded.erase(prev, ++next);
							if(expanded.empty())end=next=expanded.end();
							expanded.splice(next, rescanned);
							prev=next;
							if(next!=expanded.end())--prev;
						}
						else
						{
							(*prev).set_value(concat_result);
							if(T_NONREPLACABLE_IDENTIFIER==token_id(*prev))(*prev).set_token_id(T_IDENTIFIER);
							iterator_type first_to_delete=prev;
							expanded.erase(++first_to_delete, ++next);
						}
						it=next;
						continue;
					}
					if(!((((*it)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false))prev=it;
					++it;
				}
				return true;
			}
			template<typename ContextT>
			inline void macromap<ContextT>::predefine_macro(defined_macros_type*scope, string_type const&name, token_type const&t)
			{
				definition_container_type macrodefinition;
				std::vector<token_type>param;
				macrodefinition.push_back(t);
				add_macro(token_type(T_IDENTIFIER, name, t.get_position()), false, param, macrodefinition, true, scope);
			}
			template<typename ContextT>
			inline void macromap<ContextT>::init_predefined_macros(char const*fname, defined_macros_type*scope, bool at_global_scope)
			{
				defined_macros_type*current_scope=scope?scope: current_macros;
				position_type pos("<built-in>");
				if(boost::wave::need_c99(ctx.get_language()))
				{
					for(int i=0;
					0!=predef.static_data_c99(i).name;
					++i)
					{
						predefined_macros::static_macros const&m=predef.static_data_c99(i);
						predefine_macro(current_scope, m.name, token_type(m.token_id, m.value, pos));
					}
				}
				else
				{
					for(int i=0;
					0!=predef.static_data_cpp(i).name;
					++i)
					{
						predefined_macros::static_macros const&m=predef.static_data_cpp(i);
						predefine_macro(current_scope, m.name, token_type(m.token_id, m.value, pos));
					}
					if(boost::wave::need_variadics(ctx.get_language()))
					{
						predefine_macro(current_scope, "__WAVE_HAS_VARIADICS__", token_type(T_INTLIT, "1", pos));
					}
				}
				namespace fs=boost::filesystem;
				if(string_type(fname)!="<Unknown>")
				{
					fs::path filename(create_path(fname));
					using boost::wave::util::impl::escape_lit;
					predefine_macro(current_scope, "__BASE_FILE__", token_type(T_STRINGLIT, string_type("\"")+escape_lit(native_file_string(filename)).c_str()+"\"", pos));
					base_name=fname;
				}
				else if(!base_name.empty())
				{
					fs::path filename(create_path(base_name.c_str()));
					using boost::wave::util::impl::escape_lit;
					predefine_macro(current_scope, "__BASE_FILE__", token_type(T_STRINGLIT, string_type("\"")+escape_lit(native_file_string(filename)).c_str()+"\"", pos));
				}
				for(int j=0;
				0!=predef.dynamic_data(j).name;
				++j)
				{
					predefined_macros::dynamic_macros const&m=predef.dynamic_data(j);
					predefine_macro(current_scope, m.name, token_type(m.token_id, (predef.*m.generator)(), pos));
				}
			}
			template<typename ContextT>
			inline void macromap<ContextT>::reset_macromap()
			{
				current_macros->clear();
				predef.reset();
				act_token=token_type();
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		struct this_type
		{
		};
		template<typename IteratorT, typename LexIteratorT, typename InputPolicyT=iteration_context_policies::load_file_to_string, typename HooksT=context_policies::eat_whitespace<typename LexIteratorT::token_type>, typename DerivedT=this_type>
		class context: private boost::noncopyable
		{
		private:
			typedef typename mpl::if_<is_same<DerivedT, this_type>, context, DerivedT>::type actual_context_type;
		public:
			enum
			{
				boost_concept_check102=sizeof(::boost::concept::require_((void(*)(boost::ForwardIteratorConcept<IteratorT>))0))
			};
			typedef typename LexIteratorT::token_type token_type;
			typedef typename token_type::string_type string_type;
			typedef IteratorT target_iterator_type;
			typedef LexIteratorT lexer_type;
			typedef pp_iterator<context>iterator_type;
			typedef InputPolicyT input_policy_type;
			typedef typename token_type::position_type position_type;
			typedef std::list<token_type, boost::fast_pool_allocator<token_type> >token_sequence_type;
			typedef HooksT hook_policy_type;
		private:
			typedef boost::shared_ptr<base_iteration_context<context, lexer_type> >iteration_ptr_type;
			typedef boost::wave::util::iteration_context_stack<iteration_ptr_type>iteration_context_stack_type;
			typedef typename iteration_context_stack_type::size_type iter_size_type;
			context*this_()
			{
				return this;
			}
		public:
			context(target_iterator_type const&first_, target_iterator_type const&last_, char const*fname="<Unknown>", HooksT const&hooks_=HooksT()): first(first_), last(last_), filename(fname), has_been_initialized(false), current_filename(fname), macros(*this_()), language(language_support(support_cpp|support_option_convert_trigraphs|support_option_emit_line_directives|support_option_include_guard_detection|support_option_emit_pragma_directives|support_option_insert_whitespace)), hooks(hooks_)
			{
				macros.init_predefined_macros(fname);
			}
			iterator_type begin()
			{
				std::string fname(filename);
				if(filename!="<Unknown>"&&filename!="<stdin>")
				{
					using namespace boost::filesystem;
					path fpath(complete(path(filename)));
					fname=fpath.string();
				}
				return iterator_type(*this, first, last, position_type(fname.c_str()));
			}
			iterator_type begin(target_iterator_type const&first_, target_iterator_type const&last_)
			{
				std::string fname(filename);
				if(filename!="<Unknown>"&&filename!="<stdin>")
				{
					using namespace boost::filesystem;
					path fpath(complete(path(filename)));
					fname=fpath.string();
				}
				return iterator_type(*this, first_, last_, position_type(fname.c_str()));
			}
			iterator_type end()const
			{
				return iterator_type();
			}
			bool add_include_path(char const*path_)
			{
				return includes.add_include_path(path_, false);
			}
			bool add_sysinclude_path(char const*path_)
			{
				return includes.add_include_path(path_, true);
			}
			void set_sysinclude_delimiter()
			{
				includes.set_sys_include_delimiter();
			}
			typename iteration_context_stack_type::size_type get_iteration_depth()const
			{
				return iter_ctxs.size();
			}
			template<typename StringT>
			bool add_macro_definition(StringT macrostring, bool is_predefined=false)
			{
				return boost::wave::util::add_macro_definition(*this, util::to_string<std::string>(macrostring), is_predefined, get_language());
			}
			template<typename StringT>
			bool add_macro_definition(StringT const&name, position_type const&pos, bool has_params, std::vector<token_type>&parameters, token_sequence_type&definition, bool is_predefined=false)
			{
				return macros.add_macro(token_type(T_IDENTIFIER, util::to_string<string_type>(name), pos), has_params, parameters, definition, is_predefined);
			}
			template<typename StringT>
			bool is_defined_macro(StringT const&str)const
			{
				return macros.is_defined(util::to_string<string_type>(str));
			}
			template<typename StringT>
			bool get_macro_definition(StringT const&name, bool&has_params, bool&is_predefined, position_type&pos, std::vector<token_type>&parameters, token_sequence_type&definition)const
			{
				return macros.get_macro(util::to_string<string_type>(name), has_params, is_predefined, pos, parameters, definition);
			}
			template<typename StringT>
			bool remove_macro_definition(StringT const&name, bool even_predefined=false)
			{
				includes.remove_pragma_once_header(util::to_string<std::string>(name));
				return macros.remove_macro(util::to_string<string_type>(name), macros.get_main_pos(), even_predefined);
			}
			void reset_macro_definitions()
			{
				macros.reset_macromap();
				macros.init_predefined_macros();
			}
			typedef boost::wave::util::macromap<context>macromap_type;
			typedef typename macromap_type::name_iterator name_iterator;
			typedef typename macromap_type::const_name_iterator const_name_iterator;
			name_iterator macro_names_begin()
			{
				return macros.begin();
			}
			name_iterator macro_names_end()
			{
				return macros.end();
			}
			const_name_iterator macro_names_begin()const
			{
				return macros.begin();
			}
			const_name_iterator macro_names_end()const
			{
				return macros.end();
			}
			bool add_macro_definition(token_type const&name, bool has_params, std::vector<token_type>&parameters, token_sequence_type&definition, bool is_predefined=false)
			{
				return macros.add_macro(name, has_params, parameters, definition, is_predefined);
			}
			static std::string get_version()
			{
				boost::wave::util::predefined_macros p;
				return util::to_string<std::string>(p.get_fullversion());
			}
			static std::string get_version_string()
			{
				boost::wave::util::predefined_macros p;
				return util::to_string<std::string>(p.get_versionstr());
			}
			void set_language(boost::wave::language_support language_, bool reset_macros=true)
			{
				language=language_;
				if(reset_macros)reset_macro_definitions();
			}
			boost::wave::language_support get_language()const
			{
				return language;
			}
			void set_max_include_nesting_depth(iter_size_type new_depth)
			{
				iter_ctxs.set_max_include_nesting_depth(new_depth);
			}
			iter_size_type get_max_include_nesting_depth()const
			{
				return iter_ctxs.get_max_include_nesting_depth();
			}
			hook_policy_type&get_hooks()
			{
				return hooks;
			}
			hook_policy_type const&get_hooks()const
			{
				return hooks;
			}
			actual_context_type&derived()
			{
				return *static_cast<actual_context_type*>(this);
			}
			actual_context_type const&derived()const
			{
				return *static_cast<actual_context_type const*>(this);
			}
			boost::filesystem::path get_current_directory()const
			{
				return includes.get_current_directory();
			}
			void init_context()
			{
				if(!has_been_initialized)
				{
					std::string fname(filename);
					if(filename!="<Unknown>"&&filename!="<stdin>")
					{
						using namespace boost::filesystem;
						path fpath(complete(path(filename)));
						fname=fpath.string();
						includes.set_current_directory(fname.c_str());
					}
					has_been_initialized=true;
				}
			}
			template<typename IteratorT2>
			bool is_defined_macro(IteratorT2 const&begin, IteratorT2 const&end)const
			{
				return macros.is_defined(begin, end);
			}
			bool find_include_file(std::string&s, std::string&d, bool is_system, char const*current_file)const
			{
				return includes.find_include_file(s, d, is_system, current_file);
			}
			void set_current_directory(char const*path_)
			{
				includes.set_current_directory(path_);
			}
			bool get_if_block_status()const
			{
				return ifblocks.get_status();
			}
			bool get_if_block_some_part_status()const
			{
				return ifblocks.get_some_part_status();
			}
			bool get_enclosing_if_block_status()const
			{
				return ifblocks.get_enclosing_status();
			}
			void enter_if_block(bool new_status)
			{
				ifblocks.enter_if_block(new_status);
			}
			bool enter_elif_block(bool new_status)
			{
				return ifblocks.enter_elif_block(new_status);
			}
			bool enter_else_block()
			{
				return ifblocks.enter_else_block();
			}
			bool exit_if_block()
			{
				return ifblocks.exit_if_block();
			}
			typename boost::wave::util::if_block_stack::size_type get_if_block_depth()const
			{
				return ifblocks.get_if_block_depth();
			}
			iteration_ptr_type pop_iteration_context()
			{
				iteration_ptr_type top=iter_ctxs.top();
				iter_ctxs.pop();
				return top;
			}
			void push_iteration_context(position_type const&act_pos, iteration_ptr_type iter_ctx)
			{
				iter_ctxs.push(*this, act_pos, iter_ctx);
			}
			position_type&get_main_pos()
			{
				return macros.get_main_pos();
			}
			template<typename IteratorT2>
			token_type expand_tokensequence(IteratorT2&first_, IteratorT2 const&last_, token_sequence_type&pending, token_sequence_type&expanded, bool&seen_newline, bool expand_undefined=false)
			{
				return macros.expand_tokensequence(first_, last_, pending, expanded, seen_newline, expand_undefined);
			}
			template<typename IteratorT2>
			void expand_whole_tokensequence(IteratorT2&first_, IteratorT2 const&last_, token_sequence_type&expanded, bool expand_undefined=true)
			{
				macros.expand_whole_tokensequence(expanded, first_, last_, expand_undefined);
				boost::wave::util::impl::remove_placeholders(expanded);
			}
		public:
			void set_current_filename(char const*real_name)
			{
				current_filename=real_name;
			}
			std::string const&get_current_filename()const
			{
				return current_filename;
			}
			bool has_pragma_once(std::string const&filename_)
			{
				return includes.has_pragma_once(filename_);
			}
			bool add_pragma_once_header(std::string const&filename_, std::string const&guard_name)
			{
				get_hooks().detected_include_guard(derived(), filename_, guard_name);
				return includes.add_pragma_once_header(filename_, guard_name);
			}
			bool add_pragma_once_header(token_type const&pragma_, std::string const&filename_)
			{
				get_hooks().detected_pragma_once(derived(), pragma_, filename_);
				return includes.add_pragma_once_header(filename_, "__BOOST_WAVE_PRAGMA_ONCE__");
			}
		private:
			target_iterator_type first;
			target_iterator_type last;
			std::string filename;
			bool has_been_initialized;
			std::string current_filename;
			boost::wave::util::if_block_stack ifblocks;
			boost::wave::util::include_paths includes;
			iteration_context_stack_type iter_ctxs;
			macromap_type macros;
			boost::wave::language_support language;
			hook_policy_type hooks;
		};
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace impl
			{
				template<typename StringTypeT, typename PositionT>
				class token_data
				{
				public:
					typedef StringTypeT string_type;
					typedef PositionT position_type;
					token_data(): id(T_EOI), refcnt(1)
					{
					}
					explicit token_data(int): id(T_UNKNOWN), refcnt(1)
					{
					}
					token_data(token_id id_, string_type const&value_, position_type const&pos_): id(id_), value(value_), pos(pos_), refcnt(1)
					{
					}
					token_data(token_data const&rhs): id(rhs.id), value(rhs.value), pos(rhs.pos), refcnt(1)
					{
					}
					~token_data()
					{
					}
					std::size_t addref()
					{
						return ++refcnt;
					}
					std::size_t release()
					{
						return --refcnt;
					}
					std::size_t get_refcnt()const
					{
						return refcnt;
					}
					operator token_id()const
					{
						return id;
					}
					string_type const&get_value()const
					{
						return value;
					}
					position_type const&get_position()const
					{
						return pos;
					}
					void set_token_id(token_id id_)
					{
						id=id_;
					}
					void set_value(string_type const&value_)
					{
						value=value_;
					}
					void set_position(position_type const&pos_)
					{
						pos=pos_;
					}
					friend bool operator==(token_data const&lhs, token_data const&rhs)
					{
						return (lhs.id==rhs.id&&lhs.value==rhs.value)?true: false;
					}
					void init(token_id id_, string_type const&value_, position_type const&pos_)
					{
						(void)((!!(refcnt==1))||(_wassert(L"refcnt == 1", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpplexer\\cpp_lex_token.hpp", 90), 0));
						id=id_;
						value=value_;
						pos=pos_;
					}
					void init(token_data const&rhs)
					{
						(void)((!!(refcnt==1))||(_wassert(L"refcnt == 1", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpplexer\\cpp_lex_token.hpp", 98), 0));
						id=rhs.id;
						value=rhs.value;
						pos=rhs.pos;
					}
					static void*operator new(std::size_t size);
					static void operator delete(void*p, std::size_t size);
				private:
					token_id id;
					string_type value;
					position_type pos;
					boost::detail::atomic_count refcnt;
				};
				struct token_data_tag
				{
				};
				template<typename StringTypeT, typename PositionT>
				inline void*token_data<StringTypeT, PositionT>::operator new(std::size_t size)
				{
					(void)((!!(sizeof(token_data<StringTypeT, PositionT>)==size))||(_wassert(L"sizeof(token_data<StringTypeT, PositionT>) == size", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpplexer\\cpp_lex_token.hpp", 151), 0));
					typedef boost::singleton_pool<token_data_tag, sizeof(token_data<StringTypeT, PositionT>)>pool_type;
					void*ret=pool_type::malloc();
					if(0==ret)boost::throw_exception(std::bad_alloc());
					return ret;
				}
				template<typename StringTypeT, typename PositionT>
				inline void token_data<StringTypeT, PositionT>::operator delete(void*p, std::size_t size)
				{
					(void)((!!(sizeof(token_data<StringTypeT, PositionT>)==size))||(_wassert(L"sizeof(token_data<StringTypeT, PositionT>) == size", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpplexer\\cpp_lex_token.hpp", 166), 0));
					typedef boost::singleton_pool<token_data_tag, sizeof(token_data<StringTypeT, PositionT>)>pool_type;
					if(0!=p)pool_type::free(p);
				}
			}
			template<typename PositionT=boost::wave::util::file_position_type>
			class lex_token;
			template<typename PositionT>
			class lex_token
			{
			public:
				typedef boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > >string_type;
				typedef PositionT position_type;
			private:
				typedef impl::token_data<string_type, position_type>data_type;
			public:
				lex_token(): data(0)
				{
				}
				explicit lex_token(int): data(new data_type(0))
				{
				}
				lex_token(lex_token const&rhs): data(rhs.data)
				{
					if(0!=data)data->addref();
				}
				lex_token(token_id id_, string_type const&value_, PositionT const&pos_): data(new data_type(id_, value_, pos_))
				{
				}
				~lex_token()
				{
					if(0!=data&&0==data->release())delete data;
					data=0;
				}
				lex_token&operator=(lex_token const&rhs)
				{
					if(&rhs!=this)
					{
						if(0!=data&&0==data->release())delete data;
						data=rhs.data;
						if(0!=data)data->addref();
					}
					return *this;
				}
				operator token_id()const
				{
					return 0!=data?token_id(*data): T_EOI;
				}
				string_type const&get_value()const
				{
					return data->get_value();
				}
				position_type const&get_position()const
				{
					return data->get_position();
				}
				bool is_eoi()const
				{
					return 0==data||token_id(*data)==T_EOI;
				}
				bool is_valid()const
				{
					return 0!=data&&token_id(*data)!=T_UNKNOWN;
				}
				void set_token_id(token_id id_)
				{
					make_unique();
					data->set_token_id(id_);
				}
				void set_value(string_type const&value_)
				{
					make_unique();
					data->set_value(value_);
				}
				void set_position(position_type const&pos_)
				{
					make_unique();
					data->set_position(pos_);
				}
				friend bool operator==(lex_token const&lhs, lex_token const&rhs)
				{
					if(0==rhs.data)return 0==lhs.data;
					if(0==lhs.data)return false;
					return *(lhs.data)==*(rhs.data);
				}
			private:
				void make_unique()
				{
					if(1==data->get_refcnt())return ;
					data_type*newdata=new data_type(*data);
					data->release();
					data=newdata;
				}
				data_type*data;
			};
			template<typename Position>
			inline bool token_is_valid(lex_token<Position>const&t)
			{
				return t.is_valid();
			}
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace traits
		{
			struct clear_mode
			{
				enum enum_t
				{
					clear_if_enabled, clear_always
				};
			};
			template<typename Iterator>
			void clear_queue(Iterator&, clear_mode::enum_t=clear_mode::clear_if_enabled)
			{
			}
			template<typename Iterator>
			void inhibit_clear_queue(Iterator&, bool)
			{
			}
			template<typename Iterator>
			bool inhibit_clear_queue(Iterator&)
			{
				return false;
			}
			template<typename Iterator>
			struct is_multi_pass: mpl::false_
			{
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			struct input_iterator;
			struct lex_input;
			struct functor_input;
			struct split_functor_input;
			struct ref_counted;
			struct first_owner;
			class illegal_backtracking;
			struct buf_id_check;
			struct no_check;
			struct split_std_deque;
			template<std::size_t N>
			struct fixed_size_queue;
			template<typename Ownership=ref_counted, typename Checking=no_check, typename Input=input_iterator, typename Storage=split_std_deque>
			struct default_policy;
		}
		template<typename T, typename Policies=iterator_policies::default_policy<> >
		class multi_pass;
		template<typename T, typename Policies>
		void swap(multi_pass<T, Policies>&x, multi_pass<T, Policies>&y);
		namespace detail
		{
			template<typename T>
			void swap(T&t1, T&t2);
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace traits
		{
			template<typename T, typename Policies>
			void clear_queue(multi_pass<T, Policies>&, clear_mode::enum_t mode=clear_mode::clear_if_enabled);
			template<typename T, typename Policies>
			void inhibit_clear_queue(multi_pass<T, Policies>&, bool);
			template<typename T, typename Policies>
			bool inhibit_clear_queue(multi_pass<T, Policies>&);
			template<typename T, typename Policies>
			struct is_multi_pass<multi_pass<T, Policies> >: mpl::true_
			{
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace detail
		{
			template<typename T>
			inline void swap(T&t1, T&t2)
			{
				using std::swap;
				using boost::spirit::swap;
				swap(t1, t2);
			}
			struct default_input_policy
			{
				default_input_policy()
				{
				}
				template<typename Functor>
				default_input_policy(Functor const&)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&)
				{
				}
				void swap(default_input_policy&)
				{
				}
				template<typename MultiPass, typename TokenType>
				static TokenType&advance_input(MultiPass&mp, TokenType&curtok);
				template<typename MultiPass, typename TokenType>
				static bool input_at_eof(MultiPass const&mp, TokenType&curtok);
				template<typename MultiPass, typename TokenType>
				static bool input_is_valid(MultiPass&mp, TokenType&curtok);
			};
			struct default_ownership_policy
			{
				template<typename MultiPass>
				static void destroy(MultiPass&)
				{
				}
				void swap(default_ownership_policy&)
				{
				}
				template<typename MultiPass>
				static void clone(MultiPass&)
				{
				}
				template<typename MultiPass>
				static bool release(MultiPass&mp);
				template<typename MultiPass>
				static bool is_unique(MultiPass const&mp);
			};
			struct default_storage_policy
			{
				template<typename MultiPass>
				static void destroy(MultiPass&)
				{
				}
				void swap(default_storage_policy&)
				{
				}
				template<typename MultiPass>
				static typename MultiPass::reference dereference(MultiPass const&mp);
				template<typename MultiPass>
				static void increment(MultiPass&)
				{
				}
				template<typename MultiPass>
				static void clear_queue(MultiPass&)
				{
				}
				template<typename MultiPass>
				static bool is_eof(MultiPass const&mp);
				template<typename MultiPass>
				static bool equal_to(MultiPass const&mp, MultiPass const&x);
				template<typename MultiPass>
				static bool less_than(MultiPass const&mp, MultiPass const&x);
			};
			struct default_checking_policy
			{
				template<typename MultiPass>
				static void destroy(MultiPass&)
				{
				}
				void swap(default_checking_policy&)
				{
				}
				template<typename MultiPass>
				static void check(MultiPass const&)
				{
				}
				template<typename MultiPass>
				static void clear_queue(MultiPass&)
				{
				}
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			struct first_owner
			{
				struct unique
				{
					unique(): first(true)
					{
					}
					unique(unique const&): first(false)
					{
					}
					template<typename MultiPass>
					static bool release(MultiPass&mp)
					{
						return mp.first;
					}
					template<typename MultiPass>
					static bool is_unique(MultiPass const&)
					{
						return false;
					}
					protected: bool first;
				};
				struct shared
				{
				};
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			struct ref_counted
			{
				struct unique
				{
					void swap(unique&)
					{
					}
					template<typename MultiPass>
					static void clone(MultiPass&mp)
					{
						if(0!=mp.shared())++mp.shared()->count;
					}
					template<typename MultiPass>
					static bool release(MultiPass&mp)
					{
						return 0!=mp.shared()&&0==--mp.shared()->count;
					}
					template<typename MultiPass>
					static bool is_unique(MultiPass const&mp)
					{
						return 0==mp.shared()||1==mp.shared()->count;
					}
					template<typename MultiPass>
					static void destroy(MultiPass&)
					{
					}
				};
				struct shared
				{
					shared(): count(1)
					{
					}
					std::size_t count;
				};
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			namespace input_iterator_is_valid_test_
			{
				template<typename Token>
				inline bool token_is_valid(Token const&c)
				{
					return c?true: false;
				}
			}
			struct input_iterator
			{
				template<typename T>
				class unique
				{
				private:
					typedef typename boost::detail::iterator_traits<T>::value_type result_type;
				public:
					typedef typename boost::detail::iterator_traits<T>::difference_type difference_type;
					typedef typename boost::detail::iterator_traits<T>::difference_type distance_type;
					typedef typename boost::detail::iterator_traits<T>::pointer pointer;
					typedef typename boost::detail::iterator_traits<T>::reference reference;
					typedef result_type value_type;
					protected: unique()
					{
					}
					explicit unique(T x)
					{
					}
					void swap(unique&)
					{
					}
				public:
					template<typename MultiPass>
					static void destroy(MultiPass&)
					{
					}
					template<typename MultiPass>
					static value_type&advance_input(MultiPass&mp, value_type&t)
					{
						return t=*mp.shared()->input_++;
					}
					template<typename MultiPass>
					static bool input_at_eof(MultiPass const&mp, value_type const&)
					{
						static T const end_iter;
						return mp.shared()->input_==end_iter;
					}
					template<typename MultiPass>
					static bool input_is_valid(MultiPass const&mp, value_type const&t)
					{
						using namespace input_iterator_is_valid_test_;
						return token_is_valid(t);
					}
				};
				template<typename T>
				struct shared
				{
					explicit shared(T const&input): input_(input)
					{
					}
					T input_;
				};
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			struct lex_input
			{
				template<typename T>
				class unique: public detail::default_input_policy
				{
				public:
					typedef int value_type;
					typedef std::ptrdiff_t difference_type;
					typedef std::ptrdiff_t distance_type;
					typedef int*pointer;
					typedef int&reference;
					protected: unique()
					{
					}
					explicit unique(T)
					{
					}
				public:
					template<typename MultiPass>
					static value_type&advance_input(MultiPass&mp, value_type&t)
					{
						extern int yylex();
						return t=yylex();
					}
					template<typename MultiPass>
					static bool input_at_eof(MultiPass const&, value_type const&t)
					{
						return 0==t;
					}
					template<typename MultiPass>
					static bool input_is_valid(MultiPass const&, value_type const&t)
					{
						return -1!=t;
					}
				};
				template<typename T>
				struct shared
				{
					explicit shared(T)
					{
					}
				};
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			namespace split_functor_input_is_valid_test_
			{
				template<typename Token>
				inline bool token_is_valid(Token const&)
				{
					return true;
				}
			}
			struct split_functor_input
			{
				template<typename Functor, bool FunctorIsEmpty=is_empty<typename Functor::first_type>::value>
				class unique;
				template<typename Functor>
				class unique<Functor, true>
				{
					protected: typedef typename Functor::first_type functor_type;
					typedef typename functor_type::result_type result_type;
				public:
					typedef result_type value_type;
					typedef std::ptrdiff_t difference_type;
					typedef std::ptrdiff_t distance_type;
					typedef result_type*pointer;
					typedef result_type&reference;
					protected: unique()
					{
					}
					explicit unique(Functor const&)
					{
					}
				public:
					void swap(unique&)
					{
					}
					template<typename MultiPass>
					static value_type&advance_input(MultiPass&mp, value_type&t)
					{
						return functor_type::get_next(mp, t);
					}
					template<typename MultiPass>
					static bool input_at_eof(MultiPass const&, value_type const&t)
					{
						return t==functor_type::eof;
					}
					template<typename MultiPass>
					static bool input_is_valid(MultiPass const&, value_type const&t)
					{
						using namespace split_functor_input_is_valid_test_;
						return token_is_valid(t);
					}
					template<typename MultiPass>
					static void destroy(MultiPass&mp)
					{
						functor_type::destroy(mp);
					}
				};
				template<typename Functor>
				class unique<Functor, false>: public unique<Functor, true>
				{
					protected: typedef typename Functor::first_type functor_type;
					typedef typename functor_type::result_type result_type;
					protected: unique()
					{
					}
					explicit unique(Functor const&x): ftor(x.first)
					{
					}
					void swap(unique&x)
					{
						spirit::detail::swap(ftor, x.ftor);
					}
				public:
					typedef result_type value_type;
					typedef std::ptrdiff_t difference_type;
					typedef std::ptrdiff_t distance_type;
					typedef result_type*pointer;
					typedef result_type&reference;
				public:
					template<typename MultiPass>
					static value_type&advance_input(MultiPass&mp, value_type&t)
					{
						return mp.ftor.get_next(mp, t);
					}
					template<typename MultiPass>
					static bool input_at_eof(MultiPass const&mp, value_type const&t)
					{
						return t==mp.ftor.eof;
					}
					typename Functor::first_type&get_functor()const
					{
						return ftor;
					}
					mutable functor_type ftor;
				};
				template<typename Functor>
				struct shared
				{
					explicit shared(Functor const&x): ftor(x.second)
					{
					}
					mutable typename Functor::second_type ftor;
				private:
					shared&operator=(shared const&);
				};
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			class illegal_backtracking: public std::exception
			{
			public:
				illegal_backtracking()throw()
				{
				}
				~illegal_backtracking()throw()
				{
				}
				char const*what()const throw()
				{
					return "boost::spirit::multi_pass::illegal_backtracking";
				}
			};
			struct buf_id_check
			{
				struct unique
				{
					unique(): buf_id(0)
					{
					}
					unique(unique const&x): buf_id(x.buf_id)
					{
					}
					void swap(unique&x)
					{
						spirit::detail::swap(buf_id, x.buf_id);
					}
					template<typename MultiPass>
					static void check(MultiPass const&mp)
					{
						if(mp.buf_id!=mp.shared()->shared_buf_id)boost::throw_exception(illegal_backtracking());
					}
					template<typename MultiPass>
					static void clear_queue(MultiPass&mp)
					{
						++mp.shared()->shared_buf_id;
						++mp.buf_id;
					}
					template<typename MultiPass>
					static void destroy(MultiPass&)
					{
					}
					protected: unsigned long buf_id;
				};
				struct shared
				{
					shared(): shared_buf_id(0)
					{
					}
					unsigned long shared_buf_id;
				};
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			struct no_check
			{
				struct unique
				{
					void swap(unique&)
					{
					}
					template<typename MultiPass>
					static void check(MultiPass const&)
					{
					}
					template<typename MultiPass>
					static void clear_queue(MultiPass&)
					{
					}
					template<typename MultiPass>
					static void destroy(MultiPass&)
					{
					}
				};
				struct shared
				{
				};
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace detail
		{
			template<typename Queue, typename T, typename Pointer>
			class fsq_iterator: public boost::iterator_adaptor<fsq_iterator<Queue, T, Pointer>, Pointer, T, std::random_access_iterator_tag>
			{
			public:
				typedef typename Queue::position_type position_type;
				typedef boost::iterator_adaptor<fsq_iterator<Queue, T, Pointer>, Pointer, T, std::random_access_iterator_tag>base_type;
				fsq_iterator()
				{
				}
				fsq_iterator(position_type const&p_): p(p_)
				{
				}
				position_type const&get_position()const
				{
					return p;
				}
			private:
				friend class boost::iterator_core_access;
				typename base_type::reference dereference()const
				{
					return p.self->m_queue[p.pos];
				}
				void increment()
				{
					++p.pos;
					if(p.pos==Queue::MAX_SIZE+1)p.pos=0;
				}
				void decrement()
				{
					if(p.pos==0)p.pos=Queue::MAX_SIZE;
					else--p.pos;
				}
				template<typename OtherDerived, typename OtherIterator, typename V, typename C, typename R, typename D>
				bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D>const&x)const
				{
					position_type const&rhs_pos=static_cast<OtherDerived const&>(x).get_position();
					return (p.self==rhs_pos.self)&&(p.pos==rhs_pos.pos);
				}
				template<typename OtherDerived, typename OtherIterator, typename V, typename C, typename R, typename D>
				typename base_type::difference_type distance_to(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D>const&x)const
				{
					typedef typename base_type::difference_type difference_type;
					position_type const&p2=static_cast<OtherDerived const&>(x).get_position();
					std::size_t pos1=p.pos;
					std::size_t pos2=p2.pos;
					(void)((!!(p.self==p2.self))||(_wassert(L"p.self == p2.self", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 105), 0));
					if(pos1<p.self->m_head)pos1+=Queue::MAX_SIZE;
					if(pos2<p2.self->m_head)pos2+=Queue::MAX_SIZE;
					if(pos2>pos1)return difference_type(pos2-pos1);
					else return -difference_type(pos1-pos2);
				}
				void advance(typename base_type::difference_type n)
				{
					if(n<0)
					{
						n=-n;
						if(p.pos<(std::size_t)n)p.pos=Queue::MAX_SIZE+1-(n-p.pos);
						else p.pos-=n;
					}
					else
					{
						p.pos+=n;
						if(p.pos>=Queue::MAX_SIZE+1)p.pos-=Queue::MAX_SIZE+1;
					}
				}
			private:
				position_type p;
			};
			template<typename T, std::size_t N>
			class fixed_size_queue
			{
			private:
				struct position
				{
					fixed_size_queue*self;
					std::size_t pos;
					position(): self(0), pos(0)
					{
					}
					position(const fixed_size_queue*s, std::size_t p): self(const_cast<fixed_size_queue*>(s)), pos(p)
					{
					}
				};
			public:
				typedef fsq_iterator<fixed_size_queue<T, N>, T, T*>iterator;
				typedef fsq_iterator<fixed_size_queue<T, N>, T const, T const*>const_iterator;
				typedef position position_type;
				friend class fsq_iterator<fixed_size_queue<T, N>, T, T*>;
				friend class fsq_iterator<fixed_size_queue<T, N>, T const, T const*>;
				fixed_size_queue();
				fixed_size_queue(const fixed_size_queue&x);
				fixed_size_queue&operator=(const fixed_size_queue&x);
				~fixed_size_queue();
				void push_back(const T&e);
				void push_front(const T&e);
				void serve(T&e);
				void pop_front();
				bool empty()const
				{
					return m_size==0;
				}
				bool full()const
				{
					return m_size==N;
				}
				iterator begin()
				{
					return iterator(position(this, m_head));
				}
				const_iterator begin()const
				{
					return const_iterator(position(this, m_head));
				}
				iterator end()
				{
					return iterator(position(this, m_tail));
				}
				const_iterator end()const
				{
					return const_iterator(position(this, m_tail));
				}
				std::size_t size()const
				{
					return m_size;
				}
				T&front()
				{
					return m_queue[m_head];
				}
				const T&front()const
				{
					return m_queue[m_head];
				}
			private:
				static const std::size_t MAX_SIZE=N;
				std::size_t m_head;
				std::size_t m_tail;
				std::size_t m_size;
				T m_queue[N+1];
			};
			template<typename T, std::size_t N>
			inline fixed_size_queue<T, N>::fixed_size_queue(): m_head(0), m_tail(0), m_size(0)
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 250), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 251), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 252), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 253), 0));
			}
			template<typename T, std::size_t N>
			inline fixed_size_queue<T, N>::fixed_size_queue(const fixed_size_queue&x): m_head(x.m_head), m_tail(x.m_tail), m_size(x.m_size)
			{
				copy(x.begin(), x.end(), begin());
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 264), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 265), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 266), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 267), 0));
			}
			template<typename T, std::size_t N>
			inline fixed_size_queue<T, N>&fixed_size_queue<T, N>::operator=(const fixed_size_queue&x)
			{
				if(this!=&x)
				{
					m_head=x.m_head;
					m_tail=x.m_tail;
					m_size=x.m_size;
					copy(x.begin(), x.end(), begin());
				}
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 281), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 282), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 283), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 284), 0));
				return *this;
			}
			template<typename T, std::size_t N>
			inline fixed_size_queue<T, N>::~fixed_size_queue()
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 293), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 294), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 295), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 296), 0));
			}
			template<typename T, std::size_t N>
			inline void fixed_size_queue<T, N>::push_back(const T&e)
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 303), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 304), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 305), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 306), 0));
				(void)((!!(!full()))||(_wassert(L"!full()", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 308), 0));
				m_queue[m_tail]=e;
				++m_size;
				++m_tail;
				if(m_tail==N+1)m_tail=0;
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 317), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 318), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 319), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 320), 0));
			}
			template<typename T, std::size_t N>
			inline void fixed_size_queue<T, N>::push_front(const T&e)
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 327), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 328), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 329), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 330), 0));
				(void)((!!(!full()))||(_wassert(L"!full()", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 332), 0));
				if(m_head==0)m_head=N;
				else--m_head;
				m_queue[m_head]=e;
				++m_size;
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 342), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 343), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 344), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 345), 0));
			}
			template<typename T, std::size_t N>
			inline void fixed_size_queue<T, N>::serve(T&e)
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 353), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 354), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 355), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 356), 0));
				e=m_queue[m_head];
				pop_front();
			}
			template<typename T, std::size_t N>
			inline void fixed_size_queue<T, N>::pop_front()
			{
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 368), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 369), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 370), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 371), 0));
				++m_head;
				if(m_head==N+1)m_head=0;
				--m_size;
				(void)((!!(m_size<=N+1))||(_wassert(L"m_size <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 378), 0));
				(void)((!!(((m_tail+N+1)-m_head)%(N+1)==m_size%(N+1)))||(_wassert(L"((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 379), 0));
				(void)((!!(m_head<=N+1))||(_wassert(L"m_head <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 380), 0));
				(void)((!!(m_tail<=N+1))||(_wassert(L"m_tail <= N+1", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\fixed_size_queue.hpp", 381), 0));
			}
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			template<std::size_t N>
			struct fixed_size_queue
			{
				template<typename Value>
				class unique: public detail::default_storage_policy
				{
				private:
					typedef detail::fixed_size_queue<Value, N>queue_type;
					protected: unique()
					{
					}
					unique(unique const&x): queuePosition(x.queuePosition)
					{
					}
					void swap(unique&x)
					{
						spirit::detail::swap(queuePosition, x.queuePosition);
					}
					template<typename MultiPass>
					static typename MultiPass::reference dereference(MultiPass const&mp)
					{
						if(mp.queuePosition==mp.shared()->queuedElements.end())
						{
							return MultiPass::get_input(mp);
						}
						else
						{
							return *mp.queuePosition;
						}
					}
					template<typename MultiPass>
					static void increment(MultiPass&mp)
					{
						if(mp.queuePosition==mp.shared()->queuedElements.end())
						{
							if(mp.shared()->queuedElements.size()>=N)mp.shared()->queuedElements.pop_front();
							mp.shared()->queuedElements.push_back(MultiPass::get_input(mp));
							MultiPass::advance_input(mp);
						}
						++mp.queuePosition;
					}
					template<typename MultiPass>
					static bool is_eof(MultiPass const&mp)
					{
						return mp.queuePosition==mp.shared()->queuedElements.end()&&MultiPass::input_at_eof(mp);
					}
					template<typename MultiPass>
					static bool equal_to(MultiPass const&mp, MultiPass const&x)
					{
						return mp.queuePosition==x.queuePosition;
					}
					template<typename MultiPass>
					static bool less_than(MultiPass const&mp, MultiPass const&x)
					{
						return mp.queuePosition<x.queuePosition;
					}
					protected: mutable typename queue_type::iterator queuePosition;
				};
				template<typename Value>
				struct shared
				{
					typedef detail::fixed_size_queue<Value, N>queue_type;
					queue_type queuedElements;
				};
			};
		}
	}
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			struct split_std_deque
			{
				enum
				{
					threshold=16
				};
				template<typename Value>
				class unique
				{
				private:
					typedef std::vector<Value>queue_type;
					protected: unique(): queued_position(1)
					{
					}
					unique(unique const&x): queued_position(x.queued_position)
					{
					}
					void swap(unique&x)
					{
						spirit::detail::swap(queued_position, x.queued_position);
					}
					template<typename MultiPass>
					static typename MultiPass::reference dereference(MultiPass const&mp)
					{
						queue_type&queue=mp.shared()->queued_elements;
						(void)((!!(mp.queued_position>0&&mp.queued_position<=queue.size()))||(_wassert(L"mp.queued_position > 0 && mp.queued_position <= queue.size()", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\split_std_deque_policy.hpp", 57), 0));
						Value&v(queue[mp.queued_position-1]);
						if(!MultiPass::input_is_valid(mp, v))return MultiPass::advance_input(mp, v);
						return v;
					}
					template<typename MultiPass>
					static void increment(MultiPass&mp)
					{
						queue_type&queue=mp.shared()->queued_elements;
						typename queue_type::size_type size=queue.size();
						(void)((!!(mp.queued_position>0&&mp.queued_position<=size))||(_wassert(L"mp.queued_position > 0 && mp.queued_position <= size", L"D:\\dev\\boost_1_41_0\\boost\\spirit\\home\\support\\iterators\\detail\\split_std_deque_policy.hpp", 74), 0));
						if(size>0&&!MultiPass::input_is_valid(mp, queue[mp.queued_position-1]))return ;
						if(mp.queued_position==size)
						{
							if(size>=threshold&&MultiPass::is_unique(mp))
							{
								queue.erase(queue.begin()+1, queue.end());
								mp.queued_position=0;
							}
							else
							{
								queue.push_back(Value(0));
							}
							MultiPass::advance_input(mp, queue[mp.queued_position++]);
						}
						else
						{
							++mp.queued_position;
						}
					}
					template<typename MultiPass>
					static void clear_queue(MultiPass&mp)
					{
						mp.shared()->queued_elements.clear();
						mp.shared()->queued_elements.push_back(Value(0));
						mp.queued_position=1;
					}
					template<typename MultiPass>
					static bool is_eof(MultiPass const&mp)
					{
						queue_type&queue=mp.shared()->queued_elements;
						return 0!=mp.queued_position&&mp.queued_position==queue.size()&&MultiPass::input_at_eof(mp, queue[mp.queued_position-1]);
					}
					template<typename MultiPass>
					static bool equal_to(MultiPass const&mp, MultiPass const&x)
					{
						return mp.queued_position==x.queued_position;
					}
					template<typename MultiPass>
					static bool less_than(MultiPass const&mp, MultiPass const&x)
					{
						return mp.queued_position<x.queued_position;
					}
					template<typename MultiPass>
					static void destroy(MultiPass&)
					{
					}
					protected: mutable typename queue_type::size_type queued_position;
				};
				template<typename Value>
				struct shared
				{
					shared()
					{
						queued_elements.reserve(threshold);
						queued_elements.push_back(Value(0));
					}
					typedef std::vector<Value>queue_type;
					queue_type queued_elements;
				};
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		namespace iterator_policies
		{
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage, bool OwnershipIsEmpty=boost::is_empty<Ownership>::value, bool CheckingIsEmpty=boost::is_empty<Checking>::value, bool InputIsEmpty=boost::is_empty<Input>::value>
			struct multi_pass_unique;
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_unique<T, Ownership, Checking, Input, Storage, false, false, false>: Ownership, Checking, Input, Storage
			{
				multi_pass_unique()
				{
				}
				multi_pass_unique(T const&x): Input(x)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&mp)
				{
					Ownership::destroy(mp);
					Checking::destroy(mp);
					Input::destroy(mp);
					Storage::destroy(mp);
				}
				void swap(multi_pass_unique&x)
				{
					this->Ownership::swap(x);
					this->Checking::swap(x);
					this->Input::swap(x);
					this->Storage::swap(x);
				}
			};
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_unique<T, Ownership, Checking, Input, Storage, false, false, true>: Ownership, Checking, Storage
			{
				multi_pass_unique()
				{
				}
				multi_pass_unique(T const&x)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&mp)
				{
					Ownership::destroy(mp);
					Checking::destroy(mp);
					Input::destroy(mp);
					Storage::destroy(mp);
				}
				void swap(multi_pass_unique&x)
				{
					this->Ownership::swap(x);
					this->Checking::swap(x);
					this->Storage::swap(x);
				}
				template<typename MultiPass, typename TokenType>
				inline static TokenType&advance_input(MultiPass&mp, TokenType&curtok)
				{
					return Input::advance_input(mp, curtok);
				}
				template<typename MultiPass, typename TokenType>
				inline static bool input_at_eof(MultiPass const&mp, TokenType&curtok)
				{
					return Input::input_at_eof(mp, curtok);
				}
				template<typename MultiPass, typename TokenType>
				inline static bool input_is_valid(MultiPass&mp, TokenType&curtok)
				{
					return Input::input_is_valid(mp, curtok);
				}
			};
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_unique<T, Ownership, Checking, Input, Storage, false, true, false>: Ownership, Input, Storage
			{
				multi_pass_unique()
				{
				}
				multi_pass_unique(T const&x): Input(x)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&mp)
				{
					Ownership::destroy(mp);
					Input::destroy(mp);
					Storage::destroy(mp);
				}
				void swap(multi_pass_unique&x)
				{
					this->Ownership::swap(x);
					this->Input::swap(x);
					this->Storage::swap(x);
				}
				template<typename MultiPass>
				inline static void check(MultiPass const&mp)
				{
					Checking::check(mp);
				}
				template<typename MultiPass>
				inline static void clear_queue(MultiPass&mp)
				{
					Checking::clear_queue(mp);
				}
			};
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_unique<T, Ownership, Checking, Input, Storage, false, true, true>: Ownership, Storage
			{
				multi_pass_unique()
				{
				}
				multi_pass_unique(T const&x)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&mp)
				{
					Ownership::destroy(mp);
					Input::destroy(mp);
					Storage::destroy(mp);
				}
				void swap(multi_pass_unique&x)
				{
					this->Ownership::swap(x);
					this->Storage::swap(x);
				}
				template<typename MultiPass, typename TokenType>
				inline static TokenType&advance_input(MultiPass&mp, TokenType&curtok)
				{
					return Input::advance_input(mp, curtok);
				}
				template<typename MultiPass, typename TokenType>
				inline static bool input_at_eof(MultiPass const&mp, TokenType&curtok)
				{
					return Input::input_at_eof(mp, curtok);
				}
				template<typename MultiPass, typename TokenType>
				inline static bool input_is_valid(MultiPass&mp, TokenType&curtok)
				{
					return Input::input_is_valid(mp, curtok);
				}
				template<typename MultiPass>
				inline static void check(MultiPass const&mp)
				{
					Checking::check(mp);
				}
				template<typename MultiPass>
				inline static void clear_queue(MultiPass&mp)
				{
					Checking::clear_queue(mp);
				}
			};
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_unique<T, Ownership, Checking, Input, Storage, true, false, false>: Checking, Input, Storage
			{
				multi_pass_unique()
				{
				}
				multi_pass_unique(T const&x): Input(x)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&mp)
				{
					Checking::destroy(mp);
					Input::destroy(mp);
					Storage::destroy(mp);
				}
				void swap(multi_pass_unique&x)
				{
					this->Checking::swap(x);
					this->Input::swap(x);
					this->Storage::swap(x);
				}
				template<typename MultiPass>
				inline static void clone(MultiPass&mp)
				{
					Ownership::clone(mp);
				}
				template<typename MultiPass>
				inline static bool release(MultiPass&mp)
				{
					return Ownership::release(mp);
				}
				template<typename MultiPass>
				inline static bool is_unique(MultiPass const&mp)
				{
					return Ownership::is_unique(mp);
				}
			};
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_unique<T, Ownership, Checking, Input, Storage, true, false, true>: Checking, Storage
			{
				multi_pass_unique()
				{
				}
				multi_pass_unique(T const&x)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&mp)
				{
					Checking::destroy(mp);
					Input::destroy(mp);
					Storage::destroy(mp);
				}
				void swap(multi_pass_unique&x)
				{
					this->Checking::swap(x);
					this->Storage::swap(x);
				}
				template<typename MultiPass, typename TokenType>
				inline static TokenType&advance_input(MultiPass&mp, TokenType&curtok)
				{
					return Input::advance_input(mp, curtok);
				}
				template<typename MultiPass, typename TokenType>
				inline static bool input_at_eof(MultiPass const&mp, TokenType&curtok)
				{
					return Input::input_at_eof(mp, curtok);
				}
				template<typename MultiPass, typename TokenType>
				inline static bool input_is_valid(MultiPass&mp, TokenType&curtok)
				{
					return Input::input_is_valid(mp, curtok);
				}
				template<typename MultiPass>
				inline static void clone(MultiPass&mp)
				{
					Ownership::clone(mp);
				}
				template<typename MultiPass>
				inline static bool release(MultiPass&mp)
				{
					return Ownership::release(mp);
				}
				template<typename MultiPass>
				inline static bool is_unique(MultiPass const&mp)
				{
					return Ownership::is_unique(mp);
				}
			};
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_unique<T, Ownership, Checking, Input, Storage, true, true, false>: Input, Storage
			{
				multi_pass_unique()
				{
				}
				multi_pass_unique(T const&x): Input(x)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&mp)
				{
					Input::destroy(mp);
					Storage::destroy(mp);
				}
				void swap(multi_pass_unique&x)
				{
					this->Input::swap(x);
					this->Storage::swap(x);
				}
				template<typename MultiPass>
				inline static void check(MultiPass const&mp)
				{
					Checking::check(mp);
				}
				template<typename MultiPass>
				inline static void clear_queue(MultiPass&mp)
				{
					Checking::clear_queue(mp);
				}
				template<typename MultiPass>
				inline static void clone(MultiPass&mp)
				{
					Ownership::clone(mp);
				}
				template<typename MultiPass>
				inline static bool release(MultiPass&mp)
				{
					return Ownership::release(mp);
				}
				template<typename MultiPass>
				inline static bool is_unique(MultiPass const&mp)
				{
					return Ownership::is_unique(mp);
				}
			};
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_unique<T, Ownership, Checking, Input, Storage, true, true, true>: Storage
			{
				multi_pass_unique()
				{
				}
				multi_pass_unique(T const&)
				{
				}
				template<typename MultiPass>
				static void destroy(MultiPass&mp)
				{
					Input::destroy(mp);
					Storage::destroy(mp);
				}
				void swap(multi_pass_unique&x)
				{
					this->Storage::swap(x);
				}
				template<typename MultiPass, typename TokenType>
				inline static TokenType&advance_input(MultiPass&mp, TokenType&curtok)
				{
					return Input::advance_input(mp, curtok);
				}
				template<typename MultiPass, typename TokenType>
				inline static bool input_at_eof(MultiPass const&mp, TokenType&curtok)
				{
					return Input::input_at_eof(mp, curtok);
				}
				template<typename MultiPass, typename TokenType>
				inline static bool input_is_valid(MultiPass&mp, TokenType&curtok)
				{
					return Input::input_is_valid(mp, curtok);
				}
				template<typename MultiPass>
				inline static void check(MultiPass const&mp)
				{
					Checking::check(mp);
				}
				template<typename MultiPass>
				inline static void clear_queue(MultiPass&mp)
				{
					Checking::clear_queue(mp);
				}
				template<typename MultiPass>
				inline static void clone(MultiPass&mp)
				{
					Ownership::clone(mp);
				}
				template<typename MultiPass>
				inline static bool release(MultiPass&mp)
				{
					return Ownership::release(mp);
				}
				template<typename MultiPass>
				inline static bool is_unique(MultiPass const&mp)
				{
					return Ownership::is_unique(mp);
				}
			};
			template<typename T, typename Ownership, typename Checking, typename Input, typename Storage>
			struct multi_pass_shared: Ownership, Checking, Input, Storage
			{
				explicit multi_pass_shared(T const&input): Input(input)
				{
				}
			};
			template<typename Ownership, typename Checking, typename Input, typename Storage>
			struct default_policy
			{
				typedef Ownership ownership_policy;
				typedef Checking checking_policy;
				typedef Input input_policy;
				typedef Storage storage_policy;
				template<typename T>
				struct unique: multi_pass_unique<T, typename Ownership::unique, typename Checking::unique, typename Input::template unique<T>, typename Storage::template unique<typename Input::template unique<T>::value_type> >
				{
					typedef typename Ownership::unique ownership_policy;
					typedef typename Checking::unique checking_policy;
					typedef typename Input::template unique<T>input_policy;
					typedef typename Storage::template unique<typename input_policy::value_type>storage_policy;
					typedef multi_pass_unique<T, ownership_policy, checking_policy, input_policy, storage_policy>unique_base_type;
					unique()
					{
					}
					explicit unique(T const&input): unique_base_type(input)
					{
					}
				};
				template<typename T>
				struct shared: multi_pass_shared<T, typename Ownership::shared, typename Checking::shared, typename Input::template shared<T>, typename Storage::template shared<typename Input::template unique<T>::value_type> >
				{
					typedef typename Ownership::shared ownership_policy;
					typedef typename Checking::shared checking_policy;
					typedef typename Input::template shared<T>input_policy;
					typedef typename Storage::template shared<typename Input::template unique<T>::value_type>storage_policy;
					typedef multi_pass_shared<T, ownership_policy, checking_policy, input_policy, storage_policy>shared_base_type;
					explicit shared(T const&input): shared_base_type(input), inhibit_clear_queue_(false)
					{
					}
					bool inhibit_clear_queue_;
				};
			};
		}
	}
}
namespace boost
{
	namespace spirit
	{
		template<typename T, typename Policies>
		class multi_pass: private boost::base_from_member<typename Policies::template shared<T>*>, public Policies::template unique<T>
		{
		private:
			typedef typename Policies::template unique<T>policies_base_type;
			typedef typename Policies::template shared<T>shared_data_type;
			typedef boost::base_from_member<shared_data_type*>member_base;
			typedef typename policies_base_type::input_policy iterator_type;
		public:
			typedef std::forward_iterator_tag iterator_category;
			typedef typename iterator_type::value_type value_type;
			typedef typename iterator_type::difference_type difference_type;
			typedef typename iterator_type::distance_type distance_type;
			typedef typename iterator_type::reference reference;
			typedef typename iterator_type::pointer pointer;
			multi_pass(): member_base((shared_data_type*)0)
			{
			}
			explicit multi_pass(T const&input): member_base(new shared_data_type(input)), policies_base_type(input)
			{
			}
			multi_pass(multi_pass const&x): member_base(x.member), policies_base_type(x)
			{
				policies_base_type::clone(*this);
			}
			~multi_pass()
			{
				if(policies_base_type::release(*this))
				{
					policies_base_type::destroy(*this);
					delete this->member;
				}
			}
			multi_pass&operator=(multi_pass const&x)
			{
				if(this!=&x)
				{
					multi_pass temp(x);
					temp.swap(*this);
				}
				return *this;
			}
			void swap(multi_pass&x)
			{
				spirit::detail::swap(this->member, x.member);
				this->policies_base_type::swap(x);
			}
			reference operator*()const
			{
				policies_base_type::check(*this);
				return policies_base_type::dereference(*this);
			}
			pointer operator->()const
			{
				return &(operator*());
			}
			multi_pass&operator++()
			{
				policies_base_type::check(*this);
				policies_base_type::increment(*this);
				return *this;
			}
			multi_pass operator++(int)
			{
				multi_pass tmp(*this);
				++*this;
				return tmp;
			}
			void clear_queue(traits::clear_mode::enum_t mode=traits::clear_mode::clear_if_enabled)
			{
				if(mode==traits::clear_mode::clear_always||!inhibit_clear_queue())policies_base_type::clear_queue(*this);
			}
			bool inhibit_clear_queue()const
			{
				return this->member->inhibit_clear_queue_;
			}
			void inhibit_clear_queue(bool flag)
			{
				this->member->inhibit_clear_queue_=flag;
			}
			bool operator==(multi_pass const&y)const
			{
				if(is_eof())return y.is_eof();
				if(y.is_eof())return false;
				return policies_base_type::equal_to(*this, y);
			}
			bool operator<(multi_pass const&y)const
			{
				return policies_base_type::less_than(*this, y);
			}
			shared_data_type*shared()const
			{
				return this->member;
			}
		private:
			bool is_eof()const
			{
				return (0==this->member)||policies_base_type::is_eof(*this);
			}
		};
		template<typename T, typename Policies>
		inline bool operator!=(multi_pass<T, Policies>const&x, multi_pass<T, Policies>const&y)
		{
			return !(x==y);
		}
		template<typename T, typename Policies>
		inline bool operator>(multi_pass<T, Policies>const&x, multi_pass<T, Policies>const&y)
		{
			return y<x;
		}
		template<typename T, typename Policies>
		inline bool operator>=(multi_pass<T, Policies>const&x, multi_pass<T, Policies>const&y)
		{
			return !(x<y);
		}
		template<typename T, typename Policies>
		inline bool operator<=(multi_pass<T, Policies>const&x, multi_pass<T, Policies>const&y)
		{
			return !(y<x);
		}
		template<typename Policies, typename T>
		inline multi_pass<T, Policies>make_multi_pass(T const&i)
		{
			return multi_pass<T, Policies>(i);
		}
		template<typename T>
		inline multi_pass<T>make_default_multi_pass(T const&i)
		{
			return multi_pass<T>(i);
		}
		template<typename T, typename Policies>
		inline void swap(multi_pass<T, Policies>&x, multi_pass<T, Policies>&y)
		{
			x.swap(y);
		}
		namespace traits
		{
			template<typename T, typename Policies>
			void clear_queue(multi_pass<T, Policies>&mp, traits::clear_mode::enum_t mode)
			{
				mp.clear_queue(mode);
			}
			template<typename T, typename Policies>
			void inhibit_clear_queue(multi_pass<T, Policies>&mp, bool flag)
			{
				mp.inhibit_clear_queue(flag);
			}
			template<typename T, typename Policies>
			bool inhibit_clear_queue(multi_pass<T, Policies>&mp)
			{
				return mp.inhibit_clear_queue();
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			template<typename TokenT>
			struct lex_input_interface
			{
				typedef typename TokenT::position_type position_type;
				lex_input_interface()
				{
				}
				virtual~lex_input_interface()
				{
				}
				virtual TokenT&get(TokenT&)=0;
				virtual void set_position(position_type const&pos)=0;
				virtual bool has_include_guards(std::string&guard_name)const=0;
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			template<typename IteratorT, typename PositionT=boost::wave::util::file_position_type, typename TokenT=lex_token<PositionT> >
			struct new_lexer_gen
			{
				static lex_input_interface<TokenT>*new_lexer(IteratorT const&first, IteratorT const&last, PositionT const&pos, boost::wave::language_support language);
			};
			template<typename TokenT>
			struct lex_input_interface_generator: lex_input_interface<TokenT>
			{
				typedef typename lex_input_interface<TokenT>::position_type position_type;
				lex_input_interface_generator()
				{
				}
				~lex_input_interface_generator()
				{
				}
				template<typename IteratorT>
				static lex_input_interface<TokenT>*new_lexer(IteratorT const&first, IteratorT const&last, position_type const&pos, boost::wave::language_support language)
				{
					return new_lexer_gen<IteratorT, position_type, TokenT>::new_lexer(first, last, pos, language);
				}
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace impl
			{
				template<typename TokenT>
				class lex_iterator_functor_shim
				{
					typedef typename TokenT::position_type position_type;
				public:
					lex_iterator_functor_shim()
					{
					}
					typedef TokenT result_type;
					typedef lex_iterator_functor_shim unique;
					typedef lex_input_interface<TokenT>*shared;
					static result_type const eof;
					template<typename MultiPass>
					static result_type&get_next(MultiPass&mp, result_type&result)
					{
						return mp.shared()->ftor->get(result);
					}
					template<typename MultiPass>
					static void destroy(MultiPass&mp)
					{
						delete mp.shared()->ftor;
					}
					template<typename MultiPass>
					static void set_position(MultiPass&mp, position_type const&pos)
					{
						mp.shared()->ftor->set_position(pos);
					}
					template<typename MultiPass>
					static bool has_include_guards(MultiPass&mp, std::string&guard_name)
					{
						return mp.shared()->ftor->has_include_guards(guard_name);
					}
				};
				template<typename TokenT>
				typename lex_iterator_functor_shim<TokenT>::result_type const lex_iterator_functor_shim<TokenT>::eof;
			}
			template<typename FunctorData>
			struct make_multi_pass
			{
				typedef std::pair<typename FunctorData::unique, typename FunctorData::shared>functor_data_type;
				typedef typename FunctorData::result_type result_type;
				typedef boost::spirit::iterator_policies::split_functor_input input_policy;
				typedef boost::spirit::iterator_policies::ref_counted ownership_policy;
				typedef boost::spirit::iterator_policies::no_check check_policy;
				typedef boost::spirit::iterator_policies::split_std_deque storage_policy;
				typedef boost::spirit::iterator_policies::default_policy<ownership_policy, check_policy, input_policy, storage_policy>policy_type;
				typedef boost::spirit::multi_pass<functor_data_type, policy_type>type;
			};
			template<typename TokenT>
			class lex_iterator: public make_multi_pass<impl::lex_iterator_functor_shim<TokenT> >::type
			{
				typedef impl::lex_iterator_functor_shim<TokenT>input_policy_type;
				typedef typename make_multi_pass<input_policy_type>::type base_type;
				typedef typename make_multi_pass<input_policy_type>::functor_data_type functor_data_type;
				typedef typename input_policy_type::unique unique_functor_type;
				typedef typename input_policy_type::shared shared_functor_type;
			public:
				typedef TokenT token_type;
				lex_iterator()
				{
				}
				template<typename IteratorT>
				lex_iterator(IteratorT const&first, IteratorT const&last, typename TokenT::position_type const&pos, boost::wave::language_support language): base_type(functor_data_type(unique_functor_type(), lex_input_interface_generator<TokenT>::new_lexer(first, last, pos, language)))
				{
				}
				void set_position(typename TokenT::position_type const&pos)
				{
					typedef typename TokenT::position_type position_type;
					token_type&currtoken=this->base_type::dereference(*this);
					position_type currpos=currtoken.get_position();
					currpos.set_file(pos.get_file());
					currpos.set_line(pos.get_line());
					currtoken.set_position(currpos);
					if(token_type::string_type::npos!=currtoken.get_value().find_first_of('\n'))
					{
						currpos.set_line(pos.get_line()+1);
					}
					unique_functor_type::set_position(*this, currpos);
				}
				bool has_include_guards(std::string&guard_name)const
				{
					return unique_functor_type::has_include_guards(*this, guard_name);
				}
			};
		}
	}
}
typedef boost::wave::util::file_position<boost::wave::util::flex_string<char, std::char_traits<char>, std::allocator<char>, boost::wave::util::CowString<boost::wave::util::AllocatorStringStorage<char> > > >LexFilePosition;
typedef boost::wave::cpplexer::lex_token<LexFilePosition>token_type;
typedef boost::wave::cpplexer::lex_iterator<token_type>lex_iterator_type;
typedef std::basic_string<char, std::char_traits<char>, DebugAllocator<char> >LexString;
LexTokenId LEXER_INTRINSIC_IDS[]=
{
	boost::wave::T_HAS_NOTHROW_CONSTRUCTOR, boost::wave::T_HAS_NOTHROW_COPY, boost::wave::T_HAS_TRIVIAL_ASSIGN, boost::wave::T_HAS_TRIVIAL_CONSTRUCTOR, boost::wave::T_HAS_TRIVIAL_COPY, boost::wave::T_HAS_TRIVIAL_DESTRUCTOR, boost::wave::T_HAS_VIRTUAL_DESTRUCTOR, boost::wave::T_IS_ABSTRACT, boost::wave::T_IS_BASE_OF, boost::wave::T_IS_CLASS, boost::wave::T_IS_CONVERTIBLE_TO, boost::wave::T_IS_EMPTY, boost::wave::T_IS_ENUM, boost::wave::T_IS_POD, boost::wave::T_IS_POLYMORPHIC, boost::wave::T_IS_UNION, boost::wave::T_IS_TRIVIAL, boost::wave::T_IS_TRIVIALLY_CONSTRUCTIBLE, boost::wave::T_IS_TRIVIALLY_ASSIGNABLE, boost::wave::T_IS_TRIVIALLY_COPYABLE, boost::wave::T_IS_STANDARD_LAYOUT, boost::wave::T_IS_LITERAL_TYPE, boost::wave::T_UNDERLYING_TYPE,
};
typedef const char*LexTokenValue;
LexTokenValue LEXER_INTRINSIC_VALUES[]=
{
	"__has_nothrow_constructor", "__has_nothrow_copy", "__has_trivial_assign", "__has_trivial_constructor", "__has_trivial_copy", "__has_trivial_destructor", "__has_virtual_destructor", "__is_abstract", "__is_base_of", "__is_class", "__is_convertible_to", "__is_empty", "__is_enum", "__is_pod", "__is_polymorphic", "__is_union", "__is_trivial", "__is_trivially_constructible", "__is_trivially_assignable", "__is_trivially_copyable", "__is_standard_layout", "__is_literal_type", "__underlying_type",
};
struct StringEqualPredicate
{
	const char*s;
	StringEqualPredicate(const char*s): s(s)
	{
	}
	bool operator()(const char*other)const
	{
		return string_equal(s, other);
	}
};
LexTokenId getLexerIntrinsicId(const char*value)
{
	const LexTokenValue*result=std::find_if(LEXER_INTRINSIC_VALUES, ((LEXER_INTRINSIC_VALUES)+(sizeof(LEXER_INTRINSIC_VALUES)/sizeof(*LEXER_INTRINSIC_VALUES))), StringEqualPredicate(value));
	if(result!=((LEXER_INTRINSIC_VALUES)+(sizeof(LEXER_INTRINSIC_VALUES)/sizeof(*LEXER_INTRINSIC_VALUES))))
	{
		return LEXER_INTRINSIC_IDS[result-LEXER_INTRINSIC_VALUES];
	}
	return boost::wave::T_IDENTIFIER;
}
struct LexNames
{
	typedef std::set<LexString, std::less<LexString>, DebugAllocator<int> >Identifiers;
	Identifiers identifiers;
	Identifiers filenames;
	const char*makeIdentifier(const char*value)
	{
		ProfileScope profile(gProfileIdentifier);
		return (*identifiers.insert(value).first).c_str();
	}
	Name makeFilename(const char*value)
	{
		ProfileScope profile(gProfileIdentifier);
		LexString tmp(value);
		for(LexString::iterator i=tmp.begin();
		i!=tmp.end();
		++i)
		{
			if(*i=='\\')
			{
				*i='/';
			}
		}
		return Name((*filenames.insert(tmp).first).c_str());
	}
	FilePosition makeFilePosition(const LexFilePosition&position)
	{
		FilePosition result=
		{
			position.get_file(), position.get_line(), position.get_column()
		};
		return result;
	}
};
std::ptrdiff_t popDirectories(const char*path, std::size_t n)
{
	const char*last=findFilename(path);
	for(std::size_t i=0;
	i!=n;
	++i)
	{
		if(!(last!=path))
		{
			throw LexError();
		};
		const char*p=last-1;
		for(;
		;
		)
		{
			if(path==p)
			{
				return i-n;
			}
			--p;
			if(*p=='/')
			{
				last=p+1;
				break;
			}
		}
	}
	return last-path;
}
class Hooks: public boost::wave::context_policies::eat_whitespace<token_type>
{
public:
	LexNames&names;
	Path includes[1024];
	size_t depth;
	std::string directive;
	size_t macroDepth;
	size_t macroTokenCount;
	FilePosition macroPosition;
	IncludeDependencyGraph dependencies;
	IncludeDependencyGraph includeGraph;
	IncludeEvents events;
	StringStack ifdef;
	Hooks(LexNames&names): names(names), depth(1), macroDepth(0), macroTokenCount(0)
	{
		includes[0]=Path(Name(""), Name("$outer"));
	}
	template<typename ContextT, typename TokenT>
	bool found_directive(ContextT const&ctx, TokenT const&directive)
	{
		return false;
	}
	template<typename ContextT, typename TokenT, typename ContainerT>
	bool evaluated_conditional_expression(ContextT const&ctx, TokenT const&directive, ContainerT const&expression, bool expression_value)
	{
		return false;
	}
	template<typename ContextT>
	bool found_include_directive(ContextT const&ctx, std::string const&filename, bool include_next)
	{
		directive=std::string(filename.c_str()+1, findFilename(filename.c_str()+1));
		return false;
	}
	template<typename ContextT>
	void resolved_include_file(ContextT const&ctx, std::string const&relname, std::string const&absname, bool is_system_include)
	{
		IncludeDependencyNode&d=includeGraph.get(names.makeFilename(absname.c_str()));
		includeGraph.get(getSourcePath().absolute).insert(&d);
	}
	template<typename ContextT>
	void opened_include_file(ContextT const&ctx, std::string const&relname, std::string const&absname, bool is_system_include)
	{
		std::size_t up=0;
		std::vector<char>normalised;

		{
			const char*p=directive.c_str();
			for(const char*i=p;
			*i!='\0';
			++i)
			{
				if(*i=='\\'||*i=='/')
				{
					if(i-p==0)
					{
					}
					if(i-p==1&&*p=='.')
					{
					}
					else if(i-p==2&&*p=='.'&&*(p+1)=='.')
					{
						if(normalised.empty())
						{
							++up;
						}
						else for(;
						;
						)
						{
							normalised.pop_back();
							if(normalised.back()=='/')
							{
								break;
							}
						}
					}
					else
					{
						normalised.insert(normalised.end(), p, i);
						normalised.push_back('/');
					}
					p=i+1;
				}
			}
		}
		Path parent=includes[depth-1];
		Name absolute=names.makeFilename(absname.c_str());
		bool isLocal=false;
		if(!is_system_include)
		{
			if(*parent.absolute.c_str()=='$')
			{
				isLocal=true;
			}
			else
			{
				std::ptrdiff_t n=popDirectories(parent.absolute.c_str(), up);
				if(n>=0)
				{
					isLocal=std::equal(parent.absolute.c_str(), parent.absolute.c_str()+n, absolute.c_str())&&std::equal(normalised.begin(), normalised.end(), absolute.c_str()+n);
				}
			}
		}
		std::ptrdiff_t n=up;
		StringRange suffix=makeRange("");
		std::vector<char>root;
		if(!isLocal)
		{
			StringRange tmp(makeRange("$include/"));
			root.insert(root.end(), tmp.first, tmp.last);
		}
		else
		{
			n=popDirectories(parent.relative.c_str(), up);
			if(n>0)
			{
				suffix=StringRange(parent.relative.c_str(), parent.relative.c_str()+n);
				n=0;
			}
			else
			{
				n=-n;
			}
		}
		for(;
		n!=0;
		--n)
		{
			StringRange tmp(makeRange("$../"));
			root.insert(root.end(), tmp.first, tmp.last);
		}
		root.insert(root.end(), suffix.first, suffix.last);
		Name relative=names.makeFilename(Concatenate(makeRange(root), makeRange(normalised)).c_str());
		includes[depth]=Path(relative, absolute);
		std::cout<<"lexer: "<<findFilename(includes[depth-1].c_str())<<"  included: "<<findFilename(includes[depth].c_str())<<"\n";
		++depth;
		++events.push;
	}
	template<typename ContextT>
	void returning_from_include_file(ContextT const&ctx)
	{
		--depth;
		std::cout<<"lexer: "<<findFilename(includes[depth-1].c_str())<<"  returned: "<<findFilename(includes[depth].c_str())<<"\n";
		if(events.push!=0)
		{
			--events.push;
		}
		else
		{
			++events.pop;
		}
	}
	bool isConditional(const char*name)
	{
		for(StringStack::const_iterator i=ifdef.begin();
		i!=ifdef.end();
		++i)
		{
			if(*i==name)
			{
				return true;
			}
		}
		return false;
	}
	template<typename ContextT, typename TokenT>
	void expanding_macro(ContextT&ctx, const TokenT&macrodef, const TokenT&macrocall)
	{
		if(++macroDepth==1)
		{
			macroPosition=names.makeFilePosition(macrocall.get_position());
		}
		Name defPath=names.makeFilename(macrodef.get_position().get_file().c_str());
		IncludeDependencyNode&d=dependencies.get(defPath);
		dependencies.get(getSourcePath().absolute).insert(&d);
		if(defPath!=getSourcePath().absolute)
		{
			const char*name=names.makeIdentifier(macrodef.get_value().c_str());
			includeGraph.macros[getSourcePath().absolute].insert(MacroDeclarationSet::value_type(defPath, name));
		}
	}
	template<typename ContextT, typename TokenT, typename ContainerT, typename IteratorT>
	bool expanding_function_like_macro(ContextT&ctx, TokenT const&macrodef, std::vector<TokenT>const&formal_args, ContainerT const&definition, TokenT const&macrocall, std::vector<ContainerT>const&arguments, IteratorT const&seqstart, IteratorT const&seqend)
	{
		expanding_macro(ctx, macrodef, macrocall);
		return false;
	}
	template<typename ContextT, typename TokenT, typename ContainerT>
	bool expanding_object_like_macro(ContextT const&ctx, TokenT const&macrodef, ContainerT const&definition, TokenT const&macrocall)
	{
		expanding_macro(ctx, macrodef, macrocall);
		return false;
	}
	template<typename ContextT, typename ContainerT>
	void rescanned_macro(ContextT const&ctx, ContainerT const&result)
	{
		if(!(macroDepth!=0))
		{
			throw LexError();
		};
		if(--macroDepth==0)
		{
			if(!(result.size()>0))
			{
				throw LexError();
			};
			macroTokenCount=result.size()-1;
		}
	}
	template<typename ContextT, typename TokenT, typename ParametersT, typename DefinitionT>
	void defined_macro(ContextT const&ctx, TokenT const&macro_name, bool is_functionlike, ParametersT const&parameters, DefinitionT const&definition, bool is_predefined)
	{
	}
	template<typename ContextT, typename ExceptionT>
	void throw_exception(ContextT const&ctx, ExceptionT const&e)
	{
		boost::throw_exception(e);
	}
	template<typename ContextT>
	void throw_exception(ContextT const&ctx, boost::wave::preprocess_exception const&e)
	{
		std::cerr<<e.file_name()<<"("<<e.line_no()<<"): "<<e.description()<<std::endl;
		if(!boost::wave::is_recoverable(e))
		{
			throw LexError();
		}
	}
	Path getSourcePath()const
	{
		return includes[depth-1];
	}
};
class FileBuffer
{
	FileBuffer(const FileBuffer&);
	FileBuffer&operator=(const FileBuffer&);
public:
	char*buffer;
	size_t length;
	FileBuffer(): buffer(0)
	{
	}
	FileBuffer(std::ifstream&instream)
	{
		instream.seekg(0, std::ios::end);
		length=size_t(instream.tellg());
		instream.seekg(0, std::ios::beg);
		buffer=new char[length];
		length=size_t(instream.readsome(buffer, length));
	}
	~FileBuffer()
	{
		delete[]buffer;
	}
};
struct LoadFile
{
	typedef const char*iterator_type;
	template<typename IterContextT>
	struct inner
	{
		FileBuffer file;
		template<typename PositionT>
		static void init_iterators(IterContextT&iter_ctx, PositionT const&act_pos, boost::wave::language_support language)
		{
			ProfileScope profile(gProfileIo);
			typedef typename IterContextT::iterator_type iterator_type;
			std::ifstream instream(iter_ctx.filename.c_str());
			if(!instream.is_open())
			{

				{
					using namespace boost::wave;
					std::stringstream stream;
					stream<<preprocess_exception::severity_text(preprocess_exception::bad_include_file)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_include_file);
					if((iter_ctx.filename.c_str())[0]!=0)stream<<": "<<(iter_ctx.filename.c_str());
					stream<<std::ends;
					iter_ctx.ctx.get_hooks().throw_exception(iter_ctx.ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_include_file, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
				};
				return ;
			}
			instream.unsetf(std::ios::skipws);
			iter_ctx.file.~FileBuffer();
			new(&iter_ctx.file)FileBuffer(instream);
			iter_ctx.first=iterator_type(iter_ctx.file.buffer, iter_ctx.file.buffer+iter_ctx.file.length, PositionT(iter_ctx.filename), language);
			iter_ctx.last=iterator_type();
		}
	};
};
struct StreamFile
{
	typedef std::istreambuf_iterator<char>base_iterator_type;
	typedef boost::spirit::multi_pass<base_iterator_type>IteratorBase;
	struct Iterator: IteratorBase
	{
		Iterator()
		{
		}
		Iterator(const base_iterator_type&other): IteratorBase(other)
		{
		}
		reference operator*()const
		{
			return IteratorBase::operator*();
		}
		pointer operator->()const
		{
			return &(operator*());
		}
	};
	typedef Iterator iterator_type;
	template<typename IterContextT>
	struct inner
	{
		template<typename PositionT>
		static void init_iterators(IterContextT&iter_ctx, PositionT const&act_pos, boost::wave::language_support language)
		{
			typedef typename IterContextT::iterator_type iterator_type;
			std::ifstream instream(iter_ctx.filename.c_str());
			if(!instream.is_open())
			{

				{
					using namespace boost::wave;
					std::stringstream stream;
					stream<<preprocess_exception::severity_text(preprocess_exception::bad_include_file)<<": "<<preprocess_exception::error_text(preprocess_exception::bad_include_file);
					if((iter_ctx.filename.c_str())[0]!=0)stream<<": "<<(iter_ctx.filename.c_str());
					stream<<std::ends;
					iter_ctx.ctx.get_hooks().throw_exception(iter_ctx.ctx.derived(), preprocess_exception(stream.str().c_str(), preprocess_exception::bad_include_file, (act_pos).get_line(), (act_pos).get_column(), (act_pos).get_file().c_str()));
				};
				return ;
			}
			instream.unsetf(std::ios::skipws);
			iter_ctx.first=iterator_type(Iterator(base_iterator_type(instream.rdbuf())), Iterator(base_iterator_type()), PositionT(iter_ctx.filename), language);
			iter_ctx.last=iterator_type();
		}
	};
};
typedef LoadFile input_policy_type;
typedef boost::wave::context<input_policy_type::iterator_type, lex_iterator_type, input_policy_type, Hooks>context_type;
struct LexContext: public FileBuffer, public context_type, public LexNames
{
	LexContext(std::ifstream&instream, const char*input): FileBuffer(instream), context_type(FileBuffer::buffer, FileBuffer::buffer+FileBuffer::length, input, *this)
	{
		set_language(boost::wave::language_support(boost::wave::support_normal|boost::wave::support_option_variadics|(boost::wave::support_option_mask&~(boost::wave::support_option_emit_line_directives|boost::wave::support_option_single_line|boost::wave::support_option_emit_pragma_directives))));
	}
};
struct LexIterator: public context_type::iterator_type
{
	LexIterator(const context_type::iterator_type&iterator): context_type::iterator_type(iterator)
	{
	}
};
struct LexToken: public token_type
{
	LexToken(const token_type&token): token_type(token)
	{
	}
};
LexToken&makeToken(token_type&token)
{
	return *static_cast<LexToken*>(&token);
}
const context_type::iterator_type&makeBase(const LexIterator&i)
{
	return *static_cast<const context_type::iterator_type*>(&i);
}
context_type::iterator_type&makeBase(LexIterator&i)
{
	return *static_cast<context_type::iterator_type*>(&i);
}
LexContext&createContext(std::ifstream&instring, const char*input)
{
	return *(new LexContext(instring, input));
}
bool add_include_path(LexContext&context, char const*path)
{
	return context.add_include_path(path);
}
bool add_sysinclude_path(LexContext&context, char const*path)
{
	return context.add_sysinclude_path(path);
}
bool add_macro_definition(LexContext&context, const char*macrostring, bool is_predefined)
{
	return context.add_macro_definition(macrostring, is_predefined);
}
void release(LexContext&context)
{
	delete&context;
}
LexIterator&createBegin(LexContext&lexer)
{
	return *(new LexIterator(lexer.begin()));
}
LexIterator&createEnd(LexContext&lexer)
{
	return *(new LexIterator(lexer.end()));
}
LexIterator&cloneIterator(LexIterator&i)
{
	return *(new LexIterator(i));
}
void assignIterator(LexIterator&i, LexIterator&other)
{
	i=other;
}
void release(LexIterator&i)
{
	delete&i;
}
bool operator==(const LexIterator&l, const LexIterator&r)
{
	return makeBase(l)==makeBase(r);
}
const IncludeDependencyGraph&Lexer::getIncludeGraph()const
{
	return context.get_hooks().includeGraph;
}
const char*Lexer::makeIdentifier(const char*value)
{
	return context.makeIdentifier(value);
}
void Lexer::debugEvents(IncludeEvents events, Name source)
{
	for(unsigned short i=0;
	i!=events.pop;
	++i)
	{
		--depth;
		includes[depth]=Name(0);
	}
	for(unsigned short i=0;
	i!=events.push;
	++i)
	{
		includes[depth++]=Name(0);
	}
	if(includes[depth-1]==Name(0))
	{
		includes[depth-1]=source;
		std::cout<<"parser: "<<findFilenameSafe(includes[depth-1].c_str())<<std::endl;
	}
}
Token*Lexer::read(Token*first, Token*last)
{
	try
	{
		ProfileScope profile(gProfileWave);
		for(;
		this->first!=this->last;
		++makeBase(this->first))
		{
			const token_type&token=*makeBase(this->first);
			if(!isWhiteSpace(token))
			{
				if(isEOF(token))
				{
					continue;
				}
				if(first==last)
				{
					break;
				}

				{
					ProfileScope profile(gProfileDiagnose);
					printer.printToken(token, token.get_value().c_str());
				}
				FilePosition position=context.get_hooks().macroTokenCount==0?context.makeFilePosition(token.get_position()): context.get_hooks().macroPosition;
				LexTokenId id=token;
				const char*name=context.makeIdentifier(token.get_value().c_str());
				if(id==boost::wave::T_IDENTIFIER&&name[0]=='_'&&name[1]=='_')
				{
					id=getLexerIntrinsicId(name);
				}
				*first++=Token(id, TokenValue(name), position, Source(context.get_hooks().getSourcePath(), position.line, position.column), context.get_hooks().events);
				context.get_hooks().events=IncludeEvents();
				if(context.get_hooks().macroTokenCount!=0)
				{
					--context.get_hooks().macroTokenCount;
				}
			}
		}
		if(this->first==this->last&&first!=last)
		{
			*first++=Token(boost::wave::T_EOF, TokenValue(), FilePosition(), Source(context.get_hooks().getSourcePath(), 0, 0), context.get_hooks().events);
		}
	}
	catch(boost::wave::cpp_exception const&e)
	{
		std::cerr<<e.file_name()<<"("<<e.line_no()<<"): "<<e.description()<<std::endl;
		throw LexError();
	}
	catch(boost::wave::cpplexer::lexing_exception const&e)
	{
		std::cerr<<e.file_name()<<"("<<e.line_no()<<"): "<<e.description()<<std::endl;
		throw LexError();
	}
	return first;
}
void increment(LexIterator&i)
{
	try
	{
		++makeBase(i);
	}
	catch(boost::wave::cpp_exception const&e)
	{
		std::cerr<<e.file_name()<<"("<<e.line_no()<<"): "<<e.description()<<std::endl;
		throw LexError();
	}
	catch(boost::wave::cpplexer::lexing_exception const&e)
	{
		std::cerr<<e.file_name()<<"("<<e.line_no()<<"): "<<e.description()<<std::endl;
		throw LexError();
	}
}
const LexToken&dereference(const LexIterator&i)
{
	try
	{
		return makeToken(*i);
	}
	catch(boost::wave::cpp_exception const&e)
	{
		std::cerr<<e.file_name()<<"("<<e.line_no()<<"): "<<e.description()<<std::endl;
		throw LexError();
	}
	catch(boost::wave::cpplexer::lexing_exception const&e)
	{
		std::cerr<<e.file_name()<<"("<<e.line_no()<<"): "<<e.description()<<std::endl;
		throw LexError();
	}
}
const char*get_value(const LexToken&token)
{
	return token.get_value().c_str();
}
LexTokenId get_id(const LexToken&token)
{
	return token;
}
const LexFilePosition&get_position(const LexToken&token)
{
	return token.get_position();
}
namespace std
{
	using::va_list;
}
extern "C"
{
	void _wassert(const wchar_t*_Message, const wchar_t*_File, unsigned _Line);
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			template<typename StringT>
			class token_cache
			{
			public:
				token_cache(): cache(T_LAST_TOKEN-T_FIRST_TOKEN)
				{
					typename std::vector<StringT>::iterator it=cache.begin();
					for(unsigned int i=T_FIRST_TOKEN;
					i<T_LAST_TOKEN;
					++i, ++it)
					{
						*it=StringT(boost::wave::get_token_value(token_id(i)));
					}
				}
				StringT const&get_token_value(token_id id)const
				{
					return cache[boost::wave::token_id(((id)&~boost::wave::ExtTokenTypeMask))-T_FIRST_TOKEN];
				}
			private:
				std::vector<StringT>cache;
			};
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace impl
			{
				template<typename StringT>
				inline bool is_trigraph(StringT const&trigraph)
				{
					if(trigraph.size()<3||'?'!=trigraph[0]||'?'!=trigraph[1])return false;
					switch(trigraph[2])
					{
						case '\'': case '=': case '/': case '(': case ')': case '<': case '>': case '!': case '-': break;
						default: return false;
					}
					return true;
				}
				template<typename StringT>
				inline StringT convert_trigraph(StringT const&trigraph)
				{
					StringT result(trigraph);
					if(is_trigraph(trigraph))
					{
						switch(trigraph[2])
						{
							case '\'': result="^";
							break;
							case '=': result="#";
							break;
							case '/': result="\\";
							break;
							case '(': result="[";
							break;
							case ')': result="]";
							break;
							case '<': result="{";
							break;
							case '>': result="}";
							break;
							case '!': result="|";
							break;
							case '-': result="~";
							break;
						}
					}
					return result;
				}
				template<typename StringT>
				inline StringT convert_trigraphs(StringT const&value)
				{
					StringT result;
					typename StringT::size_type pos=0;
					typename StringT::size_type pos1=value.find_first_of("?", 0);
					if(StringT::npos!=pos1)
					{
						do
						{
							result+=value.substr(pos, pos1-pos);
							StringT trigraph(value.substr(pos1));
							if(is_trigraph(trigraph))
							{
								result+=convert_trigraph(trigraph);
								pos1=value.find_first_of("?", pos=pos1+3);
							}
							else
							{
								result+=value[pos1];
								pos1=value.find_first_of("?", pos=pos1+1);
							}
						}
						while(StringT::npos!=pos1);
						result+=value.substr(pos);
					}
					else
					{
						result=value;
					}
					return result;
				}
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace re2clex
			{
				typedef std::size_t aq_stdelement;
				typedef struct tag_aq_queuetype
				{
					std::size_t head;
					std::size_t tail;
					std::size_t size;
					std::size_t max_size;
					aq_stdelement*queue;
				}
				aq_queuetype;
				typedef aq_queuetype*aq_queue;
				int aq_enqueue(aq_queue q, aq_stdelement e);
				int aq_enqueue_front(aq_queue q, aq_stdelement e);
				int aq_serve(aq_queue q, aq_stdelement*e);
				int aq_pop(aq_queue q);
				int aq_grow(aq_queue q);
				aq_queue aq_create(void);
				void aq_terminate(aq_queue q);
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace re2clex
			{
				struct Scanner;
				typedef unsigned char uchar;
				typedef int(*ReportErrorProc)(struct Scanner const*, int errorcode, char const*, ...);
				typedef struct Scanner
				{
					uchar*first;
					uchar*act;
					uchar*last;
					uchar*bot;
					uchar*top;
					uchar*eof;
					uchar*tok;
					uchar*ptr;
					uchar*cur;
					uchar*lim;
					unsigned int line;
					unsigned int column;
					unsigned int curr_column;
					ReportErrorProc error_proc;
					char const*file_name;
					aq_queue eol_offsets;
					bool enable_ms_extensions;
					bool act_in_c99_mode;
					bool detect_pp_numbers;
					bool enable_import_keyword;
					bool single_line_only;
				}
				Scanner;
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace re2clex
			{
				struct Scanner;
				boost::wave::token_id scan(Scanner*s);
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			template<typename Token>
			class include_guards
			{
			public:
				include_guards(): state(&include_guards::state_0), detected_guards(false), current_state(true), if_depth(0)
				{
				}
				Token&detect_guard(Token&t)
				{
					return current_state?(this->*state)(t): t;
				}
				bool detected(std::string&guard_name_)const
				{
					if(detected_guards)
					{
						guard_name_=guard_name.c_str();
						return true;
					}
					return false;
				}
			private:
				typedef Token&state_type(Token&t);
				state_type include_guards::*state;
				bool detected_guards;
				bool current_state;
				typename Token::string_type guard_name;
				int if_depth;
				state_type state_0, state_1, state_2, state_3, state_4, state_5;
				state_type state_1a, state_1b, state_1c, state_1d, state_1e;
				bool is_skippable(token_id id)const
				{
					return (T_POUND==boost::wave::token_id((id)&boost::wave::MainTokenMask)||((((id)&boost::wave::TokenTypeMask)==(WhiteSpaceTokenType))?true: false)||((((id)&boost::wave::TokenTypeMask)==(EOLTokenType))?true: false));
				}
			};
			template<typename Token>
			inline Token&include_guards<Token>::state_0(Token&t)
			{
				token_id id=token_id(t);
				if(T_PP_IFNDEF==id)state=&include_guards::state_1;
				else if(T_PP_IF==id)state=&include_guards::state_1a;
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_1(Token&t)
			{
				token_id id=token_id(t);
				if(T_IDENTIFIER==id)
				{
					guard_name=t.get_value();
					state=&include_guards::state_2;
				}
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_1a(Token&t)
			{
				token_id id=token_id(t);
				if(T_NOT==boost::wave::token_id((id)&boost::wave::MainTokenMask))state=&include_guards::state_1b;
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_1b(Token&t)
			{
				token_id id=token_id(t);
				if(T_IDENTIFIER==id&&t.get_value()=="defined")state=&include_guards::state_1c;
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_1c(Token&t)
			{
				token_id id=token_id(t);
				if(T_LEFTPAREN==id)state=&include_guards::state_1d;
				else if(T_IDENTIFIER==id)
				{
					guard_name=t.get_value();
					state=&include_guards::state_2;
				}
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_1d(Token&t)
			{
				token_id id=token_id(t);
				if(T_IDENTIFIER==id)
				{
					guard_name=t.get_value();
					state=&include_guards::state_1e;
				}
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_1e(Token&t)
			{
				token_id id=token_id(t);
				if(T_RIGHTPAREN==id)state=&include_guards::state_2;
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_2(Token&t)
			{
				token_id id=token_id(t);
				if(T_PP_DEFINE==id)state=&include_guards::state_3;
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_3(Token&t)
			{
				token_id id=token_id(t);
				if(T_IDENTIFIER==id&&t.get_value()==guard_name)state=&include_guards::state_4;
				else if(!is_skippable(id))current_state=false;
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_4(Token&t)
			{
				token_id id=token_id(t);
				if(T_PP_IF==id||T_PP_IFDEF==id||T_PP_IFNDEF==id)++if_depth;
				else if(T_PP_ENDIF==id)
				{
					if(if_depth>0)--if_depth;
					else state=&include_guards::state_5;
				}
				return t;
			}
			template<typename Token>
			inline Token&include_guards<Token>::state_5(Token&t)
			{
				token_id id=token_id(t);
				if(T_EOF==id)detected_guards=current_state;
				else if(!is_skippable(id))current_state=false;
				return t;
			}
		}
	}
}
namespace boost
{
	namespace wave
	{
		namespace cpplexer
		{
			namespace re2clex
			{
				template<typename IteratorT, typename PositionT=boost::wave::util::file_position_type, typename TokenT=lex_token<PositionT> >
				class lexer
				{
				public:
					typedef TokenT token_type;
					typedef typename token_type::string_type string_type;
					lexer(IteratorT const&first, IteratorT const&last, PositionT const&pos, boost::wave::language_support language_);
					~lexer();
					token_type&get(token_type&);
					void set_position(PositionT const&pos)
					{
						filename=pos.get_file();
						scanner.line=pos.get_line();
						scanner.file_name=filename.c_str();
					}
					bool has_include_guards(std::string&guard_name)const
					{
						return guards.detected(guard_name);
					}
					static int report_error(Scanner const*s, int code, char const*, ...);
				private:
					static char const*tok_names[];
					Scanner scanner;
					string_type filename;
					string_type value;
					bool at_eof;
					boost::wave::language_support language;
					include_guards<token_type>guards;
					static token_cache<string_type>const cache;
				};
				template<typename IteratorT, typename PositionT, typename TokenT>
				inline lexer<IteratorT, PositionT, TokenT>::lexer(IteratorT const&first, IteratorT const&last, PositionT const&pos, boost::wave::language_support language_): filename(pos.get_file()), at_eof(false), language(language_)
				{
					using namespace std;
					memset(&scanner, '\0', sizeof(Scanner));
					scanner.eol_offsets=aq_create();
					if(first!=last)
					{
						scanner.first=scanner.act=(uchar*)&(*first);
						scanner.last=scanner.first+std::distance(first, last);
					}
					scanner.line=pos.get_line();
					scanner.column=scanner.curr_column=pos.get_column();
					scanner.error_proc=report_error;
					scanner.file_name=filename.c_str();
					scanner.enable_ms_extensions=false;
					scanner.act_in_c99_mode=boost::wave::need_c99(language_);
					scanner.enable_import_keyword=false;
					scanner.detect_pp_numbers=boost::wave::need_prefer_pp_numbers(language_);
					scanner.single_line_only=boost::wave::need_single_line(language_);
				}
				template<typename IteratorT, typename PositionT, typename TokenT>
				inline lexer<IteratorT, PositionT, TokenT>::~lexer()
				{
					using namespace std;
					aq_terminate(scanner.eol_offsets);
					free(scanner.bot);
				}
				template<typename IteratorT, typename PositionT, typename TokenT>
				inline TokenT&lexer<IteratorT, PositionT, TokenT>::get(TokenT&result)
				{
					if(at_eof)return result=token_type();
					unsigned int actline=scanner.line;
					token_id id=token_id(scan(&scanner));
					switch(static_cast<unsigned int>(id))
					{
						case T_IDENTIFIER: value=string_type((char const*)scanner.tok, scanner.cur-scanner.tok);
						if(!boost::wave::need_no_character_validation(language))impl::validate_identifier_name(value, actline, scanner.column, filename);
						break;
						case T_STRINGLIT: case T_CHARLIT: value=string_type((char const*)scanner.tok, scanner.cur-scanner.tok);
						if(boost::wave::need_convert_trigraphs(language))value=impl::convert_trigraphs(value);
						if(!boost::wave::need_no_character_validation(language))impl::validate_literal(value, actline, scanner.column, filename);
						break;
						case T_PP_HHEADER: case T_PP_QHEADER: case T_PP_INCLUDE:
						{
							value=string_type((char const*)scanner.tok, scanner.cur-scanner.tok);
							typename string_type::size_type start=value.find("include");
							if(value.compare(start, 12, "include_next", 12)==0)id=token_id(id|AltTokenType);
							break;
						}
						case T_LONGINTLIT: value=string_type((char const*)scanner.tok, scanner.cur-scanner.tok);
						if(!boost::wave::need_long_long(language))
						{

							{
								using namespace boost::wave;
								std::stringstream stream;
								stream<<lexing_exception::severity_text(lexing_exception::invalid_long_long_literal)<<": "<<lexing_exception::error_text(lexing_exception::invalid_long_long_literal);
								if((value.c_str())[0]!=0)stream<<": "<<(value.c_str());
								stream<<std::ends;
								boost::throw_exception(lexing_exception(stream.str().c_str(), lexing_exception::invalid_long_long_literal, actline, scanner.column, filename.c_str()));
							};
						}
						break;
						case T_OCTALINT: case T_DECIMALINT: case T_HEXAINT: case T_INTLIT: case T_FLOATLIT: case T_FIXEDPOINTLIT: case T_CCOMMENT: case T_CPPCOMMENT: case T_SPACE: case T_SPACE2: case T_ANY: case T_PP_NUMBER: value=string_type((char const*)scanner.tok, scanner.cur-scanner.tok);
						break;
						case T_EOF: at_eof=true;
						value.clear();
						break;
						case T_OR_TRIGRAPH: case T_XOR_TRIGRAPH: case T_LEFTBRACE_TRIGRAPH: case T_RIGHTBRACE_TRIGRAPH: case T_LEFTBRACKET_TRIGRAPH: case T_RIGHTBRACKET_TRIGRAPH: case T_COMPL_TRIGRAPH: case T_POUND_TRIGRAPH: if(boost::wave::need_convert_trigraphs(language))
						{
							value=cache.get_token_value(boost::wave::token_id(((id)&~boost::wave::ExtTokenTypeMask)));
						}
						else
						{
							value=string_type((char const*)scanner.tok, scanner.cur-scanner.tok);
						}
						break;
						case T_ANY_TRIGRAPH: if(boost::wave::need_convert_trigraphs(language))
						{
							value=impl::convert_trigraph(string_type((char const*)scanner.tok));
						}
						else
						{
							value=string_type((char const*)scanner.tok, scanner.cur-scanner.tok);
						}
						break;
						default: if(((id)&boost::wave::TokenTypeMask)!=((id)&boost::wave::ExtTokenTypeMask)||((((id)&boost::wave::TokenTypeMask)==(UnknownTokenType))?true: false))
						{
							value=string_type((char const*)scanner.tok, scanner.cur-scanner.tok);
						}
						else
						{
							value=cache.get_token_value(id);
						}
						break;
					}
					result=token_type(id, value, PositionT(filename, actline, scanner.column));
					return guards.detect_guard(result);
				}
				template<typename IteratorT, typename PositionT, typename TokenT>
				inline int lexer<IteratorT, PositionT, TokenT>::report_error(Scanner const*s, int errcode, char const*msg, ...)
				{
					(void)((!!(0!=s))||(_wassert(L"0 != s", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpplexer\\re2clex\\cpp_re2c_lexer.hpp", 306), 0));
					(void)((!!(0!=msg))||(_wassert(L"0 != msg", L"D:\\dev\\boost_1_41_0\\boost\\wave\\cpplexer\\re2clex\\cpp_re2c_lexer.hpp", 307), 0));
					using namespace std;
					char buffer[200];
					va_list params;
					(params=(va_list)(&reinterpret_cast<const char&>(msg))+((sizeof(msg)+sizeof(int)-1)&~(sizeof(int)-1)));
					vsprintf(buffer, msg, params);
					(params=(va_list)0);

					{
						using namespace boost::wave;
						lexing_exception::error_code code=static_cast<lexing_exception::error_code>(errcode);
						std::stringstream stream;
						stream<<lexing_exception::severity_text(code)<<": "<<lexing_exception::error_text(code);
						if((buffer)[0]!=0)stream<<": "<<(buffer);
						stream<<std::ends;
						boost::throw_exception(lexing_exception(stream.str().c_str(), code, s->line, s->column, s->file_name));
					};
					return 0;
				}
				template<typename IteratorT, typename PositionT=boost::wave::util::file_position_type, typename TokenT=typename lexer<IteratorT, PositionT>::token_type>
				class lex_functor: public lex_input_interface_generator<TokenT>
				{
				public:
					typedef TokenT token_type;
					lex_functor(IteratorT const&first, IteratorT const&last, PositionT const&pos, boost::wave::language_support language): re2c_lexer(first, last, pos, language)
					{
					}
					virtual~lex_functor()
					{
					}
					token_type&get(token_type&result)
					{
						return re2c_lexer.get(result);
					}
					void set_position(PositionT const&pos)
					{
						re2c_lexer.set_position(pos);
					}
					bool has_include_guards(std::string&guard_name)const
					{
						return re2c_lexer.has_include_guards(guard_name);
					}
				private:
					lexer<IteratorT, PositionT, TokenT>re2c_lexer;
				};
				template<typename IteratorT, typename PositionT, typename TokenT>
				token_cache<typename lexer<IteratorT, PositionT, TokenT>::string_type>const lexer<IteratorT, PositionT, TokenT>::cache=token_cache<typename lexer<IteratorT, PositionT, TokenT>::string_type>();
			}
			template<typename IteratorT, typename PositionT, typename TokenT>
			lex_input_interface<TokenT>*new_lexer_gen<IteratorT, PositionT, TokenT>::new_lexer(IteratorT const&first, IteratorT const&last, PositionT const&pos, boost::wave::language_support language)
			{
				using re2clex::lex_functor;
				return new lex_functor<IteratorT, PositionT, TokenT>(first, last, pos, language);
			}
		}
	}
}
template struct boost::wave::cpplexer::new_lexer_gen<input_policy_type::iterator_type, LexFilePosition>
;

