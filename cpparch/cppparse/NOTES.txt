
+ task: remove check for 'declaration->enclosing' in LEFTBRACE of class-specifier
+ task: assert result of findEnclosingType is not 0
+ task: assert Type::unique is valid when checking Type::isDependent
+ crash: infinite loop in findDeclaration, type is base of base of itself
	- struct D : B {}; struct B : D {};
	- use visited flag to prevent infinite recursion
+ assert: D:\dev\cpparch\cppparse\msvc-8.0\include\xdebug:110
	- instantiation of basic_string<char, char_traits<char>, _DebugHeapAllocator<char> > in base-specifier of _DebugHeapString
	- when instantiated at point of declaration of _DebugHeapString, unique-type differs to instantiation in base-specifier
	- second template argument has a different type: iosfwd:155 char_traits<T> vs iosfwd:406 char_traits<char>
	- occurs because type was uniqued with 'allowDependent' when it was not dependent
+ assert: D:\dev\cpparch\cppparse\msvc-8.0\include\xlocale:347 (iostream.prepro.cpp:6966:25)
	- instantiation of std::string in return value of Locinfo::Getname()
	- when instantiated at overload resolution for Getname(), unique-type differs to instantiation in declaration
	- second template argument has a different type: new: char_traits<T> vs original: char_traits<char>
	- occurs because type was uniqued with 'allowDependent' when it was not dependent
+ task: make-unique for all types at point of parse, allowDependent=true for unique types
	- set isDependent=true on Type if dependent, do not look up names in base classes with isDependent=true
+ task: make-unique the enclosing type even when it's a template
	- always allow dependent if it's a template
+ task: use enclosing scope to determine whether type name is name of enclosing class
+ task: modify instantiateClass to instantiate base classes of the enclosing template class
	- also instantiate dependent base classes, but don't add them to the list if allowDependent=true
	- is allowDependent=true in context where base classes are no longer dependent?
		- e.g. D<int>::B
+ task: use the 'type' of a class definition to store unique-type
+ task: proper type for enumerators, instead of gEnumerator
+ problem: ambiguity in template-argument between assignment-expression and type-id: T() and T(arg)
	- trying 'type-id' first is correct in former, wrong in latter
	- vice versa for assignment-expression
	- [temp.arg] In a template argument, an ambiguity between a typeid and an expression is resolved to a typeid,
		regardless of the form of the corresponding template parameter
	- detect ambiguous expression and explicitly mark with isTemplateArgumentAmbiguity
+ test: parsing f(x,...)
+ task: basic support for non-type arguments
	+ store non-type argument value
	+ parse constant literals
	+ get value for constant id-expression
		+ enumerator
	+ evaluate non-dependent integral constant expressions
		- binary
		- ternary
		- cast
		- sizeof
	+ deferred evaluation of dependent integral constant expressions
		- need to substitute non-type template parameters
			- N
			- T::value
		- need to substitute template-parameters
			- sizeof(T)
			- T(0)
		- parse expression into visitable tree
		- walk tree to perform substitution
			- is this necessary for values? can evaluate and substitute at the same time..
			- does this work when substituting types?
		- walk tree to evaluate
		- walk tree to compare for equality?
			- unique expressions?
		- ensure comma-operator evaluated left to right
		- can evaluate types with separate tree?
			- evaluating types (but not values) also required for non-integral non-constant expression
				- to determine argument types for overload resolution
				- evaluation must be deferred if expression is dependent
				- node set overlaps - some also occur in integral constant-expression
				- required in integral-constant-expression to evaluate sizeof(f())
			- sometimes type depends on value, and vice versa
				- sizeof(0) // value depends on type of '0' (but NOT value)
				- X<0> // type depends on value of '0' (but NOT type
+ investigate: how does bidirectional_map work?
	- multi_index_container -> multi_index_base_type<...>::type -> nth_layer<0, ...>::type
		- nth_layer::type = apply2<index_applier, T1, T2>::type
			- apply2<F, T1, T2> -> lambda<F>::type::apply<T1, T2> -> F::apply<T1, T2>
		- index_applier::apply<T1, T2>::type -> T1::type::index_class<T2>::type
			- T1 = at_c<IndexSpecifierList, N>
			- T2 = nth_layer<N+1, ...>
			-> at_c<IndexSpecifierList, N>::type::index_class<nth_layer<N+1, ...>>::type
		- IndexSpecifier list: either ordered_unique or ordered_non_unique
		- ordered_unique::index_class<T1>::type -> ordered_index<T1 ...>::type
		- why is 'length' 20?
			- indexed_by is a vector20
			- vector<T1, T2, na, ..> should be vector2!
+ issue: 'context' is still being instantiated while looking up names within it
	LexContext
		-> context
		-> macromap<context>::name_iterator (instantiate macromap<context>)
		-> ContextT::token_type token_type (instantiate ContextT)
	- correct behaviour left unspecified, see DR 287
		- "This was discussed at length. The consensus was that the template case should be treated the same as the non-template class case
			in terms of the order in which members get declared/defined and classes get completed."
	- during qualified name lookup within instantiation for a member of a class which is partially instantiated, only names declared before the point of instantiation are visible
		- including dependent base classes!
		- but names in bases of partially instantiated class cannot be accessed from within instantiation of its base
	- track point of instantiation for each declaration in WalkerState
		- automatically rolls back if parse fails
		- per instance, because redeclaration may make name visible after being hidden
	- during parse of template definition, when complete type is required
		- if non-dependent, instantiate type and store point of instantiation
		- else add type to list of child instantiations and store declaration visibility
		- when instantiating template, used stored declaration visibility when instantiating child
	- in what contexts do child instantiations occur?
		- type of member definition required to be complete
		- type of base required to be complete
		- type named in member/base type-id
			- nested-name-specifier
		- type in expression required to be complete
			- static-const initializer
			- template-argument expression
				- in specialization arguments
+ task: template argument deduction
	+ for function templates
	+ for class template partial-specializations
		- specialization is matched if its arguments can be deduced from the template arguments vs the specialization argument list
	- what is "type deduction"?
		- the process of determining the template arguments, from a set of dependent types (e.g. function parameters) and a set of non-dependent types (e.g. function-call arguments)
		- involves 'substitution' of 'substition-failure'
		- [temp.deduct] When an explicit template argument list is specified, the template arguments must be compatible with the
			template parameter list and must result in a valid function type.
			If a substitution in a template parameter or in the function type of the function template results in an invalid type, type deduction fails.
		- unspecified arguments must be deduced before substitution
		- for each dependent type, substitute template-parameters with template-arguments; fail if the result is an invalid type
		- perform function parameter type adjustments
	- steps in argument deduction for function template
		- for each function-parameter, find template-parameters (for allowed forms, ignoring nondeduced contexts) and fill in template-arguments with corresponding type from function-call arguments
	- type substitution for name qualified by dependent type
		- similar process to what currently happens in makeUniqueType
		- look up declaration in enclosing type
		- perform substitution in context of enclosing type
	- partial ordering of partial-specializations
		- compare specialization A to specialisation B
		- use A's specialization-arguments to match B
		- e.g. 'A<T*>' matches 'B<T>', but 'A<T>' does not match 'B<T*>'
		- if A matches B but B does not match A, A is more specialized
	- what causes <const T> and 'int' to fail deduction?
		- likewise, what causes <const T> and 'const int' to deduce 'int' ?
	- deduction for non-type
	- substitution for non-type
	- substitute while deducing?
		- [temp.deduct] When all template arguments have been deduced, all uses of template parameters in
			nondeduced contexts are replaced with the corresponding deduced argument values. If the substitution
			results in an invalid type, as described above, type deduction fails.

+ task: make enclosingType valid for out-of-line member definitions
+ task: unique dependent template-name: T::template X<int>

+ task: correct name lookup for template explicit/partial specializations
	- [temp.class.spec] Partial specialization declarations themselves are not found by name lookup.
	- [temp.class.spec.match] When a class template is used in a context that requires an instantiation of the class, it is necessary to determine
			whether the instantiation is to be generated using the primary template or one of the partial specializations.
		- implies that this is not determined (e.g. no argument deduction is performed) until the class template is instantiated?
	- don't add to declarations? If not, where to store Declaration?
	- add, but ignore during name lookup?
		- inefficient, but works
	- store list of specializations in primary template
		- modifying existing declaration when specialization is declared is hard to undo when specialization is undeclared
	- forward declaration of partial specialization is invisible?
+ task: in makeUniqueType, use previously uniqued type if available and isDependent=false.
	+ assert that previously uniqued type is equal to result of makeUniqueType
		- can only do this if both the previously uniqued type and the result of makeUniqueType are not dependent
	- in declaration with dependent type, store index into array of dependent member types
		- build array of dependent member types on parse, stored in enclosing dependent unique-type
		- when instantiating unique-type, fill array with member unique-types
	+ perform type substitution on dependent unique-type
		- DependentType: substitute template parameter from enclosing type for argument
		- DependentTypename: perform name lookup to find member-declaration
			- if member-declaration is class-declaration, build simple ObjectType from declaration
			- else if found member-declaration's Type has isDependent=false, use its unique-type
			- else look up unique-type in (instantiated) enclosing type
		- DependentTemplate: as above, plus stored template arguments
			- add default arguments to stored arguments if necessary, add to ObjectType
+ task: template instantiation debugging
	- for a given instantiation, report which instantiations it requires
		- track required instantiations
		- add to list in enclosing-type when calling instantiateClass
			- contains instance+location
			- reversal of existing graph?
				- except that existing graph does not store location
		- instantiation graph: maps enclosing-type to children
			- multimap, key of enclosing type, data of instance+location?
				- hard to debug
	- for each required instantiation
		- link to instantiation page
		- point of instantiation: file/line/column
	- display point of instantiation in source code
		- source file? can't auto scroll without inserting markup
		- inline only selected line(s)?
			- how to display long lines?
			- performance if file is large?
				- create index of source lines during prepro?
					- unnecessary performance hit?
				- ideally could get pointer to location in input file buffer for each token
				- performance not critical for error reporting
			- source lines should only be within template definition?
+ task: remove check for isMemberOfTemplate that guards overload resolution: findBestMatch
	- investigate: is it possible to do overload resolution and choose a function that has a dependent return type?
		- example: calling an overloaded static member of a template, within sizeof(), to initialise a static-const member
		- should defer overload resolution if any overload is declared with a dependent type
		- defect 541: http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html
	- required because member-functions of template classes may have dependent arguments
		- conformant solution: function-call expression is dependent if function has any overloads that are declared with a dependent type
		- don't perform overload resolution if function-call expression is dependent
+ issue: out-of-line member function template definition is not determined to be template
	- because testing 'parent == templateEnclosing'
	- should test 'enclosing == templateEnclosing'?
		- but 'enclosing' refers to template-param scope
		- enclosing is the scope in which name lookup occurs
			- must include template-params in name lookup
	- test whether template-params were specified
		- empty params for explicit specialization
+ issue: ignoring difference in return type means two template functions that differ only by return-type (and template-params) are considered equivalent
	- this is a hack for case where return-type is a typename - template<typename U> typename S<U>::Type S<U>::f() {}
	- ignore return type and compare template params instead
	
+ investigate: how to reduce callstack depth in debug
	- sample of small call-stack within expression-parsing
		- 233 levels
		- parseExpression: 11
		+ parseSymbol: 37
		- parseSymbolRequired: 38
		+ ParserGeneric::parse: 38
		- cpp::[symbol]::parse: 13
		- ParsingVisitor::visit: 13
		- *Walker::visit: 26
		- Default.ChoiceParser::parseSymbol: 22
+ investigate: when resolving unique type of a declaration named by an id-expression, do we need an enclosing-type if the id-expression names a non-member?
	- if member, use type of enclosing class when resolving unique type of the member
	- if non-member, type cannot be dependent on an enclosing class?
		- could be dependent on template parameter of enclosing template function
	- therefore answer is yes
+ task: correct implementation of partial ordering for function templates
	- use C++11 [temp.deduct.partial]
+ task: implement types for enumerators
	- declare unique type for each enum
	- give its enumerators that type
	- integral promotion
	[ dcl.enum]
	Each enumeration defines a type that is different from all other types. Following the closing brace of an
	enum-specifier, each enumerator has the type of its enumeration. Prior to the closing brace, the type of
	each enumerator is the type of its initializing value. If an initializer is specified for an enumerator, the initializing
	value has the same type as the expression. If no initializer is specified for the first enumerator, the
	type is an unspecified integral type. Otherwise the type is the same as the type of the initializing value of
	the preceding enumerator unless the incremented value is not representable in that type, in which case the
	type is an unspecified integral type sufficient to contain the incremented value.
+ task: ellipsis in overload resolution
	+ if more arguments than parameters, excess arguments become ellipsis-conversion-sequence
+ task: array-to-pointer conversion in binary expression
	- infer that binary expression requires rvalue operands
	- therefore lvalue-to-rvalue (array to pointer) conversion is performed
	[conv]
	expressions with a given type will be implicitly converted to other types in several contexts:
	- When used as operands of operators. The operator’s requirements for its operands dictate the destination type
	[expr]
	Whenever an lvalue expression appears as an operand of an operator that expects an rvalue for that operand,
	the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are
	applied to convert the expression to an rvalue. [Note: because cv-qualifiers are removed from the type of
	an expression of non-class type when the expression is converted to an rvalue, an lvalue expression of type
	const int can, for example, be used where an rvalue expression of type int is required. ]	
	[expr.add]
	For addition, either both operands shall have arithmetic or enumeration type, or one operand shall be a
	pointer to a completely defined object type and the other shall have integral or enumeration type.



- task: build list of dependent types for deferred uniquing/instantiation in instantiateClass
	- cannot instantiate until unique-type is known, should hold reference to placeholder 'deferred' unique-type
	- avoid duplicates: use dependent unique-type to distinguish?
	- do this whenever complete type is required, but type is dependent

- issue: for class-template, out of line definition of static member is (incorrectly) added to list of child instantiations
	- not usually a problem, except that class-template is 'partially instantiated' during instantiation of its children
		- side effects of child instantiation may require name-lookup within the partially-instantiated class, will fail if names do not 
	- static members should not be instantiated until they are used?

- investigate: can explicit/partial-specializations omit template arguments where there are defaults in the primary template?
	- clang allows with c++98

- investigate: need to compare two function templates with different numbers of parameters when determining partial ordering?

- investigate: is typename required in operator T::Dependent?
	- seems to be..

- investigate: partial specializations: how to substitute template-arguments when uniquing
- investigate: what is the dependent unique-type of a template-partial-specialization?
	- A<T*> where T is the enclosing template parameter?
	- ok to resolve specialization of a dependent unique-type?
	- necessary to correctly unique the enclosing class when parsing a template-partial-specialization

- investigate: is result of makeUniqueType cached during cached-parse of template-id?

- investigate: isMemberObject returns true if member is class definition?
	- is this a problem?

- investigate: is Declaration::valueDependent necessary? Why is it initialised with dependent-ness of it's type's array size?


- investigate: template instantiation
	- perform substitution on dependent unique-types instead of Type

	template<typename T>
	struct S
	{
		T m; // 'S<T>' contains dependent unique-type 'T'

		template<typename U>
		struct V
		{
			U m; // 'S<T>::V<U>' contains dependent unique-type 'U'
		};
	};

	S<int> s; // instantiate S<T> -> S<int>
	S<int>::V<int> v; // instantiate S::<T>::V<U> -> S<int>::V<int>
	
	- S<T> is TypeInstance, with one dependent template-argument
	- unique: 
	- instantiate:


- task: disallow implicit instantiation of a template within its own definition

- problem: findEnclosingType searches bases of incomplete class when within class definition
	- don't use instantiateClass to enable this search: search non-dependent bases if..
		- class is an enclosing template
	- return enclosing type from findDeclaration
		- why?

- test: correct type of expression x = y (should be type of 'x'?)

- task: determine type of dependent pointer-to-member expression
	- for SFINAE during substitution of nontype pointer-to-member parameter &T::member -> int T::*member

- task: determine type of dependent expression
	- requires two-phase name lookup for unqualified names within expression. e.g. f(dependent);
		- for now: [temp.dep.res] Declarations that are visible at the point of definition of the template.
		- if operand is dependent, must store unqualified-id and point-of-definition.
			- point-of-definition is location of original template
		- could do unqualified lookup (but not overload resolution) at point of parse?
		- lookup of member operator overloads within the operand must be deferred, to allow searching dependent base class

- investigate: what is instantiated when instantiating a class?
	- direct member declarations: yes
	- member-functions: no
	- member-classes: no

- task: remove if(walker.type.declaration != 0) and addBase even if declaration is not found

- issue: parser loses track of current token just after parsing last token of default-parameter (and other deferred parse?)

- task: construct templateParamScope when parsing 'template' token
	- construct empty template param scope for explicit specialization?

- task: avoid having to revert changes to TypeId in between parsing multiple declarators in init-declarator-list

- task: when complete type is required for dependent type, add it to children list in enclosing template class

- task: determine type of all non-dependent expressions
	- overload resolution
		- unique type for dependent member of template
		- null-pointer-constant
	- template argument deduction for function template
		- along with explicit template argument specification
		- requires support for function templates
		- substitute template params that have explicit arguments
			- ignore unspecified template params at this point
			- substitute unspecified template params with themselves?
				- much like when name of current-instantiation is used in class template definition

- task: type of overloaded operators: required to determine type of expression
	- postfix operator[]
	- postfix operator++
	- operator->

- task: determine type of conditional-expression with differing second and third operands
	- write tests!

- task: refactor PARSE_EXPRESSION

+ task: overload resolution: implicit object parameter/argument
	// [over.match.funcs] a member function is considered to have an extra parameter, called the implicit object parameter, which
	// represents the object for which the member function has been called. For the purposes of overload resolution,
	// both static and non-static member functions have an implicit object parameter, but constructors do not.
	// Similarly, when appropriate, the context can construct an argument list that contains an implied object
	// argument to denote the object to be operated on.
	- when calling a member function, must always supply an implicit-object-argument
		- when that member is static and is called without a class object, the implied-object-argument is ???

- task: declare copy-assign if not already declared
	- name lookup fails for id-expression 'operator=' when it has not been declared
	- correct behaviour: name lookup for 'operator=' within class should always return default, if not found
		- need a proper declaration to find enclosing class, but implicit declaration has no associated identifier?
			- too complex to manufacture declaration from nothing
		- avoid conflict with overload declarations

- task: test integral promotion for enum

- task: implement function template explicit specialization

- task: implement user-defined-conversion: required for overload resolution
	- over.best.ics] An implicit conversion sequence is a sequence of conversions used to convert an argument in a function
		call to the type of the corresponding parameter of the function being called. The sequence of conversions is
		an implicit conversion as defined in clause 4, which means it is governed by the rules for initialization of an
		object or reference by a single expression (8.5, 8.5.3).
	- [over.ics.user] Since an implicit conversion sequence is an initialization, the special rules for
		initialization by user-defined conversion apply when selecting the best user-defined conversion for a user-
		defined conversion sequence
	- [over.match.ctor], [over.match.copy], [over.match.conv]
	- [class.conv] Function overload resolution selects the best conversion function to perform the conversion.
	- what prevents two user-defined conversions occurring in sequence?
	- constructor call
	- conversion function
	- semantics of initializers
		- references?
		- if destination is class-type (non-reference)
			- if source is same or derived class-type, gather converting constructors, perform overload resolution
			- else gather conversion functions and converting constructors, perform overload resolution
		- else if source is class-type (non-reference)
			- gather conversion functions, perform overload resolution
	- what second standard-conversion is required in user-defined conversion involving constructor-call?
		- is result of constructor-call an lvalue/rvalue?

- task: fix type of conversion function declaration: declarator-ptr not correctly parsed

- task: test conversion function parse special-case
	The conversion-type-id shall not represent a function type nor an array type. The conversion-type-id in a
	conversion-function-id is the longest possible sequence of conversion-declarators. [Note: this prevents
	ambiguities between the declarator operator * and its expression counterparts. [Example:
	&ac.operator int*i; // syntax error:
	// parsed as: &(ac.operator int *) i
	// not as: &(ac.operator int)*i
	The * is the pointer declarator and not the multiplication operator. ] ]

- task: function parameter type transformations during template argument deduction
	[dcl.fct] After determining the
	type of each parameter, any parameter of type “array of T” or “function returning T” is adjusted to be
	“pointer to T” or “pointer to function returning T,” respectively. After producing the list of parameter
	types, several transformations take place upon these types to determine the function type. Any cv-qualifier
	modifying a parameter type is deleted. The resulting list of transformed parameter types is the function’s parameter
	type list.
	[temp.deduct]
	After this substitution is performed, the function parameter type adjustments described in 8.3.5 are performed.
	[Example: A parameter type of “void ()(const int, int[5])” becomes “void(*)(int,int*)”. ]


- task: overload resolution for built-in operators
	- required only when an operand has class or enumeration type
	- how to create infinite number of built-in overloads? e.g. match any pointer type
		- class may have multiple user-defined-conversions that match different types
		- pointer may have multiple valid conversions - e.g. Derived->Base*, T*->void*
		- in case of 'operator==(T*, T*)' arguments may be incompatible but both convertible to void* or Base*
		- for each argument type, need to find intersection of potential parameters types with types to which argument can be converted
		- possible to re-use implicit-conversion code to determine types?
			- difficult to return multiple values, may be simpler to write new code
		- find superset and narrow via overload resolution?
		- initial implementation can disregard user-defined-conversions
		- T*[volatile]& (object)
			- from lvalue T* (or T*volatile), direct reference binding (derived not considered)
			- from C, direct reference binding via operator T* (derived not considered)
			- cannot bind rvalue to non-const reference
		- T* (object, any) (may be cv-qualified)
			- from nullptr, wildcard for other argument
			- from T*, exact match or derived/void
			- from C, user-defined conversion via operator T* (or derived/void)
		- T* (function) (may be cv-qualified)
			- from nullptr, wildcard for other argument
			- from T*, exact match
			- from C, user-defined conversion via operator T*
		- T (pointer to member) (may be cv-qualified)
			- from nullptr, wildcard for other argument
			- from T, exact match or derived
			- from C, user-defined conversion via operator T (or derived)
		- [volatile] T& (arithmetic)
			- from lvalue T, exact match (conversion not considered)
			- from C, user-defined conversion via operator T&
		- [volatile] T& (enum)
			- from lvalue T, exact match (conversion not considered)
			- from C, user-defined conversion via operator T&
		- T (arithmetic)
			- from any arithmetic (or enum), exact match or conversion
			- from C, user-defined conversion via conversion function to any arithmetic (or enum)
		- for a given placeholder parameter/argument pair, find set of types which can replace 'T'
			- takes (to, from, source, enclosing): may cause template instantiation!
			- if reference, bind directly, otherwise perform lvalue-to-rvalue conversion
			- if pointer (or member pointer), add all cv-qualification permutations (and bases)
			- result is simple vector of types for now
			- if T is shared between two parameters, find the union of both sets
			- if T is in two parameters but not shared (e.g. L, R), find all permutations of both sets
			- generate function types and perform overload resolution
	- hide user-written candidates that match built-in overload parameters exactly
	- for enum, overload set contains built-in operators that take types that enum can be converted to
		- e.g. promote to int, convert to any integer type, convert to any floating point type, convert to bool
	- types:
		O=object (not reference, not function, not void)
		F=Function
		G=object-or-function
		A=Arithmetic
		I=Integral
		T=Type
		C=class
		E=enum
		P=pointer
		M=pointer-to-member
	- forms
		O*
		[const] [volatile] O*
		F* (operator*)
		T*
		A
		I
		E
		P
		M
		[volatile] I&
		[volatile] E&
		[volatile] M&
		[volatile] A&
		[volatile] A& (not bool)
		O*[volatile]&
		P[volatile]&
		[const] [volatile] C*
		[const] [volatile] G C::*
	- multiple conversion functions may match?
	- other ambiguities?
	- what conversions should be detected?
		- reference binding
		- exact: pointer qualification adjustment
		- promotion: float -> double, I -> int
		- conversion: A/E -> A
	- which match-all types required?
		- could match all T and reject later?
			- no, would not get correct conversion result
	- placeholder types
		- any
			- T* (unary-plus, relation, equality, assign-r)
			- T*[volatile]& (assign-l)
		- arithmetic
			- [volatile]T& (incr, decr, assign-l)
		- integral
			- [volatile]T& (assign-l)
		- object
			- T*[volatile]& (incr, decr)
			- T* (deref, ptr-add, subscript)
		- function
			- T* (deref)
		- promoted-arithmetic
			- T (assign-r, unary-plus, unary-minus, mul, add, relational, equality, conditional)
		- promoted-integral
			- T (compl, bitwise, shift, remainder)
		- class
			- T* (mptr-call)
		- mptr
			- T (mptr-call, equality, assign-r)
			- [volatile]T& (assign-l)
	- add overloads
		- deref: T* -> T&
		- unary-add: T* -> T* or T -> T
		- compl: T -> T
		- mptr-call: CV1 C1*, CV2 T C2::* -> CV12 T&
		- mul, add: L, R -> LR
		- relational, equality: L, R -> bool
		- ptr-add: T*, ptrdiff_t -> T*
		- subscript: T*, ptrdiff_t -> T&
		- ptr-sub: T, T -> bool
		- relational, equality: T, T -> bool
		- bitwise: L, R -> LR
		- shift: L, R -> L
		- assign: [volatile]L&, R -> [volatile]L&
		- 
	- issue: how to ensure both arguments are same type when matching (T, T) ?


- investigate: TemplateIdWalker doesn't do name lookup, leads to unnecessary failed parse when expression begins with 'a < b'
	- in case of 'a < b || c' causes error evaluating expression type if 'b' is not convertible to bool
	- ideally, defer evaluation of expression type until ambiguity is resolved.
	- temporary hack to avoid?

+ task: remove special-cases for gEnumerator

- task: check for undesired forward declaration of 'A' in elaborated type specifier: template<class T> friend struct N::A;

- investigate: deferred evaluation of expression type
	- evaluate expression type in context of (enclosing scope, enclosing type, location)
	- id-expression
		- deferred lookup for dependent nested-name-specifier
		- store qualifying type/namespace as unique-type
	- binary-expression
		- operator
		- left, right: the operand expressions
	- unary-expression
		- operator
		- operand: the operand expression
	- function-call expression
		- id: the name in a call-to-named-function
		- type: type of the postfix-expression, the context in which 'operator()' is found
		- memberClass: if this is the righthand side of a member access expression, the class type of the left-hand side - provides implicit object argument for nonstatic member.
		- arguments: the expression-list for the function call.
		- templateArguments: the explicitly-specified template arguments for the function call.
		- idEnclosing: the class of which the name is a member, required if the name is a member of a template. Provides implicit object argument for static member.
	- member-access
		- memberType?
			- valid only when expression is not dependent
			- represents type of expression on left hand side of class-member access
			- store objectExpression instead
			- issue: what to do when left hand side of class-member-access expression is dependent, and followed by nested name-specifier?
				- e.g. 'x.C::m'
				- type of 'C' will be later looked up both within type of 'x' and in enclosing scope
		- inputs:
			- id: the name in a call-to-named-function
			- qualifying: the optional nested-name-specifier as in 'x.C::m'
		- outputs
			- idEnclosing: the class of which the name is a member, used when uniquing the type of a member of a template class
			- type: the type of the member access expression
			- memberClass: if the type is a function, the class type of the lefthand side - provides implicit object argument for overload resolution
	- subscript
		- type: type of the lefthand postfix-expression, the context in which 'operator[]' is found
		- argument: expression found within []
	- explicit-type: cast, construct
		- type

- task: remove unused 'isTemplate' stuff

- investigate: special handling for declarator name lookup still required?

- investigate: 'T->T' and 'T->const T&' are indistinguishable conversion sequences?
	- T->T: identity
	- T->const T&:
		- also an identity sequence?
		- qualification adjustment?
	- When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion
		sequence is the identity conversion, unless the argument expression has a type that is a derived class of
		the parameter type, in which case the implicit conversion sequence is a derived-to-base Conversion.
	- The rank of a conversion sequence is determined by considering the rank of each conversion in the sequence and the rank of any reference binding
	- Any difference in top-level cv-qualification is
		subsumed by the initialization itself and does not constitute a conversion. [ Example: a parameter of type A
		can be initialized from an argument of type const A. The implicit conversion sequence for that case is the
		identity sequence; it contains no “conversion” from const A to A. —end example ]
	- If no conversions are required to match an argument to a parameter type, the implicit conversion sequence
		is the standard conversion sequence consisting of the identity conversion.


+ task: built-in operator overload resolution for ptr-to-member expression

- task: ptr-to-member expression: built-in candidates for overload resolution
	- cull invalid candidates (e.g. incompatible class type between arguments, incompatible const)
		- could break in case of passing class-type args, which can also be converted to C* or T C::*
	- write tests

- task: tests for overload resolution
	- ranking of implicit conversion sequences, all rules in [over.ics.rank]
	- choice of built-in operator over user-defined overload
		- ensure only the correct set of built-in operator overloads are used, and do not hide user-defined overloads

- task: tests for argument-dependent-lookup
	- friend definitions


- investigate: automated build and testing
	- better error reporting from tests?
	- separate test mode?
	- teamcity server/agent
	- need to make everything buildable from svn
		- boost
		- stlport

- task: name lookup should always find primary template

+ task: clean up makeUniqueType
	- remove redundant code

- task: rename stuff
	+ merge TypeInstance with ObjectType
		- new name: not an object type
		- class type or built-in type - terminates declarator
		- SimpleType, as in simple-type-specifier

- task: deferred name lookup for nested name specifier in dependent class member access
	- e.g. dependent.A::B::C::m
	- A and B could be namespace or type
	- if A, B or C are types, each may be a template-id
	- namespace always comes before type
	- 'C' always names a type which is a base of 'dependent'
	- 'm' always names a member of the type of 'dependent' via the base 'C'
	- current deferred lookup for 'typename T::Type' relies on namespace lookup not being deferred
		- assumes lefthand side always names a type that can be substituted in context of instantiation
	- need type element similar to DependentTypename
		- contains list of qualifying ids that are either namespace-name or class-name
			- up to first template-id?
		- contains enclosing-scope for lookup of first nested name specifier
		- contains type of dependent object expression
		- when evaluated
			- substitute dependent object expression
			- lookup first name in both enclosing scope and type of object expression
				- lookup in enclosing scope should search all base-classes, not just non-dependent?
	- simpler just to wrap namespace as a UniqueType?
		- evaluating new DependentTypename may then result in a namespace
		- could use SimpleType, or NamespaceType
		- or could 
	- add special polymorphic type for nested-name-specifier
		- abstract wrapper for a (possibly qualified) qualifier
		- equivalent of Qualifying, but uniqued
		- can be substituted to yield concrete type/namespace in which name can be looked up
		- either
			- class-member-access expression + context
			- qualifying + identifier (class or namespace name)
			- qualifying + template-id
	- include context when uniquing DependentTypename
		- both objectExpression and enclosingScope
		- if nested-name-specifier prefix is dependent, allow empty qualifying
		- allow finding namespace