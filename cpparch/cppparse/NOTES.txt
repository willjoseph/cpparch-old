
+ task: remove check for 'declaration->enclosing' in LEFTBRACE of class-specifier
+ task: assert result of findEnclosingType is not 0
+ task: assert Type::unique is valid when checking Type::isDependent
+ crash: infinite loop in findDeclaration, type is base of base of itself
	- struct D : B {}; struct B : D {};
	- use visited flag to prevent infinite recursion
+ assert: D:\dev\cpparch\cppparse\msvc-8.0\include\xdebug:110
	- instantiation of basic_string<char, char_traits<char>, _DebugHeapAllocator<char> > in base-specifier of _DebugHeapString
	- when instantiated at point of declaration of _DebugHeapString, unique-type differs to instantiation in base-specifier
	- second template argument has a different type: iosfwd:155 char_traits<T> vs iosfwd:406 char_traits<char>
	- occurs because type was uniqued with 'allowDependent' when it was not dependent
+ assert: D:\dev\cpparch\cppparse\msvc-8.0\include\xlocale:347 (iostream.prepro.cpp:6966:25)
	- instantiation of std::string in return value of Locinfo::Getname()
	- when instantiated at overload resolution for Getname(), unique-type differs to instantiation in declaration
	- second template argument has a different type: new: char_traits<T> vs original: char_traits<char>
	- occurs because type was uniqued with 'allowDependent' when it was not dependent
+ task: make-unique for all types at point of parse, allowDependent=true for unique types
	- set isDependent=true on Type if dependent, do not look up names in base classes with isDependent=true
+ task: make-unique the enclosing type even when it's a template
	- always allow dependent if it's a template
+ task: use enclosing scope to determine whether type name is name of enclosing class
+ task: modify instantiateClass to instantiate base classes of the enclosing template class
	- also instantiate dependent base classes, but don't add them to the list if allowDependent=true
	- is allowDependent=true in context where base classes are no longer dependent?
		- e.g. D<int>::B
+ task: use the 'type' of a class definition to store unique-type
+ task: proper type for enumerators, instead of gEnumerator
+ problem: ambiguity in template-argument between assignment-expression and type-id: T() and T(arg)
	- trying 'type-id' first is correct in former, wrong in latter
	- vice versa for assignment-expression
	- [temp.arg] In a template argument, an ambiguity between a typeid and an expression is resolved to a typeid,
		regardless of the form of the corresponding template parameter
	- detect ambiguous expression and explicitly mark with isTemplateArgumentAmbiguity
+ test: parsing f(x,...)
+ task: basic support for non-type arguments
	+ store non-type argument value
	+ parse constant literals
	+ get value for constant id-expression
		+ enumerator
	+ evaluate non-dependent integral constant expressions
		- binary
		- ternary
		- cast
		- sizeof
	+ deferred evaluation of dependent integral constant expressions
		- need to substitute non-type template parameters
			- N
			- T::value
		- need to substitute template-parameters
			- sizeof(T)
			- T(0)
		- parse expression into visitable tree
		- walk tree to perform substitution
			- is this necessary for values? can evaluate and substitute at the same time..
			- does this work when substituting types?
		- walk tree to evaluate
		- walk tree to compare for equality?
			- unique expressions?
		- ensure comma-operator evaluated left to right
		- can evaluate types with separate tree?
			- evaluating types (but not values) also required for non-integral non-constant expression
				- to determine argument types for overload resolution
				- evaluation must be deferred if expression is dependent
				- node set overlaps - some also occur in integral constant-expression
				- required in integral-constant-expression to evaluate sizeof(f())
			- sometimes type depends on value, and vice versa
				- sizeof(0) // value depends on type of '0' (but NOT value)
				- X<0> // type depends on value of '0' (but NOT type
+ investigate: how does bidirectional_map work?
	- multi_index_container -> multi_index_base_type<...>::type -> nth_layer<0, ...>::type
		- nth_layer::type = apply2<index_applier, T1, T2>::type
			- apply2<F, T1, T2> -> lambda<F>::type::apply<T1, T2> -> F::apply<T1, T2>
		- index_applier::apply<T1, T2>::type -> T1::type::index_class<T2>::type
			- T1 = at_c<IndexSpecifierList, N>
			- T2 = nth_layer<N+1, ...>
			-> at_c<IndexSpecifierList, N>::type::index_class<nth_layer<N+1, ...>>::type
		- IndexSpecifier list: either ordered_unique or ordered_non_unique
		- ordered_unique::index_class<T1>::type -> ordered_index<T1 ...>::type
		- why is 'length' 20?
			- indexed_by is a vector20
			- vector<T1, T2, na, ..> should be vector2!
+ issue: 'context' is still being instantiated while looking up names within it
	LexContext
		-> context
		-> macromap<context>::name_iterator (instantiate macromap<context>)
		-> ContextT::token_type token_type (instantiate ContextT)
	- correct behaviour left unspecified, see DR 287
		- "This was discussed at length. The consensus was that the template case should be treated the same as the non-template class case
			in terms of the order in which members get declared/defined and classes get completed."
	- during qualified name lookup within instantiation for a member of a class which is partially instantiated, only names declared before the point of instantiation are visible
		- including dependent base classes!
		- but names in bases of partially instantiated class cannot be accessed from within instantiation of its base
	- track point of instantiation for each declaration in WalkerState
		- automatically rolls back if parse fails
		- per instance, because redeclaration may make name visible after being hidden
	- during parse of template definition, when complete type is required
		- if non-dependent, instantiate type and store point of instantiation
		- else add type to list of child instantiations and store declaration visibility
		- when instantiating template, used stored declaration visibility when instantiating child
	- in what contexts do child instantiations occur?
		- type of member definition required to be complete
		- type of base required to be complete
		- type named in member/base type-id
			- nested-name-specifier
		- type in expression required to be complete
			- static-const initializer
			- template-argument expression
				- in specialization arguments
+ task: template argument deduction
	+ for function templates
	+ for class template partial-specializations
		- specialization is matched if its arguments can be deduced from the template arguments vs the specialization argument list
	- what is "type deduction"?
		- the process of determining the template arguments, from a set of dependent types (e.g. function parameters) and a set of non-dependent types (e.g. function-call arguments)
		- involves 'substitution' of 'substition-failure'
		- [temp.deduct] When an explicit template argument list is specified, the template arguments must be compatible with the
			template parameter list and must result in a valid function type.
			If a substitution in a template parameter or in the function type of the function template results in an invalid type, type deduction fails.
		- unspecified arguments must be deduced before substitution
		- for each dependent type, substitute template-parameters with template-arguments; fail if the result is an invalid type
		- perform function parameter type adjustments
	- steps in argument deduction for function template
		- for each function-parameter, find template-parameters (for allowed forms, ignoring nondeduced contexts) and fill in template-arguments with corresponding type from function-call arguments
	- type substitution for name qualified by dependent type
		- similar process to what currently happens in makeUniqueType
		- look up declaration in enclosing type
		- perform substitution in context of enclosing type
	- partial ordering of partial-specializations
		- compare specialization A to specialisation B
		- use A's specialization-arguments to match B
		- e.g. 'A<T*>' matches 'B<T>', but 'A<T>' does not match 'B<T*>'
		- if A matches B but B does not match A, A is more specialized
	- what causes <const T> and 'int' to fail deduction?
		- likewise, what causes <const T> and 'const int' to deduce 'int' ?
	- deduction for non-type
	- substitution for non-type
	- substitute while deducing?
		- [temp.deduct] When all template arguments have been deduced, all uses of template parameters in
			nondeduced contexts are replaced with the corresponding deduced argument values. If the substitution
			results in an invalid type, as described above, type deduction fails.

+ task: make enclosingType valid for out-of-line member definitions
+ task: unique dependent template-name: T::template X<int>

+ task: correct name lookup for template explicit/partial specializations
	- [temp.class.spec] Partial specialization declarations themselves are not found by name lookup.
	- [temp.class.spec.match] When a class template is used in a context that requires an instantiation of the class, it is necessary to determine
			whether the instantiation is to be generated using the primary template or one of the partial specializations.
		- implies that this is not determined (e.g. no argument deduction is performed) until the class template is instantiated?
	- don't add to declarations? If not, where to store Declaration?
	- add, but ignore during name lookup?
		- inefficient, but works
	- store list of specializations in primary template
		- modifying existing declaration when specialization is declared is hard to undo when specialization is undeclared
	- forward declaration of partial specialization is invisible?
+ task: in makeUniqueType, use previously uniqued type if available and isDependent=false.
	+ assert that previously uniqued type is equal to result of makeUniqueType
		- can only do this if both the previously uniqued type and the result of makeUniqueType are not dependent
	- in declaration with dependent type, store index into array of dependent member types
		- build array of dependent member types on parse, stored in enclosing dependent unique-type
		- when instantiating unique-type, fill array with member unique-types
	+ perform type substitution on dependent unique-type
		- DependentType: substitute template parameter from enclosing type for argument
		- DependentTypename: perform name lookup to find member-declaration
			- if member-declaration is class-declaration, build simple ObjectType from declaration
			- else if found member-declaration's Type has isDependent=false, use its unique-type
			- else look up unique-type in (instantiated) enclosing type
		- DependentTemplate: as above, plus stored template arguments
			- add default arguments to stored arguments if necessary, add to ObjectType
+ task: template instantiation debugging
	- for a given instantiation, report which instantiations it requires
		- track required instantiations
		- add to list in enclosing-type when calling instantiateClass
			- contains instance+location
			- reversal of existing graph?
				- except that existing graph does not store location
		- instantiation graph: maps enclosing-type to children
			- multimap, key of enclosing type, data of instance+location?
				- hard to debug
	- for each required instantiation
		- link to instantiation page
		- point of instantiation: file/line/column
	- display point of instantiation in source code
		- source file? can't auto scroll without inserting markup
		- inline only selected line(s)?
			- how to display long lines?
			- performance if file is large?
				- create index of source lines during prepro?
					- unnecessary performance hit?
				- ideally could get pointer to location in input file buffer for each token
				- performance not critical for error reporting
			- source lines should only be within template definition?
+ task: remove check for isMemberOfTemplate that guards overload resolution: findBestOverloadedFunction
	- investigate: is it possible to do overload resolution and choose a function that has a dependent return type?
		- example: calling an overloaded static member of a template, within sizeof(), to initialise a static-const member
		- should defer overload resolution if any overload is declared with a dependent type
		- defect 541: http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html
	- required because member-functions of template classes may have dependent arguments
		- conformant solution: function-call expression is dependent if function has any overloads that are declared with a dependent type
		- don't perform overload resolution if function-call expression is dependent
+ issue: out-of-line member function template definition is not determined to be template
	- because testing 'parent == templateEnclosing'
	- should test 'enclosing == templateEnclosing'?
		- but 'enclosing' refers to template-param scope
		- enclosing is the scope in which name lookup occurs
			- must include template-params in name lookup
	- test whether template-params were specified
		- empty params for explicit specialization
+ issue: ignoring difference in return type means two template functions that differ only by return-type (and template-params) are considered equivalent
	- this is a hack for case where return-type is a typename - template<typename U> typename S<U>::Type S<U>::f() {}
	- ignore return type and compare template params instead
	
+ investigate: how to reduce callstack depth in debug
	- sample of small call-stack within expression-parsing
		- 233 levels
		- parseExpression: 11
		+ parseSymbol: 37
		- parseSymbolRequired: 38
		+ ParserGeneric::parse: 38
		- cpp::[symbol]::parse: 13
		- ParsingVisitor::visit: 13
		- *Walker::visit: 26
		- Default.ChoiceParser::parseSymbol: 22
+ investigate: when resolving unique type of a declaration named by an id-expression, do we need an enclosing-type if the id-expression names a non-member?
	- if member, use type of enclosing class when resolving unique type of the member
	- if non-member, type cannot be dependent on an enclosing class?
		- could be dependent on template parameter of enclosing template function
	- therefore answer is yes
+ task: correct implementation of partial ordering for function templates
	- use C++11 [temp.deduct.partial]
+ task: implement types for enumerators
	- declare unique type for each enum
	- give its enumerators that type
	- integral promotion
	[ dcl.enum]
	Each enumeration defines a type that is different from all other types. Following the closing brace of an
	enum-specifier, each enumerator has the type of its enumeration. Prior to the closing brace, the type of
	each enumerator is the type of its initializing value. If an initializer is specified for an enumerator, the initializing
	value has the same type as the expression. If no initializer is specified for the first enumerator, the
	type is an unspecified integral type. Otherwise the type is the same as the type of the initializing value of
	the preceding enumerator unless the incremented value is not representable in that type, in which case the
	type is an unspecified integral type sufficient to contain the incremented value.
+ task: ellipsis in overload resolution
	+ if more arguments than parameters, excess arguments become ellipsis-conversion-sequence
+ task: array-to-pointer conversion in binary expression
	- infer that binary expression requires rvalue operands
	- therefore lvalue-to-rvalue (array to pointer) conversion is performed
	[conv]
	expressions with a given type will be implicitly converted to other types in several contexts:
	- When used as operands of operators. The operator’s requirements for its operands dictate the destination type
	[expr]
	Whenever an lvalue expression appears as an operand of an operator that expects an rvalue for that operand,
	the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are
	applied to convert the expression to an rvalue. [Note: because cv-qualifiers are removed from the type of
	an expression of non-class type when the expression is converted to an rvalue, an lvalue expression of type
	const int can, for example, be used where an rvalue expression of type int is required. ]	
	[expr.add]
	For addition, either both operands shall have arithmetic or enumeration type, or one operand shall be a
	pointer to a completely defined object type and the other shall have integral or enumeration type.
+ task: ADL should filter everything but functions and function templates
+ task: allow undeclared bare-identifier followed by (params), assume to be found via ADL
	- disallow undeclared[], undeclared.m, undeclared.~X(), undeclared++
+ task: assert (walker.type.declaration != 0) before addBase
+ task: type of overloaded operators: required to determine type of expression
	+ postfix operator[]
	+ postfix operator++
	+ operator->
+ task: remove special-cases for gEnumerator
+ task: built-in operator overload resolution for ptr-to-member expression
+ task: overload resolution: implicit object parameter/argument
	// [over.match.funcs] a member function is considered to have an extra parameter, called the implicit object parameter, which
	// represents the object for which the member function has been called. For the purposes of overload resolution,
	// both static and non-static member functions have an implicit object parameter, but constructors do not.
	// Similarly, when appropriate, the context can construct an argument list that contains an implied object
	// argument to denote the object to be operated on.
	- when calling a member function, must always supply an implicit-object-argument
		- when that member is static and is called without a class object, the implied-object-argument is the type of the class containing the member
+ task: clean up makeUniqueType
	- remove redundant code
+ task: rename TypeInstance
	+ merge TypeInstance with ObjectType
		- new name: not an object type
		- class type or built-in type - terminates declarator
		- SimpleType, as in simple-type-specifier



- task: build list of dependent types for deferred uniquing/instantiation in instantiateClass
	- cannot instantiate until unique-type is known, should hold reference to placeholder 'deferred' unique-type
	- avoid duplicates: use dependent unique-type to distinguish?
	- do this whenever complete type is required, but type is dependent

- issue: for class-template, out of line definition of static member is (incorrectly) added to list of child instantiations
	- not usually a problem, except that class-template is 'partially instantiated' during instantiation of its children
		- side effects of child instantiation may require name-lookup within the partially-instantiated class, will fail if names do not 
	- static members should not be instantiated until they are used?

- investigate: can explicit/partial-specializations omit template arguments where there are defaults in the primary template?
	- clang allows with c++98

- investigate: is there ever a need to compare two function templates with different numbers of parameters when determining partial ordering?

- investigate: is typename required in conversion-function-id: operator T::Dependent?
	- yes - perhaps research to confirm?

- investigate: partial specializations: how to substitute template-arguments when uniquing
- investigate: what is the dependent unique-type of a template-partial-specialization?
	- A<T*> where T is the enclosing template parameter?
	- ok to resolve specialization of a dependent unique-type?
	- necessary to correctly unique the enclosing class when parsing a template-partial-specialization

- investigate: is result of makeUniqueType cached during cached-parse of template-id?

- investigate: isMemberObject returns true if member is class definition?
	- is this a problem?

- investigate: is Declaration::valueDependent necessary? Why is it initialised with dependent-ness of it's type's array size?


- investigate: template instantiation
	- perform substitution on dependent unique-types instead of Type

	template<typename T>
	struct S
	{
		T m; // 'S<T>' contains dependent unique-type 'T'

		template<typename U>
		struct V
		{
			U m; // 'S<T>::V<U>' contains dependent unique-type 'U'
		};
	};

	S<int> s; // instantiate S<T> -> S<int>
	S<int>::V<int> v; // instantiate S::<T>::V<U> -> S<int>::V<int>
	
	- S<T> is TypeInstance, with one dependent template-argument
	- unique: 
	- instantiate:


- task: disallow implicit instantiation of a template within its own definition

- problem: findEnclosingType searches bases of incomplete class when within class definition
	- don't use instantiateClass to enable this search: search non-dependent bases if..
		- class is an enclosing template
	- return enclosing type from findDeclaration
		- why?

- test: correct type of expression x = y (should be type of 'x'?)
	- test overload resolution against user defined operator=

- task: determine type of dependent pointer-to-member expression
	- for SFINAE during substitution of nontype pointer-to-member parameter &T::member -> int T::*member

- task: deferred evaluation of type of dependent expression
	- requires two-phase name lookup for unqualified names within expression. e.g. f(dependent);
		- for now: [temp.dep.res] Declarations that are visible at the point of definition of the template.
		- if operand is dependent, must store unqualified-id and point-of-definition.
			- point-of-definition is location of original template
		- could do unqualified lookup (but not overload resolution) at point of parse?
		- lookup of member operator overloads within the operand must be deferred, to allow searching dependent base class

- investigate: what is instantiated when instantiating a class?
	- direct member declarations: yes
	- member-functions: no
	- member-classes: no

- issue: parser loses track of current token just after parsing last token of default-parameter (and other deferred parse?)
	- syntax error at last token of deferred-parse block results in invalid parser location

- task: construct templateParamScope when parsing 'template' token
	- construct empty template param scope for explicit specialization?

- task: avoid having to revert changes to TypeId in between parsing multiple declarators in init-declarator-list
	- in SimpleDeclarationWalker

- task: when complete type is required and type is dependent, add type to children list in enclosing template class

- task: determine type of all non-dependent expressions
	- overload resolution
		- unique type for dependent member of template
		- null-pointer-constant
	- template argument deduction for function template
		- along with explicit template argument specification
		- requires support for function templates
		- substitute template params that have explicit arguments
			- ignore unspecified template params at this point
			- substitute unspecified template params with themselves?
				- much like when name of current-instantiation is used in class template definition

- task: determine type of conditional-expression with differing second and third operands
	- write tests!

- task: refactor PARSE_EXPRESSION

- task: declare copy-assign if not already declared
	- name lookup fails for id-expression 'operator=' when it has not been declared
	- correct behaviour: name lookup for 'operator=' within class should always return default, if not found
		- need a proper declaration to find enclosing class, but implicit declaration has no associated identifier?
			- too complex to manufacture declaration from nothing
		- avoid conflict with overload declarations
	- cannot determine whether copy-assign is already declared until class is instantiated
	- need to include declaration in overload set for call to operator=
	- can't declare in base declarations for type, must synthesise special declaration?
	- consider name-lookup of operator= while inside a template definition
		- name lookup will be deferred if operands are dependent

- task: test integral promotion for enum

- task: implement function template explicit specialization

- task: implement user-defined-conversion: required for overload resolution
	- over.best.ics] An implicit conversion sequence is a sequence of conversions used to convert an argument in a function
		call to the type of the corresponding parameter of the function being called. The sequence of conversions is
		an implicit conversion as defined in clause 4, which means it is governed by the rules for initialization of an
		object or reference by a single expression (8.5, 8.5.3).
	- [over.ics.user] Since an implicit conversion sequence is an initialization, the special rules for
		initialization by user-defined conversion apply when selecting the best user-defined conversion for a user-
		defined conversion sequence
	- [over.match.ctor], [over.match.copy], [over.match.conv]
	- [class.conv] Function overload resolution selects the best conversion function to perform the conversion.
	- what prevents two user-defined conversions occurring in sequence?
	- constructor call
	- conversion function
	- semantics of initializers
		- references?
		- if destination is class-type (non-reference)
			- if source is same or derived class-type, gather converting constructors, perform overload resolution
			- else gather conversion functions and converting constructors, perform overload resolution
		- else if source is class-type (non-reference)
			- gather conversion functions, perform overload resolution
	- what second standard-conversion is required in user-defined conversion involving constructor-call?
		- is result of constructor-call an lvalue/rvalue?

+ task: fix type of conversion function declaration: declarator-ptr not correctly parsed

- task: test conversion function parse special-case
	- standard quote:
		The conversion-type-id shall not represent a function type nor an array type. The conversion-type-id in a
		conversion-function-id is the longest possible sequence of conversion-declarators. [Note: this prevents
		ambiguities between the declarator operator * and its expression counterparts. [Example:
		&ac.operator int*i; // syntax error:
		// parsed as: &(ac.operator int *) i
		// not as: &(ac.operator int)*i
		The * is the pointer declarator and not the multiplication operator. ] ]
	- produces syntax error as expected
	- add test that checks for a syntax error in this case

- task: function parameter type transformations during template argument deduction
	[dcl.fct] After determining the
	type of each parameter, any parameter of type “array of T” or “function returning T” is adjusted to be
	“pointer to T” or “pointer to function returning T,” respectively. After producing the list of parameter
	types, several transformations take place upon these types to determine the function type. Any cv-qualifier
	modifying a parameter type is deleted. The resulting list of transformed parameter types is the function’s parameter
	type list.
	[temp.deduct]
	After this substitution is performed, the function parameter type adjustments described in 8.3.5 are performed.
	[Example: A parameter type of “void ()(const int, int[5])” becomes “void(*)(int,int*)”. ]


- task: overload resolution for built-in operators
	- required only when an operand has class or enumeration type
	- how to create infinite number of built-in overloads? e.g. match any pointer type
		- class may have multiple user-defined-conversions that match different types
		- pointer may have multiple valid conversions - e.g. Derived->Base*, T*->void*
		- in case of 'operator==(T*, T*)' arguments may be incompatible but both convertible to void* or Base*
		- for each argument type, need to find intersection of potential parameters types with types to which argument can be converted
		- possible to re-use implicit-conversion code to determine types?
			- difficult to return multiple values, may be simpler to write new code
		- find superset and narrow via overload resolution?
		- initial implementation can disregard user-defined-conversions
		- T*[volatile]& (object)
			- from lvalue T* (or T*volatile), direct reference binding (derived not considered)
			- from C, direct reference binding via operator T* (derived not considered)
			- cannot bind rvalue to non-const reference
		- T* (object, any) (may be cv-qualified)
			- from nullptr, wildcard for other argument
			- from T*, exact match or derived/void
			- from C, user-defined conversion via operator T* (or derived/void)
		- T* (function) (may be cv-qualified)
			- from nullptr, wildcard for other argument
			- from T*, exact match
			- from C, user-defined conversion via operator T*
		- T (pointer to member) (may be cv-qualified)
			- from nullptr, wildcard for other argument
			- from T, exact match or derived
			- from C, user-defined conversion via operator T (or derived)
		- [volatile] T& (arithmetic)
			- from lvalue T, exact match (conversion not considered)
			- from C, user-defined conversion via operator T&
		- [volatile] T& (enum)
			- from lvalue T, exact match (conversion not considered)
			- from C, user-defined conversion via operator T&
		- T (arithmetic)
			- from any arithmetic (or enum), exact match or conversion
			- from C, user-defined conversion via conversion function to any arithmetic (or enum)
		- for a given placeholder parameter/argument pair, find set of types which can replace 'T'
			- takes (to, from, source, enclosing): may cause template instantiation!
			- if reference, bind directly, otherwise perform lvalue-to-rvalue conversion
			- if pointer (or member pointer), add all cv-qualification permutations (and bases)
			- result is simple vector of types for now
			- if T is shared between two parameters, find the union of both sets
			- if T is in two parameters but not shared (e.g. L, R), find all permutations of both sets
			- generate function types and perform overload resolution
	- hide user-written candidates that match built-in overload parameters exactly
	- for enum, overload set contains built-in operators that take types that enum can be converted to
		- e.g. promote to int, convert to any integer type, convert to any floating point type, convert to bool
	- types:
		O=object (not reference, not function, not void)
		F=Function
		G=object-or-function
		A=Arithmetic
		I=Integral
		T=Type
		C=class
		E=enum
		P=pointer
		M=pointer-to-member
	- forms
		O*
		[const] [volatile] O*
		F* (operator*)
		T*
		A
		I
		E
		P
		M
		[volatile] I&
		[volatile] E&
		[volatile] M&
		[volatile] A&
		[volatile] A& (not bool)
		O*[volatile]&
		P[volatile]&
		[const] [volatile] C*
		[const] [volatile] G C::*
	- multiple conversion functions may match?
	- other ambiguities?
	- what conversions should be detected?
		- reference binding
		- exact: pointer qualification adjustment
		- promotion: float -> double, I -> int
		- conversion: A/E -> A
	- which match-all types required?
		- could match all T and reject later?
			- no, would not get correct conversion result
	- placeholder types
		- any
			- T* (unary-plus, relation, equality, assign-r)
			- T*[volatile]& (assign-l)
		- arithmetic
			- [volatile]T& (incr, decr, assign-l)
		- integral
			- [volatile]T& (assign-l)
		- object
			- T*[volatile]& (incr, decr)
			- T* (deref, ptr-add, subscript)
		- function
			- T* (deref)
		- promoted-arithmetic
			- T (assign-r, unary-plus, unary-minus, mul, add, relational, equality, conditional)
		- promoted-integral
			- T (compl, bitwise, shift, remainder)
		- class
			- T* (mptr-call)
		- mptr
			- T (mptr-call, equality, assign-r)
			- [volatile]T& (assign-l)
	- add overloads
		- deref: T* -> T&
		- unary-add: T* -> T* or T -> T
		- compl: T -> T
		- mptr-call: CV1 C1*, CV2 T C2::* -> CV12 T&
		- mul, add: L, R -> LR
		- relational, equality: L, R -> bool
		- ptr-add: T*, ptrdiff_t -> T*
		- subscript: T*, ptrdiff_t -> T&
		- ptr-sub: T, T -> bool
		- relational, equality: T, T -> bool
		- bitwise: L, R -> LR
		- shift: L, R -> L
		- assign: [volatile]L&, R -> [volatile]L&
		- 
	- issue: how to ensure both arguments are same type when matching (T, T) ?


- investigate: TemplateIdWalker doesn't do name lookup, leads to unnecessary failed parse when expression begins with 'a < b'
	- in case of 'a < b || c' causes error evaluating expression type if 'b' is not convertible to bool
	- ideally, defer evaluation of expression type until ambiguity is resolved.
	- temporary hack to avoid?
	- conformant solution (see below): look up identifier during template-id parse, and reject if it does not name a template
- don't need to handle template-id ambiguity between id-expression and type-name?
	- can template-name ever be hidden?
	- always look up template-name immediately and reject if first name found is not template?
		- test implementation works well
	- what if hiding name is non-template?
		- gcc, clang, msvc all reject
	- what if within class-member-access?
		- lookup first in class of object-expression, then in enclosing scope
		- if object expression is dependent, name lookup should be deferred when looking for non-type name?
			- only if preceded by 'template'
		- if not preceded by 'template', first look in class of object expression (if present and non-dependent), then in enclosing scope
	- what if within declarator?
		- e.g. 'C<T>::C()' vs 'C<T> f()'
			- still ok to look up 'C' to find whether it's a template
		- e.g. 'C<T>::M<U>::M()' vs 'typename C<T>::template M<U> f()'
			- different behaviour when in declarator?
				- 'C<T>' is known to be the current instantiation, therefore lookup of M is not deferred
			- otherwise, lookup of second 'M' deferred because qualified by dependent
			- still ok to look up template name if not preceded by 'template'?
				- even if qualified by dependent type name?
					- don't bother with lookup in this case?
					- what if 'C<T>::M' names a non-type and therefore '<' could be less-than?
					- impossible, always preceded by 'template<>'?
		- e.g. 'template<> template<> C<int>::M<int>::M()' vs 'template<> template<> C<int>::M<int> C<int>::M<int>::f()'
			- different behaviour when in declarator?
			- still ok to look up template name if not preceded by 'template'
			- if qualified, look up in qualifying
		- issueL within declarator, qualifyingClass is not valid even when type was not dependent

- task: check for undesired forward declaration of 'A' in elaborated type specifier: template<class T> friend struct N::A;

- investigate: deferred evaluation of expression type
	- evaluate expression type in context of (enclosing scope, enclosing type, location)
	- dependent vs nondependent
		- can evaluate nondependent immediately, no need to store expression tree?
			- no, need to defer evaluation of type
		- need to do some evaluation of nondependent in order to do name lookup
		- simple example: id-expression with dependent qualifying-type
			- can't perform name lookup, assume name is non-type
			- still need to perform overload resolution later
		- for now, can assume non-dependent operands when performing overload resolution
	- id-expression
		- deferred lookup for dependent nested-name-specifier
		- store qualifying type/namespace as unique-type
		- template-arguments?
			- possibly dependent
	- binary-expression
		- operator
		- left, right: the operand expressions
	- unary-expression
		- operator
		- operand: the operand expression
	- function-call expression
		- id: the name in a call-to-named-function
			- overload-set (getDeclaration/findOverloaded)
			- name-lookup (ADL)
			- only if postfix-expression is an id-expression (possibly class-member-access) (possibly dependent)
			- if class-member-access, argument list is augmented by left operand of class-member-access expression
		- type: type of the postfix-expression, the context in which 'operator()' is found
		- memberClass: if this is the righthand side of a member access expression, the class type of the left-hand side - provides implicit object argument for nonstatic member.
		- arguments: the expression-list for the function call.
		- templateArguments: the explicitly-specified template arguments for the function call.
		- idEnclosing: the class of which the name is a member, required if the name is a member of a template. Provides implicit object argument for static member
	- member-access
		- memberType?
			- valid only when expression is not dependent
			- represents type of expression on left hand side of class-member access
			- store objectExpression instead
		- inputs:
			- id: the name in a call-to-named-function
			- qualifying: the optional nested-name-specifier as in 'x.C::m'
		- outputs
			- idEnclosing: the class of which the name is a member, used when uniquing the type of a member of a template class
			- type: the type of the member access expression
			- memberClass: if the type is a function, the class type of the lefthand side - provides implicit object argument for overload resolution
	- subscript
		- type: type of the lefthand postfix-expression, the context in which 'operator[]' is found
		- argument: expression found within []
	- explicit-type: cast, construct
		- type

- investigate: 'T->T' and 'T->const T&' are indistinguishable conversion sequences?
	- T->T: identity
	- T->const T&:
		- also an identity sequence?
		- qualification adjustment?
	- When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion
		sequence is the identity conversion, unless the argument expression has a type that is a derived class of
		the parameter type, in which case the implicit conversion sequence is a derived-to-base Conversion.
	- The rank of a conversion sequence is determined by considering the rank of each conversion in the sequence and the rank of any reference binding
	- Any difference in top-level cv-qualification is
		subsumed by the initialization itself and does not constitute a conversion. [ Example: a parameter of type A
		can be initialized from an argument of type const A. The implicit conversion sequence for that case is the
		identity sequence; it contains no “conversion” from const A to A. —end example ]
	- If no conversions are required to match an argument to a parameter type, the implicit conversion sequence
		is the standard conversion sequence consisting of the identity conversion.


- task: improve: ptr-to-member expression: built-in candidates for overload resolution
	- cull invalid candidates (e.g. incompatible class type between arguments, incompatible const)
		- could break in case of passing class-type args, which can also be converted to C* or T C::*
	- write tests

- task: tests for overload resolution
	- ranking of implicit conversion sequences, all rules in [over.ics.rank]
	- choice of built-in operator over user-defined overload
		- ensure only the correct set of built-in operator overloads are used, and do not hide user-defined overloads

- task: tests for argument-dependent-lookup
	- friend definitions


- investigate: automated build and testing
	- better error reporting from tests?
	- separate test mode?
	- teamcity server/agent
	- need to make everything buildable from svn
		- boost
		- stlport
	- proper database!

- task: name lookup should always find primary template


- task: rename stuff
	- UniqueTypeWrapper

- task: deferred name lookup for nested name specifier in dependent class member access
	- e.g. dependent.A::B::C::m
	- A and B could be namespace or type
	- if A, B or C are types, each may be a template-id
	- namespace always comes before type
	- 'C' always names a type which is a base of 'dependent'
	- 'm' always names a member of the type of 'dependent' via the base 'C'
	- current deferred lookup for 'typename T::Type' relies on namespace lookup not being deferred
		- assumes lefthand side always names a type that can be substituted in context of instantiation
	- need type element similar to DependentTypename
		- contains list of qualifying ids that are either namespace-name or class-name
			- up to first template-id?
		- contains enclosing-scope for lookup of first nested name specifier
		- contains type of dependent object expression
		- when evaluated
			- substitute dependent object expression
			- lookup first name in both enclosing scope and type of object expression
				- lookup in enclosing scope should search all base-classes, not just non-dependent?
	- simpler just to wrap namespace as a UniqueType?
		- evaluating new DependentTypename may then result in a namespace
		- could use SimpleType, or NamespaceType
		- or could 
	- add special polymorphic type for nested-name-specifier
		- abstract wrapper for a (possibly qualified) qualifier
		- equivalent of Qualifying, but uniqued
		- can be substituted to yield concrete type/namespace in which name can be looked up
		- either
			- class-member-access expression + context
			- qualifying + identifier (class or namespace name)
			- qualifying + template-id
	- include context when uniquing DependentTypename
		- both objectExpression and enclosingScope
		- if nested-name-specifier prefix is dependent, allow empty qualifying
		- allow finding namespace
	- closer analysis of the standard suggests that nested name specifier prefix in class-member-access cannot be dependent


- task: overload resolution for built-in assignment operator

- task: don't find friend function definition via normal lookup, only via ADL
	- friend that "declares a namespace-scope function" means?
		- e.g. friend void f() {}
		- declares global 'f', not visible to normal lookup
		- always filter out of name lookup
		- 
	- [class.friend] A friend function defined in a class is in the (lexical) scope of the	
class in which it is defined. A friend function defined outside the class is not

 Name lookup for a name used in the definition of a friend function (11.3) defined inline in the class granting
friendship shall proceed as described for lookup in member function definitions. If the friend function is
not defined in the class granting friendship, name lookup in the friend function definition shall proceed as
described for lookup in namespace member function definitions.


- investigate: function-scope using directive?
	- supported?

- task: detect when expression 'enum < 0' (otherwise constant) would call an overloaded operator
	- expression should longer be constant

- task: template<bool b, int x = sizeof(b)>
	- must defer evaluation of template parameter default until context is known?
	- should be evaluated immediately as is non-dependent?
	- value is not required for correct parse 

- investigate: function call: correct expression to pass into findBestOverloadedFunction
	- either member-call: object-expression id-expression ( expression-list )
		- either explicit class-member-access: a.m()
		- or implicit: (*this).m()
		- or static: m()
	- or ordinary-call: id-expression ( expression-list )
	- other forms do not require overload resolution
		- pointer to function
		- pointer to member function

- investigate: evaluate enclosing-class for id-expression that names member when parsed?
	- if unqualified, depends on context: object-expression or enclosing-class
	- must also evaluate whether it's a pointer-to-member expression '&C::m' when parsed.

- investigate: when do we need to evaluate an expression's type?
	- when determining whether it's a constant-expression
		- how exactly?
	- when determining whether it's a pointer-to-member-expression
	- when determining types of arguments for overload resolution
	- need to evaluate in order to discover side effects that affect name binding
		- non-dependent expressions should be immediately evaluated
		- dependent expressions should be evaluated at point of instantiation


- investigate: when checking whether identifier in template-id is template-name, is it safe to re-use the result of name-lookup rather than performing lookup again?
	- would break name-hiding of class-template by function-template, but that's consistent with other implementations
	- probably need to unify qualified name lookup between declarator and non-declarator anyway
	- check rule: lookup of name found after :: finds only namespace or type names
		- could find function-template name

- investigate: in 'template<> struct A::B<int> {};' lookup of 'B' fails because 'A' is not considered as the qualifying name?

- investigate: special handling for declarator name lookup still required?

- investigate: refactor Walker to allow splitting across multiple files
	- eliminate circular dependency between all walker types?
		- commit() requires knowing complete type of walker
	- refactor visit methods, split up?
	- declare out of line? nonmember?
		- moves related code apart: definition of walker state vs code using the state
		- semantic actions don't care about internal walker state though, only inner walker result
		- separate result type for each walker?
		- also need to instantiate inner walker: need to call constructor and allocate stack space
	- SFINAE to choose overload for specific symbol type?
		#define HAS_MEM_FUNC(func, name)                                        \
		template<typename T, typename Sign>                                 \
		struct name {                                                       \
			typedef char yes[1];                                            \
			typedef char no [2];                                            \
			template <typename U, U> struct type_check;                     \
			template <typename _1> static yes &chk(type_check<Sign, &_1::func> *); \
			template <typename   > static no  &chk(...);                    \
			static bool const value = sizeof(chk<T>(0)) == sizeof(yes);     \
		}
		- alternative way to make overload valid only if class does not contain a specific member
			- need to obtain true/false for case where it does
				- use enable-if
		- apply to default actions
		- apply to makePolicy
			- can't check for function with unknown return type?
			- sfinae taking SemaT and SymbolT and finding return type if overload exists
			- need to invoke overload resolution during sfinae for this member
			- appears to be impossible without decltype
			- pose on stack-overflow

	- major refactor to turn 'visit' methods into actions
		+ overloadable-operator matches any T
		+ clearQualifying called before creating Walker
		+ enumerator_definition calls stuff before creating Walker
		+ declareEts for parameter declaration in SimpleDeclarationWalker
		+ cached parse
		- declare-ets-guard
			- leaf only
			- required because decl-spec-seq may contain forward-declared class
			- and declarator parse may cause modification of typeSequence
		- deferred parse
			+ member_declaration
			- declarator
			- leaf only: default_argument, statement_seq_wrapper, mem_initializer_clause
		- source
		- include-events (declaration)
		- operator-function source
	- dir structure
		- mixed-case names
		- cppparse
			- Common: generic data structures, util, sequence, indirect_set, copied, allocator
			- Language: unique-type, deduce, substitute, overload, conversion, evaluate expression
			- Ast: Declaration, Type, TemplateParameter etc.. Scope?
				- Identifier, ExpressionNode, DeclarationInstance
			- Sema: walkers
			- Parse: grammar, parser
			- Lex: lexer, token
			- Report:
			- Test: tests in symbols.cpp
	- split symbols.h
		- core types: DeclSpecifiers, Identifier, TemplateArguments, TemplateArgument,
			Types, TypeIds, Type, Scope, Declaration, Dependent, TemplateParameter, TemplateParameters
		- TypeId, type-sequence
		- template-param-defaults
		- integral-constant-evaluation: IntegralConstant, getBinaryIceOp, getUnaryIceOp
		- abstract expression: ExpressionNode/visitor, UniqueExpressions, ExpressionWrapper
		- data-structure for declaration map in Scope: DeclarationInstance, getDeclaration
		- UniqueNames: names of declarations
		- undeclare: used when undoing semantic actions
		- enclosesEts, getEnclosingClass, getEnclosingNamespace
		- meta-type-of-declaration utils: isXYZ: deals with meta-types: e.g. arithmetic, class, enum 
			- move isAnonymous
		- abstract unique-types: TypeElement/visitor, wrapper, isEqual, getInner, isSameType, built-in-type, UniqueTypeGeneric
		- concrete unique-types: NonType, TemplateTemplateArgument, DependentType/Typename/NonType, Pointer/Reference/MemberPointer/Array/Function
			SimpleType
		- instantiateClass: addBase, dumpTemplateInstantiations
		- declaration-equivalence: compare function parameters at point of declaration
		- Parameter/Parameters
		- Location (source + point of instantiation)
		- findPrimaryTemplate, findLastDeclaration, findPrimaryTemplateLastDeclaration
		- InstantiationContext: used when evaluating type/value of expression, or subsituting types
		- concrete expression node types: *Expression
		- typeOfExpression
		- findEnclosingTemplate: given a template parameter and an enclosing template, find the enclosing template that declares the template parameter
		- findEnclosingPrimaryTemplate: used when determining if name is name of enclosing template definition
		- getEnclosingType: used only when adding child instantiations
		- evaluateExpression
		- isDependent
		- deduce
		- TypeError objects: generally used in substitution
		- substitute
		- makeUniqueType/getUniqueType/makeUniqueQualifying/makeUniqueEnclosing/makeUniqueTemplateArguments/makeUniqueTemplateParameters
		- getEnclosingTemplate, findScope, getClassDeclaration, findEnclosingClassTemplate
		- isDependentImpl
		- findOverloaded
		- requireCompleteObjectType
		- matchTemplatePartialSpecialization/findTemplateSpecialization
		- findEnclosingType
		- expression type annotation helper
		- built-in/fundamental type construction
		- literal parsing
		- getOverloadableOperatorId
		- unique-type utils: isXYZ: requires built-in types
		- type-adjustment: function-param-adjust, remove-reference, removePointer
		- implicit conversions: array-to-pointer, funtion-to-pointer, integral-promotions, usual-arithmetic-conversions, lvalue-to-rvalue, qualification-adjustment
			- standard-conversion
			- ranking conversion sequences
			- depends on findBestConversionFunction (circular!)
		- overload-resolver:
			- ranking candidate functions
			- addOverload, addConversionFunctionOverloads, findBestConversionFunction
		- declaration-error, getPrimaryDeclaration
		- symbol-printer
		- TypeTraits.h
			- type-traits intrinsic
		- NameLookup.h
			- lookup-filter + implementations
			- lookup-result, declaration-instance-ref, lookup-result-ref
			- name-lookup: findDeclaration(SimpleType)
			- name-lookup: findDeclaration overloads
		- non-unique findTemplateSpecialization implementation (used only in getDeclaratorQualifying)
	- move common code from semantic.cpp into header(s)
		- cull unused code?
		- declaration-equivalence
		- koenig lookup
		- overload-gathering
		- overload resolution for builtin operators
		- expression type determination
		- SemaContext/SemaState/SemaBase
		- deferred-symbols-list
		- sema-result types
		- sema-qualified
		- sema policy generic types
		- sema policy concrete types
		- sema policy macros
		- is-hidden filters: type/namespace
		- sema walker types: group by chapter?
		- prim
			- [expr.prim] primary-expression, id-expression, unqualified-id, qualified-id, nested-name-specifier
		- post
			- [expr.post] postfix-expression, expression-list, psuedo-destructor-name
		- new-delete
			- [expr.new] new-expression, new-placement, new-type-id, new-declarator, new-initializer
			- [expr.delete] delete-expression
		- expr
			- [expr.cast] cast-expression
			- [expr.mptr.oper] pm-expression
			- [expr.mul/add/shift/rel/eq/and/xor/or/log.and/log.or/cond/ass/comma] etc
		- stmt
			- [stmt.stmt] statement, labeled-statement, expression-statement, compound-statement, statement-seq, 
				selection-statement, condition, iteration-statement, for-init-statement, jump-statement, declaration-statement
		- dcl
			- [dcl.dcl] declaration-seq, declaration, block-declaration, simple-declaration
		- spec
			- [dcl.spec] decl-specifier, decl-specifier-seq, storage-class-specifier, function-specifier, typedef-name
			- [dcl.type] type-specifier, simple-type-specifier, type-name, elaborated-type-specifier
		- enum
			- [dcl.enum] enum-specifier, enumerator-definition
		- namespace
			- [basic.namespace] namespace-definition
			- [namespace.alias]
			- [namespace.udecl] using-declaration
			- [namespace.udir] using.directive
		- asm
			- [dcl.asm] asm-definition
			- [dcl.link] linkage-specification
		- decl
			- [dcl.decl] init-declarator, declarator, ptr-operator
		- type
			- [dcl.name] type-id, type-specifier-seq, abstract-declarator
		- class				
			- [class] class-head, class-specifier
			- [class.derived] base-specifier, access-specifier
			- [class.base.init] mem-initializer
		- conv
			- [class.conv.fct] conversion-type-id, conversion-function-id, conversion-declarator
		- temp
			- [temp] template-declaration, template-parameter-list, template-parameter, type-parameter
		- temp.names
			- [temp.names] template-id, template-argument-list, template-argument
		- except
			- [except] try-block, handler-seq, handler, exception-declaration, throw-expression
		- n/a
			- [class.mem] member-declaration, member-declarator
			- [dcl.fct.def] function-definition
			- [dcl.init] initializer

			Operator: SemaOverloadableOperator, SemaOperatorFunctionId
			PrimaryExpression: SemaUnqualifiedId, SemaQualifiedId, SemaIdExpression, SemaLiteral, SemaPrimaryExpression
			PostfixExpression: SemaPostfixExpression, SemaArgumentList, SemaSubscript, SemaPostfixExpressionMember, SemaTypeTraitsIntrinsic
			Expression: SemaExpression, SemaExplicitTypeExpression, SemaSizeofTypeExpression, SemaConditionalExpression
			NestedNameSpecifier: SemaNestedNameSpecifierSuffix, SemaNestedNameSpecifierPrefix, SemaNestedNameSpecifier
			TypeId: SemaTypeName, SemaTypeSpecifier, SemaElaboratedTypeSpecifier, SemaTypeId, SemaNewType
			DeclaratorFunction: SemaParameterDeclarationList, SemaParameterDeclarationClause, SemaExceptionSpecification, SemaDeclaratorFunction, SemaCvQualifierSeq
			Declarator: SemaUnqualifiedDeclaratorId, SemaQualifiedDeclaratorId, SemaDeclaratorId, SemaPtrOperator, SemaDeclaratorArray, SemaDeclarator, SemaInitializer
			Class: SemaBaseSpecifier, SemaClassHead, SemaClassSpecifier, SemaQualifiedTypeName, SemaMemInitializer, SemaMemInitializerClause, SemaMemberDeclaratorBitfield, SemaMemberDeclaration
			Namespace: SemaNamespaceName, SemaUsingDeclaration, SemaUsingDirective, SemaNamespace, SemaNamespaceAliasDefinition
			Enum: SemaEnumeratorDefinition, SemaEnumSpecifier
			Statement: SemaLabeledStatement, SemaStatement, SemaControlStatement, SemaCompoundStatement, SemaStatementSeq
			Exception: SemaTryBlock, SemaHandler, SemaHandlerSeq
			Declaration: SemaDeclSpecifierSeq, SemaDeclarationSuffix, SemaSimpleDeclaration, SemaDeclaration
			TemplateDeclaration: SemaTypeParameter, SemaTemplateParameterList, SemaTemplateParameterClause, SemaTemplateDeclaration
			TemplateName: SemaTemplateId, SemaTemplateArgumentList, SemaTypenameSpecifier, SemaExplicitInstantiation


+ task: replace .swap with assignment

- investigate: what's going on with SimpleDeclarationWalker
	- complex
	- used with:
		- decl-spec-seq <suffix>
			simple_declaration -> simple_declaration_suffix: type_declaration_suffix/simple_declaration_named
			general_declaration -> general_declaration_suffix: type_declaration_suffix/simple_declaration_named/function_definition
			member_declaration_default -> member_declaration_suffix: type_declaration_suffix/member_declaration_bitfield/member_declaration_named/function_definition
			parameter_declaration -> parameter_declaration_suffix
		- type-specifier-seq <suffix>
			condition_init -> condition_declarator
			exception_declaration_default -> exception_declarator
		- function-specifier-seq <suffix>
			constructor_definition -> function_definition
			member_declaration_implicit -> member_declaration_suffix
	- all variations contain some type of declarator
	- decl-spec/type-spec may contain forward-declaration
		- declare immediately after decl-spec?
		- target scope depends on whether this is an explicit forward-declaration or occurs within another declaration
	- split into prefix/suffix?


- investigate: refactoring makes avoidance of double-parsing of default-argument unnecessary in the following scenario
	- as described
		// while parsing simple-declaration-named declarator which contains deferred default-argument expression,
		// on finding '{', we backtrack and try parsing function-definition.
		// symbols may be deferred during attempt to parse shared-prefix declarator: f(int i = j)
		// first parsed as member_declaration_named, backtracks on reaching '{'
	- no longer necessary because Declarator parse is successfully cached

+ task: implement overload resolution for implicitly-defined operator= in expression (x = y)

- task: remove circular dependency: evaluateExpression in OverloadResolver::makeConversion

- task: evaluate expression immediately if possible
	- if only type-dependent, find value
	- if only value-dependent, find type
	- if neither, find both
	- substitute evaluated nodes into expression tree?
		- need to preserve tree if only value-dependent or only type-dependent?
		- e.g. sizeof(T) is only value-dependent
		- is only value-dependent even possible?

- issue: when evaluating type of [non-dependent expression involving a] non-type template parameter, we only have the template-parameter index
	- must look up the template parameter in the enclosingType, just to get the type (not to perform substitution)
	- enclosingType not [currently] available within a function template
	- this is not a problem unless evaluation is deferred.
	- does this ever need to be deferred?
		- yes: template<class T, T x>
		- when evaluating 'sizeof(x)'

- issue: when evaluating type of id-expression within a function-call expression, cannot resolve type
	- need to know arguments before overload resolution can be performed
	- should type resolve to 'function overload set' ?

- issue: when evaluating type of id-expression within a member-access expression, cannot resolve type
	- need to know object-expression before type can be resolved

- issue: what should type of enumerator be during deferred evaluation?
	- e.g. enum { A = TEMPLATE_NONTYPE_PARAM, B = sizeof(A) };

- task: profile with vtune to check for low hanging fruit
	- instrument code to profile only parser
	- rtti in comparison of UniqueType
		- abstractLess: std::type_info::before() is very slow.
			- comparing type_info ptr is faster, but not standard compliant
			- 300ms -> 120ms
			- many comparisons occurring
		- isClass: std::type_info::operator==() is slow.
		- measure cost of typeid()
			- halving number of calls : 120ms -> 70ms
			- typeid() cost is 100ms out of 120ms
	- findDeclaration (7% of total)
		- upper_bound is expensive
	- allocations during overload resolution
		- CandidateFunction members
		- when replacing an existing best candidate
		- when destroying an OverloadResolver
		- allocate enough mem for N arguments on stack?
	- pushUniqueType<SimpleType>()
		- in addOverload: makeUniqueSimpleType(*context.enclosingType)
		- in typeOfFunctionCallExpression: makeUniqueSimpleType(classType)
		- copying non-trivial SimpleType is expensive
		- faster way to get unique-type for enclosingType?
