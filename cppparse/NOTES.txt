
+ task: remove check for 'declaration->enclosing' in LEFTBRACE of class-specifier
+ task: assert result of findEnclosingType is not 0
+ task: assert Type::unique is valid when checking Type::isDependent
+ crash: infinite loop in findDeclaration, type is base of base of itself
	- struct D : B {}; struct B : D {};
	- use visited flag to prevent infinite recursion
+ assert: D:\dev\cpparch\cppparse\msvc-8.0\include\xdebug:110
	- instantiation of basic_string<char, char_traits<char>, _DebugHeapAllocator<char> > in base-specifier of _DebugHeapString
	- when instantiated at point of declaration of _DebugHeapString, unique-type differs to instantiation in base-specifier
	- second template argument has a different type: iosfwd:155 char_traits<T> vs iosfwd:406 char_traits<char>
	- occurs because type was uniqued with 'allowDependent' when it was not dependent
+ assert: D:\dev\cpparch\cppparse\msvc-8.0\include\xlocale:347 (iostream.prepro.cpp:6966:25)
	- instantiation of std::string in return value of Locinfo::Getname()
	- when instantiated at overload resolution for Getname(), unique-type differs to instantiation in declaration
	- second template argument has a different type: new: char_traits<T> vs original: char_traits<char>
	- occurs because type was uniqued with 'allowDependent' when it was not dependent
+ task: make-unique for all types at point of parse, allowDependent=true for unique types
	- set isDependent=true on Type if dependent, do not look up names in base classes with isDependent=true
+ task: make-unique the enclosing type even when it's a template
	- always allow dependent if it's a template
+ task: use enclosing scope to determine whether type name is name of enclosing class
+ task: modify instantiateClass to instantiate base classes of the enclosing template class
	- also instantiate dependent base classes, but don't add them to the list if allowDependent=true
	- is allowDependent=true in context where base classes are no longer dependent?
		- e.g. D<int>::B
+ task: use the 'type' of a class definition to store unique-type

- task: build list of dependent types for deferred uniquing/instantiation in instantiateClass
	- cannot instantiate until unique-type is known, should hold reference to placeholder 'deferred' unique-type
	- avoid duplicates: use dependent unique-type to distinguish?
	- do this whenever complete type is required, but type is dependent


- investigate: template instantiation
	- perform substitution on dependent unique-types instead of Type

	template<typename T>
	struct S
	{
		T m; // 'S<T>' contains dependent unique-type 'T'

		template<typename U>
		struct V
		{
			U m; // 'S<T>::V<U>' contains dependent unique-type 'U'
		};
	};

	S<int> s; // instantiate S<T> -> S<int>
	S<int>::V<int> v; // instantiate S::<T>::V<U> -> S<int>::V<int>
	
	- S<T> is TypeInstance, with one dependent template-argument
	- unique: 
	- instantiate:


- task: disallow implicit instantiation of a template within its own definition

- task: proper type for enumerators, instead of gEnumerator

- problem: findEnclosingType searches bases of incomplete class when within class definition
	- don't use instantiateClass to enable this search: search non-dependent bases if..
		- class is an enclosing template
	- return enclosing type from findDeclaration

- problem: ambiguity in template-argument between assignment-expression and type-id: T() and T(arg)
	- trying 'type-id' first is correct in former, wrong in latter
	- vice versa for assignment-expression
	- [temp.arg] In a template argument, an ambiguity between a typeid and an expression is resolved to a typeid,
		regardless of the form of the corresponding template parameter

- investigate: isMemberObject returns true if member is class definition?

- test: parsing f(x,...)

- test: correct type of expression x = y (should be type of 'x'?)

- task: basic support for non-type arguments
	+ store non-type argument value
	+ parse constant literals
	+ get value for constant id-expression
		+ enumerator
	- evaluate integral constant expressions
		- binary
		- ternary
		- cast
		- sizeof
	- deferred evaluation of dependent integral constant expressions
		- need to substitute non-type template parameters
			- N
			- T::value
		- need to substitute template-parameters
			- sizeof(T)
			- T(0)
		- parse expression into visitable tree
		- walk tree to perform substitution
			- is this necessary for values? can evaluate and substitute at the same time..
			- does this work when substituting types?
		- walk tree to evaluate
		- walk tree to compare for equality?
			- unique expressions?
		- ensure comma-operator evaluated left to right
		- can evaluate types with separate tree?
			- evaluating types (but not values) also required for non-integral non-constant expression
				- to determine argument types for overload resolution
				- evaluation must be deferred if expression is dependent
				- node set overlaps - some also occur in integral constant-expression
				- required in integral-constant-expression to evaluate sizeof(f())
			- sometimes type depends on value, and vice versa
				- sizeof(0) // value depends on type of '0' (but NOT value)
				- X<0> // type depends on value of '0' (but NOT type
	- determine type of dependent pointer-to-member expression
		- for SFINAE during substitution of nontype pointer-to-member parameter &T::member -> int T::*member

- determine type of dependent expression
	- requires two-phase name lookup for unqualified names within expression. e.g. f(dependent);
		- for now: [temp.dep.res] Declarations that are visible at the point of definition of the template.
		- if operand is dependent, must store unqualified-id and point-of-definition.
			- point-of-definition is location of original template
		- could do lookup (but not overload resolution) at point of parse?

+ issue: 'context' is still being instantiated while looking up names within it
	LexContext
		-> context
		-> macromap<context>::name_iterator (instantiate macromap<context>)
		-> ContextT::token_type token_type (instantiate ContextT)
	- during qualified name lookup within instantiation for a member of a class which is partially instantiated, only names declared before the point of instantiation are visible
		- including dependent base classes!
		- but names in bases of partially instantiated class cannot be accessed from within instantiation of its base
	- track point of instantiation for each declaration in WalkerState
		- automatically rolls back if parse fails
		- per instance, because redeclaration may make name visible after being hidden
	- during parse of template definition, when complete type is required
		- if non-dependent, instantiate type and store point of instantiation
		- else add type to list of child instantiations and store declaration visibility
		- when instantiating template, used stored declaration visibility when instantiating child
	- in what contexts do child instantiations occur?
		- type of member definition required to be complete
		- type of base required to be complete
		- type named in member/base type-id
			- nested-name-specifier
		- type in expression required to be complete
			- static-const initializer
			- template-argument expression
				- in specialization arguments

- investigate: how does bidirectional_map work?
	- multi_index_container -> multi_index_base_type<...>::type -> nth_layer<0, ...>::type
		- nth_layer::type = apply2<index_applier, T1, T2>::type
			- apply2<F, T1, T2> -> lambda<F>::type::apply<T1, T2> -> F::apply<T1, T2>
		- index_applier::apply<T1, T2>::type -> T1::type::index_class<T2>::type
			- T1 = at_c<IndexSpecifierList, N>
			- T2 = nth_layer<N+1, ...>
			-> at_c<IndexSpecifierList, N>::type::index_class<nth_layer<N+1, ...>>::type
		- IndexSpecifier list: either ordered_unique or ordered_non_unique
		- ordered_unique::index_class<T1>::type -> ordered_index<T1 ...>::type
		- why is 'length' 20?
			- indexed_by is a vector20
			- vector<T1, T2, na, ..> should be vector2!

- task: template argument deduction
	- for function templates
	- for class template partial-specializations
		- specialization is matched if its arguments can be deduced from the template arguments vs the specialization argument list
	- what is "type deduction"?
		- the process of determining the template arguments, from a set of dependent types (e.g. function parameters) and a set of non-dependent types (e.g. function-call arguments)
		- involves 'substitution' of 'substition-failure'
		- [temp.deduct] When an explicit template argument list is specified, the template arguments must be compatible with the
			template parameter list and must result in a valid function type.
			If a substitution in a template parameter or in the function type of the function template results in an invalid type, type deduction fails.
		- unspecified arguments must be deduced before substitution
		- for each dependent type, substitute template-parameters with template-arguments; fail if the result is an invalid type
		- perform function parameter type adjustments
	- steps in argument deduction for function template
		- for each function-parameter, find template-parameters (for allowed forms, ignoring nondeduced contexts) and fill in template-arguments with corresponding type from function-call arguments
	- type substitution for name qualified by dependent type
		- similar process to what currently happens in makeUniqueType
		- look up declaration in enclosing type
		- perform substitution in context of enclosing type
	- partial ordering of partial-specializations
		- compare specialization A to specialisation B
		- use A's specialization-arguments to match B
		- e.g. 'A<T*>' matches 'B<T>', but 'A<T>' does not match 'B<T*>'
		- if A matches B but B does not match A, A is more specialized
	- what causes <const T> and 'int' to fail deduction?
		- likewise, what causes <const T> and 'const int' to deduce 'int' ?
	- deduction for non-type
	- substitution for non-type
	- substitute while deducing?
		- [temp.deduct] When all template arguments have been deduced, all uses of template parameters in
			nondeduced contexts are replaced with the corresponding deduced argument values. If the substitution
			results in an invalid type, as described above, type deduction fails.


+ task: make enclosingType valid for out-of-line member definitions
+ task: unique dependent template-name: T::template X<int>

+ task: correct name lookup for template explicit/partial specializations
	- [temp.class.spec] Partial specialization declarations themselves are not found by name lookup.
	- [temp.class.spec.match] When a class template is used in a context that requires an instantiation of the class, it is necessary to determine
			whether the instantiation is to be generated using the primary template or one of the partial specializations.
		- implies that this is not determined (e.g. no argument deduction is performed) until the class template is instantiated?
	- don't add to declarations? If not, where to store Declaration?
	- add, but ignore during name lookup?
		- inefficient, but works
	- store list of specializations in primary template
		- modifying existing declaration when specialization is declared is hard to undo when specialization is undeclared
	- forward declaration of partial specialization is invisible?

+ task: in makeUniqueType, use previously uniqued type if available and isDependent=false.
	+ assert that previously uniqued type is equal to result of makeUniqueType
		- can only do this if both the previously uniqued type and the result of makeUniqueType are not dependent
	- in declaration with dependent type, store index into array of dependent member types
		- build array of dependent member types on parse, stored in enclosing dependent unique-type
		- when instantiating unique-type, fill array with member unique-types
	- perform type substitution on dependent unique-type
		- DependentType: substitute template parameter from enclosing type for argument
		- DependentTypename: perform name lookup to find member-declaration
			- if member-declaration is class-declaration, build simple ObjectType from declaration
			- else if found member-declaration's Type has isDependent=false, use its unique-type
			- else look up unique-type in (instantiated) enclosing type
		- DependentTemplate: as above, plus stored template arguments
			- add default arguments to stored arguments if necessary, add to ObjectType

+ task: template instantiation debugging
	- for a given instantiation, report which instantiations it requires
		- track required instantiations
		- add to list in enclosing-type when calling instantiateClass
			- contains instance+location
			- reversal of existing graph?
				- except that existing graph does not store location
		- instantiation graph: maps enclosing-type to children
			- multimap, key of enclosing type, data of instance+location?
				- hard to debug
	- for each required instantiation
		- link to instantiation page
		- point of instantiation: file/line/column
	- display point of instantiation in source code
		- source file? can't auto scroll without inserting markup
		- inline only selected line(s)?
			- how to display long lines?
			- performance if file is large?
				- create index of source lines during prepro?
					- unnecessary performance hit?
				- ideally could get pointer to location in input file buffer for each token
				- performance not critical for error reporting
			- source lines should only be within template definition?

- investigate: can explicit/partial-specializations omit template arguments where there are defaults in the primary template?
	- clang allows with c++98

- investigate: what is instantiated when instantiating a class?
	- direct member declarations: yes
	- member-functions: no
	- member-classes: no

- task: remove if(walker.type.declaration != 0) and addBase even if declaration is not found

- issue: parser loses track of current token just after parsing last token of default-parameter (and other deferred parse?)

- task: remove check for isMemberOfTemplate that guards overload resolution: findBestMatch
	- investigate: is it possible to do overload resolution and choose a function that has a dependent return type?
		- example: calling an overloaded static member of a template, within sizeof(), to initialise a static-const member
		- should defer overload resolution if any overload is declared with a dependent type
		- defect 541: http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html
	- required because member-functions of template classes may have dependent arguments
		- conformant solution: function-call expression is dependent if function has any overloads that are declared with a dependent type
		- don't perform overload resolution if function-call expression is dependent

- task: construct templateParamScope when parsing 'template' token
	- construct empty template param scope for explicit specialization?

- task: avoid having to revert changes to TypeId in between parsing multiple declarators in init-declarator-list


- investigate: what is the dependent unique-type of a template-partial-specialization?
	- A<T*> where T is the enclosing template parameter?
	- ok to resolve specialization of a dependent unique-type?
	- necessary to correctly unique the enclosing class when parsing a template-partial-specialization


- investigate: partial specializations: how to substitute template-arguments when uniquing


- investigate: is result of makeUniqueType cached during cached-parse of template-id?

- task: when complete type is required for dependent type, add it to children list in enclosing template class

- issue: out-of-line member function template definition is not determined to be template
	- because testing 'parent == templateEnclosing'
	- should test 'enclosing == templateEnclosing'?
		- but 'enclosing' refers to template-param scope
		- enclosing is the scope in which name lookup occurs
			- must include template-params in name lookup
	- test something else?

