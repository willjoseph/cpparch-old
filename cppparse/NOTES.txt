
+ task: remove check for 'declaration->enclosing' in LEFTBRACE of class-specifier
+ task: assert result of findEnclosingType is not 0
+ task: assert Type::unique is valid when checking Type::isDependent
+ crash: infinite loop in findDeclaration, type is base of base of itself
	- struct D : B {}; struct B : D {};
	- use visited flag to prevent infinite recursion
+ assert: D:\dev\cpparch\cppparse\msvc-8.0\include\xdebug:110
	- instantiation of basic_string<char, char_traits<char>, _DebugHeapAllocator<char> > in base-specifier of _DebugHeapString
	- when instantiated at point of declaration of _DebugHeapString, unique-type differs to instantiation in base-specifier
	- second template argument has a different type: iosfwd:155 char_traits<T> vs iosfwd:406 char_traits<char>
	- occurs because type was uniqued with 'allowDependent' when it was not dependent
+ assert: D:\dev\cpparch\cppparse\msvc-8.0\include\xlocale:347 (iostream.prepro.cpp:6966:25)
	- instantiation of std::string in return value of Locinfo::Getname()
	- when instantiated at overload resolution for Getname(), unique-type differs to instantiation in declaration
	- second template argument has a different type: new: char_traits<T> vs original: char_traits<char>
	- occurs because type was uniqued with 'allowDependent' when it was not dependent
+ task: make-unique for all types at point of parse, allowDependent=true for unique types
	- set isDependent=true on Type if dependent, do not look up names in base classes with isDependent=true
+ task: make-unique the enclosing type even when it's a template
	- always allow dependent if it's a template
+ task: use enclosing scope to determine whether type name is name of enclosing class
+ task: modify instantiateClass to instantiate base classes of the enclosing template class
	- also instantiate dependent base classes, but don't add them to the list if allowDependent=true
	- is allowDependent=true in context where base classes are no longer dependent?
		- e.g. D<int>::B

- task: build list of dependent types for deferred uniquing/instantiation in instantiateClass
	- cannot instantiate until unique-type is known, should hold reference to placeholder 'deferred' unique-type
	- avoid duplicates: use dependent unique-type to distinguish?
	- addBase: 

- task: use the 'type' of a class definition to store unique-type

- investigate: template instantiation
	- perform substitution on dependent unique-types instead of Type

	template<typename T>
	struct S
	{
		T m; // 'S<T>' contains dependent unique-type 'T'

		template<typename U>
		struct V
		{
			U m; // 'S<T>::V<U>' contains dependent unique-type 'U'
		};
	};

	S<int> s; // instantiate S<T> -> S<int>
	S<int>::V<int> v; // instantiate S::<T>::V<U> -> S<int>::V<int>
	
	- S<T> is TypeInstance, with one dependent template-argument
	- unique: 
	- instantiate:


- task: disallow implicit instantiation of a template within its own definition

- problem: findEnclosingType searches bases of incomplete class when within class definition
	- don't use instantiateClass to enable this search: search non-dependent bases if..
		- class is an enclosing template
	- return enclosing type from findDeclaration

- problem: ambiguity in template-argument between assignment-expression and type-id: T() and T(arg)
	- trying 'type-id' first is correct in former, wrong in latter
	- vice versa for assignment-expression
	- [temp.arg] In a template argument, an ambiguity between a typeid and an expression is resolved to a typeid,
		regardless of the form of the corresponding template parameter

- investigate: isMemberObject returns true if member is class definition?

- test: parsing f(x,...)

- test: correct type of expression x = y (should be type of 'x'?)

- task: basic support for non-type arguments
	+ store non-type argument value
	+ parse constant literals
	+ get value for constant id-expression
		+ enumerator
	- evaluate integral constant expressions
		- binary
		- ternary
		- cast
		- sizeof
	- deferred evaluation of dependent integral constant expressions
		- need to substitute non-type template parameters
			- N
			- T::value
		- need to substitute template-parameters
			- sizeof(T)
			- T(0)
		- parse expression into visitable tree
		- walk tree to perform substitution
			- is this necessary for values? can evaluate and substitute at the same time..
			- does this work when substituting types?
		- walk tree to evaluate
		- walk tree to compare for equality?
			- unique expressions?
		- ensure comma-operator evaluated left to right
		- can evaluate types with separate tree?
			- evaluating types (but not values) also required for non-integral non-constant expression
				- to determine argument types for overload resolution
				- evaluation must be deferred if expression is dependent
				- node set overlaps - some also occur in integral constant-expression
				- required in integral-constant-expression to evaluate sizeof(f())
			- sometimes type depends on value, and vice versa
				- sizeof(0) // value depends on type of '0' (but NOT value)
				- X<0> // type depends on value of '0' (but NOT type

- task: template argument deduction
	- for function templates
	- for class template partial-specializations
		- specialization is matched if its arguments can be deduced from the template arguments vs the specialization argument list
	- what is "type deduction"?
		- the process of determining the template arguments, from a set of dependent types (e.g. function parameters) and a set of non-dependent types (e.g. function-call arguments)
		- involves 'substitution' of 'substition-failure'
		- [temp.deduct] When an explicit template argument list is specified, the template arguments must be compatible with the
			template parameter list and must result in a valid function type.
			If a substitution in a template parameter or in the function type of the function template results in an invalid type, type deduction fails.
		- unspecified arguments must be deduced before substitution
		- for each dependent type, substitute template-parameters with template-arguments; fail if the result is an invalid type
		- perform function parameter type adjustments
	- steps in argument deduction for function template
		- for each function-parameter, find template-parameters (for allowed forms, ignoring nondeduced contexts) and fill in template-arguments with corresponding type from function-call arguments
	- type substitution for name qualified by dependent type
		- similar process to what currently happens in makeUniqueType
		- look up declaration in enclosing type
		- perform substitution in context of enclosing type
	- partial ordering of partial-specializations
		- compare specialization A to specialisation B
		- use A's specialization-arguments to match B
		- e.g. 'A<T*>' matches 'B<T>', but 'A<T>' does not match 'B<T*>'
		- if A matches B but B does not match A, A is more specialized
	- what causes <const T> and 'int' to fail deduction?
		- likewise, what causes <const T> and 'const int' to deduce 'int' ?

- task: in makeUniqueType, use previously uniqued type if available and isDependent=false.
	+ assert that previously uniqued type is equal to result of makeUniqueType
		- can only do this if both the previously uniqued type and the result of makeUniqueType are not dependent
	- in declaration with dependent type, store index into array of dependent member types
		- build array of dependent member types on parse, stored in enclosing dependent unique-type
		- when instantiating unique-type, fill array with member unique-types
	- perform type substitution on dependent unique-type
		- DependentType: substitute template parameter from enclosing type for argument
		- DependentTypename: perform name lookup to find member-declaration
			- if member-declaration is class-declaration, build simple ObjectType from declaration
			- else if found member-declaration's Type has isDependent=false, use its unique-type
			- else look up unique-type in (instantiated) enclosing type
		- DependentTemplate: as above, plus stored template arguments
			- add default arguments to stored arguments if necessary, add to ObjectType

- investigate: can explicit/partial-specializations omit template arguments where there are defaults in the primary template?
	- clang allows with c++98

- investigate: what is instantiated when instantiating a class?
	- direct members: yes
	- member-functions: no
	- member-classes: no

- task: remove if(walker.type.declaration != 0) and addBase even if declaration is not found

- issue: parser loses track of current token just after parsing last token of default-parameter (and other deferred parse?)

- task: remove check for isMemberOfTemplate that guards overload resolution: findBestMatch
	- investigate: is it possible to do overload resolution and choose a function that has a dependent return type?
		- example: calling an overloaded static member of a template, within sizeof(), to initialise a static-const member
		- should defer overload resolution if any overload is declared with a dependent type
		- defect 541: http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html
	- required because member-functions of template classes may have dependent arguments
		- conformant solution: function-call expression is dependent if function has any overloads that are declared with a dependent type
		- don't perform overload resolution if function-call expression is dependent

- task: construct templateParamScope when parsing 'template' token
	- construct empty template param scope for explicit specialization?

- task: make enclosingType valid for out-of-line member definitions

- task: avoid having to revert changes to TypeId in between parsing multiple declarators in init-declarator-list

- task: unique dependent template-name: T::template X<int>


- investigate: what is the dependent unique-type of a template-partial-specialization?
	- A<T*> where T is the enclosing template parameter?
	- ok to resolve specialization of a dependent unique-type?
	- necessary to correctly unique the enclosing class when parsing a template-partial-specialization


- investigate: partial specializations: how to substitute template-arguments when uniquing


- investigate: is result of makeUniqueType cached during cached-parse of template-id?

