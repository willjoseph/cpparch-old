

- check that include-path search order is consistent with MSVC/GCC

- test parser for completeness and compliance

- build against stlport for performance?

- allow source file + includes to be specified on commandline or config file

- profile wave
	- reading files
	- searching include paths
	- recognises pragma once and include-guards
	
- optimise parser allocations
	- ensure allocator uses good block size: 128kb?
	- use parse-tree allocator where possible
		- scopes
		- declarations
		- types
	- avoid allocations where possible
		- don't allocate symbol until successful parse
			- measure cost
		- avoid copying 'qualifying' when creating WalkerState
			- parsing nested-name-specifier
			- copy-on-write?
			- move to walker-base?
			- ref instead of copy?
			- avoid copying 'global-type'
			- use list instead of 'copied'
		- don't track list of scopes/declarations unless debugging
		
- buffer tokens from lexer
	- huge speed improvement
	
- optimise name-lookup
	- hashtable?
	- single global id table, id:scopes?
		- how to sort scopes?
	- trace name-lookup pattern
	
- remove disambiguation hacks
	- init_declarator_disambiguate
	
- handle errors
	- if member-initializer parse fails, member declaration is already committed
		- committed declaration cannot be deallocated (unless forward-declaration), causes allocator check failure
		- need to commit at point of declaration: failure to parse member-initializer is fatal
		- detect that this is a fatal error and don't clean up symbols?
		- for now, track all declarations and clean up if parse fails..
			- doubles parse time, optimise!
			
- bug: 
c:\dev\boost_1_41_0\boost\wave\cpp_iteration_context.hpp(73)

- profile:
- vector
	wave                   21737366
	parser                 30846199
	ambiguity                 50397
	diagnose                      0
	allocator              19302030
	identifier              7748102
- iostream
	wave                   48499593
	parser                 63617130
	ambiguity                106620
	diagnose                      0
	allocator              39960755
	identifier             16882862
- windows
	wave                  469218637
	parser                141999356
	ambiguity                111879
	diagnose                      0
	allocator              89381859
	identifier             37617169

NEW/DELETE
- vector		
	io                       508691
	wave                   41324007
	parser                 82063803
	ambiguity                     0
	diagnose                      0
	allocator              20110129
	identifier              9453886
- iostream
	io                       884982
	wave                   72270147
	parser                146057297
	ambiguity                     0
	diagnose                      0
	allocator              41178337
	identifier             19643432
	
TREE
- vector
	io                       568027
	wave                   15583271
	parser                 40107449
	ambiguity                     0
	diagnose                      0
	allocator              32477248
	identifier              7014206
- iostream
	io                      1121058
	wave                   38006128
	parser                 83479098
	ambiguity                     0
	diagnose                      0
	allocator              66734488
	identifier             15814600
	
STLPORT+TREE
- vector
	io                       445430
	wave                    6840977
	parser                 30122501
	ambiguity                     0
	diagnose                      0
	allocator              21647419
	identifier              6718764
- iostream
	io                      1005437
	wave                   16988790
	parser                 63241322
	ambiguity                     0
	diagnose                      0
	allocator              44870679
	identifier             15404659
- windows
	io                      1873929
	wave                  162443353
	parser                141978326
	ambiguity                     0
	diagnose                      0
	allocator              99781309
	identifier             34715545
	
STLPORT+TREE+SWAP
- vector
	io                       317450
	wave                    6584380
	parser                 27955728
	ambiguity                     0
	diagnose                      0
	allocator              20275536
	identifier              6456379
- iostream
	io                       567670
	wave                   15366589
	parser                 58518065
	ambiguity                     0
	diagnose                      0
	allocator              41955459
	identifier             14694980
	
STLPORT+TREE+SWAP+NODTOR
- vector
	io                       220464
	wave                    6355605
	parser                 27956837
	ambiguity                     0
	diagnose                      0
	allocator              20200340
	identifier              6438978
- iostream
	io                       474440
	wave                   15658861
	parser                 59074170
	ambiguity                     0
	diagnose                      0
	allocator              42071153
	identifier             14853047

BUFFERED LEXER
- iostream
	io                       626678
	wave                   14295285
	parser                 10937817
	lookup                 11108735
	diagnose                      0
	allocator                 90220
	identifier              2245122
	
NO LOOKUP PROFILE
- iostream
	io                       690777
	wave                   16251974
	parser                  3415241
	lookup                  1579450
	diagnose                      0
	allocator                 89982
	identifier              2356020
		
- faster lexer
	- optimise boost::wave?
	- custom lexer/preprocessor?
	- http://www.ibm.com/developerworks/aix/library/au-c_plusplus_antlr/index.html
	- GNU cpplib?
		- doesn't build easily on win32
	- ucpp?
		- only supports C99 tokens

- faster debugging
	- parse declaration-seq iteratively

- fix printer bugs
	- space between *= and &=
	- space before and after =
	- space between return and true/false
	- space between nested > in template decl
	
- enabled syntax-highlighted output from mingled parse 

- generate parser
	- point of declaration
		- namespace: after identifier in namespace-declaration
			- contains block-declarations
		- class: after identifier/simple-template-id in class-head, unless anonymous
			- contains template-params, member-declarations
		- enum: after identifier in enum-specifier, unless anonymous
			- contains nothing
		- enumerator: after enumerator-definition
		- elaborated-type-specifer (unqualified): after identifier (in enclosing class/namespace)
		- elaborated-type-specifier (forward): after identifier
		- declaration: after declarator
			- contains template-params, simple-declarations
		- bitfield: after identifier in member-declarator-bitfield, unless anonymous
		- type-parameter: after identifier in type-parameter-default, unless anonymous
	- add context to hand-written parser

- create 'under-construction' scope when beginning template-declaration, class-declaration, function-declaration
- push/clear under-construction scope at point of declaration


- implement template-instantiation
	- specializations are chosen at point of instantiation
	- dependent-names/types are bound at point of instantiation-
	- partial-ordering of class template specialisations
- perform type-deduction
	- store function-type as R(A1, A2) rather than just R
	- store member-function-type as R C::*(A1, A2) rather than just R
	- store member-pointer-type as R C::* rather than just R

- distinguish names that refer to 'current instantiation' as not dependent - 14.6.2.1

- overload resolution
- argument-dependent-lookup
- name-lookup for overloaded-operators


argument dependent lookup
3.4.2-2
For each argument type T in the function call, there is a set of zero or more associated namespaces and a
set of zero or more associated classes to be considered. The sets of namespaces and classes is determined
entirely by the types of the function arguments (and the namespace of any template template argument).
Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of
namespaces and classes are determined in the following way:
— If T is a fundamental type, its associated sets of namespaces and classes are both empty.
— If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a
member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces
of which its associated classes are members. Furthermore, if T is a class template specialization,
its associated namespaces and classes also include: the namespaces and classes associated with the
types of the template arguments provided for template type parameters (excluding template template
parameters); the namespaces of which any template template arguments are members; and the classes
of which any member templates used as template template arguments are members. [ Note: non-type
template arguments do not contribute to the set of associated namespaces.—end note ]
— If T is an enumeration type, its associated namespace is the namespace in which it is defined. If it is
class member, its associated class is the member’s class; else it has no associated class.
— If T is a pointer to U or an array of U, its associated namespaces and classes are those associated with
U.
— If T is a function type, its associated namespaces and classes are those associated with the function
parameter types and those associated with the return type.
— If T is a pointer to a member function of a class X, its associated namespaces and classes are those
associated with the function parameter types and return type, together with those associated with X.
— If T is a pointer to a data member of class X, its associated namespaces and classes are those associated
with the member type together with those associated with X.


class member lookup
3.4.1-8
A name used in the definition of a member function (9.3) of class X following the function’s declarator-id 28
or in the brace-or-equal-initializer of a non-static data member (9.2) of class X shall be declared in one of
the following ways:
— before its use in the block in which it is used or in an enclosing block (6.3), or
— shall be a member of class X or be a member of a base class of X (10.2), or
— if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y
(this lookup applies in turn to Y’s enclosing classes, starting with the innermost enclosing class),29 or
— if X is a local class (9.8) or is a nested class of a local class, before the definition of class X in a block
enclosing the definition of class X, or
— if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class
or a nested class within a local class of a function that is a member of N, before the use of the name,
in namespace N or in one of N ’s enclosing namespaces.


