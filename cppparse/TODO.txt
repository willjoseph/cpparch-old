

- check that include-path search order is consistent with MSVC/GCC

- test parser for completeness and compliance

- build against stlport for performance?

- allow source file + includes to be specified on commandline or config file

- profile wave
	- reading files
	- searching include paths
	- recognises pragma once and include-guards
	
- optimise parser allocations
	- ensure allocator uses good block size: 128kb?
	- use parse-tree allocator where possible
	
- remove disambiguation hacks
	- init_declarator_disambiguate

- profile:
	- vector
		wave                   21737366
		parser                 30846199
		ambiguity                 50397
		diagnose                      0
		allocator              19302030
		identifier              7748102
	- iostream
		wave                   48499593
		parser                 63617130
		ambiguity                106620
		diagnose                      0
		allocator              39960755
		identifier             16882862
	- windows
		wave                  469218637
		parser                141999356
		ambiguity                111879
		diagnose                      0
		allocator              89381859
		identifier             37617169

- faster lexer
	- optimise boost::wave?
	- custom lexer/preprocessor?
	- http://www.ibm.com/developerworks/aix/library/au-c_plusplus_antlr/index.html
	- GNU cpplib?
		- doesn't build easily on win32
	- ucpp?
		- only supports C99 tokens

- faster debugging
	- parse declaration-seq iteratively

- fix printer bugs
	- space between *= and &=
	- space before and after =
	- space between return and true/false
	- space between nested > in template decl
	
- enabled syntax-highlighted output from mingled parse 

- generate parser
	- point of declaration
		- namespace: after identifier in namespace-declaration
			- contains block-declarations
		- class: after identifier/simple-template-id in class-head, unless anonymous
			- contains template-params, member-declarations
		- enum: after identifier in enum-specifier, unless anonymous
			- contains nothing
		- enumerator: after enumerator-definition
		- elaborated-type-specifer (unqualified): after identifier (in enclosing class/namespace)
		- elaborated-type-specifier (forward): after identifier
		- declaration: after declarator
			- contains template-params, simple-declarations
		- bitfield: after identifier in member-declarator-bitfield, unless anonymous
		- type-parameter: after identifier in type-parameter-default, unless anonymous
	- add context to hand-written parser

- create 'under-construction' scope when beginning template-declaration, class-declaration, function-declaration
- push/clear under-construction scope at point of declaration


- implement template-instantiation
	- specializations are chosen at point of instantiation
	- dependent-names/types are bound at point of instantiation-
	- partial-ordering of class template specialisations
- perform type-deduction
	- store function-type as R(A1, A2) rather than just R
	- store member-function-type as R C::*(A1, A2) rather than just R
	- store member-pointer-type as R C::* rather than just R

- distinguish names that refer to 'current instantiation' as not dependent - 14.6.2.1

- overload resolution
- argument-dependent-lookup
- name-lookup for overloaded-operators


argument dependent lookup
3.4.2-2
For each argument type T in the function call, there is a set of zero or more associated namespaces and a
set of zero or more associated classes to be considered. The sets of namespaces and classes is determined
entirely by the types of the function arguments (and the namespace of any template template argument).
Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of
namespaces and classes are determined in the following way:
— If T is a fundamental type, its associated sets of namespaces and classes are both empty.
— If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a
member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces
of which its associated classes are members. Furthermore, if T is a class template specialization,
its associated namespaces and classes also include: the namespaces and classes associated with the
types of the template arguments provided for template type parameters (excluding template template
parameters); the namespaces of which any template template arguments are members; and the classes
of which any member templates used as template template arguments are members. [ Note: non-type
template arguments do not contribute to the set of associated namespaces.—end note ]
— If T is an enumeration type, its associated namespace is the namespace in which it is defined. If it is
class member, its associated class is the member’s class; else it has no associated class.
— If T is a pointer to U or an array of U, its associated namespaces and classes are those associated with
U.
— If T is a function type, its associated namespaces and classes are those associated with the function
parameter types and those associated with the return type.
— If T is a pointer to a member function of a class X, its associated namespaces and classes are those
associated with the function parameter types and return type, together with those associated with X.
— If T is a pointer to a data member of class X, its associated namespaces and classes are those associated
with the member type together with those associated with X.


class member lookup
3.4.1-8
A name used in the definition of a member function (9.3) of class X following the function’s declarator-id 28
or in the brace-or-equal-initializer of a non-static data member (9.2) of class X shall be declared in one of
the following ways:
— before its use in the block in which it is used or in an enclosing block (6.3), or
— shall be a member of class X or be a member of a base class of X (10.2), or
— if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y
(this lookup applies in turn to Y’s enclosing classes, starting with the innermost enclosing class),29 or
— if X is a local class (9.8) or is a nested class of a local class, before the definition of class X in a block
enclosing the definition of class X, or
— if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class
or a nested class within a local class of a function that is a member of N, before the use of the name,
in namespace N or in one of N ’s enclosing namespaces.


