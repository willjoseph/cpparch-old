
+ clean up main()

+ fixed mergeIncludes crash in lexer.cpp: failed to handle cyclic includes
+ fixed crash in dependency analysis: declareEts not rolled back completely after parse fail - 'type' was left modified
+ fixed crash parsing cppparse.cpp, caused by friend-declaration shortcut

- implement friend declaration?
	- has no effect
		- name-lookup:
			- unqualified: innermost enclosing namespace only
			- qualified (or template-id): 
			- if not found by name lookup (first declaration) is a  member of innermost enclosing namespace, but cannot be found by name-lookup
			- A function can be defined in a friend declaration of a class if and only if the class is a non-local class (9.8),
				the function name is unqualified, and the function has namespace scope.
			- A friend function defined in a class is in the (lexical) scope of the
				class in which it is defined. A friend function defined outside the class is not (3.4.1).
			- 7.3.1.2-3: If a friend declaration in a nonlocal
class first declares a class or function the friend class or function is a member of the innermost enclosing
namespace. The name of the friend is not found by unqualified lookup (3.4.1) or by qualified lookup (3.4.3)
until a matching declaration is provided in that namespace scope (either before or after the class definition
granting friendship). If a friend function is called, its name may be found by the name lookup that considers
functions from namespaces and classes associated with the types of the function arguments (3.4.2). If the
name in a friend declaration is neither qualified nor a template-id and the declaration is a function or
an elaborated-type-specifier, the lookup to determine whether the entity has been previously declared shall
not consider any scopes outside the innermost enclosing namespace.

- slow parsing of cpptree.h
	- caused by pathological case: nested template-ids
		- isDependent is slow?
		- each iteration is parsed first as nested-name-specifier
		
- make gUniqueNames a member of Scope?

- clean up error handling - multiple assert exception types?


- improve error messages
	- e.g. detect when 'typename' keyword is missing
	
- explain template_argument_clause_disambiguate
	- disambiguates: < CONSTANT_EXPRESSION < 0 >
	- how?
	- only required when template-id appears in an expression
	
- explain postfix_expression_disambiguate
	- disambiguates nested function-call expression from postfix_expression_construct
	- e.g. T()()

- parser is hard to work with - refactor?
	- remove dead code
	+ move List into separate file
	- replace Copied with a list?
	- remove unmingled parse
		- remove disambiguation grammar: init_declarator_disambiguate
	- clean up SimpleDeclarationWalker::deferred
	- naming:
		- ParserContext is lexer?
	- TREEWALKER macros
	
- generate remaining handwritten parseSymbol functions
	- PARSE_SELECT_TOKEN
	- PARSE_EXPRESSION_LEFTASSOCIATIVE
	- inTemplateArgumentList
	- overloadable_operator
	
- replace std::list with custom List class?
	- or just use custom tree-allocator?

- ensure output files are unique
	- one output subdir per .cpp
	- create subdirs relative to include-path
		- how to determine which include-path a source file is rooted in?
		- include-path '.' may override other include-paths?
			- put output files sourced from include-paths into $include subdir
		- use '$..' to indicate looking outside an include-path
	- compare output files generated from same source?
- warn on escaping from include-path using '..'
- add exclusions for warning messages
- detect order-dependent includes
	- e.g. header1.h depends on header2.h but does not (in)directly include it
		- confused by multiple declarations in different headers: e.g. getwchar in stdio.h and wchar.h
			- prefer (in)directly included source when determining location of declaration
		- confused by #ifndef NULL #define NULL 0 #endif
			- recognise ifndef-define pattern as redeclaration?
				- heuristic is bad
			- tag all declarations within #ifndef X #define X #endif
				- determine all tagged declarations to be present within any file containing #ifndef X
		- confused by #ifdef X X() #endif
			- ignore dependency on X when wrapped in #ifdef X
- detect cyclic includes
- detect unused includes

- list symbols depended on by each module
	- use consistent path-separator/root in filenames
		- how does wave derive the absolute root from the relative include-path?
	~ exclude predefined symbols
		~ pass contents of predefined_msvc.h directly to lexer, rather than via #include
	- including macro definitions
	- support overloaded-operators
	- ignore namespace names
	- perform type-dependent name-lookup for template instantiations
	- handle multiple identical typedef/forward-declaration in different modules
			
		
- optimise parsing of cpptree?
	- profile parse, find out exactly what's taking so long
	- factor out shared-prefix between nested-name-specifier and type-name?
		- check that this is actually the cause of the slow parse?
		- problem with basic.lookup.qual: During the lookup for a name preceding the :: scope resolution operator, object, function, and enumerator names are ignored.
		- occurs: base_specifier, mem_initializer_id_base, typename_specifier, simple_type_specifier_name/template
			simple-type-specifier:
				[::] [nested-name-specifier] type-name
				[::] nested-name-specifier template simple-template-id
			nested-namespace-specifier:
				namespace-name :: [nested-namespace-specifier-seq]
			nested-namespace-specifier-seq:
				nested-namespace-specifier [nested-namespace-specifier-seq]
			qualified-type-name:
				[nested-namespace-specifier-seq] type-name [qualified-type-name-suffix]
			qualified-type-name-suffix:
				:: type-name [qualified-type-name-suffix]
	- use LR parse instead?
		- how much do context actions rely on the assumption that parsing is top-down?
	- cache the type-name parsed from the beginning of a nested-name-specifier?
		- when nested-name-specifier parse fails at '::', defer backtrack and store type-name
			- need to re-lookup type-name to check that it is not hidden by a non-type-name
			- make '::' optional in nested-name-specifier when specifying a type-name?
			

- fix or remove macroPosition

- use found-include-directive hook to build include-graph
	- doesn't give full path, need to add resolved_include_file
	- how to uniquely identify a source file?
		- absolute path
	- opened_include_file gives relname/absname
		- always the same?
		- always use forward-slash?
	
- detect mid-declaration-includes

- output one html per #include
	- why?
		- not required for dependency-tracking?
		- easier to browse html source
		- recognises repeat-includes
		- recognises mid-declaration-includes
	- tag all declarations with the source file?
	- need to track include push/pop
	- emit extra tokens?
		- modify grammar? include-declaration: include declaration-seq eof
		- swallow in lexer?
	- tag first and last token in file?
		- fails if no tokens after #include
	- build include-graph with parent-links, make file-position point at node?
	- append sequence of push/pop commands 'between' tokens?
		- +a = +1
		- -a = -1
		- +a, -a = nothing
		- -a, +a, -a = -1
		- -a, +a = -1, +1
		- -a, +b = -1, +1
		- +a, -a, -b = -1
		- +a, -a, +b = +1
		- +a, +b, -b = +1


- macro dependencies
	- associate macro definitions with source files
	- for each macro expansion, add definition to list of dependencies

- check that include-path search order is consistent with MSVC/GCC

- test parser for completeness and compliance

- build against stlport for performance?

- allow source file + includes to be specified on commandline or config file

- profile wave
	- reading files
	- searching include paths
	- recognises pragma once and include-guards
	
- optimise parser allocations
	- ensure allocator uses good block size: 128kb?
	- use parse-tree allocator where possible
		- scopes
		- declarations
		- types
	- avoid allocations where possible
		- don't allocate symbol until successful parse
			- measure cost
		- avoid copying 'qualifying' when creating WalkerState
			- parsing nested-name-specifier
			- copy-on-write?
			- move to walker-base?
			- ref instead of copy?
			- avoid copying 'global-type'
			- use list instead of 'copied'
		- don't track list of scopes/declarations unless debugging
		
- buffer tokens from lexer
	- huge speed improvement
	
- optimise name-lookup?
	- hashtable?
	- single global id table, id:scopes?
		- how to sort scopes?
	- trace name-lookup pattern
	
- remove disambiguation hacks
	- init_declarator_disambiguate
	
- handle errors
	- if member-initializer parse fails, member declaration is already committed
		- committed declaration cannot be deallocated (unless forward-declaration), causes allocator check failure
		- need to commit at point of declaration: failure to parse member-initializer is fatal
		- detect that this is a fatal error and don't clean up symbols?
		- for now, track all declarations and clean up if parse fails..
			- doubles parse time, optimise!
			- don't track declarations (except forward-decl) unless ALLOCATOR_DEBUG
			
- clean up test code

- profile:
- vector
	wave                   21737366
	parser                 30846199
	ambiguity                 50397
	diagnose                      0
	allocator              19302030
	identifier              7748102
- iostream
	wave                   48499593
	parser                 63617130
	ambiguity                106620
	diagnose                      0
	allocator              39960755
	identifier             16882862
- windows
	wave                  469218637
	parser                141999356
	ambiguity                111879
	diagnose                      0
	allocator              89381859
	identifier             37617169

NEW/DELETE
- vector		
	io                       508691
	wave                   41324007
	parser                 82063803
	ambiguity                     0
	diagnose                      0
	allocator              20110129
	identifier              9453886
- iostream
	io                       884982
	wave                   72270147
	parser                146057297
	ambiguity                     0
	diagnose                      0
	allocator              41178337
	identifier             19643432
	
TREE
- vector
	io                       568027
	wave                   15583271
	parser                 40107449
	ambiguity                     0
	diagnose                      0
	allocator              32477248
	identifier              7014206
- iostream
	io                      1121058
	wave                   38006128
	parser                 83479098
	ambiguity                     0
	diagnose                      0
	allocator              66734488
	identifier             15814600
	
STLPORT+TREE
- vector
	io                       445430
	wave                    6840977
	parser                 30122501
	ambiguity                     0
	diagnose                      0
	allocator              21647419
	identifier              6718764
- iostream
	io                      1005437
	wave                   16988790
	parser                 63241322
	ambiguity                     0
	diagnose                      0
	allocator              44870679
	identifier             15404659
- windows
	io                      1873929
	wave                  162443353
	parser                141978326
	ambiguity                     0
	diagnose                      0
	allocator              99781309
	identifier             34715545
	
STLPORT+TREE+SWAP
- vector
	io                       317450
	wave                    6584380
	parser                 27955728
	ambiguity                     0
	diagnose                      0
	allocator              20275536
	identifier              6456379
- iostream
	io                       567670
	wave                   15366589
	parser                 58518065
	ambiguity                     0
	diagnose                      0
	allocator              41955459
	identifier             14694980
	
STLPORT+TREE+SWAP+NODTOR
- vector
	io                       220464
	wave                    6355605
	parser                 27956837
	ambiguity                     0
	diagnose                      0
	allocator              20200340
	identifier              6438978
- iostream
	io                       474440
	wave                   15658861
	parser                 59074170
	ambiguity                     0
	diagnose                      0
	allocator              42071153
	identifier             14853047

BUFFERED LEXER
- iostream
	io                       626678
	wave                   14295285
	parser                 10937817
	lookup                 11108735
	diagnose                      0
	allocator                 90220
	identifier              2245122
	
NO LOOKUP PROFILE
- iostream
	io                       690777
	wave                   16251974
	parser                  3415241
	lookup                  1579450
	diagnose                      0
	allocator                 89982
	identifier              2356020
		
- faster lexer
	- optimise boost::wave?
	- custom lexer/preprocessor?
	- http://www.ibm.com/developerworks/aix/library/au-c_plusplus_antlr/index.html
	- GNU cpplib?
		- doesn't build easily on win32
	- ucpp?
		- only supports C99 tokens

- faster debugging
	- parse declaration-seq iteratively

- fix printer bugs
	- space between *= and &=
	- space before and after =
	- space between return and true/false
	- space between nested > in template decl
	
- enabled syntax-highlighted output from mingled parse 

- generate parser
	- point of declaration
		- namespace: after identifier in namespace-declaration
			- contains block-declarations
		- class: after identifier/simple-template-id in class-head, unless anonymous
			- contains template-params, member-declarations
		- enum: after identifier in enum-specifier, unless anonymous
			- contains nothing
		- enumerator: after enumerator-definition
		- elaborated-type-specifer (unqualified): after identifier (in enclosing class/namespace)
		- elaborated-type-specifier (forward): after identifier
		- declaration: after declarator
			- contains template-params, simple-declarations
		- bitfield: after identifier in member-declarator-bitfield, unless anonymous
		- type-parameter: after identifier in type-parameter-default, unless anonymous
	- add context to hand-written parser

- create 'under-construction' scope when beginning template-declaration, class-declaration, function-declaration
- push/clear under-construction scope at point of declaration


- implement template-instantiation
	- specializations are chosen at point of instantiation
	- dependent-names/types are bound at point of instantiation-
	- partial-ordering of class template specialisations
- perform type-deduction
	- store function-type as R(A1, A2) rather than just R
	- store member-function-type as R C::*(A1, A2) rather than just R
	- store member-pointer-type as R C::* rather than just R

- distinguish names that refer to 'current instantiation' as not dependent - 14.6.2.1

- overload resolution
- argument-dependent-lookup
- name-lookup for overloaded-operators


argument dependent lookup
3.4.2-2
For each argument type T in the function call, there is a set of zero or more associated namespaces and a
set of zero or more associated classes to be considered. The sets of namespaces and classes is determined
entirely by the types of the function arguments (and the namespace of any template template argument).
Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of
namespaces and classes are determined in the following way:
— If T is a fundamental type, its associated sets of namespaces and classes are both empty.
— If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a
member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces
of which its associated classes are members. Furthermore, if T is a class template specialization,
its associated namespaces and classes also include: the namespaces and classes associated with the
types of the template arguments provided for template type parameters (excluding template template
parameters); the namespaces of which any template template arguments are members; and the classes
of which any member templates used as template template arguments are members. [ Note: non-type
template arguments do not contribute to the set of associated namespaces.—end note ]
— If T is an enumeration type, its associated namespace is the namespace in which it is defined. If it is
class member, its associated class is the member’s class; else it has no associated class.
— If T is a pointer to U or an array of U, its associated namespaces and classes are those associated with
U.
— If T is a function type, its associated namespaces and classes are those associated with the function
parameter types and those associated with the return type.
— If T is a pointer to a member function of a class X, its associated namespaces and classes are those
associated with the function parameter types and return type, together with those associated with X.
— If T is a pointer to a data member of class X, its associated namespaces and classes are those associated
with the member type together with those associated with X.


class member lookup
3.4.1-8
A name used in the definition of a member function (9.3) of class X following the function’s declarator-id 28
or in the brace-or-equal-initializer of a non-static data member (9.2) of class X shall be declared in one of
the following ways:
— before its use in the block in which it is used or in an enclosing block (6.3), or
— shall be a member of class X or be a member of a base class of X (10.2), or
— if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y
(this lookup applies in turn to Y’s enclosing classes, starting with the innermost enclosing class),29 or
— if X is a local class (9.8) or is a nested class of a local class, before the definition of class X in a block
enclosing the definition of class X, or
— if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class
or a nested class within a local class of a function that is a member of N, before the use of the name,
in namespace N or in one of N ’s enclosing namespaces.




Windows SDK 1.7 changes:

C:\Program Files\Microsoft SDKs\Windows\v7.1\Include\objbase.h(239) - comment this line, IUnknown is not declared