
+ clean up main()
+ fixed mergeIncludes crash in lexer.cpp: failed to handle cyclic includes
+ fixed crash in dependency analysis: declareEts not rolled back completely after parse fail - 'type' was left modified
+ fixed crash parsing cppparse.cpp, caused by friend-declaration shortcut
+ fixed false-positive order-dependent includes warnings
+ fixed skipping default-argument with nested parentheses
+ check that correct std::swap() is called for Copied
+ remove 'original' in LookupResult
+ remove ambiguity<T>
+ move List into separate file
+ remove init_declarator_disambiguate
+ build against stlport for performance
+ buffer tokens from lexer: huge speed improvement!
+ allow source file + includes to be specified on commandline or config file
+ faster debugging: parse declaration-seq iteratively
+ fixed: template-function template-param scope not renamed from $template
+ bug: infinite loop when source file ends without newline?
+ remove 'else' after 'return reportIdentifierMismatch'
+ shared prefix: declarator
	- simple-declaration-named -> init-declarator-list -> init-declarator -> declarator
	- function-definition -> declarator
+ bug: without ALLOCATOR_DEBUG: stomped global-scope declarations
	- occurs only when deferring delete of declarations
	- stomped entry contains ets-declaration in failed parse-tree
	- onBacktrack not called when ALLOCATER_DEBUG enabled
+ enabled syntax-highlighted output from mingled parse 
+ replaced std::list with custom List class
	- custom tree-allocator with std::list doesn't work: allocation pattern is implementation-defined
+ in parseSymbolRequired, defer allocation of symbol until successful parse
	- requires stack-allocation and copying of parse-tree node
	- when parsing identifier, we store a persistent reference to symbol
		- allocate within visit()?
			- if parseSymbol succeeds
	- when deferring parse, we store a persistent reference to symbol
+ avoid copying Type in addDependent/Dependent
	- use list allocated with tree-allocator
		- use reference-counting to ensure nodes not freed before release
+ make using-declaration link to named declaration





- check that using-declaration is linked to correct definition: the one visible at point of using-declaration

- overhead of multiple-inherited vtables in identifier: 34 vtable pointers, 136 bytes
	- constructor calls are slow
	- is there an alternative mechanism for visiting parse-tree?
	- visiting is not required during parse!
		- removing vtable reduces overhead to 1 byte per base-class, trivial constructor
			- would be zero with empty-base-optimisation
			- remove multiple-inheritance?
				- need alternative method to enforce valid casting?

- C++0x
	- support '>>' in nested template-argument-list
	- implement 'auto' 


- document boost::wave modification: resolved_include_file

- implement friend declaration?
	- has no effect
		- name-lookup:
			- unqualified: innermost enclosing namespace only
			- qualified (or template-id): 
			- if not found by name lookup (first declaration) is a  member of innermost enclosing namespace, but cannot be found by name-lookup
			- A function can be defined in a friend declaration of a class if and only if the class is a non-local class (9.8),
				the function name is unqualified, and the function has namespace scope.
			- A friend function defined in a class is in the (lexical) scope of the
				class in which it is defined. A friend function defined outside the class is not (3.4.1).
			- 7.3.1.2-3: If a friend declaration in a nonlocal
class first declares a class or function the friend class or function is a member of the innermost enclosing
namespace. The name of the friend is not found by unqualified lookup (3.4.1) or by qualified lookup (3.4.3)
until a matching declaration is provided in that namespace scope (either before or after the class definition
granting friendship). If a friend function is called, its name may be found by the name lookup that considers
functions from namespaces and classes associated with the types of the function arguments (3.4.2). If the
name in a friend declaration is neither qualified nor a template-id and the declaration is a function or
an elaborated-type-specifier, the lookup to determine whether the entity has been previously declared shall
not consider any scopes outside the innermost enclosing namespace.

- bug: lookup skipped for name nominated by friend declaration, if called with parameters incorrectly determined to be type-dependent.
	A name nominated by a friend declaration shall be accessible in the scope of the class containing the friend declaration.
	- fails to report error gracefully if lookup fails.


- clean up duplicated html string escape in SymbolPrinter/ParseTreePrinter
	
- refactor mingled stuff
	- combine WalkerContext and ParserContext?
	- WALK macros


- test-cases
	- document existing tests
	- ensure there are tests for:
		- nested-name-specifier-prefix: name lookup ignores object/function/enumerator names
		- type-name lookup hidden by constructor
		
- move Callback stuff into callback.h

- fix leak of global WalkerContext in parseFile
	- currently required so that parse-tree declarations can be used in reporting?

- check that template-arguments are 'evaluated in the context in which the entire postfix-expression occurs'
- test that the simple-template-id in simple-type-specifier-template is looked up correctly
- test that template-arguments in a nested-name-specifier-suffix-template are considered when deciding that the NNS is dependent
- test that names introduced into namespace by using-directive correctly hide previously-declared names



- bug: with ALLOCATOR_DEBUG, if type_info is not defined, error parsing malloc.h?

- avoid constructing complex *_NULL constants on the fly
- use custom list class for DeferredSymbols?

- clean up caching and deferred destruction
	- clean up CachedSymbols
		+ enable caching at any point in parse
		+ use linear-allocator
		+ remove entry from cache when alternative parse succeeds
			- otherwise, causes error when looking up template-id cached within nested-name-specifier-suffix?
		+ treat cache as stack, only top item considered?
			- handle X<Y>::Z<W>
		+ cache more than just template-id
		+ cache multiple symbols for each position
			- e.g. declarator-id -> id-expression -> unqualified-id -> template-id -> identifier
			- linear search?
			- test case
				- type-specifier -> nested-name-specifier -> nested-name -> type-name -> identifier
				- type-specifier -> type-name -> identifier
		- use custom list class
		+ cache shared-prefix 'class-key'		
			- type-specifier -> elaborated-type-specifier -> elaborated-type-specifier-key -> class-key
			- type-specifier -> class-specifier -> class-head -> class-key
	- clean up ParserAllocatorWrapper
		- defer destruction at level of container
			- need replacement for multimap?
	- clean up BacktrackCallbacks
		+ use linear-allocator
		+ use custom list class
		- store items grouped into frames, keyed off allocation-position stored in parser
		- specialise list class for front-insertion

- generalised solution for re-using failed parse-tree
	- requires that re-parsing a symbol in-place behaves the same way
		- make type-name parse behave the same way inside or outside a nested-name-specifier-prefix
			- defer rejection of type names hidden by non-type/namespace names
	- pattern of swapping walker result values means only outermost walker is valid
		- make walker results a weak-reference, except for outermost walker?
			- replace Type::swap with non-copying assign?
				- same for template-arguments/params
			- splice dependents without removing from inner list?
			- store types in template-argument-list by reference?
			- DeferredSymbols?
		- avoid calling inner walker destructors?
			- walker destructors should only be called when debugging allocator?
				- do walkers own global-allocator allocations?
					- only OpaqueCopied
				- do walker destructors have side effects?
					- WalkerBase::declarations removes non-committed declarations on fail
					- DeferredSymbols
		- defer deletion of symbol-table data
	- handle ETS declaration side-effects of failed parse tree
		- defer modification of enclosing scope until..?
			- completion of statement?
		- when does ETS declaration modify enclosing scope?
			- decl-specifier-seq or parameter-declaration-clause in namespace scope -> containing namespace
			- else, smallest non-class non-function-prototype scope that contains the declaration
	- handle scope creation side-effects of failed parse tree
		- preserve allocated scopes
		
- slow parsing of cpptree.h
	- profile parse, find out exactly what's taking so long
	- caused by pathological case: nested template-ids
		- isDependent is pathologically slow for nested template-ids
			- will always return false when invoked outside a template declaration
			- must examine all template-arguments and their bases
				- a type is dependent if it is a template-parameter visible in an enclosing scope or template-declaration
		- each iteration is parsed first as nested-name-specifier
			- cache successful parse of template-id component
	- shared-prefix: simple-type-specifier:
		- nested-name-specifier -> type-name -> simple-template-id
		- type-name -> simple-template-id
	- shared-prefix: id-expression:
		- qualified-id -> nested-name-specifier -> type-name -> simple-template-id
		- unqualified-id -> template-id -> simple-template-id
	- shared-prefix: template-argument:
		- type-id -> simple-type-specifier -> simple-template-id
		- postfix-expression -> postfix-expression-construct -> simple-type-specifier -> simple-template-id
		- id-expression -> simple-template-id
	- factor out shared-prefix between nested-name-specifier and type-name?
		- check that this is actually the cause of the slow parse?
		- problem with basic.lookup.qual: During the lookup for a name preceding the :: scope resolution operator, object, function, and enumerator names are ignored.
		- occurs: base_specifier, mem_initializer_id_base, typename_specifier, simple_type_specifier_name/template
			simple-type-specifier:
				[::] [nested-name-specifier] type-name
				[::] nested-name-specifier template simple-template-id
			nested-namespace-specifier:
				namespace-name :: [nested-namespace-specifier-seq]
			nested-namespace-specifier-seq:
				nested-namespace-specifier [nested-namespace-specifier-seq]
			qualified-type-name:
				[nested-namespace-specifier-seq] type-name [qualified-type-name-suffix]
			qualified-type-name-suffix:
				:: type-name [qualified-type-name-suffix]
	- use LR parse instead?
		- how much do context actions rely on the assumption that parsing is top-down?
	- cache the type-name parsed from the beginning of a nested-name-specifier?
		- when nested-name-specifier parse fails at '::', defer backtrack and store type-name
			- need to re-lookup type-name to check that it is not hidden by a non-type-name
			- make '::' optional in nested-name-specifier when specifying a type-name?
	- cache a successfully parsed template-argument-clause
		- only for the duration of parsing simple-type-specifier
		- cache forward-declarations within template-argument-clause
			- problem: declaration added to enclosing scope, address taken
				- store declaration by reference?
				- should declaration be added to enclosing scope?
					- name not visible in enclosing namespace scope (Comeau, msvc)
			- problem: declaration of function-type contains parameter-scope
			- avoid deallocation/destruction of cached parse-tree
				- when nested-name-specifier parse fails at '::', preserve parse-tree allocation and do not destroy template-argument-clause
				- relocate parse-tree: generate relocateSymbol()?
					- relocates from one allocator to another
						- for each node, visit children, create copy, delete original, replace original ref with copy
					- copying seems wasteful, when original could be left in-place.
					- defer deletion until next allocation, defer next allocation until successful parse
						- does anything cause allocation before cache hit?
							- empty lists allocate a node
							- isDependent causes construction of empty Scope, empty multimap allocates a node
							- ParameterDeclarationClauseWalker creates a new scope
								- create scope on stack? Scope::Declarations multimap allocates a node
								- implement scope-swap?
									- Scope::parent/Declaration::scope pointer fixup required?
						- on successful parse, replace cache with symbol
						- perform cache lookup for each subsequent parse attempt, using rtti
						- on cache hit, return cached parse-tree, indicate that result is cached
			- defer deallocation of cached symbol table
				- problem: ETS declaration in failed parse-tree is found by lookup of subsequent parse attempt
					- move point of ets declaration to end of decl-specifier-seq?
					- flush cached parse-tree at point of declaration
					- in findDeclaration, assert that cached parse-tree does not contain declarations?
			- manage parse-tree allocations
				- defer destruction/deallocation of symbol data within allocator
					- list of successfully parsed symbols
						- with point of allocation
					- causes problem with removal of elements in std::map
						- microsoft implementation doesn't use construct() correctly
						- replace with a hash_map?
				- need to preserve parse-tree, until next successful parse causes partial unwind
				- added complication: need to remove ETS allocations from enclosing scope
				- remove ScopeGuard and declarations/scopes in WalkerBase
				- don't use deleteSymbol/SymbolDelete
				- avoid copying parse-tree allocations
				- fix !ALLOCATOR_DEBUG
					- don't destroy scopes/declarations
					- only undeclare ETS declarations
		
- make gUniqueNames a member of Scope?

- clean up error handling - multiple assert exception types?


- improve error messages
	- e.g. detect when 'typename' keyword is missing
	- on reportIdentifierMismatch, show the location of the mismatching identifier
	
- explain template_argument_clause_disambiguate
	- disambiguates: < CONSTANT_EXPRESSION < 0 >
	- how?
	- only required when template-id appears in an expression
	
- explain postfix_expression_disambiguate
	- required in the context of a template definition
	- matches: unqualified-id ( expression-list )
	- handles dependent names (somehow?)
	
- parser is hard to work with - refactor?
	+ remove unmingled parse
	- remove dead code
	- replace Copied with a list?
		- done mostly, except for addDependent(Dependent)?
	- clean up SimpleDeclarationWalker::deferred
	- naming:
		- ParserContext is lexer?
	- TREEWALKER macros
	
- generate remaining handwritten parseSymbol functions
	- PARSE_SELECT_TOKEN
	- PARSE_EXPRESSION_LEFTASSOCIATIVE
	- inTemplateArgumentList
	- overloadable_operator
	
- bug: using-declaration has wrong source path?
	- std::size_t in <ctime>

- add exclusions/suppression for warning messages
	- specify source file, warning-type, identifier
	- automatically exclude external library headers? e.g. STLPort, boost, stdc, win32
		- how to tell if they're external?
			- require user to specify root(s) for files to report about?
- report files that contain no definitions
- support case-insensitivity for include lookup
- ensure output files are unique
	- one output subdir per .cpp
		- grouped by project and /Fo
	- move identifier.css to sensible place
		- or inline in html?
	- store relative paths in output html
	- create subdirs relative to include-path
		- use name found in include-directive: e.g. included from c:/project/src/source.cpp
			- <header.h> -> c:/project/inc/header.h -> $include/
			- "header.h" -> c:/project/src/header.h -> $./
			- "../header.h" -> c:/project/header.h -> $../
			- "subdir/header.h" -> c:/project/src/subdir/header.h -> subdir/
				- "header2.h" -> c:/project/src/subdir/header2.h -> subdir/
				- <header.h> -> c:/project/inc/header.h -> $include/
				- "header3.h" -> c:/project/inc/header3.h -> $include/
				- "../header.h" -> c:/project/src/header.h -> $./
		- how to determine which include-path a source file is rooted in?
		- include-path '.' may override other include-paths?
			- put output files sourced from include-paths into $include subdir
		- use '$..' to indicate looking outside an include-path
	- compare output files generated from same source?
- warn on escaping from include-path using '..'
- detect order-dependent includes
	- e.g. header1.h depends on header2.h but does not (in)directly include it
		- confused by multiple declarations in different headers: e.g. getwchar in stdio.h and wchar.h
			- prefer (in)directly included source when determining location of declaration
		- confused by #ifndef NULL #define NULL 0 #endif
			- recognise ifndef-define pattern as redeclaration?
				- heuristic is bad
			- tag all declarations within #ifndef X #define X #endif
				- determine all tagged declarations to be present within any file containing #ifndef X
		- confused by #ifdef X X() #endif
			- ignore dependency on X when wrapped in #ifdef X
- detect cyclic includes
- detect unused includes
	- if directly included and not used
		- and all children are not used
	- unused if not directly or indirectly included
- detect missing includes
	- if module A is directly dependent on module B, A should directly include B
- visualise include graph
	- as module dependency graph?
	- module dependency graph not built until after .html
		- two pass
	- show dependencies that are indirect
- in each output file, add link to original source file
- show point-of-declaration for macros?
- improve formatting of output html
	- enum members on separate line


- list symbols depended on by each module
	- use consistent path-separator/root in filenames
		- how does wave derive the absolute root from the relative include-path?
	~ exclude predefined symbols
		~ pass contents of predefined_msvc.h directly to lexer, rather than via #include
	- including macro definitions
	- support overloaded-operators
	- ignore namespace names
	- perform type-dependent name-lookup for template instantiations
	- handle multiple identical typedef/forward-declaration in different modules
	- if symbol is forward-declared, link to primary declaration if visible
			

- fix or remove macroPosition

- use found-include-directive hook to build include-graph
	- doesn't give full path, need to add resolved_include_file
		- or use opened_include_file and compile without BOOST_WAVE_SUPPORT_PRAGMA_ONCE
		- or derive from context and call find_include_file
	- how to uniquely identify a source file?
		- absolute path
	- opened_include_file gives relname/absname
		- always the same?
		- always use forward-slash?
	
- detect mid-declaration-includes

+ output one html per #include
	- why?
		- not required for dependency-tracking?
		- easier to browse html source
		- recognises repeat-includes
		- recognises mid-declaration-includes
	- tag all declarations with the source file?
	- need to track include push/pop
	- emit extra tokens?
		- modify grammar? include-declaration: include declaration-seq eof
		- swallow in lexer?
	- tag first and last token in file?
		- fails if no tokens after #include
	- build include-graph with parent-links, make file-position point at node?
	- append sequence of push/pop commands 'between' tokens?
		- +a = +1
		- -a = -1
		- +a, -a = nothing
		- -a, +a, -a = -1
		- -a, +a = -1, +1
		- -a, +b = -1, +1
		- +a, -a, -b = -1
		- +a, -a, +b = +1
		- +a, +b, -b = +1


- macro dependencies
	- associate macro definitions with source files
	- for each macro expansion, add definition to list of dependencies

- check that include-path search order is consistent with MSVC/GCC

- test parser for completeness and compliance

- profile wave
	- run wave on its own to profile..
	- generally difficult - symbols are too long
	- reading files
		- copying file into string?
		- why not just read straight from buffered iostream?
			- lexer makes assumption that input iterator is a char* buffer the same size as the file
	- searching include paths
	- recognises pragma once and include-guards
	- 20%: get_tss_data/set_tss_data/RtlEnterCriticalSection/RtlLeaveCriticalSection
		- compile wave without BOOST_WAVE_SUPPORT_THREADING <-- wave runs 50% faster
	- 10%: malloc/memmove/free in lexer
		- replace with stlp allocator?
	- 10%: operator-new/free in spirit trees (vector)
		- BOOST_SPIRIT_USE_BOOST_ALLOCATOR_FOR_TREES <-- much slower?
		- BOOST_SPIRIT_USE_LIST_FOR_TREES
	- 10%: print to console
	- 2%: lex_token copying
	- general string copying
		- file-position
	- BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE <--  no appreciable speedup
	
- profile parser
	- 10%: construction/destruction of multi-inherited interfaces
		- remove virtual-destructors <-- 10% speedup
		- non-virtual concrete symbols
	- 6%: lex-names
		- 5%: char_traits<>::compare
		- 1%: makeFilename: 0.5%: convert forward-slash to backslash
			- avoid slash-conversion unless absolutely necessary (assert correct convention)
		- customise lex-token for fast comparison and share between lexer and parser?
		- use hash-table
	- 1% findDeclaration
	
+ optimise parser allocations
	+ ensure allocator uses good block size: 128kb?
	+ use parse-tree allocator where possible
		+ scopes
		+ declarations
		+ types
	+ avoid allocations where possible
		+ don't allocate symbol until successful parse
			- measure cost
		+ avoid copying 'qualifying' when creating WalkerState: e.g. parsing nested-name-specifier
			+ ref instead of copy
		+ don't track list of scopes/declarations unless debugging
			
+ optimise name-lookup?
	- hashtable?
	- single global id table, id:scopes?
		- how to sort scopes?
	- trace name-lookup pattern
	- went with a std::multimap
	
- handle errors
	- if member-initializer parse fails, member declaration is already committed
		- committed declaration cannot be deallocated (unless forward-declaration), causes allocator check failure
		- need to commit at point of declaration: failure to parse member-initializer is fatal
		- detect that this is a fatal error and don't clean up symbols?
		- for now, track all declarations and clean up if parse fails..
			- doubles parse time, optimise!
			- don't track declarations (except forward-decl) unless ALLOCATOR_DEBUG
			
- clean up test code
		
- faster lexer
	- optimise boost::wave?
	- custom lexer/preprocessor?
	- http://www.ibm.com/developerworks/aix/library/au-c_plusplus_antlr/index.html
	- GNU cpplib?
		- doesn't build easily on win32
	- ucpp?
		- only supports C99 tokens

- fix printer bugs
	- space between *= and &=
	- space before and after =
	- space between return and true/false
	- space between nested > in template decl
	
- generate parser
	- point of declaration
		- namespace: after identifier in namespace-declaration
			- contains block-declarations
		- class: after identifier/simple-template-id in class-head, unless anonymous
			- contains template-params, member-declarations
		- enum: after identifier in enum-specifier, unless anonymous
			- contains nothing
		- enumerator: after enumerator-definition
		- elaborated-type-specifer (unqualified): after identifier (in enclosing class/namespace)
		- elaborated-type-specifier (forward): after identifier
		- declaration: after declarator
			- contains template-params, simple-declarations
		- bitfield: after identifier in member-declarator-bitfield, unless anonymous
		- type-parameter: after identifier in type-parameter-default, unless anonymous
	- add context to hand-written parser

- create 'under-construction' scope when beginning template-declaration, class-declaration, function-declaration
- push/clear under-construction scope at point of declaration


- implement template-instantiation
	- specializations are chosen at point of instantiation
	- dependent-names/types are bound at point of instantiation-
	- partial-ordering of class template specialisations
- perform type-deduction
	- store function-type as R(A1, A2) rather than just R
	- store member-function-type as R C::*(A1, A2) rather than just R
	- store member-pointer-type as R C::* rather than just R

- distinguish names that refer to 'current instantiation' as not dependent - 14.6.2.1

- overload resolution
	- across using-directive
- argument-dependent-lookup
- name-lookup for overloaded-operators


argument dependent lookup
3.4.2-2
For each argument type T in the function call, there is a set of zero or more associated namespaces and a
set of zero or more associated classes to be considered. The sets of namespaces and classes is determined
entirely by the types of the function arguments (and the namespace of any template template argument).
Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of
namespaces and classes are determined in the following way:
— If T is a fundamental type, its associated sets of namespaces and classes are both empty.
— If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a
member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces
of which its associated classes are members. Furthermore, if T is a class template specialization,
its associated namespaces and classes also include: the namespaces and classes associated with the
types of the template arguments provided for template type parameters (excluding template template
parameters); the namespaces of which any template template arguments are members; and the classes
of which any member templates used as template template arguments are members. [ Note: non-type
template arguments do not contribute to the set of associated namespaces.—end note ]
— If T is an enumeration type, its associated namespace is the namespace in which it is defined. If it is
class member, its associated class is the member’s class; else it has no associated class.
— If T is a pointer to U or an array of U, its associated namespaces and classes are those associated with
U.
— If T is a function type, its associated namespaces and classes are those associated with the function
parameter types and those associated with the return type.
— If T is a pointer to a member function of a class X, its associated namespaces and classes are those
associated with the function parameter types and return type, together with those associated with X.
— If T is a pointer to a data member of class X, its associated namespaces and classes are those associated
with the member type together with those associated with X.


class member lookup
3.4.1-8
A name used in the definition of a member function (9.3) of class X following the function’s declarator-id 28
or in the brace-or-equal-initializer of a non-static data member (9.2) of class X shall be declared in one of
the following ways:
— before its use in the block in which it is used or in an enclosing block (6.3), or
— shall be a member of class X or be a member of a base class of X (10.2), or
— if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y
(this lookup applies in turn to Y’s enclosing classes, starting with the innermost enclosing class),29 or
— if X is a local class (9.8) or is a nested class of a local class, before the definition of class X in a block
enclosing the definition of class X, or
— if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class
or a nested class within a local class of a function that is a member of N, before the use of the name,
in namespace N or in one of N ’s enclosing namespaces.

3.4.5 class member access




Windows SDK 1.7 changes:

C:\Program Files\Microsoft SDKs\Windows\v7.1\Include\objbase.h(239) - comment this line, IUnknown is not declared